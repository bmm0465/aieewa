"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pdf-parse";
exports.ids = ["vendor-chunks/pdf-parse"];
exports.modules = {

/***/ "(rsc)/./node_modules/pdf-parse/dist/cjs/index.cjs":
/*!***************************************************!*\
  !*** ./node_modules/pdf-parse/dist/cjs/index.cjs ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __typeError = (msg)=>{\n    throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg)=>member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter)=>(__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value1)=>member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value1);\nvar __privateSet = (obj, member, value1, setter)=>(__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value1) : member.set(obj, value1), value1);\nvar __privateMethod = (obj, member, method)=>(__accessCheck(obj, member, \"access private method\"), method);\nvar __privateWrapper = (obj, member, setter, getter)=>({\n        set _ (value){\n            __privateSet(obj, member, value, setter);\n        },\n        get _ () {\n            return __privateGet(obj, member, getter);\n        }\n    });\nvar _capability, _messageHandler, _port, _webWorker, _fakeWorkerId, _isWorkerDisabled, _workerPorts, _PDFWorker_instances, resolve_fn, initializeFromPort_fn, initialize_fn, setupFakeWorker_fn, _PDFWorker_static, mainThreadWorkerMessageHandler_get;\nObject.defineProperty(exports, Symbol.toStringTag, {\n    value: \"Module\"\n});\nvar _documentCurrentScript = typeof document !== \"undefined\" ? document.currentScript : null;\nvar __webpack_modules__ = {\n    /***/ 34: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var isCallable = __webpack_require__2(4901);\n        module2.exports = function(it) {\n            return typeof it == \"object\" ? it !== null : isCallable(it);\n        };\n    },\n    /***/ 81: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var call = __webpack_require__2(9565);\n        var aCallable = __webpack_require__2(9306);\n        var anObject = __webpack_require__2(8551);\n        var tryToString = __webpack_require__2(6823);\n        var getIteratorMethod = __webpack_require__2(851);\n        var $TypeError = TypeError;\n        module2.exports = function(argument, usingIterator) {\n            var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;\n            if (aCallable(iteratorMethod)) return anObject(call(iteratorMethod, argument));\n            throw new $TypeError(tryToString(argument) + \" is not iterable\");\n        };\n    },\n    /***/ 116: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        var $ = __webpack_require__2(6518);\n        var call = __webpack_require__2(9565);\n        var iterate = __webpack_require__2(2652);\n        var aCallable = __webpack_require__2(9306);\n        var anObject = __webpack_require__2(8551);\n        var getIteratorDirect = __webpack_require__2(1767);\n        var iteratorClose = __webpack_require__2(9539);\n        var iteratorHelperWithoutClosingOnEarlyError = __webpack_require__2(4549);\n        var findWithoutClosingOnEarlyError = iteratorHelperWithoutClosingOnEarlyError(\"find\", TypeError);\n        $({\n            target: \"Iterator\",\n            proto: true,\n            real: true,\n            forced: findWithoutClosingOnEarlyError\n        }, {\n            find: function find(predicate) {\n                anObject(this);\n                try {\n                    aCallable(predicate);\n                } catch (error) {\n                    iteratorClose(this, \"throw\", error);\n                }\n                if (findWithoutClosingOnEarlyError) return call(findWithoutClosingOnEarlyError, this, predicate);\n                var record = getIteratorDirect(this);\n                var counter = 0;\n                return iterate(record, function(value1, stop) {\n                    if (predicate(value1, counter++)) return stop(value1);\n                }, {\n                    IS_RECORD: true,\n                    INTERRUPTED: true\n                }).result;\n            }\n        });\n    },\n    /***/ 283: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var uncurryThis = __webpack_require__2(9504);\n        var fails = __webpack_require__2(9039);\n        var isCallable = __webpack_require__2(4901);\n        var hasOwn = __webpack_require__2(9297);\n        var DESCRIPTORS = __webpack_require__2(3724);\n        var CONFIGURABLE_FUNCTION_NAME = __webpack_require__2(350).CONFIGURABLE;\n        var inspectSource = __webpack_require__2(3706);\n        var InternalStateModule = __webpack_require__2(1181);\n        var enforceInternalState = InternalStateModule.enforce;\n        var getInternalState = InternalStateModule.get;\n        var $String = String;\n        var defineProperty = Object.defineProperty;\n        var stringSlice = uncurryThis(\"\".slice);\n        var replace = uncurryThis(\"\".replace);\n        var join = uncurryThis([].join);\n        var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function() {\n            return defineProperty(function() {}, \"length\", {\n                value: 8\n            }).length !== 8;\n        });\n        var TEMPLATE = String(String).split(\"String\");\n        var makeBuiltIn = module2.exports = function(value1, name, options) {\n            if (stringSlice($String(name), 0, 7) === \"Symbol(\") {\n                name = \"[\" + replace($String(name), /^Symbol\\(([^)]*)\\).*$/, \"$1\") + \"]\";\n            }\n            if (options && options.getter) name = \"get \" + name;\n            if (options && options.setter) name = \"set \" + name;\n            if (!hasOwn(value1, \"name\") || CONFIGURABLE_FUNCTION_NAME && value1.name !== name) {\n                if (DESCRIPTORS) defineProperty(value1, \"name\", {\n                    value: name,\n                    configurable: true\n                });\n                else value1.name = name;\n            }\n            if (CONFIGURABLE_LENGTH && options && hasOwn(options, \"arity\") && value1.length !== options.arity) {\n                defineProperty(value1, \"length\", {\n                    value: options.arity\n                });\n            }\n            try {\n                if (options && hasOwn(options, \"constructor\") && options.constructor) {\n                    if (DESCRIPTORS) defineProperty(value1, \"prototype\", {\n                        writable: false\n                    });\n                } else if (value1.prototype) value1.prototype = void 0;\n            } catch (error) {}\n            var state = enforceInternalState(value1);\n            if (!hasOwn(state, \"source\")) {\n                state.source = join(TEMPLATE, typeof name == \"string\" ? name : \"\");\n            }\n            return value1;\n        };\n        Function.prototype.toString = makeBuiltIn(function toString() {\n            return isCallable(this) && getInternalState(this).source || inspectSource(this);\n        }, \"toString\");\n    },\n    /***/ 350: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var DESCRIPTORS = __webpack_require__2(3724);\n        var hasOwn = __webpack_require__2(9297);\n        var FunctionPrototype = Function.prototype;\n        var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;\n        var EXISTS = hasOwn(FunctionPrototype, \"name\");\n        var PROPER = EXISTS && (function something() {}).name === \"something\";\n        var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, \"name\").configurable);\n        module2.exports = {\n            EXISTS,\n            PROPER,\n            CONFIGURABLE\n        };\n    },\n    /***/ 397: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var getBuiltIn = __webpack_require__2(7751);\n        module2.exports = getBuiltIn(\"document\", \"documentElement\");\n    },\n    /***/ 421: /***/ (module2)=>{\n        module2.exports = {};\n    },\n    /***/ 456: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        var $ = __webpack_require__2(6518);\n        var globalThis2 = __webpack_require__2(4576);\n        var uncurryThis = __webpack_require__2(9504);\n        var anUint8Array = __webpack_require__2(4154);\n        var notDetached = __webpack_require__2(5169);\n        var numberToString = uncurryThis(1.1.toString);\n        var Uint8Array2 = globalThis2.Uint8Array;\n        var INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS = !Uint8Array2 || !Uint8Array2.prototype.toHex || !function() {\n            try {\n                var target = new Uint8Array2([\n                    255,\n                    255,\n                    255,\n                    255,\n                    255,\n                    255,\n                    255,\n                    255\n                ]);\n                return target.toHex() === \"ffffffffffffffff\";\n            } catch (error) {\n                return false;\n            }\n        }();\n        if (Uint8Array2) $({\n            target: \"Uint8Array\",\n            proto: true,\n            forced: INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS\n        }, {\n            toHex: function toHex() {\n                anUint8Array(this);\n                notDetached(this.buffer);\n                var result = \"\";\n                for(var i = 0, length = this.length; i < length; i++){\n                    var hex = numberToString(this[i], 16);\n                    result += hex.length === 1 ? \"0\" + hex : hex;\n                }\n                return result;\n            }\n        });\n    },\n    /***/ 507: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var call = __webpack_require__2(9565);\n        module2.exports = function(record, fn, ITERATOR_INSTEAD_OF_RECORD) {\n            var iterator = ITERATOR_INSTEAD_OF_RECORD ? record : record.iterator;\n            var next = record.next;\n            var step, result;\n            while(!(step = call(next, iterator)).done){\n                result = fn(step.value);\n                if (result !== void 0) return result;\n            }\n        };\n    },\n    /***/ 531: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        var $ = __webpack_require__2(6518);\n        var call = __webpack_require__2(9565);\n        var aCallable = __webpack_require__2(9306);\n        var anObject = __webpack_require__2(8551);\n        var getIteratorDirect = __webpack_require__2(1767);\n        var getIteratorFlattenable = __webpack_require__2(8646);\n        var createIteratorProxy = __webpack_require__2(9462);\n        var iteratorClose = __webpack_require__2(9539);\n        var IS_PURE = __webpack_require__2(6395);\n        var iteratorHelperThrowsOnInvalidIterator = __webpack_require__2(684);\n        var iteratorHelperWithoutClosingOnEarlyError = __webpack_require__2(4549);\n        var FLAT_MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR = !IS_PURE && !iteratorHelperThrowsOnInvalidIterator(\"flatMap\", function() {});\n        var flatMapWithoutClosingOnEarlyError = !IS_PURE && !FLAT_MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR && iteratorHelperWithoutClosingOnEarlyError(\"flatMap\", TypeError);\n        var FORCED = IS_PURE || FLAT_MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR || flatMapWithoutClosingOnEarlyError;\n        var IteratorProxy = createIteratorProxy(function() {\n            var iterator = this.iterator;\n            var mapper = this.mapper;\n            var result, inner;\n            while(true){\n                if (inner = this.inner) try {\n                    result = anObject(call(inner.next, inner.iterator));\n                    if (!result.done) return result.value;\n                    this.inner = null;\n                } catch (error) {\n                    iteratorClose(iterator, \"throw\", error);\n                }\n                result = anObject(call(this.next, iterator));\n                if (this.done = !!result.done) return;\n                try {\n                    this.inner = getIteratorFlattenable(mapper(result.value, this.counter++), false);\n                } catch (error) {\n                    iteratorClose(iterator, \"throw\", error);\n                }\n            }\n        });\n        $({\n            target: \"Iterator\",\n            proto: true,\n            real: true,\n            forced: FORCED\n        }, {\n            flatMap: function flatMap(mapper) {\n                anObject(this);\n                try {\n                    aCallable(mapper);\n                } catch (error) {\n                    iteratorClose(this, \"throw\", error);\n                }\n                if (flatMapWithoutClosingOnEarlyError) return call(flatMapWithoutClosingOnEarlyError, this, mapper);\n                return new IteratorProxy(getIteratorDirect(this), {\n                    mapper,\n                    inner: null\n                });\n            }\n        });\n    },\n    /***/ 616: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var fails = __webpack_require__2(9039);\n        module2.exports = !fails(function() {\n            var test = (function() {}).bind();\n            return typeof test != \"function\" || test.hasOwnProperty(\"prototype\");\n        });\n    },\n    /***/ 655: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var classof = __webpack_require__2(6955);\n        var $String = String;\n        module2.exports = function(argument) {\n            if (classof(argument) === \"Symbol\") throw new TypeError(\"Cannot convert a Symbol value to a string\");\n            return $String(argument);\n        };\n    },\n    /***/ 679: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var isPrototypeOf = __webpack_require__2(1625);\n        var $TypeError = TypeError;\n        module2.exports = function(it, Prototype) {\n            if (isPrototypeOf(Prototype, it)) return it;\n            throw new $TypeError(\"Incorrect invocation\");\n        };\n    },\n    /***/ 684: /***/ (module2)=>{\n        module2.exports = function(methodName, argument) {\n            var method = typeof Iterator == \"function\" && Iterator.prototype[methodName];\n            if (method) try {\n                method.call({\n                    next: null\n                }, argument).next();\n            } catch (error) {\n                return true;\n            }\n        };\n    },\n    /***/ 741: /***/ (module2)=>{\n        var ceil2 = Math.ceil;\n        var floor2 = Math.floor;\n        module2.exports = Math.trunc || function trunc(x) {\n            var n = +x;\n            return (n > 0 ? floor2 : ceil2)(n);\n        };\n    },\n    /***/ 757: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var getBuiltIn = __webpack_require__2(7751);\n        var isCallable = __webpack_require__2(4901);\n        var isPrototypeOf = __webpack_require__2(1625);\n        var USE_SYMBOL_AS_UID = __webpack_require__2(7040);\n        var $Object = Object;\n        module2.exports = USE_SYMBOL_AS_UID ? function(it) {\n            return typeof it == \"symbol\";\n        } : function(it) {\n            var $Symbol = getBuiltIn(\"Symbol\");\n            return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));\n        };\n    },\n    /***/ 851: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var classof = __webpack_require__2(6955);\n        var getMethod = __webpack_require__2(5966);\n        var isNullOrUndefined = __webpack_require__2(4117);\n        var Iterators = __webpack_require__2(6269);\n        var wellKnownSymbol = __webpack_require__2(8227);\n        var ITERATOR = wellKnownSymbol(\"iterator\");\n        module2.exports = function(it) {\n            if (!isNullOrUndefined(it)) return getMethod(it, ITERATOR) || getMethod(it, \"@@iterator\") || Iterators[classof(it)];\n        };\n    },\n    /***/ 944: /***/ (module2)=>{\n        var $TypeError = TypeError;\n        module2.exports = function(options) {\n            var alphabet = options && options.alphabet;\n            if (alphabet === void 0 || alphabet === \"base64\" || alphabet === \"base64url\") return alphabet || \"base64\";\n            throw new $TypeError(\"Incorrect `alphabet` option\");\n        };\n    },\n    /***/ 1072: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var internalObjectKeys = __webpack_require__2(1828);\n        var enumBugKeys = __webpack_require__2(8727);\n        module2.exports = Object.keys || function keys(O) {\n            return internalObjectKeys(O, enumBugKeys);\n        };\n    },\n    /***/ 1103: /***/ (module2)=>{\n        module2.exports = function(exec) {\n            try {\n                return {\n                    error: false,\n                    value: exec()\n                };\n            } catch (error) {\n                return {\n                    error: true,\n                    value: error\n                };\n            }\n        };\n    },\n    /***/ 1108: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var classof = __webpack_require__2(6955);\n        module2.exports = function(it) {\n            var klass = classof(it);\n            return klass === \"BigInt64Array\" || klass === \"BigUint64Array\";\n        };\n    },\n    /***/ 1148: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        var $ = __webpack_require__2(6518);\n        var call = __webpack_require__2(9565);\n        var iterate = __webpack_require__2(2652);\n        var aCallable = __webpack_require__2(9306);\n        var anObject = __webpack_require__2(8551);\n        var getIteratorDirect = __webpack_require__2(1767);\n        var iteratorClose = __webpack_require__2(9539);\n        var iteratorHelperWithoutClosingOnEarlyError = __webpack_require__2(4549);\n        var everyWithoutClosingOnEarlyError = iteratorHelperWithoutClosingOnEarlyError(\"every\", TypeError);\n        $({\n            target: \"Iterator\",\n            proto: true,\n            real: true,\n            forced: everyWithoutClosingOnEarlyError\n        }, {\n            every: function every(predicate) {\n                anObject(this);\n                try {\n                    aCallable(predicate);\n                } catch (error) {\n                    iteratorClose(this, \"throw\", error);\n                }\n                if (everyWithoutClosingOnEarlyError) return call(everyWithoutClosingOnEarlyError, this, predicate);\n                var record = getIteratorDirect(this);\n                var counter = 0;\n                return !iterate(record, function(value1, stop) {\n                    if (!predicate(value1, counter++)) return stop();\n                }, {\n                    IS_RECORD: true,\n                    INTERRUPTED: true\n                }).stopped;\n            }\n        });\n    },\n    /***/ 1181: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var NATIVE_WEAK_MAP = __webpack_require__2(8622);\n        var globalThis2 = __webpack_require__2(4576);\n        var isObject = __webpack_require__2(34);\n        var createNonEnumerableProperty = __webpack_require__2(6699);\n        var hasOwn = __webpack_require__2(9297);\n        var shared = __webpack_require__2(7629);\n        var sharedKey = __webpack_require__2(6119);\n        var hiddenKeys = __webpack_require__2(421);\n        var OBJECT_ALREADY_INITIALIZED = \"Object already initialized\";\n        var TypeError2 = globalThis2.TypeError;\n        var WeakMap2 = globalThis2.WeakMap;\n        var set, get, has;\n        var enforce = function(it) {\n            return has(it) ? get(it) : set(it, {});\n        };\n        var getterFor = function(TYPE) {\n            return function(it) {\n                var state;\n                if (!isObject(it) || (state = get(it)).type !== TYPE) {\n                    throw new TypeError2(\"Incompatible receiver, \" + TYPE + \" required\");\n                }\n                return state;\n            };\n        };\n        if (NATIVE_WEAK_MAP || shared.state) {\n            var store = shared.state || (shared.state = new WeakMap2());\n            store.get = store.get;\n            store.has = store.has;\n            store.set = store.set;\n            set = function(it, metadata) {\n                if (store.has(it)) throw new TypeError2(OBJECT_ALREADY_INITIALIZED);\n                metadata.facade = it;\n                store.set(it, metadata);\n                return metadata;\n            };\n            get = function(it) {\n                return store.get(it) || {};\n            };\n            has = function(it) {\n                return store.has(it);\n            };\n        } else {\n            var STATE = sharedKey(\"state\");\n            hiddenKeys[STATE] = true;\n            set = function(it, metadata) {\n                if (hasOwn(it, STATE)) throw new TypeError2(OBJECT_ALREADY_INITIALIZED);\n                metadata.facade = it;\n                createNonEnumerableProperty(it, STATE, metadata);\n                return metadata;\n            };\n            get = function(it) {\n                return hasOwn(it, STATE) ? it[STATE] : {};\n            };\n            has = function(it) {\n                return hasOwn(it, STATE);\n            };\n        }\n        module2.exports = {\n            set,\n            get,\n            has,\n            enforce,\n            getterFor\n        };\n    },\n    /***/ 1291: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var trunc = __webpack_require__2(741);\n        module2.exports = function(argument) {\n            var number = +argument;\n            return number !== number || number === 0 ? 0 : trunc(number);\n        };\n    },\n    /***/ 1385: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var iteratorClose = __webpack_require__2(9539);\n        module2.exports = function(iters, kind, value1) {\n            for(var i = iters.length - 1; i >= 0; i--){\n                if (iters[i] === void 0) continue;\n                try {\n                    value1 = iteratorClose(iters[i].iterator, kind, value1);\n                } catch (error) {\n                    kind = \"throw\";\n                    value1 = error;\n                }\n            }\n            if (kind === \"throw\") throw value1;\n            return value1;\n        };\n    },\n    /***/ 1548: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var globalThis2 = __webpack_require__2(4576);\n        var fails = __webpack_require__2(9039);\n        var V8 = __webpack_require__2(9519);\n        var ENVIRONMENT = __webpack_require__2(4215);\n        var structuredClone2 = globalThis2.structuredClone;\n        module2.exports = !!structuredClone2 && !fails(function() {\n            if (ENVIRONMENT === \"DENO\" && V8 > 92 || ENVIRONMENT === \"NODE\" && V8 > 94 || ENVIRONMENT === \"BROWSER\" && V8 > 97) return false;\n            var buffer = new ArrayBuffer(8);\n            var clone = structuredClone2(buffer, {\n                transfer: [\n                    buffer\n                ]\n            });\n            return buffer.byteLength !== 0 || clone.byteLength !== 8;\n        });\n    },\n    /***/ 1549: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        __webpack_require__2(6632);\n    },\n    /***/ 1625: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var uncurryThis = __webpack_require__2(9504);\n        module2.exports = uncurryThis({}.isPrototypeOf);\n    },\n    /***/ 1689: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        var $ = __webpack_require__2(6518);\n        var globalThis2 = __webpack_require__2(4576);\n        var apply = __webpack_require__2(8745);\n        var slice = __webpack_require__2(7680);\n        var newPromiseCapabilityModule = __webpack_require__2(6043);\n        var aCallable = __webpack_require__2(9306);\n        var perform = __webpack_require__2(1103);\n        var Promise2 = globalThis2.Promise;\n        var ACCEPT_ARGUMENTS = false;\n        var FORCED = !Promise2 || !Promise2[\"try\"] || perform(function() {\n            Promise2[\"try\"](function(argument) {\n                ACCEPT_ARGUMENTS = argument === 8;\n            }, 8);\n        }).error || !ACCEPT_ARGUMENTS;\n        $({\n            target: \"Promise\",\n            stat: true,\n            forced: FORCED\n        }, {\n            \"try\": function(callbackfn) {\n                var args = arguments.length > 1 ? slice(arguments, 1) : [];\n                var promiseCapability = newPromiseCapabilityModule.f(this);\n                var result = perform(function() {\n                    return apply(aCallable(callbackfn), void 0, args);\n                });\n                (result.error ? promiseCapability.reject : promiseCapability.resolve)(result.value);\n                return promiseCapability.promise;\n            }\n        });\n    },\n    /***/ 1698: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        var $ = __webpack_require__2(6518);\n        var union = __webpack_require__2(4204);\n        var setMethodGetKeysBeforeCloning = __webpack_require__2(9835);\n        var setMethodAcceptSetLike = __webpack_require__2(4916);\n        var FORCED = !setMethodAcceptSetLike(\"union\") || !setMethodGetKeysBeforeCloning(\"union\");\n        $({\n            target: \"Set\",\n            proto: true,\n            real: true,\n            forced: FORCED\n        }, {\n            union\n        });\n    },\n    /***/ 1701: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        var $ = __webpack_require__2(6518);\n        var call = __webpack_require__2(9565);\n        var aCallable = __webpack_require__2(9306);\n        var anObject = __webpack_require__2(8551);\n        var getIteratorDirect = __webpack_require__2(1767);\n        var createIteratorProxy = __webpack_require__2(9462);\n        var callWithSafeIterationClosing = __webpack_require__2(6319);\n        var iteratorClose = __webpack_require__2(9539);\n        var iteratorHelperThrowsOnInvalidIterator = __webpack_require__2(684);\n        var iteratorHelperWithoutClosingOnEarlyError = __webpack_require__2(4549);\n        var IS_PURE = __webpack_require__2(6395);\n        var MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR = !IS_PURE && !iteratorHelperThrowsOnInvalidIterator(\"map\", function() {});\n        var mapWithoutClosingOnEarlyError = !IS_PURE && !MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR && iteratorHelperWithoutClosingOnEarlyError(\"map\", TypeError);\n        var FORCED = IS_PURE || MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR || mapWithoutClosingOnEarlyError;\n        var IteratorProxy = createIteratorProxy(function() {\n            var iterator = this.iterator;\n            var result = anObject(call(this.next, iterator));\n            var done = this.done = !!result.done;\n            if (!done) return callWithSafeIterationClosing(iterator, this.mapper, [\n                result.value,\n                this.counter++\n            ], true);\n        });\n        $({\n            target: \"Iterator\",\n            proto: true,\n            real: true,\n            forced: FORCED\n        }, {\n            map: function map(mapper) {\n                anObject(this);\n                try {\n                    aCallable(mapper);\n                } catch (error) {\n                    iteratorClose(this, \"throw\", error);\n                }\n                if (mapWithoutClosingOnEarlyError) return call(mapWithoutClosingOnEarlyError, this, mapper);\n                return new IteratorProxy(getIteratorDirect(this), {\n                    mapper\n                });\n            }\n        });\n    },\n    /***/ 1767: /***/ (module2)=>{\n        module2.exports = function(obj) {\n            return {\n                iterator: obj,\n                next: obj.next,\n                done: false\n            };\n        };\n    },\n    /***/ 1828: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var uncurryThis = __webpack_require__2(9504);\n        var hasOwn = __webpack_require__2(9297);\n        var toIndexedObject = __webpack_require__2(5397);\n        var indexOf = __webpack_require__2(9617).indexOf;\n        var hiddenKeys = __webpack_require__2(421);\n        var push = uncurryThis([].push);\n        module2.exports = function(object, names) {\n            var O = toIndexedObject(object);\n            var i = 0;\n            var result = [];\n            var key;\n            for(key in O)!hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);\n            while(names.length > i)if (hasOwn(O, key = names[i++])) {\n                ~indexOf(result, key) || push(result, key);\n            }\n            return result;\n        };\n    },\n    /***/ 2106: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var makeBuiltIn = __webpack_require__2(283);\n        var defineProperty = __webpack_require__2(4913);\n        module2.exports = function(target, name, descriptor) {\n            if (descriptor.get) makeBuiltIn(descriptor.get, name, {\n                getter: true\n            });\n            if (descriptor.set) makeBuiltIn(descriptor.set, name, {\n                setter: true\n            });\n            return defineProperty.f(target, name, descriptor);\n        };\n    },\n    /***/ 2140: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var wellKnownSymbol = __webpack_require__2(8227);\n        var TO_STRING_TAG = wellKnownSymbol(\"toStringTag\");\n        var test = {};\n        test[TO_STRING_TAG] = \"z\";\n        module2.exports = String(test) === \"[object z]\";\n    },\n    /***/ 2195: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var uncurryThis = __webpack_require__2(9504);\n        var toString = uncurryThis({}.toString);\n        var stringSlice = uncurryThis(\"\".slice);\n        module2.exports = function(it) {\n            return stringSlice(toString(it), 8, -1);\n        };\n    },\n    /***/ 2211: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var fails = __webpack_require__2(9039);\n        module2.exports = !fails(function() {\n            function F() {}\n            F.prototype.constructor = null;\n            return Object.getPrototypeOf(new F()) !== F.prototype;\n        });\n    },\n    /***/ 2303: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var globalThis2 = __webpack_require__2(4576);\n        var uncurryThis = __webpack_require__2(9504);\n        var Uint8Array2 = globalThis2.Uint8Array;\n        var SyntaxError2 = globalThis2.SyntaxError;\n        var parseInt2 = globalThis2.parseInt;\n        var min = Math.min;\n        var NOT_HEX = /[^\\da-f]/i;\n        var exec = uncurryThis(NOT_HEX.exec);\n        var stringSlice = uncurryThis(\"\".slice);\n        module2.exports = function(string, into) {\n            var stringLength = string.length;\n            if (stringLength % 2 !== 0) throw new SyntaxError2(\"String should be an even number of characters\");\n            var maxLength = into ? min(into.length, stringLength / 2) : stringLength / 2;\n            var bytes = into || new Uint8Array2(maxLength);\n            var read = 0;\n            var written = 0;\n            while(written < maxLength){\n                var hexits = stringSlice(string, read, read += 2);\n                if (exec(NOT_HEX, hexits)) throw new SyntaxError2(\"String should only contain hex characters\");\n                bytes[written++] = parseInt2(hexits, 16);\n            }\n            return {\n                bytes,\n                read\n            };\n        };\n    },\n    /***/ 2360: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var anObject = __webpack_require__2(8551);\n        var definePropertiesModule = __webpack_require__2(6801);\n        var enumBugKeys = __webpack_require__2(8727);\n        var hiddenKeys = __webpack_require__2(421);\n        var html = __webpack_require__2(397);\n        var documentCreateElement = __webpack_require__2(4055);\n        var sharedKey = __webpack_require__2(6119);\n        var GT = \">\";\n        var LT = \"<\";\n        var PROTOTYPE = \"prototype\";\n        var SCRIPT = \"script\";\n        var IE_PROTO = sharedKey(\"IE_PROTO\");\n        var EmptyConstructor = function() {};\n        var scriptTag = function(content) {\n            return LT + SCRIPT + GT + content + LT + \"/\" + SCRIPT + GT;\n        };\n        var NullProtoObjectViaActiveX = function(activeXDocument2) {\n            activeXDocument2.write(scriptTag(\"\"));\n            activeXDocument2.close();\n            var temp = activeXDocument2.parentWindow.Object;\n            activeXDocument2 = null;\n            return temp;\n        };\n        var NullProtoObjectViaIFrame = function() {\n            var iframe = documentCreateElement(\"iframe\");\n            var JS = \"java\" + SCRIPT + \":\";\n            var iframeDocument;\n            iframe.style.display = \"none\";\n            html.appendChild(iframe);\n            iframe.src = String(JS);\n            iframeDocument = iframe.contentWindow.document;\n            iframeDocument.open();\n            iframeDocument.write(scriptTag(\"document.F=Object\"));\n            iframeDocument.close();\n            return iframeDocument.F;\n        };\n        var activeXDocument;\n        var NullProtoObject = function() {\n            try {\n                activeXDocument = new ActiveXObject(\"htmlfile\");\n            } catch (error) {}\n            NullProtoObject = typeof document != \"undefined\" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);\n            var length = enumBugKeys.length;\n            while(length--)delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];\n            return NullProtoObject();\n        };\n        hiddenKeys[IE_PROTO] = true;\n        module2.exports = Object.create || function create(O, Properties) {\n            var result;\n            if (O !== null) {\n                EmptyConstructor[PROTOTYPE] = anObject(O);\n                result = new EmptyConstructor();\n                EmptyConstructor[PROTOTYPE] = null;\n                result[IE_PROTO] = O;\n            } else result = NullProtoObject();\n            return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);\n        };\n    },\n    /***/ 2475: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        var $ = __webpack_require__2(6518);\n        var isSupersetOf = __webpack_require__2(8527);\n        var setMethodAcceptSetLike = __webpack_require__2(4916);\n        var INCORRECT = !setMethodAcceptSetLike(\"isSupersetOf\", function(result) {\n            return !result;\n        });\n        $({\n            target: \"Set\",\n            proto: true,\n            real: true,\n            forced: INCORRECT\n        }, {\n            isSupersetOf\n        });\n    },\n    /***/ 2489: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        var $ = __webpack_require__2(6518);\n        var call = __webpack_require__2(9565);\n        var aCallable = __webpack_require__2(9306);\n        var anObject = __webpack_require__2(8551);\n        var getIteratorDirect = __webpack_require__2(1767);\n        var createIteratorProxy = __webpack_require__2(9462);\n        var callWithSafeIterationClosing = __webpack_require__2(6319);\n        var IS_PURE = __webpack_require__2(6395);\n        var iteratorClose = __webpack_require__2(9539);\n        var iteratorHelperThrowsOnInvalidIterator = __webpack_require__2(684);\n        var iteratorHelperWithoutClosingOnEarlyError = __webpack_require__2(4549);\n        var FILTER_WITHOUT_THROWING_ON_INVALID_ITERATOR = !IS_PURE && !iteratorHelperThrowsOnInvalidIterator(\"filter\", function() {});\n        var filterWithoutClosingOnEarlyError = !IS_PURE && !FILTER_WITHOUT_THROWING_ON_INVALID_ITERATOR && iteratorHelperWithoutClosingOnEarlyError(\"filter\", TypeError);\n        var FORCED = IS_PURE || FILTER_WITHOUT_THROWING_ON_INVALID_ITERATOR || filterWithoutClosingOnEarlyError;\n        var IteratorProxy = createIteratorProxy(function() {\n            var iterator = this.iterator;\n            var predicate = this.predicate;\n            var next = this.next;\n            var result, done, value1;\n            while(true){\n                result = anObject(call(next, iterator));\n                done = this.done = !!result.done;\n                if (done) return;\n                value1 = result.value;\n                if (callWithSafeIterationClosing(iterator, predicate, [\n                    value1,\n                    this.counter++\n                ], true)) return value1;\n            }\n        });\n        $({\n            target: \"Iterator\",\n            proto: true,\n            real: true,\n            forced: FORCED\n        }, {\n            filter: function filter(predicate) {\n                anObject(this);\n                try {\n                    aCallable(predicate);\n                } catch (error) {\n                    iteratorClose(this, \"throw\", error);\n                }\n                if (filterWithoutClosingOnEarlyError) return call(filterWithoutClosingOnEarlyError, this, predicate);\n                return new IteratorProxy(getIteratorDirect(this), {\n                    predicate\n                });\n            }\n        });\n    },\n    /***/ 2529: /***/ (module2)=>{\n        module2.exports = function(value1, done) {\n            return {\n                value: value1,\n                done\n            };\n        };\n    },\n    /***/ 2603: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var toString = __webpack_require__2(655);\n        module2.exports = function(argument, $default) {\n            return argument === void 0 ? arguments.length < 2 ? \"\" : $default : toString(argument);\n        };\n    },\n    /***/ 2652: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var bind = __webpack_require__2(6080);\n        var call = __webpack_require__2(9565);\n        var anObject = __webpack_require__2(8551);\n        var tryToString = __webpack_require__2(6823);\n        var isArrayIteratorMethod = __webpack_require__2(4209);\n        var lengthOfArrayLike = __webpack_require__2(6198);\n        var isPrototypeOf = __webpack_require__2(1625);\n        var getIterator = __webpack_require__2(81);\n        var getIteratorMethod = __webpack_require__2(851);\n        var iteratorClose = __webpack_require__2(9539);\n        var $TypeError = TypeError;\n        var Result = function(stopped, result) {\n            this.stopped = stopped;\n            this.result = result;\n        };\n        var ResultPrototype = Result.prototype;\n        module2.exports = function(iterable, unboundFunction, options) {\n            var that = options && options.that;\n            var AS_ENTRIES = !!(options && options.AS_ENTRIES);\n            var IS_RECORD = !!(options && options.IS_RECORD);\n            var IS_ITERATOR = !!(options && options.IS_ITERATOR);\n            var INTERRUPTED = !!(options && options.INTERRUPTED);\n            var fn = bind(unboundFunction, that);\n            var iterator, iterFn, index, length, result, next, step;\n            var stop = function(condition) {\n                if (iterator) iteratorClose(iterator, \"normal\");\n                return new Result(true, condition);\n            };\n            var callFn = function(value1) {\n                if (AS_ENTRIES) {\n                    anObject(value1);\n                    return INTERRUPTED ? fn(value1[0], value1[1], stop) : fn(value1[0], value1[1]);\n                }\n                return INTERRUPTED ? fn(value1, stop) : fn(value1);\n            };\n            if (IS_RECORD) {\n                iterator = iterable.iterator;\n            } else if (IS_ITERATOR) {\n                iterator = iterable;\n            } else {\n                iterFn = getIteratorMethod(iterable);\n                if (!iterFn) throw new $TypeError(tryToString(iterable) + \" is not iterable\");\n                if (isArrayIteratorMethod(iterFn)) {\n                    for(index = 0, length = lengthOfArrayLike(iterable); length > index; index++){\n                        result = callFn(iterable[index]);\n                        if (result && isPrototypeOf(ResultPrototype, result)) return result;\n                    }\n                    return new Result(false);\n                }\n                iterator = getIterator(iterable, iterFn);\n            }\n            next = IS_RECORD ? iterable.next : iterator.next;\n            while(!(step = call(next, iterator)).done){\n                try {\n                    result = callFn(step.value);\n                } catch (error) {\n                    iteratorClose(iterator, \"throw\", error);\n                }\n                if (typeof result == \"object\" && result && isPrototypeOf(ResultPrototype, result)) return result;\n            }\n            return new Result(false);\n        };\n    },\n    /***/ 2777: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var call = __webpack_require__2(9565);\n        var isObject = __webpack_require__2(34);\n        var isSymbol = __webpack_require__2(757);\n        var getMethod = __webpack_require__2(5966);\n        var ordinaryToPrimitive = __webpack_require__2(4270);\n        var wellKnownSymbol = __webpack_require__2(8227);\n        var $TypeError = TypeError;\n        var TO_PRIMITIVE = wellKnownSymbol(\"toPrimitive\");\n        module2.exports = function(input, pref) {\n            if (!isObject(input) || isSymbol(input)) return input;\n            var exoticToPrim = getMethod(input, TO_PRIMITIVE);\n            var result;\n            if (exoticToPrim) {\n                if (pref === void 0) pref = \"default\";\n                result = call(exoticToPrim, input, pref);\n                if (!isObject(result) || isSymbol(result)) return result;\n                throw new $TypeError(\"Can't convert object to primitive value\");\n            }\n            if (pref === void 0) pref = \"number\";\n            return ordinaryToPrimitive(input, pref);\n        };\n    },\n    /***/ 2787: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var hasOwn = __webpack_require__2(9297);\n        var isCallable = __webpack_require__2(4901);\n        var toObject = __webpack_require__2(8981);\n        var sharedKey = __webpack_require__2(6119);\n        var CORRECT_PROTOTYPE_GETTER = __webpack_require__2(2211);\n        var IE_PROTO = sharedKey(\"IE_PROTO\");\n        var $Object = Object;\n        var ObjectPrototype = $Object.prototype;\n        module2.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(O) {\n            var object = toObject(O);\n            if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];\n            var constructor = object.constructor;\n            if (isCallable(constructor) && object instanceof constructor) {\n                return constructor.prototype;\n            }\n            return object instanceof $Object ? ObjectPrototype : null;\n        };\n    },\n    /***/ 2796: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var fails = __webpack_require__2(9039);\n        var isCallable = __webpack_require__2(4901);\n        var replacement = /#|\\.prototype\\./;\n        var isForced = function(feature, detection) {\n            var value1 = data[normalize(feature)];\n            return value1 === POLYFILL ? true : value1 === NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;\n        };\n        var normalize = isForced.normalize = function(string) {\n            return String(string).replace(replacement, \".\").toLowerCase();\n        };\n        var data = isForced.data = {};\n        var NATIVE = isForced.NATIVE = \"N\";\n        var POLYFILL = isForced.POLYFILL = \"P\";\n        module2.exports = isForced;\n    },\n    /***/ 2804: /***/ (module2)=>{\n        var commonAlphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n        var base64Alphabet = commonAlphabet + \"+/\";\n        var base64UrlAlphabet = commonAlphabet + \"-_\";\n        var inverse = function(characters) {\n            var result = {};\n            var index = 0;\n            for(; index < 64; index++)result[characters.charAt(index)] = index;\n            return result;\n        };\n        module2.exports = {\n            i2c: base64Alphabet,\n            c2i: inverse(base64Alphabet),\n            i2cUrl: base64UrlAlphabet,\n            c2iUrl: inverse(base64UrlAlphabet)\n        };\n    },\n    /***/ 2812: /***/ (module2)=>{\n        var $TypeError = TypeError;\n        module2.exports = function(passed, required) {\n            if (passed < required) throw new $TypeError(\"Not enough arguments\");\n            return passed;\n        };\n    },\n    /***/ 2839: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var globalThis2 = __webpack_require__2(4576);\n        var navigator2 = globalThis2.navigator;\n        var userAgent = navigator2 && navigator2.userAgent;\n        module2.exports = userAgent ? String(userAgent) : \"\";\n    },\n    /***/ 2967: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var uncurryThisAccessor = __webpack_require__2(6706);\n        var isObject = __webpack_require__2(34);\n        var requireObjectCoercible = __webpack_require__2(7750);\n        var aPossiblePrototype = __webpack_require__2(3506);\n        module2.exports = Object.setPrototypeOf || (\"__proto__\" in {} ? function() {\n            var CORRECT_SETTER = false;\n            var test = {};\n            var setter;\n            try {\n                setter = uncurryThisAccessor(Object.prototype, \"__proto__\", \"set\");\n                setter(test, []);\n                CORRECT_SETTER = test instanceof Array;\n            } catch (error) {}\n            return function setPrototypeOf(O, proto) {\n                requireObjectCoercible(O);\n                aPossiblePrototype(proto);\n                if (!isObject(O)) return O;\n                if (CORRECT_SETTER) setter(O, proto);\n                else O.__proto__ = proto;\n                return O;\n            };\n        }() : void 0);\n    },\n    /***/ 3068: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        var $ = __webpack_require__2(6518);\n        var uncurryThis = __webpack_require__2(9504);\n        var iterate = __webpack_require__2(2652);\n        var $RangeError = RangeError;\n        var $TypeError = TypeError;\n        var $Infinity = Infinity;\n        var $NaN = NaN;\n        var abs = Math.abs;\n        var pow = Math.pow;\n        var push = uncurryThis([].push);\n        var POW_2_1023 = pow(2, 1023);\n        var MAX_SAFE_INTEGER = pow(2, 53) - 1;\n        var MAX_DOUBLE = Number.MAX_VALUE;\n        var MAX_ULP = pow(2, 971);\n        var NOT_A_NUMBER = {};\n        var MINUS_INFINITY = {};\n        var PLUS_INFINITY = {};\n        var MINUS_ZERO = {};\n        var FINITE = {};\n        var twosum = function(x, y) {\n            var hi = x + y;\n            var lo = y - (hi - x);\n            return {\n                hi,\n                lo\n            };\n        };\n        $({\n            target: \"Math\",\n            stat: true\n        }, {\n            // eslint-disable-next-line max-statements -- ok\n            sumPrecise: function sumPrecise(items) {\n                var numbers = [];\n                var count = 0;\n                var state = MINUS_ZERO;\n                iterate(items, function(n2) {\n                    if (++count >= MAX_SAFE_INTEGER) throw new $RangeError(\"Maximum allowed index exceeded\");\n                    if (typeof n2 != \"number\") throw new $TypeError(\"Value is not a number\");\n                    if (state !== NOT_A_NUMBER) {\n                        if (n2 !== n2) state = NOT_A_NUMBER;\n                        else if (n2 === $Infinity) state = state === MINUS_INFINITY ? NOT_A_NUMBER : PLUS_INFINITY;\n                        else if (n2 === -$Infinity) state = state === PLUS_INFINITY ? NOT_A_NUMBER : MINUS_INFINITY;\n                        else if ((n2 !== 0 || 1 / n2 === $Infinity) && (state === MINUS_ZERO || state === FINITE)) {\n                            state = FINITE;\n                            push(numbers, n2);\n                        }\n                    }\n                });\n                switch(state){\n                    case NOT_A_NUMBER:\n                        return $NaN;\n                    case MINUS_INFINITY:\n                        return -$Infinity;\n                    case PLUS_INFINITY:\n                        return $Infinity;\n                    case MINUS_ZERO:\n                        return -0;\n                }\n                var partials = [];\n                var overflow = 0;\n                var x, y, sum, hi, lo, tmp;\n                for(var i = 0; i < numbers.length; i++){\n                    x = numbers[i];\n                    var actuallyUsedPartials = 0;\n                    for(var j = 0; j < partials.length; j++){\n                        y = partials[j];\n                        if (abs(x) < abs(y)) {\n                            tmp = x;\n                            x = y;\n                            y = tmp;\n                        }\n                        sum = twosum(x, y);\n                        hi = sum.hi;\n                        lo = sum.lo;\n                        if (abs(hi) === $Infinity) {\n                            var sign = hi === $Infinity ? 1 : -1;\n                            overflow += sign;\n                            x = x - sign * POW_2_1023 - sign * POW_2_1023;\n                            if (abs(x) < abs(y)) {\n                                tmp = x;\n                                x = y;\n                                y = tmp;\n                            }\n                            sum = twosum(x, y);\n                            hi = sum.hi;\n                            lo = sum.lo;\n                        }\n                        if (lo !== 0) partials[actuallyUsedPartials++] = lo;\n                        x = hi;\n                    }\n                    partials.length = actuallyUsedPartials;\n                    if (x !== 0) push(partials, x);\n                }\n                var n = partials.length - 1;\n                hi = 0;\n                lo = 0;\n                if (overflow !== 0) {\n                    var next = n >= 0 ? partials[n] : 0;\n                    n--;\n                    if (abs(overflow) > 1 || overflow > 0 && next > 0 || overflow < 0 && next < 0) {\n                        return overflow > 0 ? $Infinity : -$Infinity;\n                    }\n                    sum = twosum(overflow * POW_2_1023, next / 2);\n                    hi = sum.hi;\n                    lo = sum.lo;\n                    lo *= 2;\n                    if (abs(2 * hi) === $Infinity) {\n                        if (hi > 0) {\n                            return hi === POW_2_1023 && lo === -(MAX_ULP / 2) && n >= 0 && partials[n] < 0 ? MAX_DOUBLE : $Infinity;\n                        }\n                        return hi === -POW_2_1023 && lo === MAX_ULP / 2 && n >= 0 && partials[n] > 0 ? -MAX_DOUBLE : -$Infinity;\n                    }\n                    if (lo !== 0) {\n                        partials[++n] = lo;\n                        lo = 0;\n                    }\n                    hi *= 2;\n                }\n                while(n >= 0){\n                    sum = twosum(hi, partials[n--]);\n                    hi = sum.hi;\n                    lo = sum.lo;\n                    if (lo !== 0) break;\n                }\n                if (n >= 0 && (lo < 0 && partials[n] < 0 || lo > 0 && partials[n] > 0)) {\n                    y = lo * 2;\n                    x = hi + y;\n                    if (y === x - hi) hi = x;\n                }\n                return hi;\n            }\n        });\n    },\n    /***/ 3167: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var isCallable = __webpack_require__2(4901);\n        var isObject = __webpack_require__2(34);\n        var setPrototypeOf = __webpack_require__2(2967);\n        module2.exports = function($this, dummy, Wrapper) {\n            var NewTarget, NewTargetPrototype;\n            if (// it can work only with native `setPrototypeOf`\n            setPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this\n            isCallable(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype) setPrototypeOf($this, NewTargetPrototype);\n            return $this;\n        };\n    },\n    /***/ 3238: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var globalThis2 = __webpack_require__2(4576);\n        var NATIVE_ARRAY_BUFFER = __webpack_require__2(7811);\n        var arrayBufferByteLength = __webpack_require__2(7394);\n        var DataView2 = globalThis2.DataView;\n        module2.exports = function(O) {\n            if (!NATIVE_ARRAY_BUFFER || arrayBufferByteLength(O) !== 0) return false;\n            try {\n                new DataView2(O);\n                return false;\n            } catch (error) {\n                return true;\n            }\n        };\n    },\n    /***/ 3392: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var uncurryThis = __webpack_require__2(9504);\n        var id = 0;\n        var postfix = Math.random();\n        var toString = uncurryThis(1.1.toString);\n        module2.exports = function(key) {\n            return \"Symbol(\" + (key === void 0 ? \"\" : key) + \")_\" + toString(++id + postfix, 36);\n        };\n    },\n    /***/ 3440: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var aSet = __webpack_require__2(7080);\n        var SetHelpers = __webpack_require__2(4402);\n        var clone = __webpack_require__2(9286);\n        var size = __webpack_require__2(5170);\n        var getSetRecord = __webpack_require__2(3789);\n        var iterateSet = __webpack_require__2(8469);\n        var iterateSimple = __webpack_require__2(507);\n        var has = SetHelpers.has;\n        var remove = SetHelpers.remove;\n        module2.exports = function difference(other) {\n            var O = aSet(this);\n            var otherRec = getSetRecord(other);\n            var result = clone(O);\n            if (size(O) <= otherRec.size) iterateSet(O, function(e) {\n                if (otherRec.includes(e)) remove(result, e);\n            });\n            else iterateSimple(otherRec.getIterator(), function(e) {\n                if (has(result, e)) remove(result, e);\n            });\n            return result;\n        };\n    },\n    /***/ 3463: /***/ (module2)=>{\n        var $TypeError = TypeError;\n        module2.exports = function(argument) {\n            if (typeof argument == \"string\") return argument;\n            throw new $TypeError(\"Argument is not a string\");\n        };\n    },\n    /***/ 3506: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var isPossiblePrototype = __webpack_require__2(3925);\n        var $String = String;\n        var $TypeError = TypeError;\n        module2.exports = function(argument) {\n            if (isPossiblePrototype(argument)) return argument;\n            throw new $TypeError(\"Can't set \" + $String(argument) + \" as a prototype\");\n        };\n    },\n    /***/ 3579: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        var $ = __webpack_require__2(6518);\n        var call = __webpack_require__2(9565);\n        var iterate = __webpack_require__2(2652);\n        var aCallable = __webpack_require__2(9306);\n        var anObject = __webpack_require__2(8551);\n        var getIteratorDirect = __webpack_require__2(1767);\n        var iteratorClose = __webpack_require__2(9539);\n        var iteratorHelperWithoutClosingOnEarlyError = __webpack_require__2(4549);\n        var someWithoutClosingOnEarlyError = iteratorHelperWithoutClosingOnEarlyError(\"some\", TypeError);\n        $({\n            target: \"Iterator\",\n            proto: true,\n            real: true,\n            forced: someWithoutClosingOnEarlyError\n        }, {\n            some: function some(predicate) {\n                anObject(this);\n                try {\n                    aCallable(predicate);\n                } catch (error) {\n                    iteratorClose(this, \"throw\", error);\n                }\n                if (someWithoutClosingOnEarlyError) return call(someWithoutClosingOnEarlyError, this, predicate);\n                var record = getIteratorDirect(this);\n                var counter = 0;\n                return iterate(record, function(value1, stop) {\n                    if (predicate(value1, counter++)) return stop();\n                }, {\n                    IS_RECORD: true,\n                    INTERRUPTED: true\n                }).stopped;\n            }\n        });\n    },\n    /***/ 3650: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var aSet = __webpack_require__2(7080);\n        var SetHelpers = __webpack_require__2(4402);\n        var clone = __webpack_require__2(9286);\n        var getSetRecord = __webpack_require__2(3789);\n        var iterateSimple = __webpack_require__2(507);\n        var add = SetHelpers.add;\n        var has = SetHelpers.has;\n        var remove = SetHelpers.remove;\n        module2.exports = function symmetricDifference(other) {\n            var O = aSet(this);\n            var keysIter = getSetRecord(other).getIterator();\n            var result = clone(O);\n            iterateSimple(keysIter, function(e) {\n                if (has(O, e)) remove(result, e);\n                else add(result, e);\n            });\n            return result;\n        };\n    },\n    /***/ 3706: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var uncurryThis = __webpack_require__2(9504);\n        var isCallable = __webpack_require__2(4901);\n        var store = __webpack_require__2(7629);\n        var functionToString = uncurryThis(Function.toString);\n        if (!isCallable(store.inspectSource)) {\n            store.inspectSource = function(it) {\n                return functionToString(it);\n            };\n        }\n        module2.exports = store.inspectSource;\n    },\n    /***/ 3717: /***/ (__unused_webpack_module, exports2)=>{\n        exports2.f = Object.getOwnPropertySymbols;\n    },\n    /***/ 3724: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var fails = __webpack_require__2(9039);\n        module2.exports = !fails(function() {\n            return Object.defineProperty({}, 1, {\n                get: function() {\n                    return 7;\n                }\n            })[1] !== 7;\n        });\n    },\n    /***/ 3789: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var aCallable = __webpack_require__2(9306);\n        var anObject = __webpack_require__2(8551);\n        var call = __webpack_require__2(9565);\n        var toIntegerOrInfinity = __webpack_require__2(1291);\n        var getIteratorDirect = __webpack_require__2(1767);\n        var INVALID_SIZE = \"Invalid size\";\n        var $RangeError = RangeError;\n        var $TypeError = TypeError;\n        var max = Math.max;\n        var SetRecord = function(set, intSize) {\n            this.set = set;\n            this.size = max(intSize, 0);\n            this.has = aCallable(set.has);\n            this.keys = aCallable(set.keys);\n        };\n        SetRecord.prototype = {\n            getIterator: function() {\n                return getIteratorDirect(anObject(call(this.keys, this.set)));\n            },\n            includes: function(it) {\n                return call(this.has, this.set, it);\n            }\n        };\n        module2.exports = function(obj) {\n            anObject(obj);\n            var numSize = +obj.size;\n            if (numSize !== numSize) throw new $TypeError(INVALID_SIZE);\n            var intSize = toIntegerOrInfinity(numSize);\n            if (intSize < 0) throw new $RangeError(INVALID_SIZE);\n            return new SetRecord(obj, intSize);\n        };\n    },\n    /***/ 3838: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var aSet = __webpack_require__2(7080);\n        var size = __webpack_require__2(5170);\n        var iterate = __webpack_require__2(8469);\n        var getSetRecord = __webpack_require__2(3789);\n        module2.exports = function isSubsetOf(other) {\n            var O = aSet(this);\n            var otherRec = getSetRecord(other);\n            if (size(O) > otherRec.size) return false;\n            return iterate(O, function(e) {\n                if (!otherRec.includes(e)) return false;\n            }, true) !== false;\n        };\n    },\n    /***/ 3853: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        var $ = __webpack_require__2(6518);\n        var isDisjointFrom = __webpack_require__2(4449);\n        var setMethodAcceptSetLike = __webpack_require__2(4916);\n        var INCORRECT = !setMethodAcceptSetLike(\"isDisjointFrom\", function(result) {\n            return !result;\n        });\n        $({\n            target: \"Set\",\n            proto: true,\n            real: true,\n            forced: INCORRECT\n        }, {\n            isDisjointFrom\n        });\n    },\n    /***/ 3925: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var isObject = __webpack_require__2(34);\n        module2.exports = function(argument) {\n            return isObject(argument) || argument === null;\n        };\n    },\n    /***/ 3972: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var isObject = __webpack_require__2(34);\n        var $String = String;\n        var $TypeError = TypeError;\n        module2.exports = function(argument) {\n            if (argument === void 0 || isObject(argument)) return argument;\n            throw new $TypeError($String(argument) + \" is not an object or undefined\");\n        };\n    },\n    /***/ 4055: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var globalThis2 = __webpack_require__2(4576);\n        var isObject = __webpack_require__2(34);\n        var document2 = globalThis2.document;\n        var EXISTS = isObject(document2) && isObject(document2.createElement);\n        module2.exports = function(it) {\n            return EXISTS ? document2.createElement(it) : {};\n        };\n    },\n    /***/ 4114: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        var $ = __webpack_require__2(6518);\n        var toObject = __webpack_require__2(8981);\n        var lengthOfArrayLike = __webpack_require__2(6198);\n        var setArrayLength = __webpack_require__2(4527);\n        var doesNotExceedSafeInteger = __webpack_require__2(6837);\n        var fails = __webpack_require__2(9039);\n        var INCORRECT_TO_LENGTH = fails(function() {\n            return [].push.call({\n                length: 4294967296\n            }, 1) !== 4294967297;\n        });\n        var properErrorOnNonWritableLength = function() {\n            try {\n                Object.defineProperty([], \"length\", {\n                    writable: false\n                }).push();\n            } catch (error) {\n                return error instanceof TypeError;\n            }\n        };\n        var FORCED = INCORRECT_TO_LENGTH || !properErrorOnNonWritableLength();\n        $({\n            target: \"Array\",\n            proto: true,\n            arity: 1,\n            forced: FORCED\n        }, {\n            // eslint-disable-next-line no-unused-vars -- required for `.length`\n            push: function push(item) {\n                var O = toObject(this);\n                var len = lengthOfArrayLike(O);\n                var argCount = arguments.length;\n                doesNotExceedSafeInteger(len + argCount);\n                for(var i = 0; i < argCount; i++){\n                    O[len] = arguments[i];\n                    len++;\n                }\n                setArrayLength(O, len);\n                return len;\n            }\n        });\n    },\n    /***/ 4117: /***/ (module2)=>{\n        module2.exports = function(it) {\n            return it === null || it === void 0;\n        };\n    },\n    /***/ 4149: /***/ (module2)=>{\n        var $RangeError = RangeError;\n        module2.exports = function(it) {\n            if (it === it) return it;\n            throw new $RangeError(\"NaN is not allowed\");\n        };\n    },\n    /***/ 4154: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var classof = __webpack_require__2(6955);\n        var $TypeError = TypeError;\n        module2.exports = function(argument) {\n            if (classof(argument) === \"Uint8Array\") return argument;\n            throw new $TypeError(\"Argument is not an Uint8Array\");\n        };\n    },\n    /***/ 4204: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var aSet = __webpack_require__2(7080);\n        var add = __webpack_require__2(4402).add;\n        var clone = __webpack_require__2(9286);\n        var getSetRecord = __webpack_require__2(3789);\n        var iterateSimple = __webpack_require__2(507);\n        module2.exports = function union(other) {\n            var O = aSet(this);\n            var keysIter = getSetRecord(other).getIterator();\n            var result = clone(O);\n            iterateSimple(keysIter, function(it) {\n                add(result, it);\n            });\n            return result;\n        };\n    },\n    /***/ 4209: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var wellKnownSymbol = __webpack_require__2(8227);\n        var Iterators = __webpack_require__2(6269);\n        var ITERATOR = wellKnownSymbol(\"iterator\");\n        var ArrayPrototype = Array.prototype;\n        module2.exports = function(it) {\n            return it !== void 0 && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);\n        };\n    },\n    /***/ 4215: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var globalThis2 = __webpack_require__2(4576);\n        var userAgent = __webpack_require__2(2839);\n        var classof = __webpack_require__2(2195);\n        var userAgentStartsWith = function(string) {\n            return userAgent.slice(0, string.length) === string;\n        };\n        module2.exports = function() {\n            if (userAgentStartsWith(\"Bun/\")) return \"BUN\";\n            if (userAgentStartsWith(\"Cloudflare-Workers\")) return \"CLOUDFLARE\";\n            if (userAgentStartsWith(\"Deno/\")) return \"DENO\";\n            if (userAgentStartsWith(\"Node.js/\")) return \"NODE\";\n            if (globalThis2.Bun && typeof Bun.version == \"string\") return \"BUN\";\n            if (globalThis2.Deno && typeof Deno.version == \"object\") return \"DENO\";\n            if (classof(globalThis2.process) === \"process\") return \"NODE\";\n            if (globalThis2.window && globalThis2.document) return \"BROWSER\";\n            return \"REST\";\n        }();\n    },\n    /***/ 4226: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        var $ = __webpack_require__2(6518);\n        var globalThis2 = __webpack_require__2(4576);\n        var aString = __webpack_require__2(3463);\n        var anUint8Array = __webpack_require__2(4154);\n        var notDetached = __webpack_require__2(5169);\n        var $fromHex = __webpack_require__2(2303);\n        if (globalThis2.Uint8Array) $({\n            target: \"Uint8Array\",\n            proto: true\n        }, {\n            setFromHex: function setFromHex(string) {\n                anUint8Array(this);\n                aString(string);\n                notDetached(this.buffer);\n                var read = $fromHex(string, this).read;\n                return {\n                    read,\n                    written: read / 2\n                };\n            }\n        });\n    },\n    /***/ 4235: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        __webpack_require__2(3068);\n    },\n    /***/ 4270: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var call = __webpack_require__2(9565);\n        var isCallable = __webpack_require__2(4901);\n        var isObject = __webpack_require__2(34);\n        var $TypeError = TypeError;\n        module2.exports = function(input, pref) {\n            var fn, val;\n            if (pref === \"string\" && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;\n            if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;\n            if (pref !== \"string\" && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;\n            throw new $TypeError(\"Can't convert object to primitive value\");\n        };\n    },\n    /***/ 4376: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var classof = __webpack_require__2(2195);\n        module2.exports = Array.isArray || function isArray(argument) {\n            return classof(argument) === \"Array\";\n        };\n    },\n    /***/ 4402: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var uncurryThis = __webpack_require__2(9504);\n        var SetPrototype = Set.prototype;\n        module2.exports = {\n            // eslint-disable-next-line es/no-set -- safe\n            Set,\n            add: uncurryThis(SetPrototype.add),\n            has: uncurryThis(SetPrototype.has),\n            remove: uncurryThis(SetPrototype[\"delete\"]),\n            proto: SetPrototype\n        };\n    },\n    /***/ 4449: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var aSet = __webpack_require__2(7080);\n        var has = __webpack_require__2(4402).has;\n        var size = __webpack_require__2(5170);\n        var getSetRecord = __webpack_require__2(3789);\n        var iterateSet = __webpack_require__2(8469);\n        var iterateSimple = __webpack_require__2(507);\n        var iteratorClose = __webpack_require__2(9539);\n        module2.exports = function isDisjointFrom(other) {\n            var O = aSet(this);\n            var otherRec = getSetRecord(other);\n            if (size(O) <= otherRec.size) return iterateSet(O, function(e) {\n                if (otherRec.includes(e)) return false;\n            }, true) !== false;\n            var iterator = otherRec.getIterator();\n            return iterateSimple(iterator, function(e) {\n                if (has(O, e)) return iteratorClose(iterator, \"normal\", false);\n            }) !== false;\n        };\n    },\n    /***/ 4483: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var globalThis2 = __webpack_require__2(4576);\n        var getBuiltInNodeModule = __webpack_require__2(9429);\n        var PROPER_STRUCTURED_CLONE_TRANSFER = __webpack_require__2(1548);\n        var structuredClone2 = globalThis2.structuredClone;\n        var $ArrayBuffer = globalThis2.ArrayBuffer;\n        var $MessageChannel = globalThis2.MessageChannel;\n        var detach = false;\n        var WorkerThreads, channel, buffer, $detach;\n        if (PROPER_STRUCTURED_CLONE_TRANSFER) {\n            detach = function(transferable) {\n                structuredClone2(transferable, {\n                    transfer: [\n                        transferable\n                    ]\n                });\n            };\n        } else if ($ArrayBuffer) try {\n            if (!$MessageChannel) {\n                WorkerThreads = getBuiltInNodeModule(\"worker_threads\");\n                if (WorkerThreads) $MessageChannel = WorkerThreads.MessageChannel;\n            }\n            if ($MessageChannel) {\n                channel = new $MessageChannel();\n                buffer = new $ArrayBuffer(2);\n                $detach = function(transferable) {\n                    channel.port1.postMessage(null, [\n                        transferable\n                    ]);\n                };\n                if (buffer.byteLength === 2) {\n                    $detach(buffer);\n                    if (buffer.byteLength === 0) detach = $detach;\n                }\n            }\n        } catch (error) {}\n        module2.exports = detach;\n    },\n    /***/ 4495: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var V8_VERSION = __webpack_require__2(9519);\n        var fails = __webpack_require__2(9039);\n        var globalThis2 = __webpack_require__2(4576);\n        var $String = globalThis2.String;\n        module2.exports = !!Object.getOwnPropertySymbols && !fails(function() {\n            var symbol = Symbol(\"symbol detection\");\n            return !$String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n            !Symbol.sham && V8_VERSION && V8_VERSION < 41;\n        });\n    },\n    /***/ 4527: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var DESCRIPTORS = __webpack_require__2(3724);\n        var isArray = __webpack_require__2(4376);\n        var $TypeError = TypeError;\n        var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n        var SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS && !function() {\n            if (this !== void 0) return true;\n            try {\n                Object.defineProperty([], \"length\", {\n                    writable: false\n                }).length = 1;\n            } catch (error) {\n                return error instanceof TypeError;\n            }\n        }();\n        module2.exports = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function(O, length) {\n            if (isArray(O) && !getOwnPropertyDescriptor(O, \"length\").writable) {\n                throw new $TypeError(\"Cannot set read only .length\");\n            }\n            return O.length = length;\n        } : function(O, length) {\n            return O.length = length;\n        };\n    },\n    /***/ 4549: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var globalThis2 = __webpack_require__2(4576);\n        module2.exports = function(METHOD_NAME, ExpectedError) {\n            var Iterator2 = globalThis2.Iterator;\n            var IteratorPrototype = Iterator2 && Iterator2.prototype;\n            var method = IteratorPrototype && IteratorPrototype[METHOD_NAME];\n            var CLOSED = false;\n            if (method) try {\n                method.call({\n                    next: function() {\n                        return {\n                            done: true\n                        };\n                    },\n                    \"return\": function() {\n                        CLOSED = true;\n                    }\n                }, -1);\n            } catch (error) {\n                if (!(error instanceof ExpectedError)) CLOSED = false;\n            }\n            if (!CLOSED) return method;\n        };\n    },\n    /***/ 4576: /***/ function(module2) {\n        var check = function(it) {\n            return it && it.Math === Math && it;\n        };\n        module2.exports = check(typeof globalThis == \"object\" && globalThis) || check( false && 0) || // eslint-disable-next-line no-restricted-globals -- safe\n        check(typeof self == \"object\" && self) || check(typeof global == \"object\" && global) || check(typeof this == \"object\" && this) || // eslint-disable-next-line no-new-func -- fallback\n        /* @__PURE__ */ function() {\n            return this;\n        }() || Function(\"return this\")();\n    },\n    /***/ 4603: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        var defineBuiltIn = __webpack_require__2(6840);\n        var uncurryThis = __webpack_require__2(9504);\n        var toString = __webpack_require__2(655);\n        var validateArgumentsLength = __webpack_require__2(2812);\n        var $URLSearchParams = URLSearchParams;\n        var URLSearchParamsPrototype = $URLSearchParams.prototype;\n        var append = uncurryThis(URLSearchParamsPrototype.append);\n        var $delete = uncurryThis(URLSearchParamsPrototype[\"delete\"]);\n        var forEach = uncurryThis(URLSearchParamsPrototype.forEach);\n        var push = uncurryThis([].push);\n        var params = new $URLSearchParams(\"a=1&a=2&b=3\");\n        params[\"delete\"](\"a\", 1);\n        params[\"delete\"](\"b\", void 0);\n        if (params + \"\" !== \"a=2\") {\n            defineBuiltIn(URLSearchParamsPrototype, \"delete\", function(name) {\n                var length = arguments.length;\n                var $value = length < 2 ? void 0 : arguments[1];\n                if (length && $value === void 0) return $delete(this, name);\n                var entries = [];\n                forEach(this, function(v, k) {\n                    push(entries, {\n                        key: k,\n                        value: v\n                    });\n                });\n                validateArgumentsLength(length, 1);\n                var key = toString(name);\n                var value1 = toString($value);\n                var index = 0;\n                var dindex = 0;\n                var found = false;\n                var entriesLength = entries.length;\n                var entry;\n                while(index < entriesLength){\n                    entry = entries[index++];\n                    if (found || entry.key === key) {\n                        found = true;\n                        $delete(this, entry.key);\n                    } else dindex++;\n                }\n                while(dindex < entriesLength){\n                    entry = entries[dindex++];\n                    if (!(entry.key === key && entry.value === value1)) append(this, entry.key, entry.value);\n                }\n            }, {\n                enumerable: true,\n                unsafe: true\n            });\n        }\n    },\n    /***/ 4628: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        var $ = __webpack_require__2(6518);\n        var newPromiseCapabilityModule = __webpack_require__2(6043);\n        $({\n            target: \"Promise\",\n            stat: true\n        }, {\n            withResolvers: function withResolvers() {\n                var promiseCapability = newPromiseCapabilityModule.f(this);\n                return {\n                    promise: promiseCapability.promise,\n                    resolve: promiseCapability.resolve,\n                    reject: promiseCapability.reject\n                };\n            }\n        });\n    },\n    /***/ 4644: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var NATIVE_ARRAY_BUFFER = __webpack_require__2(7811);\n        var DESCRIPTORS = __webpack_require__2(3724);\n        var globalThis2 = __webpack_require__2(4576);\n        var isCallable = __webpack_require__2(4901);\n        var isObject = __webpack_require__2(34);\n        var hasOwn = __webpack_require__2(9297);\n        var classof = __webpack_require__2(6955);\n        var tryToString = __webpack_require__2(6823);\n        var createNonEnumerableProperty = __webpack_require__2(6699);\n        var defineBuiltIn = __webpack_require__2(6840);\n        var defineBuiltInAccessor = __webpack_require__2(2106);\n        var isPrototypeOf = __webpack_require__2(1625);\n        var getPrototypeOf = __webpack_require__2(2787);\n        var setPrototypeOf = __webpack_require__2(2967);\n        var wellKnownSymbol = __webpack_require__2(8227);\n        var uid = __webpack_require__2(3392);\n        var InternalStateModule = __webpack_require__2(1181);\n        var enforceInternalState = InternalStateModule.enforce;\n        var getInternalState = InternalStateModule.get;\n        var Int8Array2 = globalThis2.Int8Array;\n        var Int8ArrayPrototype = Int8Array2 && Int8Array2.prototype;\n        var Uint8ClampedArray2 = globalThis2.Uint8ClampedArray;\n        var Uint8ClampedArrayPrototype = Uint8ClampedArray2 && Uint8ClampedArray2.prototype;\n        var TypedArray = Int8Array2 && getPrototypeOf(Int8Array2);\n        var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);\n        var ObjectPrototype = Object.prototype;\n        var TypeError2 = globalThis2.TypeError;\n        var TO_STRING_TAG = wellKnownSymbol(\"toStringTag\");\n        var TYPED_ARRAY_TAG = uid(\"TYPED_ARRAY_TAG\");\n        var TYPED_ARRAY_CONSTRUCTOR = \"TypedArrayConstructor\";\n        var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(globalThis2.opera) !== \"Opera\";\n        var TYPED_ARRAY_TAG_REQUIRED = false;\n        var NAME, Constructor, Prototype;\n        var TypedArrayConstructorsList = {\n            Int8Array: 1,\n            Uint8Array: 1,\n            Uint8ClampedArray: 1,\n            Int16Array: 2,\n            Uint16Array: 2,\n            Int32Array: 4,\n            Uint32Array: 4,\n            Float32Array: 4,\n            Float64Array: 8\n        };\n        var BigIntArrayConstructorsList = {\n            BigInt64Array: 8,\n            BigUint64Array: 8\n        };\n        var isView = function isView2(it) {\n            if (!isObject(it)) return false;\n            var klass = classof(it);\n            return klass === \"DataView\" || hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);\n        };\n        var getTypedArrayConstructor = function(it) {\n            var proto = getPrototypeOf(it);\n            if (!isObject(proto)) return;\n            var state = getInternalState(proto);\n            return state && hasOwn(state, TYPED_ARRAY_CONSTRUCTOR) ? state[TYPED_ARRAY_CONSTRUCTOR] : getTypedArrayConstructor(proto);\n        };\n        var isTypedArray = function(it) {\n            if (!isObject(it)) return false;\n            var klass = classof(it);\n            return hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);\n        };\n        var aTypedArray = function(it) {\n            if (isTypedArray(it)) return it;\n            throw new TypeError2(\"Target is not a typed array\");\n        };\n        var aTypedArrayConstructor = function(C) {\n            if (isCallable(C) && (!setPrototypeOf || isPrototypeOf(TypedArray, C))) return C;\n            throw new TypeError2(tryToString(C) + \" is not a typed array constructor\");\n        };\n        var exportTypedArrayMethod = function(KEY, property, forced, options) {\n            if (!DESCRIPTORS) return;\n            if (forced) for(var ARRAY in TypedArrayConstructorsList){\n                var TypedArrayConstructor = globalThis2[ARRAY];\n                if (TypedArrayConstructor && hasOwn(TypedArrayConstructor.prototype, KEY)) try {\n                    delete TypedArrayConstructor.prototype[KEY];\n                } catch (error) {\n                    try {\n                        TypedArrayConstructor.prototype[KEY] = property;\n                    } catch (error2) {}\n                }\n            }\n            if (!TypedArrayPrototype[KEY] || forced) {\n                defineBuiltIn(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property, options);\n            }\n        };\n        var exportTypedArrayStaticMethod = function(KEY, property, forced) {\n            var ARRAY, TypedArrayConstructor;\n            if (!DESCRIPTORS) return;\n            if (setPrototypeOf) {\n                if (forced) for(ARRAY in TypedArrayConstructorsList){\n                    TypedArrayConstructor = globalThis2[ARRAY];\n                    if (TypedArrayConstructor && hasOwn(TypedArrayConstructor, KEY)) try {\n                        delete TypedArrayConstructor[KEY];\n                    } catch (error) {}\n                }\n                if (!TypedArray[KEY] || forced) {\n                    try {\n                        return defineBuiltIn(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);\n                    } catch (error) {}\n                } else return;\n            }\n            for(ARRAY in TypedArrayConstructorsList){\n                TypedArrayConstructor = globalThis2[ARRAY];\n                if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {\n                    defineBuiltIn(TypedArrayConstructor, KEY, property);\n                }\n            }\n        };\n        for(NAME in TypedArrayConstructorsList){\n            Constructor = globalThis2[NAME];\n            Prototype = Constructor && Constructor.prototype;\n            if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;\n            else NATIVE_ARRAY_BUFFER_VIEWS = false;\n        }\n        for(NAME in BigIntArrayConstructorsList){\n            Constructor = globalThis2[NAME];\n            Prototype = Constructor && Constructor.prototype;\n            if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;\n        }\n        if (!NATIVE_ARRAY_BUFFER_VIEWS || !isCallable(TypedArray) || TypedArray === Function.prototype) {\n            TypedArray = function TypedArray2() {\n                throw new TypeError2(\"Incorrect invocation\");\n            };\n            if (NATIVE_ARRAY_BUFFER_VIEWS) for(NAME in TypedArrayConstructorsList){\n                if (globalThis2[NAME]) setPrototypeOf(globalThis2[NAME], TypedArray);\n            }\n        }\n        if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {\n            TypedArrayPrototype = TypedArray.prototype;\n            if (NATIVE_ARRAY_BUFFER_VIEWS) for(NAME in TypedArrayConstructorsList){\n                if (globalThis2[NAME]) setPrototypeOf(globalThis2[NAME].prototype, TypedArrayPrototype);\n            }\n        }\n        if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {\n            setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);\n        }\n        if (DESCRIPTORS && !hasOwn(TypedArrayPrototype, TO_STRING_TAG)) {\n            TYPED_ARRAY_TAG_REQUIRED = true;\n            defineBuiltInAccessor(TypedArrayPrototype, TO_STRING_TAG, {\n                configurable: true,\n                get: function() {\n                    return isObject(this) ? this[TYPED_ARRAY_TAG] : void 0;\n                }\n            });\n            for(NAME in TypedArrayConstructorsList)if (globalThis2[NAME]) {\n                createNonEnumerableProperty(globalThis2[NAME], TYPED_ARRAY_TAG, NAME);\n            }\n        }\n        module2.exports = {\n            NATIVE_ARRAY_BUFFER_VIEWS,\n            TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG,\n            aTypedArray,\n            aTypedArrayConstructor,\n            exportTypedArrayMethod,\n            exportTypedArrayStaticMethod,\n            getTypedArrayConstructor,\n            isView,\n            isTypedArray,\n            TypedArray,\n            TypedArrayPrototype\n        };\n    },\n    /***/ 4659: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var DESCRIPTORS = __webpack_require__2(3724);\n        var definePropertyModule = __webpack_require__2(4913);\n        var createPropertyDescriptor = __webpack_require__2(6980);\n        module2.exports = function(object, key, value1) {\n            if (DESCRIPTORS) definePropertyModule.f(object, key, createPropertyDescriptor(0, value1));\n            else object[key] = value1;\n        };\n    },\n    /***/ 4901: /***/ (module2)=>{\n        var documentAll = typeof document == \"object\" && document.all;\n        module2.exports = typeof documentAll == \"undefined\" && documentAll !== void 0 ? function(argument) {\n            return typeof argument == \"function\" || argument === documentAll;\n        } : function(argument) {\n            return typeof argument == \"function\";\n        };\n    },\n    /***/ 4913: /***/ (__unused_webpack_module, exports2, __webpack_require__2)=>{\n        var DESCRIPTORS = __webpack_require__2(3724);\n        var IE8_DOM_DEFINE = __webpack_require__2(5917);\n        var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__2(8686);\n        var anObject = __webpack_require__2(8551);\n        var toPropertyKey = __webpack_require__2(6969);\n        var $TypeError = TypeError;\n        var $defineProperty = Object.defineProperty;\n        var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n        var ENUMERABLE = \"enumerable\";\n        var CONFIGURABLE = \"configurable\";\n        var WRITABLE = \"writable\";\n        exports2.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {\n            anObject(O);\n            P = toPropertyKey(P);\n            anObject(Attributes);\n            if (typeof O === \"function\" && P === \"prototype\" && \"value\" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n                var current = $getOwnPropertyDescriptor(O, P);\n                if (current && current[WRITABLE]) {\n                    O[P] = Attributes.value;\n                    Attributes = {\n                        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],\n                        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n                        writable: false\n                    };\n                }\n            }\n            return $defineProperty(O, P, Attributes);\n        } : $defineProperty : function defineProperty(O, P, Attributes) {\n            anObject(O);\n            P = toPropertyKey(P);\n            anObject(Attributes);\n            if (IE8_DOM_DEFINE) try {\n                return $defineProperty(O, P, Attributes);\n            } catch (error) {}\n            if (\"get\" in Attributes || \"set\" in Attributes) throw new $TypeError(\"Accessors not supported\");\n            if (\"value\" in Attributes) O[P] = Attributes.value;\n            return O;\n        };\n    },\n    /***/ 4916: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var getBuiltIn = __webpack_require__2(7751);\n        var createSetLike = function(size) {\n            return {\n                size,\n                has: function() {\n                    return false;\n                },\n                keys: function() {\n                    return {\n                        next: function() {\n                            return {\n                                done: true\n                            };\n                        }\n                    };\n                }\n            };\n        };\n        var createSetLikeWithInfinitySize = function(size) {\n            return {\n                size,\n                has: function() {\n                    return true;\n                },\n                keys: function() {\n                    throw new Error(\"e\");\n                }\n            };\n        };\n        module2.exports = function(name, callback) {\n            var Set2 = getBuiltIn(\"Set\");\n            try {\n                new Set2()[name](createSetLike(0));\n                try {\n                    new Set2()[name](createSetLike(-1));\n                    return false;\n                } catch (error2) {\n                    if (!callback) return true;\n                    try {\n                        new Set2()[name](createSetLikeWithInfinitySize(-Infinity));\n                        return false;\n                    } catch (error) {\n                        var set = new Set2();\n                        set.add(1);\n                        set.add(2);\n                        return callback(set[name](createSetLikeWithInfinitySize(Infinity)));\n                    }\n                }\n            } catch (error) {\n                return false;\n            }\n        };\n    },\n    /***/ 4972: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        var $ = __webpack_require__2(6518);\n        var call = __webpack_require__2(9565);\n        var anObject = __webpack_require__2(8551);\n        var getIteratorDirect = __webpack_require__2(1767);\n        var notANaN = __webpack_require__2(4149);\n        var toPositiveInteger = __webpack_require__2(9590);\n        var createIteratorProxy = __webpack_require__2(9462);\n        var iteratorClose = __webpack_require__2(9539);\n        var iteratorHelperWithoutClosingOnEarlyError = __webpack_require__2(4549);\n        var IS_PURE = __webpack_require__2(6395);\n        var takeWithoutClosingOnEarlyError = !IS_PURE && iteratorHelperWithoutClosingOnEarlyError(\"take\", RangeError);\n        var IteratorProxy = createIteratorProxy(function() {\n            var iterator = this.iterator;\n            if (!this.remaining--) {\n                this.done = true;\n                return iteratorClose(iterator, \"normal\", void 0);\n            }\n            var result = anObject(call(this.next, iterator));\n            var done = this.done = !!result.done;\n            if (!done) return result.value;\n        });\n        $({\n            target: \"Iterator\",\n            proto: true,\n            real: true,\n            forced: IS_PURE || takeWithoutClosingOnEarlyError\n        }, {\n            take: function take(limit) {\n                anObject(this);\n                var remaining;\n                try {\n                    remaining = toPositiveInteger(notANaN(+limit));\n                } catch (error) {\n                    iteratorClose(this, \"throw\", error);\n                }\n                if (takeWithoutClosingOnEarlyError) return call(takeWithoutClosingOnEarlyError, this, remaining);\n                return new IteratorProxy(getIteratorDirect(this), {\n                    remaining\n                });\n            }\n        });\n    },\n    /***/ 4979: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        var $ = __webpack_require__2(6518);\n        var globalThis2 = __webpack_require__2(4576);\n        var getBuiltIn = __webpack_require__2(7751);\n        var createPropertyDescriptor = __webpack_require__2(6980);\n        var defineProperty = __webpack_require__2(4913).f;\n        var hasOwn = __webpack_require__2(9297);\n        var anInstance = __webpack_require__2(679);\n        var inheritIfRequired = __webpack_require__2(3167);\n        var normalizeStringArgument = __webpack_require__2(2603);\n        var DOMExceptionConstants = __webpack_require__2(5002);\n        var clearErrorStack = __webpack_require__2(8574);\n        var DESCRIPTORS = __webpack_require__2(3724);\n        var IS_PURE = __webpack_require__2(6395);\n        var DOM_EXCEPTION = \"DOMException\";\n        var Error2 = getBuiltIn(\"Error\");\n        var NativeDOMException = getBuiltIn(DOM_EXCEPTION);\n        var $DOMException = function DOMException() {\n            anInstance(this, DOMExceptionPrototype);\n            var argumentsLength = arguments.length;\n            var message = normalizeStringArgument(argumentsLength < 1 ? void 0 : arguments[0]);\n            var name = normalizeStringArgument(argumentsLength < 2 ? void 0 : arguments[1], \"Error\");\n            var that = new NativeDOMException(message, name);\n            var error = new Error2(message);\n            error.name = DOM_EXCEPTION;\n            defineProperty(that, \"stack\", createPropertyDescriptor(1, clearErrorStack(error.stack, 1)));\n            inheritIfRequired(that, this, $DOMException);\n            return that;\n        };\n        var DOMExceptionPrototype = $DOMException.prototype = NativeDOMException.prototype;\n        var ERROR_HAS_STACK = \"stack\" in new Error2(DOM_EXCEPTION);\n        var DOM_EXCEPTION_HAS_STACK = \"stack\" in new NativeDOMException(1, 2);\n        var descriptor = NativeDOMException && DESCRIPTORS && Object.getOwnPropertyDescriptor(globalThis2, DOM_EXCEPTION);\n        var BUGGY_DESCRIPTOR = !!descriptor && !(descriptor.writable && descriptor.configurable);\n        var FORCED_CONSTRUCTOR = ERROR_HAS_STACK && !BUGGY_DESCRIPTOR && !DOM_EXCEPTION_HAS_STACK;\n        $({\n            global: true,\n            constructor: true,\n            forced: IS_PURE || FORCED_CONSTRUCTOR\n        }, {\n            // TODO: fix export logic\n            DOMException: FORCED_CONSTRUCTOR ? $DOMException : NativeDOMException\n        });\n        var PolyfilledDOMException = getBuiltIn(DOM_EXCEPTION);\n        var PolyfilledDOMExceptionPrototype = PolyfilledDOMException.prototype;\n        if (PolyfilledDOMExceptionPrototype.constructor !== PolyfilledDOMException) {\n            if (!IS_PURE) {\n                defineProperty(PolyfilledDOMExceptionPrototype, \"constructor\", createPropertyDescriptor(1, PolyfilledDOMException));\n            }\n            for(var key in DOMExceptionConstants)if (hasOwn(DOMExceptionConstants, key)) {\n                var constant = DOMExceptionConstants[key];\n                var constantName = constant.s;\n                if (!hasOwn(PolyfilledDOMException, constantName)) {\n                    defineProperty(PolyfilledDOMException, constantName, createPropertyDescriptor(6, constant.c));\n                }\n            }\n        }\n    },\n    /***/ 5002: /***/ (module2)=>{\n        module2.exports = {\n            IndexSizeError: {\n                s: \"INDEX_SIZE_ERR\",\n                c: 1,\n                m: 1\n            },\n            DOMStringSizeError: {\n                s: \"DOMSTRING_SIZE_ERR\",\n                c: 2,\n                m: 0\n            },\n            HierarchyRequestError: {\n                s: \"HIERARCHY_REQUEST_ERR\",\n                c: 3,\n                m: 1\n            },\n            WrongDocumentError: {\n                s: \"WRONG_DOCUMENT_ERR\",\n                c: 4,\n                m: 1\n            },\n            InvalidCharacterError: {\n                s: \"INVALID_CHARACTER_ERR\",\n                c: 5,\n                m: 1\n            },\n            NoDataAllowedError: {\n                s: \"NO_DATA_ALLOWED_ERR\",\n                c: 6,\n                m: 0\n            },\n            NoModificationAllowedError: {\n                s: \"NO_MODIFICATION_ALLOWED_ERR\",\n                c: 7,\n                m: 1\n            },\n            NotFoundError: {\n                s: \"NOT_FOUND_ERR\",\n                c: 8,\n                m: 1\n            },\n            NotSupportedError: {\n                s: \"NOT_SUPPORTED_ERR\",\n                c: 9,\n                m: 1\n            },\n            InUseAttributeError: {\n                s: \"INUSE_ATTRIBUTE_ERR\",\n                c: 10,\n                m: 1\n            },\n            InvalidStateError: {\n                s: \"INVALID_STATE_ERR\",\n                c: 11,\n                m: 1\n            },\n            SyntaxError: {\n                s: \"SYNTAX_ERR\",\n                c: 12,\n                m: 1\n            },\n            InvalidModificationError: {\n                s: \"INVALID_MODIFICATION_ERR\",\n                c: 13,\n                m: 1\n            },\n            NamespaceError: {\n                s: \"NAMESPACE_ERR\",\n                c: 14,\n                m: 1\n            },\n            InvalidAccessError: {\n                s: \"INVALID_ACCESS_ERR\",\n                c: 15,\n                m: 1\n            },\n            ValidationError: {\n                s: \"VALIDATION_ERR\",\n                c: 16,\n                m: 0\n            },\n            TypeMismatchError: {\n                s: \"TYPE_MISMATCH_ERR\",\n                c: 17,\n                m: 1\n            },\n            SecurityError: {\n                s: \"SECURITY_ERR\",\n                c: 18,\n                m: 1\n            },\n            NetworkError: {\n                s: \"NETWORK_ERR\",\n                c: 19,\n                m: 1\n            },\n            AbortError: {\n                s: \"ABORT_ERR\",\n                c: 20,\n                m: 1\n            },\n            URLMismatchError: {\n                s: \"URL_MISMATCH_ERR\",\n                c: 21,\n                m: 1\n            },\n            QuotaExceededError: {\n                s: \"QUOTA_EXCEEDED_ERR\",\n                c: 22,\n                m: 1\n            },\n            TimeoutError: {\n                s: \"TIMEOUT_ERR\",\n                c: 23,\n                m: 1\n            },\n            InvalidNodeTypeError: {\n                s: \"INVALID_NODE_TYPE_ERR\",\n                c: 24,\n                m: 1\n            },\n            DataCloneError: {\n                s: \"DATA_CLONE_ERR\",\n                c: 25,\n                m: 1\n            }\n        };\n    },\n    /***/ 5024: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        var $ = __webpack_require__2(6518);\n        var symmetricDifference = __webpack_require__2(3650);\n        var setMethodGetKeysBeforeCloning = __webpack_require__2(9835);\n        var setMethodAcceptSetLike = __webpack_require__2(4916);\n        var FORCED = !setMethodAcceptSetLike(\"symmetricDifference\") || !setMethodGetKeysBeforeCloning(\"symmetricDifference\");\n        $({\n            target: \"Set\",\n            proto: true,\n            real: true,\n            forced: FORCED\n        }, {\n            symmetricDifference\n        });\n    },\n    /***/ 5031: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var getBuiltIn = __webpack_require__2(7751);\n        var uncurryThis = __webpack_require__2(9504);\n        var getOwnPropertyNamesModule = __webpack_require__2(8480);\n        var getOwnPropertySymbolsModule = __webpack_require__2(3717);\n        var anObject = __webpack_require__2(8551);\n        var concat = uncurryThis([].concat);\n        module2.exports = getBuiltIn(\"Reflect\", \"ownKeys\") || function ownKeys(it) {\n            var keys = getOwnPropertyNamesModule.f(anObject(it));\n            var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n            return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;\n        };\n    },\n    /***/ 5169: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var isDetached = __webpack_require__2(3238);\n        var $TypeError = TypeError;\n        module2.exports = function(it) {\n            if (isDetached(it)) throw new $TypeError(\"ArrayBuffer is detached\");\n            return it;\n        };\n    },\n    /***/ 5170: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var uncurryThisAccessor = __webpack_require__2(6706);\n        var SetHelpers = __webpack_require__2(4402);\n        module2.exports = uncurryThisAccessor(SetHelpers.proto, \"size\", \"get\") || function(set) {\n            return set.size;\n        };\n    },\n    /***/ 5213: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        var $ = __webpack_require__2(6518);\n        var globalThis2 = __webpack_require__2(4576);\n        var arrayFromConstructorAndList = __webpack_require__2(5370);\n        var $fromBase64 = __webpack_require__2(9143);\n        var Uint8Array2 = globalThis2.Uint8Array;\n        var INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS = !Uint8Array2 || !Uint8Array2.fromBase64 || !function() {\n            try {\n                Uint8Array2.fromBase64(\"a\");\n                return;\n            } catch (error) {}\n            try {\n                Uint8Array2.fromBase64(\"\", null);\n            } catch (error) {\n                return true;\n            }\n        }();\n        if (Uint8Array2) $({\n            target: \"Uint8Array\",\n            stat: true,\n            forced: INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS\n        }, {\n            fromBase64: function fromBase64(string) {\n                var result = $fromBase64(string, arguments.length > 1 ? arguments[1] : void 0, null, 9007199254740991);\n                return arrayFromConstructorAndList(Uint8Array2, result.bytes);\n            }\n        });\n    },\n    /***/ 5370: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var lengthOfArrayLike = __webpack_require__2(6198);\n        module2.exports = function(Constructor, list, $length) {\n            var index = 0;\n            var length = arguments.length > 2 ? $length : lengthOfArrayLike(list);\n            var result = new Constructor(length);\n            while(length > index)result[index] = list[index++];\n            return result;\n        };\n    },\n    /***/ 5397: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var IndexedObject = __webpack_require__2(7055);\n        var requireObjectCoercible = __webpack_require__2(7750);\n        module2.exports = function(it) {\n            return IndexedObject(requireObjectCoercible(it));\n        };\n    },\n    /***/ 5610: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var toIntegerOrInfinity = __webpack_require__2(1291);\n        var max = Math.max;\n        var min = Math.min;\n        module2.exports = function(index, length) {\n            var integer = toIntegerOrInfinity(index);\n            return integer < 0 ? max(integer + length, 0) : min(integer, length);\n        };\n    },\n    /***/ 5623: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        __webpack_require__2(456);\n    },\n    /***/ 5636: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var globalThis2 = __webpack_require__2(4576);\n        var uncurryThis = __webpack_require__2(9504);\n        var uncurryThisAccessor = __webpack_require__2(6706);\n        var toIndex = __webpack_require__2(7696);\n        var notDetached = __webpack_require__2(5169);\n        var arrayBufferByteLength = __webpack_require__2(7394);\n        var detachTransferable = __webpack_require__2(4483);\n        var PROPER_STRUCTURED_CLONE_TRANSFER = __webpack_require__2(1548);\n        var structuredClone2 = globalThis2.structuredClone;\n        var ArrayBuffer2 = globalThis2.ArrayBuffer;\n        var DataView2 = globalThis2.DataView;\n        var min = Math.min;\n        var ArrayBufferPrototype = ArrayBuffer2.prototype;\n        var DataViewPrototype = DataView2.prototype;\n        var slice = uncurryThis(ArrayBufferPrototype.slice);\n        var isResizable = uncurryThisAccessor(ArrayBufferPrototype, \"resizable\", \"get\");\n        var maxByteLength = uncurryThisAccessor(ArrayBufferPrototype, \"maxByteLength\", \"get\");\n        var getInt8 = uncurryThis(DataViewPrototype.getInt8);\n        var setInt8 = uncurryThis(DataViewPrototype.setInt8);\n        module2.exports = (PROPER_STRUCTURED_CLONE_TRANSFER || detachTransferable) && function(arrayBuffer, newLength, preserveResizability) {\n            var byteLength = arrayBufferByteLength(arrayBuffer);\n            var newByteLength = newLength === void 0 ? byteLength : toIndex(newLength);\n            var fixedLength = !isResizable || !isResizable(arrayBuffer);\n            var newBuffer;\n            notDetached(arrayBuffer);\n            if (PROPER_STRUCTURED_CLONE_TRANSFER) {\n                arrayBuffer = structuredClone2(arrayBuffer, {\n                    transfer: [\n                        arrayBuffer\n                    ]\n                });\n                if (byteLength === newByteLength && (preserveResizability || fixedLength)) return arrayBuffer;\n            }\n            if (byteLength >= newByteLength && (!preserveResizability || fixedLength)) {\n                newBuffer = slice(arrayBuffer, 0, newByteLength);\n            } else {\n                var options = preserveResizability && !fixedLength && maxByteLength ? {\n                    maxByteLength: maxByteLength(arrayBuffer)\n                } : void 0;\n                newBuffer = new ArrayBuffer2(newByteLength, options);\n                var a = new DataView2(arrayBuffer);\n                var b = new DataView2(newBuffer);\n                var copyLength = min(newByteLength, byteLength);\n                for(var i = 0; i < copyLength; i++)setInt8(b, i, getInt8(a, i));\n            }\n            if (!PROPER_STRUCTURED_CLONE_TRANSFER) detachTransferable(arrayBuffer);\n            return newBuffer;\n        };\n    },\n    /***/ 5745: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var store = __webpack_require__2(7629);\n        module2.exports = function(key, value1) {\n            return store[key] || (store[key] = value1 || {});\n        };\n    },\n    /***/ 5781: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        var $ = __webpack_require__2(6518);\n        var getBuiltIn = __webpack_require__2(7751);\n        var validateArgumentsLength = __webpack_require__2(2812);\n        var toString = __webpack_require__2(655);\n        var USE_NATIVE_URL = __webpack_require__2(7416);\n        var URL2 = getBuiltIn(\"URL\");\n        $({\n            target: \"URL\",\n            stat: true,\n            forced: !USE_NATIVE_URL\n        }, {\n            parse: function parse(url) {\n                var length = validateArgumentsLength(arguments.length, 1);\n                var urlString = toString(url);\n                var base = length < 2 || arguments[1] === void 0 ? void 0 : toString(arguments[1]);\n                try {\n                    return new URL2(urlString, base);\n                } catch (error) {\n                    return null;\n                }\n            }\n        });\n    },\n    /***/ 5854: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var toPrimitive = __webpack_require__2(2777);\n        var $TypeError = TypeError;\n        module2.exports = function(argument) {\n            var prim = toPrimitive(argument, \"number\");\n            if (typeof prim == \"number\") throw new $TypeError(\"Can't convert number to bigint\");\n            return BigInt(prim);\n        };\n    },\n    /***/ 5876: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        var $ = __webpack_require__2(6518);\n        var isSubsetOf = __webpack_require__2(3838);\n        var setMethodAcceptSetLike = __webpack_require__2(4916);\n        var INCORRECT = !setMethodAcceptSetLike(\"isSubsetOf\", function(result) {\n            return result;\n        });\n        $({\n            target: \"Set\",\n            proto: true,\n            real: true,\n            forced: INCORRECT\n        }, {\n            isSubsetOf\n        });\n    },\n    /***/ 5917: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var DESCRIPTORS = __webpack_require__2(3724);\n        var fails = __webpack_require__2(9039);\n        var createElement = __webpack_require__2(4055);\n        module2.exports = !DESCRIPTORS && !fails(function() {\n            return Object.defineProperty(createElement(\"div\"), \"a\", {\n                get: function() {\n                    return 7;\n                }\n            }).a !== 7;\n        });\n    },\n    /***/ 5966: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var aCallable = __webpack_require__2(9306);\n        var isNullOrUndefined = __webpack_require__2(4117);\n        module2.exports = function(V, P) {\n            var func = V[P];\n            return isNullOrUndefined(func) ? void 0 : aCallable(func);\n        };\n    },\n    /***/ 6043: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var aCallable = __webpack_require__2(9306);\n        var $TypeError = TypeError;\n        var PromiseCapability = function(C) {\n            var resolve, reject;\n            this.promise = new C(function($$resolve, $$reject) {\n                if (resolve !== void 0 || reject !== void 0) throw new $TypeError(\"Bad Promise constructor\");\n                resolve = $$resolve;\n                reject = $$reject;\n            });\n            this.resolve = aCallable(resolve);\n            this.reject = aCallable(reject);\n        };\n        module2.exports.f = function(C) {\n            return new PromiseCapability(C);\n        };\n    },\n    /***/ 6080: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var uncurryThis = __webpack_require__2(7476);\n        var aCallable = __webpack_require__2(9306);\n        var NATIVE_BIND = __webpack_require__2(616);\n        var bind = uncurryThis(uncurryThis.bind);\n        module2.exports = function(fn, that) {\n            aCallable(fn);\n            return that === void 0 ? fn : NATIVE_BIND ? bind(fn, that) : function() {\n                return fn.apply(that, arguments);\n            };\n        };\n    },\n    /***/ 6119: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var shared = __webpack_require__2(5745);\n        var uid = __webpack_require__2(3392);\n        var keys = shared(\"keys\");\n        module2.exports = function(key) {\n            return keys[key] || (keys[key] = uid(key));\n        };\n    },\n    /***/ 6193: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var ENVIRONMENT = __webpack_require__2(4215);\n        module2.exports = ENVIRONMENT === \"NODE\";\n    },\n    /***/ 6198: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var toLength = __webpack_require__2(8014);\n        module2.exports = function(obj) {\n            return toLength(obj.length);\n        };\n    },\n    /***/ 6269: /***/ (module2)=>{\n        module2.exports = {};\n    },\n    /***/ 6279: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var defineBuiltIn = __webpack_require__2(6840);\n        module2.exports = function(target, src, options) {\n            for(var key in src)defineBuiltIn(target, key, src[key], options);\n            return target;\n        };\n    },\n    /***/ 6319: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var anObject = __webpack_require__2(8551);\n        var iteratorClose = __webpack_require__2(9539);\n        module2.exports = function(iterator, fn, value1, ENTRIES) {\n            try {\n                return ENTRIES ? fn(anObject(value1)[0], value1[1]) : fn(value1);\n            } catch (error) {\n                iteratorClose(iterator, \"throw\", error);\n            }\n        };\n    },\n    /***/ 6395: /***/ (module2)=>{\n        module2.exports = false;\n    },\n    /***/ 6518: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var globalThis2 = __webpack_require__2(4576);\n        var getOwnPropertyDescriptor = __webpack_require__2(7347).f;\n        var createNonEnumerableProperty = __webpack_require__2(6699);\n        var defineBuiltIn = __webpack_require__2(6840);\n        var defineGlobalProperty = __webpack_require__2(9433);\n        var copyConstructorProperties = __webpack_require__2(7740);\n        var isForced = __webpack_require__2(2796);\n        module2.exports = function(options, source) {\n            var TARGET = options.target;\n            var GLOBAL = options.global;\n            var STATIC = options.stat;\n            var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n            if (GLOBAL) {\n                target = globalThis2;\n            } else if (STATIC) {\n                target = globalThis2[TARGET] || defineGlobalProperty(TARGET, {});\n            } else {\n                target = globalThis2[TARGET] && globalThis2[TARGET].prototype;\n            }\n            if (target) for(key in source){\n                sourceProperty = source[key];\n                if (options.dontCallGetSet) {\n                    descriptor = getOwnPropertyDescriptor(target, key);\n                    targetProperty = descriptor && descriptor.value;\n                } else targetProperty = target[key];\n                FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? \".\" : \"#\") + key, options.forced);\n                if (!FORCED && targetProperty !== void 0) {\n                    if (typeof sourceProperty == typeof targetProperty) continue;\n                    copyConstructorProperties(sourceProperty, targetProperty);\n                }\n                if (options.sham || targetProperty && targetProperty.sham) {\n                    createNonEnumerableProperty(sourceProperty, \"sham\", true);\n                }\n                defineBuiltIn(target, key, sourceProperty, options);\n            }\n        };\n    },\n    /***/ 6573: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        var DESCRIPTORS = __webpack_require__2(3724);\n        var defineBuiltInAccessor = __webpack_require__2(2106);\n        var isDetached = __webpack_require__2(3238);\n        var ArrayBufferPrototype = ArrayBuffer.prototype;\n        if (DESCRIPTORS && !(\"detached\" in ArrayBufferPrototype)) {\n            defineBuiltInAccessor(ArrayBufferPrototype, \"detached\", {\n                configurable: true,\n                get: function detached() {\n                    return isDetached(this);\n                }\n            });\n        }\n    },\n    /***/ 6632: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        var $ = __webpack_require__2(6518);\n        var globalThis2 = __webpack_require__2(4576);\n        var $fromBase64 = __webpack_require__2(9143);\n        var anUint8Array = __webpack_require__2(4154);\n        var Uint8Array2 = globalThis2.Uint8Array;\n        var INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS = !Uint8Array2 || !Uint8Array2.prototype.setFromBase64 || !function() {\n            var target = new Uint8Array2([\n                255,\n                255,\n                255,\n                255,\n                255\n            ]);\n            try {\n                target.setFromBase64(\"\", null);\n                return;\n            } catch (error) {}\n            try {\n                target.setFromBase64(\"a\");\n                return;\n            } catch (error) {}\n            try {\n                target.setFromBase64(\"MjYyZg===\");\n            } catch (error) {\n                return target[0] === 50 && target[1] === 54 && target[2] === 50 && target[3] === 255 && target[4] === 255;\n            }\n        }();\n        if (Uint8Array2) $({\n            target: \"Uint8Array\",\n            proto: true,\n            forced: INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS\n        }, {\n            setFromBase64: function setFromBase64(string) {\n                anUint8Array(this);\n                var result = $fromBase64(string, arguments.length > 1 ? arguments[1] : void 0, this, this.length);\n                return {\n                    read: result.read,\n                    written: result.written\n                };\n            }\n        });\n    },\n    /***/ 6699: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var DESCRIPTORS = __webpack_require__2(3724);\n        var definePropertyModule = __webpack_require__2(4913);\n        var createPropertyDescriptor = __webpack_require__2(6980);\n        module2.exports = DESCRIPTORS ? function(object, key, value1) {\n            return definePropertyModule.f(object, key, createPropertyDescriptor(1, value1));\n        } : function(object, key, value1) {\n            object[key] = value1;\n            return object;\n        };\n    },\n    /***/ 6706: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var uncurryThis = __webpack_require__2(9504);\n        var aCallable = __webpack_require__2(9306);\n        module2.exports = function(object, key, method) {\n            try {\n                return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));\n            } catch (error) {}\n        };\n    },\n    /***/ 6801: /***/ (__unused_webpack_module, exports2, __webpack_require__2)=>{\n        var DESCRIPTORS = __webpack_require__2(3724);\n        var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__2(8686);\n        var definePropertyModule = __webpack_require__2(4913);\n        var anObject = __webpack_require__2(8551);\n        var toIndexedObject = __webpack_require__2(5397);\n        var objectKeys = __webpack_require__2(1072);\n        exports2.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {\n            anObject(O);\n            var props = toIndexedObject(Properties);\n            var keys = objectKeys(Properties);\n            var length = keys.length;\n            var index = 0;\n            var key;\n            while(length > index)definePropertyModule.f(O, key = keys[index++], props[key]);\n            return O;\n        };\n    },\n    /***/ 6823: /***/ (module2)=>{\n        var $String = String;\n        module2.exports = function(argument) {\n            try {\n                return $String(argument);\n            } catch (error) {\n                return \"Object\";\n            }\n        };\n    },\n    /***/ 6837: /***/ (module2)=>{\n        var $TypeError = TypeError;\n        var MAX_SAFE_INTEGER = 9007199254740991;\n        module2.exports = function(it) {\n            if (it > MAX_SAFE_INTEGER) throw $TypeError(\"Maximum allowed index exceeded\");\n            return it;\n        };\n    },\n    /***/ 6840: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var isCallable = __webpack_require__2(4901);\n        var definePropertyModule = __webpack_require__2(4913);\n        var makeBuiltIn = __webpack_require__2(283);\n        var defineGlobalProperty = __webpack_require__2(9433);\n        module2.exports = function(O, key, value1, options) {\n            if (!options) options = {};\n            var simple = options.enumerable;\n            var name = options.name !== void 0 ? options.name : key;\n            if (isCallable(value1)) makeBuiltIn(value1, name, options);\n            if (options.global) {\n                if (simple) O[key] = value1;\n                else defineGlobalProperty(key, value1);\n            } else {\n                try {\n                    if (!options.unsafe) delete O[key];\n                    else if (O[key]) simple = true;\n                } catch (error) {}\n                if (simple) O[key] = value1;\n                else definePropertyModule.f(O, key, {\n                    value: value1,\n                    enumerable: false,\n                    configurable: !options.nonConfigurable,\n                    writable: !options.nonWritable\n                });\n            }\n            return O;\n        };\n    },\n    /***/ 6955: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var TO_STRING_TAG_SUPPORT = __webpack_require__2(2140);\n        var isCallable = __webpack_require__2(4901);\n        var classofRaw = __webpack_require__2(2195);\n        var wellKnownSymbol = __webpack_require__2(8227);\n        var TO_STRING_TAG = wellKnownSymbol(\"toStringTag\");\n        var $Object = Object;\n        var CORRECT_ARGUMENTS = classofRaw(/* @__PURE__ */ function() {\n            return arguments;\n        }()) === \"Arguments\";\n        var tryGet = function(it, key) {\n            try {\n                return it[key];\n            } catch (error) {}\n        };\n        module2.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {\n            var O, tag, result;\n            return it === void 0 ? \"Undefined\" : it === null ? \"Null\" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == \"string\" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) === \"Object\" && isCallable(O.callee) ? \"Arguments\" : result;\n        };\n    },\n    /***/ 6969: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var toPrimitive = __webpack_require__2(2777);\n        var isSymbol = __webpack_require__2(757);\n        module2.exports = function(argument) {\n            var key = toPrimitive(argument, \"string\");\n            return isSymbol(key) ? key : key + \"\";\n        };\n    },\n    /***/ 6980: /***/ (module2)=>{\n        module2.exports = function(bitmap, value1) {\n            return {\n                enumerable: !(bitmap & 1),\n                configurable: !(bitmap & 2),\n                writable: !(bitmap & 4),\n                value: value1\n            };\n        };\n    },\n    /***/ 7040: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var NATIVE_SYMBOL = __webpack_require__2(4495);\n        module2.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == \"symbol\";\n    },\n    /***/ 7055: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var uncurryThis = __webpack_require__2(9504);\n        var fails = __webpack_require__2(9039);\n        var classof = __webpack_require__2(2195);\n        var $Object = Object;\n        var split = uncurryThis(\"\".split);\n        module2.exports = fails(function() {\n            return !$Object(\"z\").propertyIsEnumerable(0);\n        }) ? function(it) {\n            return classof(it) === \"String\" ? split(it, \"\") : $Object(it);\n        } : $Object;\n    },\n    /***/ 7080: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var has = __webpack_require__2(4402).has;\n        module2.exports = function(it) {\n            has(it);\n            return it;\n        };\n    },\n    /***/ 7347: /***/ (__unused_webpack_module, exports2, __webpack_require__2)=>{\n        var DESCRIPTORS = __webpack_require__2(3724);\n        var call = __webpack_require__2(9565);\n        var propertyIsEnumerableModule = __webpack_require__2(8773);\n        var createPropertyDescriptor = __webpack_require__2(6980);\n        var toIndexedObject = __webpack_require__2(5397);\n        var toPropertyKey = __webpack_require__2(6969);\n        var hasOwn = __webpack_require__2(9297);\n        var IE8_DOM_DEFINE = __webpack_require__2(5917);\n        var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n        exports2.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n            O = toIndexedObject(O);\n            P = toPropertyKey(P);\n            if (IE8_DOM_DEFINE) try {\n                return $getOwnPropertyDescriptor(O, P);\n            } catch (error) {}\n            if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);\n        };\n    },\n    /***/ 7394: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var globalThis2 = __webpack_require__2(4576);\n        var uncurryThisAccessor = __webpack_require__2(6706);\n        var classof = __webpack_require__2(2195);\n        var ArrayBuffer2 = globalThis2.ArrayBuffer;\n        var TypeError2 = globalThis2.TypeError;\n        module2.exports = ArrayBuffer2 && uncurryThisAccessor(ArrayBuffer2.prototype, \"byteLength\", \"get\") || function(O) {\n            if (classof(O) !== \"ArrayBuffer\") throw new TypeError2(\"ArrayBuffer expected\");\n            return O.byteLength;\n        };\n    },\n    /***/ 7416: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var fails = __webpack_require__2(9039);\n        var wellKnownSymbol = __webpack_require__2(8227);\n        var DESCRIPTORS = __webpack_require__2(3724);\n        var IS_PURE = __webpack_require__2(6395);\n        var ITERATOR = wellKnownSymbol(\"iterator\");\n        module2.exports = !fails(function() {\n            var url = new URL(\"b?a=1&b=2&c=3\", \"https://a\");\n            var params = url.searchParams;\n            var params2 = new URLSearchParams(\"a=1&a=2&b=3\");\n            var result = \"\";\n            url.pathname = \"c%20d\";\n            params.forEach(function(value1, key) {\n                params[\"delete\"](\"b\");\n                result += key + value1;\n            });\n            params2[\"delete\"](\"a\", 2);\n            params2[\"delete\"](\"b\", void 0);\n            return IS_PURE && (!url.toJSON || !params2.has(\"a\", 1) || params2.has(\"a\", 2) || !params2.has(\"a\", void 0) || params2.has(\"b\")) || !params.size && (IS_PURE || !DESCRIPTORS) || !params.sort || url.href !== \"https://a/c%20d?a=1&c=3\" || params.get(\"c\") !== \"3\" || String(new URLSearchParams(\"?a=1\")) !== \"a=1\" || !params[ITERATOR] || new URL(\"https://a@b\").username !== \"a\" || new URLSearchParams(new URLSearchParams(\"a=b\")).get(\"a\") !== \"b\" || new URL(\"https://тест\").host !== \"xn--e1aybc\" || new URL(\"https://a#б\").hash !== \"#%D0%B1\" || result !== \"a1c3\" || new URL(\"https://x\", void 0).host !== \"x\";\n        });\n    },\n    /***/ 7476: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var classofRaw = __webpack_require__2(2195);\n        var uncurryThis = __webpack_require__2(9504);\n        module2.exports = function(fn) {\n            if (classofRaw(fn) === \"Function\") return uncurryThis(fn);\n        };\n    },\n    /***/ 7566: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        var defineBuiltIn = __webpack_require__2(6840);\n        var uncurryThis = __webpack_require__2(9504);\n        var toString = __webpack_require__2(655);\n        var validateArgumentsLength = __webpack_require__2(2812);\n        var $URLSearchParams = URLSearchParams;\n        var URLSearchParamsPrototype = $URLSearchParams.prototype;\n        var getAll = uncurryThis(URLSearchParamsPrototype.getAll);\n        var $has = uncurryThis(URLSearchParamsPrototype.has);\n        var params = new $URLSearchParams(\"a=1\");\n        if (params.has(\"a\", 2) || !params.has(\"a\", void 0)) {\n            defineBuiltIn(URLSearchParamsPrototype, \"has\", function has(name) {\n                var length = arguments.length;\n                var $value = length < 2 ? void 0 : arguments[1];\n                if (length && $value === void 0) return $has(this, name);\n                var values = getAll(this, name);\n                validateArgumentsLength(length, 1);\n                var value1 = toString($value);\n                var index = 0;\n                while(index < values.length){\n                    if (values[index++] === value1) return true;\n                }\n                return false;\n            }, {\n                enumerable: true,\n                unsafe: true\n            });\n        }\n    },\n    /***/ 7588: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        var $ = __webpack_require__2(6518);\n        var call = __webpack_require__2(9565);\n        var iterate = __webpack_require__2(2652);\n        var aCallable = __webpack_require__2(9306);\n        var anObject = __webpack_require__2(8551);\n        var getIteratorDirect = __webpack_require__2(1767);\n        var iteratorClose = __webpack_require__2(9539);\n        var iteratorHelperWithoutClosingOnEarlyError = __webpack_require__2(4549);\n        var forEachWithoutClosingOnEarlyError = iteratorHelperWithoutClosingOnEarlyError(\"forEach\", TypeError);\n        $({\n            target: \"Iterator\",\n            proto: true,\n            real: true,\n            forced: forEachWithoutClosingOnEarlyError\n        }, {\n            forEach: function forEach(fn) {\n                anObject(this);\n                try {\n                    aCallable(fn);\n                } catch (error) {\n                    iteratorClose(this, \"throw\", error);\n                }\n                if (forEachWithoutClosingOnEarlyError) return call(forEachWithoutClosingOnEarlyError, this, fn);\n                var record = getIteratorDirect(this);\n                var counter = 0;\n                iterate(record, function(value1) {\n                    fn(value1, counter++);\n                }, {\n                    IS_RECORD: true\n                });\n            }\n        });\n    },\n    /***/ 7629: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var IS_PURE = __webpack_require__2(6395);\n        var globalThis2 = __webpack_require__2(4576);\n        var defineGlobalProperty = __webpack_require__2(9433);\n        var SHARED = \"__core-js_shared__\";\n        var store = module2.exports = globalThis2[SHARED] || defineGlobalProperty(SHARED, {});\n        (store.versions || (store.versions = [])).push({\n            version: \"3.45.1\",\n            mode: IS_PURE ? \"pure\" : \"global\",\n            copyright: \"\\xa9 2014-2025 Denis Pushkarev (zloirock.ru)\",\n            license: \"https://github.com/zloirock/core-js/blob/v3.45.1/LICENSE\",\n            source: \"https://github.com/zloirock/core-js\"\n        });\n    },\n    /***/ 7642: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        var $ = __webpack_require__2(6518);\n        var difference = __webpack_require__2(3440);\n        var fails = __webpack_require__2(9039);\n        var setMethodAcceptSetLike = __webpack_require__2(4916);\n        var SET_LIKE_INCORRECT_BEHAVIOR = !setMethodAcceptSetLike(\"difference\", function(result) {\n            return result.size === 0;\n        });\n        var FORCED = SET_LIKE_INCORRECT_BEHAVIOR || fails(function() {\n            var setLike = {\n                size: 1,\n                has: function() {\n                    return true;\n                },\n                keys: function() {\n                    var index = 0;\n                    return {\n                        next: function() {\n                            var done = index++ > 1;\n                            if (baseSet.has(1)) baseSet.clear();\n                            return {\n                                done,\n                                value: 2\n                            };\n                        }\n                    };\n                }\n            };\n            var baseSet = /* @__PURE__ */ new Set([\n                1,\n                2,\n                3,\n                4\n            ]);\n            return baseSet.difference(setLike).size !== 3;\n        });\n        $({\n            target: \"Set\",\n            proto: true,\n            real: true,\n            forced: FORCED\n        }, {\n            difference\n        });\n    },\n    /***/ 7657: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var fails = __webpack_require__2(9039);\n        var isCallable = __webpack_require__2(4901);\n        var isObject = __webpack_require__2(34);\n        var create = __webpack_require__2(2360);\n        var getPrototypeOf = __webpack_require__2(2787);\n        var defineBuiltIn = __webpack_require__2(6840);\n        var wellKnownSymbol = __webpack_require__2(8227);\n        var IS_PURE = __webpack_require__2(6395);\n        var ITERATOR = wellKnownSymbol(\"iterator\");\n        var BUGGY_SAFARI_ITERATORS = false;\n        var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;\n        if ([].keys) {\n            arrayIterator = [].keys();\n            if (!(\"next\" in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;\n            else {\n                PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));\n                if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;\n            }\n        }\n        var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype) || fails(function() {\n            var test = {};\n            return IteratorPrototype[ITERATOR].call(test) !== test;\n        });\n        if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};\n        else if (IS_PURE) IteratorPrototype = create(IteratorPrototype);\n        if (!isCallable(IteratorPrototype[ITERATOR])) {\n            defineBuiltIn(IteratorPrototype, ITERATOR, function() {\n                return this;\n            });\n        }\n        module2.exports = {\n            IteratorPrototype,\n            BUGGY_SAFARI_ITERATORS\n        };\n    },\n    /***/ 7680: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var uncurryThis = __webpack_require__2(9504);\n        module2.exports = uncurryThis([].slice);\n    },\n    /***/ 7696: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var toIntegerOrInfinity = __webpack_require__2(1291);\n        var toLength = __webpack_require__2(8014);\n        var $RangeError = RangeError;\n        module2.exports = function(it) {\n            if (it === void 0) return 0;\n            var number = toIntegerOrInfinity(it);\n            var length = toLength(number);\n            if (number !== length) throw new $RangeError(\"Wrong length or index\");\n            return length;\n        };\n    },\n    /***/ 7740: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var hasOwn = __webpack_require__2(9297);\n        var ownKeys = __webpack_require__2(5031);\n        var getOwnPropertyDescriptorModule = __webpack_require__2(7347);\n        var definePropertyModule = __webpack_require__2(4913);\n        module2.exports = function(target, source, exceptions) {\n            var keys = ownKeys(source);\n            var defineProperty = definePropertyModule.f;\n            var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n            for(var i = 0; i < keys.length; i++){\n                var key = keys[i];\n                if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {\n                    defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n                }\n            }\n        };\n    },\n    /***/ 7750: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var isNullOrUndefined = __webpack_require__2(4117);\n        var $TypeError = TypeError;\n        module2.exports = function(it) {\n            if (isNullOrUndefined(it)) throw new $TypeError(\"Can't call method on \" + it);\n            return it;\n        };\n    },\n    /***/ 7751: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var globalThis2 = __webpack_require__2(4576);\n        var isCallable = __webpack_require__2(4901);\n        var aFunction = function(argument) {\n            return isCallable(argument) ? argument : void 0;\n        };\n        module2.exports = function(namespace, method) {\n            return arguments.length < 2 ? aFunction(globalThis2[namespace]) : globalThis2[namespace] && globalThis2[namespace][method];\n        };\n    },\n    /***/ 7811: /***/ (module2)=>{\n        module2.exports = typeof ArrayBuffer != \"undefined\" && typeof DataView != \"undefined\";\n    },\n    /***/ 7936: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        var $ = __webpack_require__2(6518);\n        var $transfer = __webpack_require__2(5636);\n        if ($transfer) $({\n            target: \"ArrayBuffer\",\n            proto: true\n        }, {\n            transferToFixedLength: function transferToFixedLength() {\n                return $transfer(this, arguments.length ? arguments[0] : void 0, false);\n            }\n        });\n    },\n    /***/ 8004: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        var $ = __webpack_require__2(6518);\n        var fails = __webpack_require__2(9039);\n        var intersection = __webpack_require__2(8750);\n        var setMethodAcceptSetLike = __webpack_require__2(4916);\n        var INCORRECT = !setMethodAcceptSetLike(\"intersection\", function(result) {\n            return result.size === 2 && result.has(1) && result.has(2);\n        }) || fails(function() {\n            return String(Array.from(/* @__PURE__ */ new Set([\n                1,\n                2,\n                3\n            ]).intersection(/* @__PURE__ */ new Set([\n                3,\n                2\n            ])))) !== \"3,2\";\n        });\n        $({\n            target: \"Set\",\n            proto: true,\n            real: true,\n            forced: INCORRECT\n        }, {\n            intersection\n        });\n    },\n    /***/ 8014: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var toIntegerOrInfinity = __webpack_require__2(1291);\n        var min = Math.min;\n        module2.exports = function(argument) {\n            var len = toIntegerOrInfinity(argument);\n            return len > 0 ? min(len, 9007199254740991) : 0;\n        };\n    },\n    /***/ 8100: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        var $ = __webpack_require__2(6518);\n        var $transfer = __webpack_require__2(5636);\n        if ($transfer) $({\n            target: \"ArrayBuffer\",\n            proto: true\n        }, {\n            transfer: function transfer() {\n                return $transfer(this, arguments.length ? arguments[0] : void 0, true);\n            }\n        });\n    },\n    /***/ 8111: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        var $ = __webpack_require__2(6518);\n        var globalThis2 = __webpack_require__2(4576);\n        var anInstance = __webpack_require__2(679);\n        var anObject = __webpack_require__2(8551);\n        var isCallable = __webpack_require__2(4901);\n        var getPrototypeOf = __webpack_require__2(2787);\n        var defineBuiltInAccessor = __webpack_require__2(2106);\n        var createProperty = __webpack_require__2(4659);\n        var fails = __webpack_require__2(9039);\n        var hasOwn = __webpack_require__2(9297);\n        var wellKnownSymbol = __webpack_require__2(8227);\n        var IteratorPrototype = __webpack_require__2(7657).IteratorPrototype;\n        var DESCRIPTORS = __webpack_require__2(3724);\n        var IS_PURE = __webpack_require__2(6395);\n        var CONSTRUCTOR = \"constructor\";\n        var ITERATOR = \"Iterator\";\n        var TO_STRING_TAG = wellKnownSymbol(\"toStringTag\");\n        var $TypeError = TypeError;\n        var NativeIterator = globalThis2[ITERATOR];\n        var FORCED = IS_PURE || !isCallable(NativeIterator) || NativeIterator.prototype !== IteratorPrototype || !fails(function() {\n            NativeIterator({});\n        });\n        var IteratorConstructor = function Iterator2() {\n            anInstance(this, IteratorPrototype);\n            if (getPrototypeOf(this) === IteratorPrototype) throw new $TypeError(\"Abstract class Iterator not directly constructable\");\n        };\n        var defineIteratorPrototypeAccessor = function(key, value1) {\n            if (DESCRIPTORS) {\n                defineBuiltInAccessor(IteratorPrototype, key, {\n                    configurable: true,\n                    get: function() {\n                        return value1;\n                    },\n                    set: function(replacement) {\n                        anObject(this);\n                        if (this === IteratorPrototype) throw new $TypeError(\"You can't redefine this property\");\n                        if (hasOwn(this, key)) this[key] = replacement;\n                        else createProperty(this, key, replacement);\n                    }\n                });\n            } else IteratorPrototype[key] = value1;\n        };\n        if (!hasOwn(IteratorPrototype, TO_STRING_TAG)) defineIteratorPrototypeAccessor(TO_STRING_TAG, ITERATOR);\n        if (FORCED || !hasOwn(IteratorPrototype, CONSTRUCTOR) || IteratorPrototype[CONSTRUCTOR] === Object) {\n            defineIteratorPrototypeAccessor(CONSTRUCTOR, IteratorConstructor);\n        }\n        IteratorConstructor.prototype = IteratorPrototype;\n        $({\n            global: true,\n            constructor: true,\n            forced: FORCED\n        }, {\n            Iterator: IteratorConstructor\n        });\n    },\n    /***/ 8227: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var globalThis2 = __webpack_require__2(4576);\n        var shared = __webpack_require__2(5745);\n        var hasOwn = __webpack_require__2(9297);\n        var uid = __webpack_require__2(3392);\n        var NATIVE_SYMBOL = __webpack_require__2(4495);\n        var USE_SYMBOL_AS_UID = __webpack_require__2(7040);\n        var Symbol2 = globalThis2.Symbol;\n        var WellKnownSymbolsStore = shared(\"wks\");\n        var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2[\"for\"] || Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;\n        module2.exports = function(name) {\n            if (!hasOwn(WellKnownSymbolsStore, name)) {\n                WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol2, name) ? Symbol2[name] : createWellKnownSymbol(\"Symbol.\" + name);\n            }\n            return WellKnownSymbolsStore[name];\n        };\n    },\n    /***/ 8235: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var uncurryThis = __webpack_require__2(9504);\n        var hasOwn = __webpack_require__2(9297);\n        var $SyntaxError = SyntaxError;\n        var $parseInt = parseInt;\n        var fromCharCode = String.fromCharCode;\n        var at = uncurryThis(\"\".charAt);\n        var slice = uncurryThis(\"\".slice);\n        var exec = uncurryThis(/./.exec);\n        var codePoints = {\n            '\\\\\"': '\"',\n            \"\\\\\\\\\": \"\\\\\",\n            \"\\\\/\": \"/\",\n            \"\\\\b\": \"\\b\",\n            \"\\\\f\": \"\\f\",\n            \"\\\\n\": \"\\n\",\n            \"\\\\r\": \"\\r\",\n            \"\\\\t\": \"\t\"\n        };\n        var IS_4_HEX_DIGITS = /^[\\da-f]{4}$/i;\n        var IS_C0_CONTROL_CODE = /^[\\u0000-\\u001F]$/;\n        module2.exports = function(source, i) {\n            var unterminated = true;\n            var value1 = \"\";\n            while(i < source.length){\n                var chr = at(source, i);\n                if (chr === \"\\\\\") {\n                    var twoChars = slice(source, i, i + 2);\n                    if (hasOwn(codePoints, twoChars)) {\n                        value1 += codePoints[twoChars];\n                        i += 2;\n                    } else if (twoChars === \"\\\\u\") {\n                        i += 2;\n                        var fourHexDigits = slice(source, i, i + 4);\n                        if (!exec(IS_4_HEX_DIGITS, fourHexDigits)) throw new $SyntaxError(\"Bad Unicode escape at: \" + i);\n                        value1 += fromCharCode($parseInt(fourHexDigits, 16));\n                        i += 4;\n                    } else throw new $SyntaxError('Unknown escape sequence: \"' + twoChars + '\"');\n                } else if (chr === '\"') {\n                    unterminated = false;\n                    i++;\n                    break;\n                } else {\n                    if (exec(IS_C0_CONTROL_CODE, chr)) throw new $SyntaxError(\"Bad control character in string literal at: \" + i);\n                    value1 += chr;\n                    i++;\n                }\n            }\n            if (unterminated) throw new $SyntaxError(\"Unterminated string at: \" + i);\n            return {\n                value: value1,\n                end: i\n            };\n        };\n    },\n    /***/ 8237: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        var $ = __webpack_require__2(6518);\n        var iterate = __webpack_require__2(2652);\n        var aCallable = __webpack_require__2(9306);\n        var anObject = __webpack_require__2(8551);\n        var getIteratorDirect = __webpack_require__2(1767);\n        var iteratorClose = __webpack_require__2(9539);\n        var iteratorHelperWithoutClosingOnEarlyError = __webpack_require__2(4549);\n        var apply = __webpack_require__2(8745);\n        var fails = __webpack_require__2(9039);\n        var $TypeError = TypeError;\n        var FAILS_ON_INITIAL_UNDEFINED = fails(function() {\n            [].keys().reduce(function() {}, void 0);\n        });\n        var reduceWithoutClosingOnEarlyError = !FAILS_ON_INITIAL_UNDEFINED && iteratorHelperWithoutClosingOnEarlyError(\"reduce\", $TypeError);\n        $({\n            target: \"Iterator\",\n            proto: true,\n            real: true,\n            forced: FAILS_ON_INITIAL_UNDEFINED || reduceWithoutClosingOnEarlyError\n        }, {\n            reduce: function reduce(reducer) {\n                anObject(this);\n                try {\n                    aCallable(reducer);\n                } catch (error) {\n                    iteratorClose(this, \"throw\", error);\n                }\n                var noInitial = arguments.length < 2;\n                var accumulator = noInitial ? void 0 : arguments[1];\n                if (reduceWithoutClosingOnEarlyError) {\n                    return apply(reduceWithoutClosingOnEarlyError, this, noInitial ? [\n                        reducer\n                    ] : [\n                        reducer,\n                        accumulator\n                    ]);\n                }\n                var record = getIteratorDirect(this);\n                var counter = 0;\n                iterate(record, function(value1) {\n                    if (noInitial) {\n                        noInitial = false;\n                        accumulator = value1;\n                    } else {\n                        accumulator = reducer(accumulator, value1, counter);\n                    }\n                    counter++;\n                }, {\n                    IS_RECORD: true\n                });\n                if (noInitial) throw new $TypeError(\"Reduce of empty iterator with no initial value\");\n                return accumulator;\n            }\n        });\n    },\n    /***/ 8335: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        var $ = __webpack_require__2(6518);\n        var DESCRIPTORS = __webpack_require__2(3724);\n        var globalThis2 = __webpack_require__2(4576);\n        var getBuiltIn = __webpack_require__2(7751);\n        var uncurryThis = __webpack_require__2(9504);\n        var call = __webpack_require__2(9565);\n        var isCallable = __webpack_require__2(4901);\n        var isObject = __webpack_require__2(34);\n        var isArray = __webpack_require__2(4376);\n        var hasOwn = __webpack_require__2(9297);\n        var toString = __webpack_require__2(655);\n        var lengthOfArrayLike = __webpack_require__2(6198);\n        var createProperty = __webpack_require__2(4659);\n        var fails = __webpack_require__2(9039);\n        var parseJSONString = __webpack_require__2(8235);\n        var NATIVE_SYMBOL = __webpack_require__2(4495);\n        var JSON2 = globalThis2.JSON;\n        var Number2 = globalThis2.Number;\n        var SyntaxError2 = globalThis2.SyntaxError;\n        var nativeParse = JSON2 && JSON2.parse;\n        var enumerableOwnProperties = getBuiltIn(\"Object\", \"keys\");\n        var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n        var at = uncurryThis(\"\".charAt);\n        var slice = uncurryThis(\"\".slice);\n        var exec = uncurryThis(/./.exec);\n        var push = uncurryThis([].push);\n        var IS_DIGIT = /^\\d$/;\n        var IS_NON_ZERO_DIGIT = /^[1-9]$/;\n        var IS_NUMBER_START = /^[\\d-]$/;\n        var IS_WHITESPACE = /^[\\t\\n\\r ]$/;\n        var PRIMITIVE = 0;\n        var OBJECT = 1;\n        var $parse = function(source, reviver) {\n            source = toString(source);\n            var context = new Context(source, 0);\n            var root = context.parse();\n            var value1 = root.value;\n            var endIndex = context.skip(IS_WHITESPACE, root.end);\n            if (endIndex < source.length) {\n                throw new SyntaxError2('Unexpected extra character: \"' + at(source, endIndex) + '\" after the parsed data at: ' + endIndex);\n            }\n            return isCallable(reviver) ? internalize({\n                \"\": value1\n            }, \"\", reviver, root) : value1;\n        };\n        var internalize = function(holder, name, reviver, node) {\n            var val = holder[name];\n            var unmodified = node && val === node.value;\n            var context = unmodified && typeof node.source == \"string\" ? {\n                source: node.source\n            } : {};\n            var elementRecordsLen, keys, len, i, P;\n            if (isObject(val)) {\n                var nodeIsArray = isArray(val);\n                var nodes = unmodified ? node.nodes : nodeIsArray ? [] : {};\n                if (nodeIsArray) {\n                    elementRecordsLen = nodes.length;\n                    len = lengthOfArrayLike(val);\n                    for(i = 0; i < len; i++){\n                        internalizeProperty(val, i, internalize(val, \"\" + i, reviver, i < elementRecordsLen ? nodes[i] : void 0));\n                    }\n                } else {\n                    keys = enumerableOwnProperties(val);\n                    len = lengthOfArrayLike(keys);\n                    for(i = 0; i < len; i++){\n                        P = keys[i];\n                        internalizeProperty(val, P, internalize(val, P, reviver, hasOwn(nodes, P) ? nodes[P] : void 0));\n                    }\n                }\n            }\n            return call(reviver, holder, name, val, context);\n        };\n        var internalizeProperty = function(object, key, value1) {\n            if (DESCRIPTORS) {\n                var descriptor = getOwnPropertyDescriptor(object, key);\n                if (descriptor && !descriptor.configurable) return;\n            }\n            if (value1 === void 0) delete object[key];\n            else createProperty(object, key, value1);\n        };\n        var Node2 = function(value1, end, source, nodes) {\n            this.value = value1;\n            this.end = end;\n            this.source = source;\n            this.nodes = nodes;\n        };\n        var Context = function(source, index) {\n            this.source = source;\n            this.index = index;\n        };\n        Context.prototype = {\n            fork: function(nextIndex) {\n                return new Context(this.source, nextIndex);\n            },\n            parse: function() {\n                var source = this.source;\n                var i = this.skip(IS_WHITESPACE, this.index);\n                var fork = this.fork(i);\n                var chr = at(source, i);\n                if (exec(IS_NUMBER_START, chr)) return fork.number();\n                switch(chr){\n                    case \"{\":\n                        return fork.object();\n                    case \"[\":\n                        return fork.array();\n                    case '\"':\n                        return fork.string();\n                    case \"t\":\n                        return fork.keyword(true);\n                    case \"f\":\n                        return fork.keyword(false);\n                    case \"n\":\n                        return fork.keyword(null);\n                }\n                throw new SyntaxError2('Unexpected character: \"' + chr + '\" at: ' + i);\n            },\n            node: function(type, value1, start, end, nodes) {\n                return new Node2(value1, end, type ? null : slice(this.source, start, end), nodes);\n            },\n            object: function() {\n                var source = this.source;\n                var i = this.index + 1;\n                var expectKeypair = false;\n                var object = {};\n                var nodes = {};\n                while(i < source.length){\n                    i = this.until([\n                        '\"',\n                        \"}\"\n                    ], i);\n                    if (at(source, i) === \"}\" && !expectKeypair) {\n                        i++;\n                        break;\n                    }\n                    var result = this.fork(i).string();\n                    var key = result.value;\n                    i = result.end;\n                    i = this.until([\n                        \":\"\n                    ], i) + 1;\n                    i = this.skip(IS_WHITESPACE, i);\n                    result = this.fork(i).parse();\n                    createProperty(nodes, key, result);\n                    createProperty(object, key, result.value);\n                    i = this.until([\n                        \",\",\n                        \"}\"\n                    ], result.end);\n                    var chr = at(source, i);\n                    if (chr === \",\") {\n                        expectKeypair = true;\n                        i++;\n                    } else if (chr === \"}\") {\n                        i++;\n                        break;\n                    }\n                }\n                return this.node(OBJECT, object, this.index, i, nodes);\n            },\n            array: function() {\n                var source = this.source;\n                var i = this.index + 1;\n                var expectElement = false;\n                var array = [];\n                var nodes = [];\n                while(i < source.length){\n                    i = this.skip(IS_WHITESPACE, i);\n                    if (at(source, i) === \"]\" && !expectElement) {\n                        i++;\n                        break;\n                    }\n                    var result = this.fork(i).parse();\n                    push(nodes, result);\n                    push(array, result.value);\n                    i = this.until([\n                        \",\",\n                        \"]\"\n                    ], result.end);\n                    if (at(source, i) === \",\") {\n                        expectElement = true;\n                        i++;\n                    } else if (at(source, i) === \"]\") {\n                        i++;\n                        break;\n                    }\n                }\n                return this.node(OBJECT, array, this.index, i, nodes);\n            },\n            string: function() {\n                var index = this.index;\n                var parsed = parseJSONString(this.source, this.index + 1);\n                return this.node(PRIMITIVE, parsed.value, index, parsed.end);\n            },\n            number: function() {\n                var source = this.source;\n                var startIndex = this.index;\n                var i = startIndex;\n                if (at(source, i) === \"-\") i++;\n                if (at(source, i) === \"0\") i++;\n                else if (exec(IS_NON_ZERO_DIGIT, at(source, i))) i = this.skip(IS_DIGIT, i + 1);\n                else throw new SyntaxError2(\"Failed to parse number at: \" + i);\n                if (at(source, i) === \".\") i = this.skip(IS_DIGIT, i + 1);\n                if (at(source, i) === \"e\" || at(source, i) === \"E\") {\n                    i++;\n                    if (at(source, i) === \"+\" || at(source, i) === \"-\") i++;\n                    var exponentStartIndex = i;\n                    i = this.skip(IS_DIGIT, i);\n                    if (exponentStartIndex === i) throw new SyntaxError2(\"Failed to parse number's exponent value at: \" + i);\n                }\n                return this.node(PRIMITIVE, Number2(slice(source, startIndex, i)), startIndex, i);\n            },\n            keyword: function(value1) {\n                var keyword = \"\" + value1;\n                var index = this.index;\n                var endIndex = index + keyword.length;\n                if (slice(this.source, index, endIndex) !== keyword) throw new SyntaxError2(\"Failed to parse value at: \" + index);\n                return this.node(PRIMITIVE, value1, index, endIndex);\n            },\n            skip: function(regex, i) {\n                var source = this.source;\n                for(; i < source.length; i++)if (!exec(regex, at(source, i))) break;\n                return i;\n            },\n            until: function(array, i) {\n                i = this.skip(IS_WHITESPACE, i);\n                var chr = at(this.source, i);\n                for(var j = 0; j < array.length; j++)if (array[j] === chr) return i;\n                throw new SyntaxError2('Unexpected character: \"' + chr + '\" at: ' + i);\n            }\n        };\n        var NO_SOURCE_SUPPORT = fails(function() {\n            var unsafeInt = \"9007199254740993\";\n            var source;\n            nativeParse(unsafeInt, function(key, value1, context) {\n                source = context.source;\n            });\n            return source !== unsafeInt;\n        });\n        var PROPER_BASE_PARSE = NATIVE_SYMBOL && !fails(function() {\n            return 1 / nativeParse(\"-0 \t\") !== -Infinity;\n        });\n        $({\n            target: \"JSON\",\n            stat: true,\n            forced: NO_SOURCE_SUPPORT\n        }, {\n            parse: function parse(text, reviver) {\n                return PROPER_BASE_PARSE && !isCallable(reviver) ? nativeParse(text) : $parse(text, reviver);\n            }\n        });\n    },\n    /***/ 8469: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var uncurryThis = __webpack_require__2(9504);\n        var iterateSimple = __webpack_require__2(507);\n        var SetHelpers = __webpack_require__2(4402);\n        var Set2 = SetHelpers.Set;\n        var SetPrototype = SetHelpers.proto;\n        var forEach = uncurryThis(SetPrototype.forEach);\n        var keys = uncurryThis(SetPrototype.keys);\n        var next = keys(new Set2()).next;\n        module2.exports = function(set, fn, interruptible) {\n            return interruptible ? iterateSimple({\n                iterator: keys(set),\n                next\n            }, fn) : forEach(set, fn);\n        };\n    },\n    /***/ 8480: /***/ (__unused_webpack_module, exports2, __webpack_require__2)=>{\n        var internalObjectKeys = __webpack_require__2(1828);\n        var enumBugKeys = __webpack_require__2(8727);\n        var hiddenKeys = enumBugKeys.concat(\"length\", \"prototype\");\n        exports2.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n            return internalObjectKeys(O, hiddenKeys);\n        };\n    },\n    /***/ 8527: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var aSet = __webpack_require__2(7080);\n        var has = __webpack_require__2(4402).has;\n        var size = __webpack_require__2(5170);\n        var getSetRecord = __webpack_require__2(3789);\n        var iterateSimple = __webpack_require__2(507);\n        var iteratorClose = __webpack_require__2(9539);\n        module2.exports = function isSupersetOf(other) {\n            var O = aSet(this);\n            var otherRec = getSetRecord(other);\n            if (size(O) < otherRec.size) return false;\n            var iterator = otherRec.getIterator();\n            return iterateSimple(iterator, function(e) {\n                if (!has(O, e)) return iteratorClose(iterator, \"normal\", false);\n            }) !== false;\n        };\n    },\n    /***/ 8551: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var isObject = __webpack_require__2(34);\n        var $String = String;\n        var $TypeError = TypeError;\n        module2.exports = function(argument) {\n            if (isObject(argument)) return argument;\n            throw new $TypeError($String(argument) + \" is not an object\");\n        };\n    },\n    /***/ 8574: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var uncurryThis = __webpack_require__2(9504);\n        var $Error = Error;\n        var replace = uncurryThis(\"\".replace);\n        var TEST = function(arg) {\n            return String(new $Error(arg).stack);\n        }(\"zxcasd\");\n        var V8_OR_CHAKRA_STACK_ENTRY = /\\n\\s*at [^:]*:[^\\n]*/;\n        var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);\n        module2.exports = function(stack, dropEntries) {\n            if (IS_V8_OR_CHAKRA_STACK && typeof stack == \"string\" && !$Error.prepareStackTrace) {\n                while(dropEntries--)stack = replace(stack, V8_OR_CHAKRA_STACK_ENTRY, \"\");\n            }\n            return stack;\n        };\n    },\n    /***/ 8622: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var globalThis2 = __webpack_require__2(4576);\n        var isCallable = __webpack_require__2(4901);\n        var WeakMap2 = globalThis2.WeakMap;\n        module2.exports = isCallable(WeakMap2) && /native code/.test(String(WeakMap2));\n    },\n    /***/ 8646: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var call = __webpack_require__2(9565);\n        var anObject = __webpack_require__2(8551);\n        var getIteratorDirect = __webpack_require__2(1767);\n        var getIteratorMethod = __webpack_require__2(851);\n        module2.exports = function(obj, stringHandling) {\n            if (!stringHandling || typeof obj !== \"string\") anObject(obj);\n            var method = getIteratorMethod(obj);\n            return getIteratorDirect(anObject(method !== void 0 ? call(method, obj) : obj));\n        };\n    },\n    /***/ 8686: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var DESCRIPTORS = __webpack_require__2(3724);\n        var fails = __webpack_require__2(9039);\n        module2.exports = DESCRIPTORS && fails(function() {\n            return Object.defineProperty(function() {}, \"prototype\", {\n                value: 42,\n                writable: false\n            }).prototype !== 42;\n        });\n    },\n    /***/ 8721: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        var DESCRIPTORS = __webpack_require__2(3724);\n        var uncurryThis = __webpack_require__2(9504);\n        var defineBuiltInAccessor = __webpack_require__2(2106);\n        var URLSearchParamsPrototype = URLSearchParams.prototype;\n        var forEach = uncurryThis(URLSearchParamsPrototype.forEach);\n        if (DESCRIPTORS && !(\"size\" in URLSearchParamsPrototype)) {\n            defineBuiltInAccessor(URLSearchParamsPrototype, \"size\", {\n                get: function size() {\n                    var count = 0;\n                    forEach(this, function() {\n                        count++;\n                    });\n                    return count;\n                },\n                configurable: true,\n                enumerable: true\n            });\n        }\n    },\n    /***/ 8727: /***/ (module2)=>{\n        module2.exports = [\n            \"constructor\",\n            \"hasOwnProperty\",\n            \"isPrototypeOf\",\n            \"propertyIsEnumerable\",\n            \"toLocaleString\",\n            \"toString\",\n            \"valueOf\"\n        ];\n    },\n    /***/ 8745: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var NATIVE_BIND = __webpack_require__2(616);\n        var FunctionPrototype = Function.prototype;\n        var apply = FunctionPrototype.apply;\n        var call = FunctionPrototype.call;\n        module2.exports = typeof Reflect == \"object\" && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function() {\n            return call.apply(apply, arguments);\n        });\n    },\n    /***/ 8750: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var aSet = __webpack_require__2(7080);\n        var SetHelpers = __webpack_require__2(4402);\n        var size = __webpack_require__2(5170);\n        var getSetRecord = __webpack_require__2(3789);\n        var iterateSet = __webpack_require__2(8469);\n        var iterateSimple = __webpack_require__2(507);\n        var Set2 = SetHelpers.Set;\n        var add = SetHelpers.add;\n        var has = SetHelpers.has;\n        module2.exports = function intersection(other) {\n            var O = aSet(this);\n            var otherRec = getSetRecord(other);\n            var result = new Set2();\n            if (size(O) > otherRec.size) {\n                iterateSimple(otherRec.getIterator(), function(e) {\n                    if (has(O, e)) add(result, e);\n                });\n            } else {\n                iterateSet(O, function(e) {\n                    if (otherRec.includes(e)) add(result, e);\n                });\n            }\n            return result;\n        };\n    },\n    /***/ 8773: /***/ (__unused_webpack_module, exports2)=>{\n        var $propertyIsEnumerable = {}.propertyIsEnumerable;\n        var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n        var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({\n            1: 2\n        }, 1);\n        exports2.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n            var descriptor = getOwnPropertyDescriptor(this, V);\n            return !!descriptor && descriptor.enumerable;\n        } : $propertyIsEnumerable;\n    },\n    /***/ 8981: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var requireObjectCoercible = __webpack_require__2(7750);\n        var $Object = Object;\n        module2.exports = function(argument) {\n            return $Object(requireObjectCoercible(argument));\n        };\n    },\n    /***/ 9039: /***/ (module2)=>{\n        module2.exports = function(exec) {\n            try {\n                return !!exec();\n            } catch (error) {\n                return true;\n            }\n        };\n    },\n    /***/ 9143: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var globalThis2 = __webpack_require__2(4576);\n        var uncurryThis = __webpack_require__2(9504);\n        var anObjectOrUndefined = __webpack_require__2(3972);\n        var aString = __webpack_require__2(3463);\n        var hasOwn = __webpack_require__2(9297);\n        var base64Map = __webpack_require__2(2804);\n        var getAlphabetOption = __webpack_require__2(944);\n        var notDetached = __webpack_require__2(5169);\n        var base64Alphabet = base64Map.c2i;\n        var base64UrlAlphabet = base64Map.c2iUrl;\n        var SyntaxError2 = globalThis2.SyntaxError;\n        var TypeError2 = globalThis2.TypeError;\n        var at = uncurryThis(\"\".charAt);\n        var skipAsciiWhitespace = function(string, index) {\n            var length = string.length;\n            for(; index < length; index++){\n                var chr = at(string, index);\n                if (chr !== \" \" && chr !== \"\t\" && chr !== \"\\n\" && chr !== \"\\f\" && chr !== \"\\r\") break;\n            }\n            return index;\n        };\n        var decodeBase64Chunk = function(chunk, alphabet, throwOnExtraBits) {\n            var chunkLength = chunk.length;\n            if (chunkLength < 4) {\n                chunk += chunkLength === 2 ? \"AA\" : \"A\";\n            }\n            var triplet = (alphabet[at(chunk, 0)] << 18) + (alphabet[at(chunk, 1)] << 12) + (alphabet[at(chunk, 2)] << 6) + alphabet[at(chunk, 3)];\n            var chunkBytes = [\n                triplet >> 16 & 255,\n                triplet >> 8 & 255,\n                triplet & 255\n            ];\n            if (chunkLength === 2) {\n                if (throwOnExtraBits && chunkBytes[1] !== 0) {\n                    throw new SyntaxError2(\"Extra bits\");\n                }\n                return [\n                    chunkBytes[0]\n                ];\n            }\n            if (chunkLength === 3) {\n                if (throwOnExtraBits && chunkBytes[2] !== 0) {\n                    throw new SyntaxError2(\"Extra bits\");\n                }\n                return [\n                    chunkBytes[0],\n                    chunkBytes[1]\n                ];\n            }\n            return chunkBytes;\n        };\n        var writeBytes = function(bytes, elements, written) {\n            var elementsLength = elements.length;\n            for(var index = 0; index < elementsLength; index++){\n                bytes[written + index] = elements[index];\n            }\n            return written + elementsLength;\n        };\n        module2.exports = function(string, options, into, maxLength) {\n            aString(string);\n            anObjectOrUndefined(options);\n            var alphabet = getAlphabetOption(options) === \"base64\" ? base64Alphabet : base64UrlAlphabet;\n            var lastChunkHandling = options ? options.lastChunkHandling : void 0;\n            if (lastChunkHandling === void 0) lastChunkHandling = \"loose\";\n            if (lastChunkHandling !== \"loose\" && lastChunkHandling !== \"strict\" && lastChunkHandling !== \"stop-before-partial\") {\n                throw new TypeError2(\"Incorrect `lastChunkHandling` option\");\n            }\n            if (into) notDetached(into.buffer);\n            var stringLength = string.length;\n            var bytes = into || [];\n            var written = 0;\n            var read = 0;\n            var chunk = \"\";\n            var index = 0;\n            if (maxLength) while(true){\n                index = skipAsciiWhitespace(string, index);\n                if (index === stringLength) {\n                    if (chunk.length > 0) {\n                        if (lastChunkHandling === \"stop-before-partial\") {\n                            break;\n                        }\n                        if (lastChunkHandling === \"loose\") {\n                            if (chunk.length === 1) {\n                                throw new SyntaxError2(\"Malformed padding: exactly one additional character\");\n                            }\n                            written = writeBytes(bytes, decodeBase64Chunk(chunk, alphabet, false), written);\n                        } else {\n                            throw new SyntaxError2(\"Missing padding\");\n                        }\n                    }\n                    read = stringLength;\n                    break;\n                }\n                var chr = at(string, index);\n                ++index;\n                if (chr === \"=\") {\n                    if (chunk.length < 2) {\n                        throw new SyntaxError2(\"Padding is too early\");\n                    }\n                    index = skipAsciiWhitespace(string, index);\n                    if (chunk.length === 2) {\n                        if (index === stringLength) {\n                            if (lastChunkHandling === \"stop-before-partial\") {\n                                break;\n                            }\n                            throw new SyntaxError2(\"Malformed padding: only one =\");\n                        }\n                        if (at(string, index) === \"=\") {\n                            ++index;\n                            index = skipAsciiWhitespace(string, index);\n                        }\n                    }\n                    if (index < stringLength) {\n                        throw new SyntaxError2(\"Unexpected character after padding\");\n                    }\n                    written = writeBytes(bytes, decodeBase64Chunk(chunk, alphabet, lastChunkHandling === \"strict\"), written);\n                    read = stringLength;\n                    break;\n                }\n                if (!hasOwn(alphabet, chr)) {\n                    throw new SyntaxError2(\"Unexpected character\");\n                }\n                var remainingBytes = maxLength - written;\n                if (remainingBytes === 1 && chunk.length === 2 || remainingBytes === 2 && chunk.length === 3) {\n                    break;\n                }\n                chunk += chr;\n                if (chunk.length === 4) {\n                    written = writeBytes(bytes, decodeBase64Chunk(chunk, alphabet, false), written);\n                    chunk = \"\";\n                    read = index;\n                    if (written === maxLength) {\n                        break;\n                    }\n                }\n            }\n            return {\n                bytes,\n                read,\n                written\n            };\n        };\n    },\n    /***/ 9286: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var SetHelpers = __webpack_require__2(4402);\n        var iterate = __webpack_require__2(8469);\n        var Set2 = SetHelpers.Set;\n        var add = SetHelpers.add;\n        module2.exports = function(set) {\n            var result = new Set2();\n            iterate(set, function(it) {\n                add(result, it);\n            });\n            return result;\n        };\n    },\n    /***/ 9297: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var uncurryThis = __webpack_require__2(9504);\n        var toObject = __webpack_require__2(8981);\n        var hasOwnProperty = uncurryThis({}.hasOwnProperty);\n        module2.exports = Object.hasOwn || function hasOwn(it, key) {\n            return hasOwnProperty(toObject(it), key);\n        };\n    },\n    /***/ 9306: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var isCallable = __webpack_require__2(4901);\n        var tryToString = __webpack_require__2(6823);\n        var $TypeError = TypeError;\n        module2.exports = function(argument) {\n            if (isCallable(argument)) return argument;\n            throw new $TypeError(tryToString(argument) + \" is not a function\");\n        };\n    },\n    /***/ 9314: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        var $ = __webpack_require__2(6518);\n        var call = __webpack_require__2(9565);\n        var anObject = __webpack_require__2(8551);\n        var getIteratorDirect = __webpack_require__2(1767);\n        var notANaN = __webpack_require__2(4149);\n        var toPositiveInteger = __webpack_require__2(9590);\n        var iteratorClose = __webpack_require__2(9539);\n        var createIteratorProxy = __webpack_require__2(9462);\n        var iteratorHelperThrowsOnInvalidIterator = __webpack_require__2(684);\n        var iteratorHelperWithoutClosingOnEarlyError = __webpack_require__2(4549);\n        var IS_PURE = __webpack_require__2(6395);\n        var DROP_WITHOUT_THROWING_ON_INVALID_ITERATOR = !IS_PURE && !iteratorHelperThrowsOnInvalidIterator(\"drop\", 0);\n        var dropWithoutClosingOnEarlyError = !IS_PURE && !DROP_WITHOUT_THROWING_ON_INVALID_ITERATOR && iteratorHelperWithoutClosingOnEarlyError(\"drop\", RangeError);\n        var FORCED = IS_PURE || DROP_WITHOUT_THROWING_ON_INVALID_ITERATOR || dropWithoutClosingOnEarlyError;\n        var IteratorProxy = createIteratorProxy(function() {\n            var iterator = this.iterator;\n            var next = this.next;\n            var result, done;\n            while(this.remaining){\n                this.remaining--;\n                result = anObject(call(next, iterator));\n                done = this.done = !!result.done;\n                if (done) return;\n            }\n            result = anObject(call(next, iterator));\n            done = this.done = !!result.done;\n            if (!done) return result.value;\n        });\n        $({\n            target: \"Iterator\",\n            proto: true,\n            real: true,\n            forced: FORCED\n        }, {\n            drop: function drop(limit) {\n                anObject(this);\n                var remaining;\n                try {\n                    remaining = toPositiveInteger(notANaN(+limit));\n                } catch (error) {\n                    iteratorClose(this, \"throw\", error);\n                }\n                if (dropWithoutClosingOnEarlyError) return call(dropWithoutClosingOnEarlyError, this, remaining);\n                return new IteratorProxy(getIteratorDirect(this), {\n                    remaining\n                });\n            }\n        });\n    },\n    /***/ 9429: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var globalThis2 = __webpack_require__2(4576);\n        var IS_NODE = __webpack_require__2(6193);\n        module2.exports = function(name) {\n            if (IS_NODE) {\n                try {\n                    return globalThis2.process.getBuiltinModule(name);\n                } catch (error) {}\n                try {\n                    return Function('return require(\"' + name + '\")')();\n                } catch (error) {}\n            }\n        };\n    },\n    /***/ 9432: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        __webpack_require__2(5213);\n    },\n    /***/ 9433: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var globalThis2 = __webpack_require__2(4576);\n        var defineProperty = Object.defineProperty;\n        module2.exports = function(key, value1) {\n            try {\n                defineProperty(globalThis2, key, {\n                    value: value1,\n                    configurable: true,\n                    writable: true\n                });\n            } catch (error) {\n                globalThis2[key] = value1;\n            }\n            return value1;\n        };\n    },\n    /***/ 9462: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var call = __webpack_require__2(9565);\n        var create = __webpack_require__2(2360);\n        var createNonEnumerableProperty = __webpack_require__2(6699);\n        var defineBuiltIns = __webpack_require__2(6279);\n        var wellKnownSymbol = __webpack_require__2(8227);\n        var InternalStateModule = __webpack_require__2(1181);\n        var getMethod = __webpack_require__2(5966);\n        var IteratorPrototype = __webpack_require__2(7657).IteratorPrototype;\n        var createIterResultObject = __webpack_require__2(2529);\n        var iteratorClose = __webpack_require__2(9539);\n        var iteratorCloseAll = __webpack_require__2(1385);\n        var TO_STRING_TAG = wellKnownSymbol(\"toStringTag\");\n        var ITERATOR_HELPER = \"IteratorHelper\";\n        var WRAP_FOR_VALID_ITERATOR = \"WrapForValidIterator\";\n        var NORMAL = \"normal\";\n        var THROW = \"throw\";\n        var setInternalState = InternalStateModule.set;\n        var createIteratorProxyPrototype = function(IS_ITERATOR) {\n            var getInternalState = InternalStateModule.getterFor(IS_ITERATOR ? WRAP_FOR_VALID_ITERATOR : ITERATOR_HELPER);\n            return defineBuiltIns(create(IteratorPrototype), {\n                next: function next() {\n                    var state = getInternalState(this);\n                    if (IS_ITERATOR) return state.nextHandler();\n                    if (state.done) return createIterResultObject(void 0, true);\n                    try {\n                        var result = state.nextHandler();\n                        return state.returnHandlerResult ? result : createIterResultObject(result, state.done);\n                    } catch (error) {\n                        state.done = true;\n                        throw error;\n                    }\n                },\n                \"return\": function() {\n                    var state = getInternalState(this);\n                    var iterator = state.iterator;\n                    state.done = true;\n                    if (IS_ITERATOR) {\n                        var returnMethod = getMethod(iterator, \"return\");\n                        return returnMethod ? call(returnMethod, iterator) : createIterResultObject(void 0, true);\n                    }\n                    if (state.inner) try {\n                        iteratorClose(state.inner.iterator, NORMAL);\n                    } catch (error) {\n                        return iteratorClose(iterator, THROW, error);\n                    }\n                    if (state.openIters) try {\n                        iteratorCloseAll(state.openIters, NORMAL);\n                    } catch (error) {\n                        return iteratorClose(iterator, THROW, error);\n                    }\n                    if (iterator) iteratorClose(iterator, NORMAL);\n                    return createIterResultObject(void 0, true);\n                }\n            });\n        };\n        var WrapForValidIteratorPrototype = createIteratorProxyPrototype(true);\n        var IteratorHelperPrototype = createIteratorProxyPrototype(false);\n        createNonEnumerableProperty(IteratorHelperPrototype, TO_STRING_TAG, \"Iterator Helper\");\n        module2.exports = function(nextHandler, IS_ITERATOR, RETURN_HANDLER_RESULT) {\n            var IteratorProxy = function Iterator2(record, state) {\n                if (state) {\n                    state.iterator = record.iterator;\n                    state.next = record.next;\n                } else state = record;\n                state.type = IS_ITERATOR ? WRAP_FOR_VALID_ITERATOR : ITERATOR_HELPER;\n                state.returnHandlerResult = !!RETURN_HANDLER_RESULT;\n                state.nextHandler = nextHandler;\n                state.counter = 0;\n                state.done = false;\n                setInternalState(this, state);\n            };\n            IteratorProxy.prototype = IS_ITERATOR ? WrapForValidIteratorPrototype : IteratorHelperPrototype;\n            return IteratorProxy;\n        };\n    },\n    /***/ 9486: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        var $ = __webpack_require__2(6518);\n        var globalThis2 = __webpack_require__2(4576);\n        var uncurryThis = __webpack_require__2(9504);\n        var anObjectOrUndefined = __webpack_require__2(3972);\n        var anUint8Array = __webpack_require__2(4154);\n        var notDetached = __webpack_require__2(5169);\n        var base64Map = __webpack_require__2(2804);\n        var getAlphabetOption = __webpack_require__2(944);\n        var base64Alphabet = base64Map.i2c;\n        var base64UrlAlphabet = base64Map.i2cUrl;\n        var charAt = uncurryThis(\"\".charAt);\n        var Uint8Array2 = globalThis2.Uint8Array;\n        var INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS = !Uint8Array2 || !Uint8Array2.prototype.toBase64 || !function() {\n            try {\n                var target = new Uint8Array2();\n                target.toBase64(null);\n            } catch (error) {\n                return true;\n            }\n        }();\n        if (Uint8Array2) $({\n            target: \"Uint8Array\",\n            proto: true,\n            forced: INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS\n        }, {\n            toBase64: function toBase64() {\n                var array = anUint8Array(this);\n                var options = arguments.length ? anObjectOrUndefined(arguments[0]) : void 0;\n                var alphabet = getAlphabetOption(options) === \"base64\" ? base64Alphabet : base64UrlAlphabet;\n                var omitPadding = !!options && !!options.omitPadding;\n                notDetached(this.buffer);\n                var result = \"\";\n                var i = 0;\n                var length = array.length;\n                var triplet;\n                var at = function(shift) {\n                    return charAt(alphabet, triplet >> 6 * shift & 63);\n                };\n                for(; i + 2 < length; i += 3){\n                    triplet = (array[i] << 16) + (array[i + 1] << 8) + array[i + 2];\n                    result += at(3) + at(2) + at(1) + at(0);\n                }\n                if (i + 2 === length) {\n                    triplet = (array[i] << 16) + (array[i + 1] << 8);\n                    result += at(3) + at(2) + at(1) + (omitPadding ? \"\" : \"=\");\n                } else if (i + 1 === length) {\n                    triplet = array[i] << 16;\n                    result += at(3) + at(2) + (omitPadding ? \"\" : \"==\");\n                }\n                return result;\n            }\n        });\n    },\n    /***/ 9504: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var NATIVE_BIND = __webpack_require__2(616);\n        var FunctionPrototype = Function.prototype;\n        var call = FunctionPrototype.call;\n        var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);\n        module2.exports = NATIVE_BIND ? uncurryThisWithBind : function(fn) {\n            return function() {\n                return call.apply(fn, arguments);\n            };\n        };\n    },\n    /***/ 9519: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var globalThis2 = __webpack_require__2(4576);\n        var userAgent = __webpack_require__2(2839);\n        var process2 = globalThis2.process;\n        var Deno2 = globalThis2.Deno;\n        var versions = process2 && process2.versions || Deno2 && Deno2.version;\n        var v8 = versions && versions.v8;\n        var match, version2;\n        if (v8) {\n            match = v8.split(\".\");\n            version2 = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n        }\n        if (!version2 && userAgent) {\n            match = userAgent.match(/Edge\\/(\\d+)/);\n            if (!match || match[1] >= 74) {\n                match = userAgent.match(/Chrome\\/(\\d+)/);\n                if (match) version2 = +match[1];\n            }\n        }\n        module2.exports = version2;\n    },\n    /***/ 9539: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var call = __webpack_require__2(9565);\n        var anObject = __webpack_require__2(8551);\n        var getMethod = __webpack_require__2(5966);\n        module2.exports = function(iterator, kind, value1) {\n            var innerResult, innerError;\n            anObject(iterator);\n            try {\n                innerResult = getMethod(iterator, \"return\");\n                if (!innerResult) {\n                    if (kind === \"throw\") throw value1;\n                    return value1;\n                }\n                innerResult = call(innerResult, iterator);\n            } catch (error) {\n                innerError = true;\n                innerResult = error;\n            }\n            if (kind === \"throw\") throw value1;\n            if (innerError) throw innerResult;\n            anObject(innerResult);\n            return value1;\n        };\n    },\n    /***/ 9565: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var NATIVE_BIND = __webpack_require__2(616);\n        var call = Function.prototype.call;\n        module2.exports = NATIVE_BIND ? call.bind(call) : function() {\n            return call.apply(call, arguments);\n        };\n    },\n    /***/ 9577: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        var arrayWith = __webpack_require__2(9928);\n        var ArrayBufferViewCore = __webpack_require__2(4644);\n        var isBigIntArray = __webpack_require__2(1108);\n        var toIntegerOrInfinity = __webpack_require__2(1291);\n        var toBigInt = __webpack_require__2(5854);\n        var aTypedArray = ArrayBufferViewCore.aTypedArray;\n        var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;\n        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\n        var PROPER_ORDER = function() {\n            try {\n                new Int8Array(1)[\"with\"](2, {\n                    valueOf: function() {\n                        throw 8;\n                    }\n                });\n            } catch (error) {\n                return error === 8;\n            }\n        }();\n        var THROW_ON_NEGATIVE_FRACTIONAL_INDEX = PROPER_ORDER && function() {\n            try {\n                new Int8Array(1)[\"with\"](-0.5, 1);\n            } catch (error) {\n                return true;\n            }\n        }();\n        exportTypedArrayMethod(\"with\", {\n            \"with\": function(index, value1) {\n                var O = aTypedArray(this);\n                var relativeIndex = toIntegerOrInfinity(index);\n                var actualValue = isBigIntArray(O) ? toBigInt(value1) : +value1;\n                return arrayWith(O, getTypedArrayConstructor(O), relativeIndex, actualValue);\n            }\n        }[\"with\"], !PROPER_ORDER || THROW_ON_NEGATIVE_FRACTIONAL_INDEX);\n    },\n    /***/ 9590: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var toIntegerOrInfinity = __webpack_require__2(1291);\n        var $RangeError = RangeError;\n        module2.exports = function(it) {\n            var result = toIntegerOrInfinity(it);\n            if (result < 0) throw new $RangeError(\"The argument can't be less than 0\");\n            return result;\n        };\n    },\n    /***/ 9617: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var toIndexedObject = __webpack_require__2(5397);\n        var toAbsoluteIndex = __webpack_require__2(5610);\n        var lengthOfArrayLike = __webpack_require__2(6198);\n        var createMethod = function(IS_INCLUDES) {\n            return function($this, el, fromIndex) {\n                var O = toIndexedObject($this);\n                var length = lengthOfArrayLike(O);\n                if (length === 0) return !IS_INCLUDES && -1;\n                var index = toAbsoluteIndex(fromIndex, length);\n                var value1;\n                if (IS_INCLUDES && el !== el) while(length > index){\n                    value1 = O[index++];\n                    if (value1 !== value1) return true;\n                }\n                else for(; length > index; index++){\n                    if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n                }\n                return !IS_INCLUDES && -1;\n            };\n        };\n        module2.exports = {\n            // `Array.prototype.includes` method\n            // https://tc39.es/ecma262/#sec-array.prototype.includes\n            includes: createMethod(true),\n            // `Array.prototype.indexOf` method\n            // https://tc39.es/ecma262/#sec-array.prototype.indexof\n            indexOf: createMethod(false)\n        };\n    },\n    /***/ 9631: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        __webpack_require__2(9486);\n    },\n    /***/ 9797: /***/ (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2)=>{\n        __webpack_require__2(4226);\n    },\n    /***/ 9835: /***/ (module2)=>{\n        module2.exports = function(METHOD_NAME) {\n            try {\n                var baseSet = /* @__PURE__ */ new Set();\n                var setLike = {\n                    size: 0,\n                    has: function() {\n                        return true;\n                    },\n                    keys: function() {\n                        return Object.defineProperty({}, \"next\", {\n                            get: function() {\n                                baseSet.clear();\n                                baseSet.add(4);\n                                return function() {\n                                    return {\n                                        done: true\n                                    };\n                                };\n                            }\n                        });\n                    }\n                };\n                var result = baseSet[METHOD_NAME](setLike);\n                return result.size === 1 && result.values().next().value === 4;\n            } catch (error) {\n                return false;\n            }\n        };\n    },\n    /***/ 9928: /***/ (module2, __unused_webpack_exports, __webpack_require__2)=>{\n        var lengthOfArrayLike = __webpack_require__2(6198);\n        var toIntegerOrInfinity = __webpack_require__2(1291);\n        var $RangeError = RangeError;\n        module2.exports = function(O, C, index, value1) {\n            var len = lengthOfArrayLike(O);\n            var relativeIndex = toIntegerOrInfinity(index);\n            var actualIndex = relativeIndex < 0 ? len + relativeIndex : relativeIndex;\n            if (actualIndex >= len || actualIndex < 0) throw new $RangeError(\"Incorrect index\");\n            var A = new C(len);\n            var k = 0;\n            for(; k < len; k++)A[k] = k === actualIndex ? value1 : O[k];\n            return A;\n        };\n    }\n};\nvar __webpack_module_cache__ = {};\nfunction __nested_webpack_require_192967__(moduleId) {\n    var cachedModule = __webpack_module_cache__[moduleId];\n    if (cachedModule !== void 0) {\n        return cachedModule.exports;\n    }\n    var module2 = __webpack_module_cache__[moduleId] = {\n        /******/ // no module.id needed\n        /******/ // no module.loaded needed\n        /******/ exports: {}\n    };\n    __webpack_modules__[moduleId].call(module2.exports, module2, module2.exports, __nested_webpack_require_192967__);\n    return module2.exports;\n}\n(()=>{\n    __nested_webpack_require_192967__.d = (exports2, definition)=>{\n        for(var key in definition){\n            if (__nested_webpack_require_192967__.o(definition, key) && !__nested_webpack_require_192967__.o(exports2, key)) {\n                Object.defineProperty(exports2, key, {\n                    enumerable: true,\n                    get: definition[key]\n                });\n            }\n        }\n    };\n})();\n(()=>{\n    __nested_webpack_require_192967__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);\n})();\n__nested_webpack_require_192967__(4114);\n__nested_webpack_require_192967__(6573);\n__nested_webpack_require_192967__(8100);\n__nested_webpack_require_192967__(7936);\n__nested_webpack_require_192967__(8111);\n__nested_webpack_require_192967__(8237);\n__nested_webpack_require_192967__(1689);\n__nested_webpack_require_192967__(9577);\n__nested_webpack_require_192967__(4235);\n__nested_webpack_require_192967__(9432);\n__nested_webpack_require_192967__(1549);\n__nested_webpack_require_192967__(9797);\n__nested_webpack_require_192967__(9631);\n__nested_webpack_require_192967__(5623);\n__nested_webpack_require_192967__(4979);\n__nested_webpack_require_192967__(5781);\nconst isNodeJS = typeof process === \"object\" && process + \"\" === \"[object process]\" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== \"browser\");\nconst FONT_IDENTITY_MATRIX = [\n    1e-3,\n    0,\n    0,\n    1e-3,\n    0,\n    0\n];\nconst LINE_FACTOR = 1.35;\nconst RenderingIntentFlag = {\n    ANY: 1,\n    DISPLAY: 2,\n    PRINT: 4,\n    ANNOTATIONS_FORMS: 16,\n    ANNOTATIONS_STORAGE: 32,\n    ANNOTATIONS_DISABLE: 64,\n    IS_EDITING: 128,\n    OPLIST: 256\n};\nconst AnnotationMode = {\n    DISABLE: 0,\n    ENABLE: 1,\n    ENABLE_FORMS: 2,\n    ENABLE_STORAGE: 3\n};\nconst AnnotationEditorPrefix = \"pdfjs_internal_editor_\";\nconst AnnotationEditorType = {\n    DISABLE: -1,\n    NONE: 0,\n    FREETEXT: 3,\n    HIGHLIGHT: 9,\n    STAMP: 13,\n    INK: 15,\n    POPUP: 16,\n    SIGNATURE: 101,\n    COMMENT: 102\n};\nconst AnnotationEditorParamsType = {\n    RESIZE: 1,\n    CREATE: 2,\n    FREETEXT_SIZE: 11,\n    FREETEXT_COLOR: 12,\n    FREETEXT_OPACITY: 13,\n    INK_COLOR: 21,\n    INK_THICKNESS: 22,\n    INK_OPACITY: 23,\n    HIGHLIGHT_COLOR: 31,\n    HIGHLIGHT_THICKNESS: 32,\n    HIGHLIGHT_FREE: 33,\n    HIGHLIGHT_SHOW_ALL: 34,\n    DRAW_STEP: 41\n};\nconst PermissionFlag = {\n    PRINT: 4,\n    MODIFY_CONTENTS: 8,\n    COPY: 16,\n    MODIFY_ANNOTATIONS: 32,\n    FILL_INTERACTIVE_FORMS: 256,\n    COPY_FOR_ACCESSIBILITY: 512,\n    ASSEMBLE: 1024,\n    PRINT_HIGH_QUALITY: 2048\n};\nconst TextRenderingMode = {\n    FILL: 0,\n    STROKE: 1,\n    FILL_STROKE: 2,\n    INVISIBLE: 3,\n    FILL_STROKE_MASK: 3,\n    ADD_TO_PATH_FLAG: 4\n};\nconst util_ImageKind = {\n    GRAYSCALE_1BPP: 1,\n    RGB_24BPP: 2,\n    RGBA_32BPP: 3\n};\nconst AnnotationType = {\n    TEXT: 1,\n    LINK: 2,\n    FREETEXT: 3,\n    LINE: 4,\n    SQUARE: 5,\n    CIRCLE: 6,\n    POLYGON: 7,\n    POLYLINE: 8,\n    HIGHLIGHT: 9,\n    UNDERLINE: 10,\n    SQUIGGLY: 11,\n    STRIKEOUT: 12,\n    STAMP: 13,\n    CARET: 14,\n    INK: 15,\n    POPUP: 16,\n    FILEATTACHMENT: 17,\n    SOUND: 18,\n    MOVIE: 19,\n    WIDGET: 20,\n    SCREEN: 21,\n    PRINTERMARK: 22,\n    TRAPNET: 23,\n    WATERMARK: 24,\n    THREED: 25,\n    REDACT: 26\n};\nconst AnnotationBorderStyleType = {\n    SOLID: 1,\n    DASHED: 2,\n    BEVELED: 3,\n    INSET: 4,\n    UNDERLINE: 5\n};\nconst VerbosityLevel = {\n    ERRORS: 0,\n    WARNINGS: 1,\n    INFOS: 5\n};\nconst OPS = {\n    dependency: 1,\n    setLineWidth: 2,\n    setLineCap: 3,\n    setLineJoin: 4,\n    setMiterLimit: 5,\n    setDash: 6,\n    setRenderingIntent: 7,\n    setFlatness: 8,\n    setGState: 9,\n    save: 10,\n    restore: 11,\n    transform: 12,\n    moveTo: 13,\n    lineTo: 14,\n    curveTo: 15,\n    curveTo2: 16,\n    curveTo3: 17,\n    closePath: 18,\n    rectangle: 19,\n    stroke: 20,\n    closeStroke: 21,\n    fill: 22,\n    eoFill: 23,\n    fillStroke: 24,\n    eoFillStroke: 25,\n    closeFillStroke: 26,\n    closeEOFillStroke: 27,\n    endPath: 28,\n    clip: 29,\n    eoClip: 30,\n    beginText: 31,\n    endText: 32,\n    setCharSpacing: 33,\n    setWordSpacing: 34,\n    setHScale: 35,\n    setLeading: 36,\n    setFont: 37,\n    setTextRenderingMode: 38,\n    setTextRise: 39,\n    moveText: 40,\n    setLeadingMoveText: 41,\n    setTextMatrix: 42,\n    nextLine: 43,\n    showText: 44,\n    showSpacedText: 45,\n    nextLineShowText: 46,\n    nextLineSetSpacingShowText: 47,\n    setCharWidth: 48,\n    setCharWidthAndBounds: 49,\n    setStrokeColorSpace: 50,\n    setFillColorSpace: 51,\n    setStrokeColor: 52,\n    setStrokeColorN: 53,\n    setFillColor: 54,\n    setFillColorN: 55,\n    setStrokeGray: 56,\n    setFillGray: 57,\n    setStrokeRGBColor: 58,\n    setFillRGBColor: 59,\n    setStrokeCMYKColor: 60,\n    setFillCMYKColor: 61,\n    shadingFill: 62,\n    beginInlineImage: 63,\n    beginImageData: 64,\n    endInlineImage: 65,\n    paintXObject: 66,\n    markPoint: 67,\n    markPointProps: 68,\n    beginMarkedContent: 69,\n    beginMarkedContentProps: 70,\n    endMarkedContent: 71,\n    beginCompat: 72,\n    endCompat: 73,\n    paintFormXObjectBegin: 74,\n    paintFormXObjectEnd: 75,\n    beginGroup: 76,\n    endGroup: 77,\n    beginAnnotation: 80,\n    endAnnotation: 81,\n    paintImageMaskXObject: 83,\n    paintImageMaskXObjectGroup: 84,\n    paintImageXObject: 85,\n    paintInlineImageXObject: 86,\n    paintInlineImageXObjectGroup: 87,\n    paintImageXObjectRepeat: 88,\n    paintImageMaskXObjectRepeat: 89,\n    paintSolidColorImageMask: 90,\n    constructPath: 91,\n    setStrokeTransparent: 92,\n    setFillTransparent: 93,\n    rawFillPath: 94\n};\nconst DrawOPS = {\n    moveTo: 0,\n    lineTo: 1,\n    curveTo: 2,\n    closePath: 3\n};\nconst PasswordResponses = {\n    NEED_PASSWORD: 1,\n    INCORRECT_PASSWORD: 2\n};\nlet verbosity = VerbosityLevel.WARNINGS;\nfunction setVerbosityLevel(level) {\n    if (Number.isInteger(level)) {\n        verbosity = level;\n    }\n}\nfunction getVerbosityLevel() {\n    return verbosity;\n}\nfunction info(msg) {\n    if (verbosity >= VerbosityLevel.INFOS) {\n        console.info(`Info: ${msg}`);\n    }\n}\nfunction warn(msg) {\n    if (verbosity >= VerbosityLevel.WARNINGS) {\n        console.warn(`Warning: ${msg}`);\n    }\n}\nfunction unreachable(msg) {\n    throw new Error(msg);\n}\nfunction assert(cond, msg) {\n    if (!cond) {\n        unreachable(msg);\n    }\n}\nfunction _isValidProtocol(url) {\n    switch(url?.protocol){\n        case \"http:\":\n        case \"https:\":\n        case \"ftp:\":\n        case \"mailto:\":\n        case \"tel:\":\n            return true;\n        default:\n            return false;\n    }\n}\nfunction createValidAbsoluteUrl(url, baseUrl = null, options = null) {\n    if (!url) {\n        return null;\n    }\n    if (options && typeof url === \"string\") {\n        if (options.addDefaultProtocol && url.startsWith(\"www.\")) {\n            const dots = url.match(/\\./g);\n            if (dots?.length >= 2) {\n                url = `http://${url}`;\n            }\n        }\n        if (options.tryConvertEncoding) {\n            try {\n                url = stringToUTF8String(url);\n            } catch  {}\n        }\n    }\n    const absoluteUrl = baseUrl ? URL.parse(url, baseUrl) : URL.parse(url);\n    return _isValidProtocol(absoluteUrl) ? absoluteUrl : null;\n}\nfunction updateUrlHash(url, hash, allowRel = false) {\n    const res = URL.parse(url);\n    if (res) {\n        res.hash = hash;\n        return res.href;\n    }\n    if (allowRel && createValidAbsoluteUrl(url, \"http://example.com\")) {\n        return url.split(\"#\", 1)[0] + `${hash ? `#${hash}` : \"\"}`;\n    }\n    return \"\";\n}\nfunction shadow(obj, prop, value1, nonSerializable = false) {\n    Object.defineProperty(obj, prop, {\n        value: value1,\n        enumerable: !nonSerializable,\n        configurable: true,\n        writable: false\n    });\n    return value1;\n}\nconst BaseException = function BaseExceptionClosure() {\n    function BaseException2(message, name) {\n        this.message = message;\n        this.name = name;\n    }\n    BaseException2.prototype = new Error();\n    BaseException2.constructor = BaseException2;\n    return BaseException2;\n}();\nclass PasswordException extends BaseException {\n    constructor(msg, code){\n        super(msg, \"PasswordException\");\n        this.code = code;\n    }\n}\nclass UnknownErrorException extends BaseException {\n    constructor(msg, details){\n        super(msg, \"UnknownErrorException\");\n        this.details = details;\n    }\n}\nclass InvalidPDFException extends BaseException {\n    constructor(msg){\n        super(msg, \"InvalidPDFException\");\n    }\n}\nclass ResponseException extends BaseException {\n    constructor(msg, status, missing){\n        super(msg, \"ResponseException\");\n        this.status = status;\n        this.missing = missing;\n    }\n}\nclass FormatError extends BaseException {\n    constructor(msg){\n        super(msg, \"FormatError\");\n    }\n}\nclass AbortException extends BaseException {\n    constructor(msg){\n        super(msg, \"AbortException\");\n    }\n}\nfunction bytesToString(bytes) {\n    if (typeof bytes !== \"object\" || bytes?.length === void 0) {\n        unreachable(\"Invalid argument for bytesToString\");\n    }\n    const length = bytes.length;\n    const MAX_ARGUMENT_COUNT = 8192;\n    if (length < MAX_ARGUMENT_COUNT) {\n        return String.fromCharCode.apply(null, bytes);\n    }\n    const strBuf = [];\n    for(let i = 0; i < length; i += MAX_ARGUMENT_COUNT){\n        const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);\n        const chunk = bytes.subarray(i, chunkEnd);\n        strBuf.push(String.fromCharCode.apply(null, chunk));\n    }\n    return strBuf.join(\"\");\n}\nfunction stringToBytes(str) {\n    if (typeof str !== \"string\") {\n        unreachable(\"Invalid argument for stringToBytes\");\n    }\n    const length = str.length;\n    const bytes = new Uint8Array(length);\n    for(let i = 0; i < length; ++i){\n        bytes[i] = str.charCodeAt(i) & 255;\n    }\n    return bytes;\n}\nfunction string32(value1) {\n    return String.fromCharCode(value1 >> 24 & 255, value1 >> 16 & 255, value1 >> 8 & 255, value1 & 255);\n}\nfunction isLittleEndian() {\n    const buffer8 = new Uint8Array(4);\n    buffer8[0] = 1;\n    const view32 = new Uint32Array(buffer8.buffer, 0, 1);\n    return view32[0] === 1;\n}\nfunction isEvalSupported() {\n    try {\n        new Function(\"\");\n        return true;\n    } catch  {\n        return false;\n    }\n}\nclass util_FeatureTest {\n    static get isLittleEndian() {\n        return shadow(this, \"isLittleEndian\", isLittleEndian());\n    }\n    static get isEvalSupported() {\n        return shadow(this, \"isEvalSupported\", isEvalSupported());\n    }\n    static get isOffscreenCanvasSupported() {\n        return shadow(this, \"isOffscreenCanvasSupported\", typeof OffscreenCanvas !== \"undefined\");\n    }\n    static get isImageDecoderSupported() {\n        return shadow(this, \"isImageDecoderSupported\", typeof ImageDecoder !== \"undefined\");\n    }\n    static get platform() {\n        const { platform, userAgent } = navigator;\n        return shadow(this, \"platform\", {\n            isAndroid: userAgent.includes(\"Android\"),\n            isLinux: platform.includes(\"Linux\"),\n            isMac: platform.includes(\"Mac\"),\n            isWindows: platform.includes(\"Win\"),\n            isFirefox: userAgent.includes(\"Firefox\")\n        });\n    }\n    static get isCSSRoundSupported() {\n        return shadow(this, \"isCSSRoundSupported\", globalThis.CSS?.supports?.(\"width: round(1.5px, 1px)\"));\n    }\n}\nconst hexNumbers = Array.from(Array(256).keys(), (n)=>n.toString(16).padStart(2, \"0\"));\nclass Util {\n    static makeHexColor(r, g, b) {\n        return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;\n    }\n    static domMatrixToTransform(dm) {\n        return [\n            dm.a,\n            dm.b,\n            dm.c,\n            dm.d,\n            dm.e,\n            dm.f\n        ];\n    }\n    static scaleMinMax(transform, minMax) {\n        let temp;\n        if (transform[0]) {\n            if (transform[0] < 0) {\n                temp = minMax[0];\n                minMax[0] = minMax[2];\n                minMax[2] = temp;\n            }\n            minMax[0] *= transform[0];\n            minMax[2] *= transform[0];\n            if (transform[3] < 0) {\n                temp = minMax[1];\n                minMax[1] = minMax[3];\n                minMax[3] = temp;\n            }\n            minMax[1] *= transform[3];\n            minMax[3] *= transform[3];\n        } else {\n            temp = minMax[0];\n            minMax[0] = minMax[1];\n            minMax[1] = temp;\n            temp = minMax[2];\n            minMax[2] = minMax[3];\n            minMax[3] = temp;\n            if (transform[1] < 0) {\n                temp = minMax[1];\n                minMax[1] = minMax[3];\n                minMax[3] = temp;\n            }\n            minMax[1] *= transform[1];\n            minMax[3] *= transform[1];\n            if (transform[2] < 0) {\n                temp = minMax[0];\n                minMax[0] = minMax[2];\n                minMax[2] = temp;\n            }\n            minMax[0] *= transform[2];\n            minMax[2] *= transform[2];\n        }\n        minMax[0] += transform[4];\n        minMax[1] += transform[5];\n        minMax[2] += transform[4];\n        minMax[3] += transform[5];\n    }\n    static transform(m1, m2) {\n        return [\n            m1[0] * m2[0] + m1[2] * m2[1],\n            m1[1] * m2[0] + m1[3] * m2[1],\n            m1[0] * m2[2] + m1[2] * m2[3],\n            m1[1] * m2[2] + m1[3] * m2[3],\n            m1[0] * m2[4] + m1[2] * m2[5] + m1[4],\n            m1[1] * m2[4] + m1[3] * m2[5] + m1[5]\n        ];\n    }\n    static multiplyByDOMMatrix(m, md) {\n        return [\n            m[0] * md.a + m[2] * md.b,\n            m[1] * md.a + m[3] * md.b,\n            m[0] * md.c + m[2] * md.d,\n            m[1] * md.c + m[3] * md.d,\n            m[0] * md.e + m[2] * md.f + m[4],\n            m[1] * md.e + m[3] * md.f + m[5]\n        ];\n    }\n    static applyTransform(p, m, pos = 0) {\n        const p0 = p[pos];\n        const p1 = p[pos + 1];\n        p[pos] = p0 * m[0] + p1 * m[2] + m[4];\n        p[pos + 1] = p0 * m[1] + p1 * m[3] + m[5];\n    }\n    static applyTransformToBezier(p, transform, pos = 0) {\n        const m0 = transform[0];\n        const m1 = transform[1];\n        const m2 = transform[2];\n        const m3 = transform[3];\n        const m4 = transform[4];\n        const m5 = transform[5];\n        for(let i = 0; i < 6; i += 2){\n            const pI = p[pos + i];\n            const pI1 = p[pos + i + 1];\n            p[pos + i] = pI * m0 + pI1 * m2 + m4;\n            p[pos + i + 1] = pI * m1 + pI1 * m3 + m5;\n        }\n    }\n    static applyInverseTransform(p, m) {\n        const p0 = p[0];\n        const p1 = p[1];\n        const d = m[0] * m[3] - m[1] * m[2];\n        p[0] = (p0 * m[3] - p1 * m[2] + m[2] * m[5] - m[4] * m[3]) / d;\n        p[1] = (-p0 * m[1] + p1 * m[0] + m[4] * m[1] - m[5] * m[0]) / d;\n    }\n    static axialAlignedBoundingBox(rect, transform, output) {\n        const m0 = transform[0];\n        const m1 = transform[1];\n        const m2 = transform[2];\n        const m3 = transform[3];\n        const m4 = transform[4];\n        const m5 = transform[5];\n        const r0 = rect[0];\n        const r1 = rect[1];\n        const r2 = rect[2];\n        const r3 = rect[3];\n        let a0 = m0 * r0 + m4;\n        let a2 = a0;\n        let a1 = m0 * r2 + m4;\n        let a3 = a1;\n        let b0 = m3 * r1 + m5;\n        let b2 = b0;\n        let b1 = m3 * r3 + m5;\n        let b3 = b1;\n        if (m1 !== 0 || m2 !== 0) {\n            const m1r0 = m1 * r0;\n            const m1r2 = m1 * r2;\n            const m2r1 = m2 * r1;\n            const m2r3 = m2 * r3;\n            a0 += m2r1;\n            a3 += m2r1;\n            a1 += m2r3;\n            a2 += m2r3;\n            b0 += m1r0;\n            b3 += m1r0;\n            b1 += m1r2;\n            b2 += m1r2;\n        }\n        output[0] = Math.min(output[0], a0, a1, a2, a3);\n        output[1] = Math.min(output[1], b0, b1, b2, b3);\n        output[2] = Math.max(output[2], a0, a1, a2, a3);\n        output[3] = Math.max(output[3], b0, b1, b2, b3);\n    }\n    static inverseTransform(m) {\n        const d = m[0] * m[3] - m[1] * m[2];\n        return [\n            m[3] / d,\n            -m[1] / d,\n            -m[2] / d,\n            m[0] / d,\n            (m[2] * m[5] - m[4] * m[3]) / d,\n            (m[4] * m[1] - m[5] * m[0]) / d\n        ];\n    }\n    static singularValueDecompose2dScale(matrix, output) {\n        const m0 = matrix[0];\n        const m1 = matrix[1];\n        const m2 = matrix[2];\n        const m3 = matrix[3];\n        const a = m0 ** 2 + m1 ** 2;\n        const b = m0 * m2 + m1 * m3;\n        const c = m2 ** 2 + m3 ** 2;\n        const first = (a + c) / 2;\n        const second = Math.sqrt(first ** 2 - (a * c - b ** 2));\n        output[0] = Math.sqrt(first + second || 1);\n        output[1] = Math.sqrt(first - second || 1);\n    }\n    static normalizeRect(rect) {\n        const r = rect.slice(0);\n        if (rect[0] > rect[2]) {\n            r[0] = rect[2];\n            r[2] = rect[0];\n        }\n        if (rect[1] > rect[3]) {\n            r[1] = rect[3];\n            r[3] = rect[1];\n        }\n        return r;\n    }\n    static intersect(rect1, rect2) {\n        const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));\n        const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));\n        if (xLow > xHigh) {\n            return null;\n        }\n        const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));\n        const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));\n        if (yLow > yHigh) {\n            return null;\n        }\n        return [\n            xLow,\n            yLow,\n            xHigh,\n            yHigh\n        ];\n    }\n    static pointBoundingBox(x, y, minMax) {\n        minMax[0] = Math.min(minMax[0], x);\n        minMax[1] = Math.min(minMax[1], y);\n        minMax[2] = Math.max(minMax[2], x);\n        minMax[3] = Math.max(minMax[3], y);\n    }\n    static rectBoundingBox(x0, y0, x1, y1, minMax) {\n        minMax[0] = Math.min(minMax[0], x0, x1);\n        minMax[1] = Math.min(minMax[1], y0, y1);\n        minMax[2] = Math.max(minMax[2], x0, x1);\n        minMax[3] = Math.max(minMax[3], y0, y1);\n    }\n    static #getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, t, minMax) {\n        if (t <= 0 || t >= 1) {\n            return;\n        }\n        const mt = 1 - t;\n        const tt = t * t;\n        const ttt = tt * t;\n        const x = mt * (mt * (mt * x0 + 3 * t * x1) + 3 * tt * x2) + ttt * x3;\n        const y = mt * (mt * (mt * y0 + 3 * t * y1) + 3 * tt * y2) + ttt * y3;\n        minMax[0] = Math.min(minMax[0], x);\n        minMax[1] = Math.min(minMax[1], y);\n        minMax[2] = Math.max(minMax[2], x);\n        minMax[3] = Math.max(minMax[3], y);\n    }\n    static #getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, a, b, c, minMax) {\n        if (Math.abs(a) < 1e-12) {\n            if (Math.abs(b) >= 1e-12) {\n                this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, -c / b, minMax);\n            }\n            return;\n        }\n        const delta = b ** 2 - 4 * c * a;\n        if (delta < 0) {\n            return;\n        }\n        const sqrtDelta = Math.sqrt(delta);\n        const a2 = 2 * a;\n        this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, (-b + sqrtDelta) / a2, minMax);\n        this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, (-b - sqrtDelta) / a2, minMax);\n    }\n    static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3, minMax) {\n        minMax[0] = Math.min(minMax[0], x0, x3);\n        minMax[1] = Math.min(minMax[1], y0, y3);\n        minMax[2] = Math.max(minMax[2], x0, x3);\n        minMax[3] = Math.max(minMax[3], y0, y3);\n        this.#getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-x0 + 3 * (x1 - x2) + x3), 6 * (x0 - 2 * x1 + x2), 3 * (x1 - x0), minMax);\n        this.#getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-y0 + 3 * (y1 - y2) + y3), 6 * (y0 - 2 * y1 + y2), 3 * (y1 - y0), minMax);\n    }\n}\nfunction stringToUTF8String(str) {\n    return decodeURIComponent(escape(str));\n}\nlet NormalizeRegex = null;\nlet NormalizationMap = null;\nfunction normalizeUnicode(str) {\n    if (!NormalizeRegex) {\n        NormalizeRegex = /([\\u00a0\\u00b5\\u037e\\u0eb3\\u2000-\\u200a\\u202f\\u2126\\ufb00-\\ufb04\\ufb06\\ufb20-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40-\\ufb41\\ufb43-\\ufb44\\ufb46-\\ufba1\\ufba4-\\ufba9\\ufbae-\\ufbb1\\ufbd3-\\ufbdc\\ufbde-\\ufbe7\\ufbea-\\ufbf8\\ufbfc-\\ufbfd\\ufc00-\\ufc5d\\ufc64-\\ufcf1\\ufcf5-\\ufd3d\\ufd88\\ufdf4\\ufdfa-\\ufdfb\\ufe71\\ufe77\\ufe79\\ufe7b\\ufe7d]+)|(\\ufb05+)/gu;\n        NormalizationMap = /* @__PURE__ */ new Map([\n            [\n                \"ﬅ\",\n                \"ſt\"\n            ]\n        ]);\n    }\n    return str.replaceAll(NormalizeRegex, (_, p1, p2)=>p1 ? p1.normalize(\"NFKC\") : NormalizationMap.get(p2));\n}\nfunction getUuid() {\n    if (typeof crypto.randomUUID === \"function\") {\n        return crypto.randomUUID();\n    }\n    const buf = new Uint8Array(32);\n    crypto.getRandomValues(buf);\n    return bytesToString(buf);\n}\nconst AnnotationPrefix = \"pdfjs_internal_id_\";\nfunction _isValidExplicitDest(validRef, validName, dest) {\n    if (!Array.isArray(dest) || dest.length < 2) {\n        return false;\n    }\n    const [page, zoom, ...args] = dest;\n    if (!validRef(page) && !Number.isInteger(page)) {\n        return false;\n    }\n    if (!validName(zoom)) {\n        return false;\n    }\n    const argsLen = args.length;\n    let allowNull = true;\n    switch(zoom.name){\n        case \"XYZ\":\n            if (argsLen < 2 || argsLen > 3) {\n                return false;\n            }\n            break;\n        case \"Fit\":\n        case \"FitB\":\n            return argsLen === 0;\n        case \"FitH\":\n        case \"FitBH\":\n        case \"FitV\":\n        case \"FitBV\":\n            if (argsLen > 1) {\n                return false;\n            }\n            break;\n        case \"FitR\":\n            if (argsLen !== 4) {\n                return false;\n            }\n            allowNull = false;\n            break;\n        default:\n            return false;\n    }\n    for (const arg of args){\n        if (typeof arg === \"number\" || allowNull && arg === null) {\n            continue;\n        }\n        return false;\n    }\n    return true;\n}\nfunction MathClamp(v, min, max) {\n    return Math.min(Math.max(v, min), max);\n}\nfunction toBase64Util(arr) {\n    if (Uint8Array.prototype.toBase64) {\n        return arr.toBase64();\n    }\n    return btoa(bytesToString(arr));\n}\nfunction fromBase64Util(str) {\n    if (Uint8Array.fromBase64) {\n        return Uint8Array.fromBase64(str);\n    }\n    return stringToBytes(atob(str));\n}\nif (typeof Math.sumPrecise !== \"function\") {\n    Math.sumPrecise = function(numbers) {\n        return numbers.reduce((a, b)=>a + b, 0);\n    };\n}\nif (typeof AbortSignal.any !== \"function\") {\n    AbortSignal.any = function(iterable) {\n        const ac = new AbortController();\n        const { signal } = ac;\n        for (const s of iterable){\n            if (s.aborted) {\n                ac.abort(s.reason);\n                return signal;\n            }\n        }\n        for (const s of iterable){\n            s.addEventListener(\"abort\", ()=>{\n                ac.abort(s.reason);\n            }, {\n                signal\n            });\n        }\n        return signal;\n    };\n}\n__nested_webpack_require_192967__(1701);\n__nested_webpack_require_192967__(4603);\n__nested_webpack_require_192967__(7566);\n__nested_webpack_require_192967__(8721);\nclass XfaText {\n    static textContent(xfa) {\n        const items = [];\n        const output = {\n            items,\n            styles: /* @__PURE__ */ Object.create(null)\n        };\n        function walk(node) {\n            if (!node) {\n                return;\n            }\n            let str = null;\n            const name = node.name;\n            if (name === \"#text\") {\n                str = node.value;\n            } else if (!XfaText.shouldBuildText(name)) {\n                return;\n            } else if (node?.attributes?.textContent) {\n                str = node.attributes.textContent;\n            } else if (node.value) {\n                str = node.value;\n            }\n            if (str !== null) {\n                items.push({\n                    str\n                });\n            }\n            if (!node.children) {\n                return;\n            }\n            for (const child of node.children){\n                walk(child);\n            }\n        }\n        walk(xfa);\n        return output;\n    }\n    static shouldBuildText(name) {\n        return !(name === \"textarea\" || name === \"input\" || name === \"option\" || name === \"select\");\n    }\n}\nclass XfaLayer {\n    static setupStorage(html, id, element, storage, intent) {\n        const storedData = storage.getValue(id, {\n            value: null\n        });\n        switch(element.name){\n            case \"textarea\":\n                if (storedData.value !== null) {\n                    html.textContent = storedData.value;\n                }\n                if (intent === \"print\") {\n                    break;\n                }\n                html.addEventListener(\"input\", (event)=>{\n                    storage.setValue(id, {\n                        value: event.target.value\n                    });\n                });\n                break;\n            case \"input\":\n                if (element.attributes.type === \"radio\" || element.attributes.type === \"checkbox\") {\n                    if (storedData.value === element.attributes.xfaOn) {\n                        html.setAttribute(\"checked\", true);\n                    } else if (storedData.value === element.attributes.xfaOff) {\n                        html.removeAttribute(\"checked\");\n                    }\n                    if (intent === \"print\") {\n                        break;\n                    }\n                    html.addEventListener(\"change\", (event)=>{\n                        storage.setValue(id, {\n                            value: event.target.checked ? event.target.getAttribute(\"xfaOn\") : event.target.getAttribute(\"xfaOff\")\n                        });\n                    });\n                } else {\n                    if (storedData.value !== null) {\n                        html.setAttribute(\"value\", storedData.value);\n                    }\n                    if (intent === \"print\") {\n                        break;\n                    }\n                    html.addEventListener(\"input\", (event)=>{\n                        storage.setValue(id, {\n                            value: event.target.value\n                        });\n                    });\n                }\n                break;\n            case \"select\":\n                if (storedData.value !== null) {\n                    html.setAttribute(\"value\", storedData.value);\n                    for (const option of element.children){\n                        if (option.attributes.value === storedData.value) {\n                            option.attributes.selected = true;\n                        } else if (option.attributes.hasOwnProperty(\"selected\")) {\n                            delete option.attributes.selected;\n                        }\n                    }\n                }\n                html.addEventListener(\"input\", (event)=>{\n                    const options = event.target.options;\n                    const value1 = options.selectedIndex === -1 ? \"\" : options[options.selectedIndex].value;\n                    storage.setValue(id, {\n                        value: value1\n                    });\n                });\n                break;\n        }\n    }\n    static setAttributes({ html, element, storage = null, intent, linkService }) {\n        const { attributes } = element;\n        const isHTMLAnchorElement = html instanceof HTMLAnchorElement;\n        if (attributes.type === \"radio\") {\n            attributes.name = `${attributes.name}-${intent}`;\n        }\n        for (const [key, value1] of Object.entries(attributes)){\n            if (value1 === null || value1 === void 0) {\n                continue;\n            }\n            switch(key){\n                case \"class\":\n                    if (value1.length) {\n                        html.setAttribute(key, value1.join(\" \"));\n                    }\n                    break;\n                case \"dataId\":\n                    break;\n                case \"id\":\n                    html.setAttribute(\"data-element-id\", value1);\n                    break;\n                case \"style\":\n                    Object.assign(html.style, value1);\n                    break;\n                case \"textContent\":\n                    html.textContent = value1;\n                    break;\n                default:\n                    if (!isHTMLAnchorElement || key !== \"href\" && key !== \"newWindow\") {\n                        html.setAttribute(key, value1);\n                    }\n            }\n        }\n        if (isHTMLAnchorElement) {\n            linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);\n        }\n        if (storage && attributes.dataId) {\n            this.setupStorage(html, attributes.dataId, element, storage);\n        }\n    }\n    static render(parameters) {\n        const storage = parameters.annotationStorage;\n        const linkService = parameters.linkService;\n        const root = parameters.xfaHtml;\n        const intent = parameters.intent || \"display\";\n        const rootHtml = document.createElement(root.name);\n        if (root.attributes) {\n            this.setAttributes({\n                html: rootHtml,\n                element: root,\n                intent,\n                linkService\n            });\n        }\n        const isNotForRichText = intent !== \"richText\";\n        const rootDiv = parameters.div;\n        rootDiv.append(rootHtml);\n        if (parameters.viewport) {\n            const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n            rootDiv.style.transform = transform;\n        }\n        if (isNotForRichText) {\n            rootDiv.setAttribute(\"class\", \"xfaLayer xfaFont\");\n        }\n        const textDivs = [];\n        if (root.children.length === 0) {\n            if (root.value) {\n                const node = document.createTextNode(root.value);\n                rootHtml.append(node);\n                if (isNotForRichText && XfaText.shouldBuildText(root.name)) {\n                    textDivs.push(node);\n                }\n            }\n            return {\n                textDivs\n            };\n        }\n        const stack = [\n            [\n                root,\n                -1,\n                rootHtml\n            ]\n        ];\n        while(stack.length > 0){\n            const [parent, i, html] = stack.at(-1);\n            if (i + 1 === parent.children.length) {\n                stack.pop();\n                continue;\n            }\n            const child = parent.children[++stack.at(-1)[1]];\n            if (child === null) {\n                continue;\n            }\n            const { name } = child;\n            if (name === \"#text\") {\n                const node = document.createTextNode(child.value);\n                textDivs.push(node);\n                html.append(node);\n                continue;\n            }\n            const childHtml = child?.attributes?.xmlns ? document.createElementNS(child.attributes.xmlns, name) : document.createElement(name);\n            html.append(childHtml);\n            if (child.attributes) {\n                this.setAttributes({\n                    html: childHtml,\n                    element: child,\n                    storage,\n                    intent,\n                    linkService\n                });\n            }\n            if (child.children?.length > 0) {\n                stack.push([\n                    child,\n                    -1,\n                    childHtml\n                ]);\n            } else if (child.value) {\n                const node = document.createTextNode(child.value);\n                if (isNotForRichText && XfaText.shouldBuildText(name)) {\n                    textDivs.push(node);\n                }\n                childHtml.append(node);\n            }\n        }\n        for (const el of rootDiv.querySelectorAll(\".xfaNonInteractive input, .xfaNonInteractive textarea\")){\n            el.setAttribute(\"readOnly\", true);\n        }\n        return {\n            textDivs\n        };\n    }\n    static update(parameters) {\n        const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n        parameters.div.style.transform = transform;\n        parameters.div.hidden = false;\n    }\n}\nconst SVG_NS = \"http://www.w3.org/2000/svg\";\nclass PixelsPerInch {\n    static{\n        this.CSS = 96;\n    }\n    static{\n        this.PDF = 72;\n    }\n    static{\n        this.PDF_TO_CSS_UNITS = this.CSS / this.PDF;\n    }\n}\nasync function fetchData(url, type = \"text\") {\n    if (isValidFetchUrl(url, document.baseURI)) {\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(response.statusText);\n        }\n        switch(type){\n            case \"arraybuffer\":\n                return response.arrayBuffer();\n            case \"blob\":\n                return response.blob();\n            case \"json\":\n                return response.json();\n        }\n        return response.text();\n    }\n    return new Promise((resolve, reject)=>{\n        const request = new XMLHttpRequest();\n        request.open(\"GET\", url, true);\n        request.responseType = type;\n        request.onreadystatechange = ()=>{\n            if (request.readyState !== XMLHttpRequest.DONE) {\n                return;\n            }\n            if (request.status === 200 || request.status === 0) {\n                switch(type){\n                    case \"arraybuffer\":\n                    case \"blob\":\n                    case \"json\":\n                        resolve(request.response);\n                        return;\n                }\n                resolve(request.responseText);\n                return;\n            }\n            reject(new Error(request.statusText));\n        };\n        request.send(null);\n    });\n}\nclass PageViewport {\n    constructor({ viewBox, userUnit, scale, rotation, offsetX = 0, offsetY = 0, dontFlip = false }){\n        this.viewBox = viewBox;\n        this.userUnit = userUnit;\n        this.scale = scale;\n        this.rotation = rotation;\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        scale *= userUnit;\n        const centerX = (viewBox[2] + viewBox[0]) / 2;\n        const centerY = (viewBox[3] + viewBox[1]) / 2;\n        let rotateA, rotateB, rotateC, rotateD;\n        rotation %= 360;\n        if (rotation < 0) {\n            rotation += 360;\n        }\n        switch(rotation){\n            case 180:\n                rotateA = -1;\n                rotateB = 0;\n                rotateC = 0;\n                rotateD = 1;\n                break;\n            case 90:\n                rotateA = 0;\n                rotateB = 1;\n                rotateC = 1;\n                rotateD = 0;\n                break;\n            case 270:\n                rotateA = 0;\n                rotateB = -1;\n                rotateC = -1;\n                rotateD = 0;\n                break;\n            case 0:\n                rotateA = 1;\n                rotateB = 0;\n                rotateC = 0;\n                rotateD = -1;\n                break;\n            default:\n                throw new Error(\"PageViewport: Invalid rotation, must be a multiple of 90 degrees.\");\n        }\n        if (dontFlip) {\n            rotateC = -rotateC;\n            rotateD = -rotateD;\n        }\n        let offsetCanvasX, offsetCanvasY;\n        let width, height;\n        if (rotateA === 0) {\n            offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;\n            offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;\n            width = (viewBox[3] - viewBox[1]) * scale;\n            height = (viewBox[2] - viewBox[0]) * scale;\n        } else {\n            offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;\n            offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;\n            width = (viewBox[2] - viewBox[0]) * scale;\n            height = (viewBox[3] - viewBox[1]) * scale;\n        }\n        this.transform = [\n            rotateA * scale,\n            rotateB * scale,\n            rotateC * scale,\n            rotateD * scale,\n            offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY,\n            offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY\n        ];\n        this.width = width;\n        this.height = height;\n    }\n    get rawDims() {\n        const dims = this.viewBox;\n        return shadow(this, \"rawDims\", {\n            pageWidth: dims[2] - dims[0],\n            pageHeight: dims[3] - dims[1],\n            pageX: dims[0],\n            pageY: dims[1]\n        });\n    }\n    clone({ scale = this.scale, rotation = this.rotation, offsetX = this.offsetX, offsetY = this.offsetY, dontFlip = false } = {}) {\n        return new PageViewport({\n            viewBox: this.viewBox.slice(),\n            userUnit: this.userUnit,\n            scale,\n            rotation,\n            offsetX,\n            offsetY,\n            dontFlip\n        });\n    }\n    convertToViewportPoint(x, y) {\n        const p = [\n            x,\n            y\n        ];\n        Util.applyTransform(p, this.transform);\n        return p;\n    }\n    convertToViewportRectangle(rect) {\n        const topLeft = [\n            rect[0],\n            rect[1]\n        ];\n        Util.applyTransform(topLeft, this.transform);\n        const bottomRight = [\n            rect[2],\n            rect[3]\n        ];\n        Util.applyTransform(bottomRight, this.transform);\n        return [\n            topLeft[0],\n            topLeft[1],\n            bottomRight[0],\n            bottomRight[1]\n        ];\n    }\n    convertToPdfPoint(x, y) {\n        const p = [\n            x,\n            y\n        ];\n        Util.applyInverseTransform(p, this.transform);\n        return p;\n    }\n}\nclass RenderingCancelledException extends BaseException {\n    constructor(msg, extraDelay = 0){\n        super(msg, \"RenderingCancelledException\");\n        this.extraDelay = extraDelay;\n    }\n}\nfunction isDataScheme(url) {\n    const ii = url.length;\n    let i = 0;\n    while(i < ii && url[i].trim() === \"\"){\n        i++;\n    }\n    return url.substring(i, i + 5).toLowerCase() === \"data:\";\n}\nfunction isPdfFile(filename) {\n    return typeof filename === \"string\" && /\\.pdf$/i.test(filename);\n}\nfunction getFilenameFromUrl(url) {\n    [url] = url.split(/[#?]/, 1);\n    return url.substring(url.lastIndexOf(\"/\") + 1);\n}\nfunction getPdfFilenameFromUrl(url, defaultFilename = \"document.pdf\") {\n    if (typeof url !== \"string\") {\n        return defaultFilename;\n    }\n    if (isDataScheme(url)) {\n        warn('getPdfFilenameFromUrl: ignore \"data:\"-URL for performance reasons.');\n        return defaultFilename;\n    }\n    const getURL = (urlString)=>{\n        try {\n            return new URL(urlString);\n        } catch  {\n            try {\n                return new URL(decodeURIComponent(urlString));\n            } catch  {\n                try {\n                    return new URL(urlString, \"https://foo.bar\");\n                } catch  {\n                    try {\n                        return new URL(decodeURIComponent(urlString), \"https://foo.bar\");\n                    } catch  {\n                        return null;\n                    }\n                }\n            }\n        }\n    };\n    const newURL = getURL(url);\n    if (!newURL) {\n        return defaultFilename;\n    }\n    const decode = (name)=>{\n        try {\n            let decoded = decodeURIComponent(name);\n            if (decoded.includes(\"/\")) {\n                decoded = decoded.split(\"/\").at(-1);\n                if (decoded.test(/^\\.pdf$/i)) {\n                    return decoded;\n                }\n                return name;\n            }\n            return decoded;\n        } catch  {\n            return name;\n        }\n    };\n    const pdfRegex = /\\.pdf$/i;\n    const filename = newURL.pathname.split(\"/\").at(-1);\n    if (pdfRegex.test(filename)) {\n        return decode(filename);\n    }\n    if (newURL.searchParams.size > 0) {\n        const values = Array.from(newURL.searchParams.values()).reverse();\n        for (const value1 of values){\n            if (pdfRegex.test(value1)) {\n                return decode(value1);\n            }\n        }\n        const keys = Array.from(newURL.searchParams.keys()).reverse();\n        for (const key of keys){\n            if (pdfRegex.test(key)) {\n                return decode(key);\n            }\n        }\n    }\n    if (newURL.hash) {\n        const reFilename = /[^/?#=]+\\.pdf\\b(?!.*\\.pdf\\b)/i;\n        const hashFilename = reFilename.exec(newURL.hash);\n        if (hashFilename) {\n            return decode(hashFilename[0]);\n        }\n    }\n    return defaultFilename;\n}\nclass StatTimer {\n    time(name) {\n        if (name in this.started) {\n            warn(`Timer is already running for ${name}`);\n        }\n        this.started[name] = Date.now();\n    }\n    timeEnd(name) {\n        if (!(name in this.started)) {\n            warn(`Timer has not been started for ${name}`);\n        }\n        this.times.push({\n            name,\n            start: this.started[name],\n            end: Date.now()\n        });\n        delete this.started[name];\n    }\n    toString() {\n        const outBuf = [];\n        let longest = 0;\n        for (const { name } of this.times){\n            longest = Math.max(name.length, longest);\n        }\n        for (const { name, start, end } of this.times){\n            outBuf.push(`${name.padEnd(longest)} ${end - start}ms\n`);\n        }\n        return outBuf.join(\"\");\n    }\n    constructor(){\n        this.started = /* @__PURE__ */ Object.create(null);\n        this.times = [];\n    }\n}\nfunction isValidFetchUrl(url, baseUrl) {\n    const res = baseUrl ? URL.parse(url, baseUrl) : URL.parse(url);\n    return res?.protocol === \"http:\" || res?.protocol === \"https:\";\n}\nfunction noContextMenu(e) {\n    e.preventDefault();\n}\nfunction stopEvent(e) {\n    e.preventDefault();\n    e.stopPropagation();\n}\nfunction deprecated(details) {\n    console.log(\"Deprecated API usage: \" + details);\n}\nclass PDFDateString {\n    static #regex;\n    static toDateObject(input) {\n        if (input instanceof Date) {\n            return input;\n        }\n        if (!input || typeof input !== \"string\") {\n            return null;\n        }\n        this.#regex ||= new RegExp(\"^D:(\\\\d{4})(\\\\d{2})?(\\\\d{2})?(\\\\d{2})?(\\\\d{2})?(\\\\d{2})?([Z|+|-])?(\\\\d{2})?'?(\\\\d{2})?'?\");\n        const matches = this.#regex.exec(input);\n        if (!matches) {\n            return null;\n        }\n        const year = parseInt(matches[1], 10);\n        let month = parseInt(matches[2], 10);\n        month = month >= 1 && month <= 12 ? month - 1 : 0;\n        let day = parseInt(matches[3], 10);\n        day = day >= 1 && day <= 31 ? day : 1;\n        let hour = parseInt(matches[4], 10);\n        hour = hour >= 0 && hour <= 23 ? hour : 0;\n        let minute = parseInt(matches[5], 10);\n        minute = minute >= 0 && minute <= 59 ? minute : 0;\n        let second = parseInt(matches[6], 10);\n        second = second >= 0 && second <= 59 ? second : 0;\n        const universalTimeRelation = matches[7] || \"Z\";\n        let offsetHour = parseInt(matches[8], 10);\n        offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;\n        let offsetMinute = parseInt(matches[9], 10) || 0;\n        offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;\n        if (universalTimeRelation === \"-\") {\n            hour += offsetHour;\n            minute += offsetMinute;\n        } else if (universalTimeRelation === \"+\") {\n            hour -= offsetHour;\n            minute -= offsetMinute;\n        }\n        return new Date(Date.UTC(year, month, day, hour, minute, second));\n    }\n}\nfunction getXfaPageViewport(xfaPage, { scale = 1, rotation = 0 }) {\n    const { width, height } = xfaPage.attributes.style;\n    const viewBox = [\n        0,\n        0,\n        parseInt(width),\n        parseInt(height)\n    ];\n    return new PageViewport({\n        viewBox,\n        userUnit: 1,\n        scale,\n        rotation\n    });\n}\nfunction getRGB(color) {\n    if (color.startsWith(\"#\")) {\n        const colorRGB = parseInt(color.slice(1), 16);\n        return [\n            (colorRGB & 16711680) >> 16,\n            (colorRGB & 65280) >> 8,\n            colorRGB & 255\n        ];\n    }\n    if (color.startsWith(\"rgb(\")) {\n        return color.slice(4, -1).split(\",\").map((x)=>parseInt(x));\n    }\n    if (color.startsWith(\"rgba(\")) {\n        return color.slice(5, -1).split(\",\").map((x)=>parseInt(x)).slice(0, 3);\n    }\n    warn(`Not a valid color format: \"${color}\"`);\n    return [\n        0,\n        0,\n        0\n    ];\n}\nfunction getColorValues(colors) {\n    const span = document.createElement(\"span\");\n    span.style.visibility = \"hidden\";\n    span.style.colorScheme = \"only light\";\n    document.body.append(span);\n    for (const name of colors.keys()){\n        span.style.color = name;\n        const computedColor = window.getComputedStyle(span).color;\n        colors.set(name, getRGB(computedColor));\n    }\n    span.remove();\n}\nfunction getCurrentTransform(ctx) {\n    const { a, b, c, d, e, f } = ctx.getTransform();\n    return [\n        a,\n        b,\n        c,\n        d,\n        e,\n        f\n    ];\n}\nfunction getCurrentTransformInverse(ctx) {\n    const { a, b, c, d, e, f } = ctx.getTransform().invertSelf();\n    return [\n        a,\n        b,\n        c,\n        d,\n        e,\n        f\n    ];\n}\nfunction setLayerDimensions(div, viewport, mustFlip = false, mustRotate = true) {\n    if (viewport instanceof PageViewport) {\n        const { pageWidth, pageHeight } = viewport.rawDims;\n        const { style } = div;\n        const useRound = util_FeatureTest.isCSSRoundSupported;\n        const w = `var(--total-scale-factor) * ${pageWidth}px`, h = `var(--total-scale-factor) * ${pageHeight}px`;\n        const widthStr = useRound ? `round(down, ${w}, var(--scale-round-x))` : `calc(${w})`, heightStr = useRound ? `round(down, ${h}, var(--scale-round-y))` : `calc(${h})`;\n        if (!mustFlip || viewport.rotation % 180 === 0) {\n            style.width = widthStr;\n            style.height = heightStr;\n        } else {\n            style.width = heightStr;\n            style.height = widthStr;\n        }\n    }\n    if (mustRotate) {\n        div.setAttribute(\"data-main-rotation\", viewport.rotation);\n    }\n}\nclass OutputScale {\n    constructor(){\n        const { pixelRatio } = OutputScale;\n        this.sx = pixelRatio;\n        this.sy = pixelRatio;\n    }\n    get scaled() {\n        return this.sx !== 1 || this.sy !== 1;\n    }\n    get symmetric() {\n        return this.sx === this.sy;\n    }\n    limitCanvas(width, height, maxPixels, maxDim, capAreaFactor = -1) {\n        let maxAreaScale = Infinity, maxWidthScale = Infinity, maxHeightScale = Infinity;\n        maxPixels = OutputScale.capPixels(maxPixels, capAreaFactor);\n        if (maxPixels > 0) {\n            maxAreaScale = Math.sqrt(maxPixels / (width * height));\n        }\n        if (maxDim !== -1) {\n            maxWidthScale = maxDim / width;\n            maxHeightScale = maxDim / height;\n        }\n        const maxScale = Math.min(maxAreaScale, maxWidthScale, maxHeightScale);\n        if (this.sx > maxScale || this.sy > maxScale) {\n            this.sx = maxScale;\n            this.sy = maxScale;\n            return true;\n        }\n        return false;\n    }\n    static get pixelRatio() {\n        return globalThis.devicePixelRatio || 1;\n    }\n    static capPixels(maxPixels, capAreaFactor) {\n        if (capAreaFactor >= 0) {\n            const winPixels = Math.ceil(window.screen.availWidth * window.screen.availHeight * this.pixelRatio ** 2 * (1 + capAreaFactor / 100));\n            return maxPixels > 0 ? Math.min(maxPixels, winPixels) : winPixels;\n        }\n        return maxPixels;\n    }\n}\nconst SupportedImageMimeTypes = [\n    \"image/apng\",\n    \"image/avif\",\n    \"image/bmp\",\n    \"image/gif\",\n    \"image/jpeg\",\n    \"image/png\",\n    \"image/svg+xml\",\n    \"image/webp\",\n    \"image/x-icon\"\n];\nclass ColorScheme {\n    static get isDarkMode() {\n        return shadow(this, \"isDarkMode\", !!window?.matchMedia?.(\"(prefers-color-scheme: dark)\").matches);\n    }\n}\nclass CSSConstants {\n    static get commentForegroundColor() {\n        const element = document.createElement(\"span\");\n        element.classList.add(\"comment\", \"sidebar\");\n        const { style } = element;\n        style.width = style.height = \"0\";\n        style.display = \"none\";\n        style.color = \"var(--comment-fg-color)\";\n        document.body.append(element);\n        const { color } = window.getComputedStyle(element);\n        element.remove();\n        return shadow(this, \"commentForegroundColor\", getRGB(color));\n    }\n}\nfunction applyOpacity(r, g, b, opacity) {\n    opacity = Math.min(Math.max(opacity ?? 1, 0), 1);\n    const white = 255 * (1 - opacity);\n    r = Math.round(r * opacity + white);\n    g = Math.round(g * opacity + white);\n    b = Math.round(b * opacity + white);\n    return [\n        r,\n        g,\n        b\n    ];\n}\nfunction RGBToHSL(rgb, output) {\n    const r = rgb[0] / 255;\n    const g = rgb[1] / 255;\n    const b = rgb[2] / 255;\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    const l = (max + min) / 2;\n    if (max === min) {\n        output[0] = output[1] = 0;\n    } else {\n        const d = max - min;\n        output[1] = l < 0.5 ? d / (max + min) : d / (2 - max - min);\n        switch(max){\n            case r:\n                output[0] = ((g - b) / d + (g < b ? 6 : 0)) * 60;\n                break;\n            case g:\n                output[0] = ((b - r) / d + 2) * 60;\n                break;\n            case b:\n                output[0] = ((r - g) / d + 4) * 60;\n                break;\n        }\n    }\n    output[2] = l;\n}\nfunction HSLToRGB(hsl, output) {\n    const h = hsl[0];\n    const s = hsl[1];\n    const l = hsl[2];\n    const c = (1 - Math.abs(2 * l - 1)) * s;\n    const x = c * (1 - Math.abs(h / 60 % 2 - 1));\n    const m = l - c / 2;\n    switch(Math.floor(h / 60)){\n        case 0:\n            output[0] = c + m;\n            output[1] = x + m;\n            output[2] = m;\n            break;\n        case 1:\n            output[0] = x + m;\n            output[1] = c + m;\n            output[2] = m;\n            break;\n        case 2:\n            output[0] = m;\n            output[1] = c + m;\n            output[2] = x + m;\n            break;\n        case 3:\n            output[0] = m;\n            output[1] = x + m;\n            output[2] = c + m;\n            break;\n        case 4:\n            output[0] = x + m;\n            output[1] = m;\n            output[2] = c + m;\n            break;\n        case 5:\n        case 6:\n            output[0] = c + m;\n            output[1] = m;\n            output[2] = x + m;\n            break;\n    }\n}\nfunction computeLuminance(x) {\n    return x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;\n}\nfunction contrastRatio(hsl1, hsl2, output) {\n    HSLToRGB(hsl1, output);\n    output.map(computeLuminance);\n    const lum1 = 0.2126 * output[0] + 0.7152 * output[1] + 0.0722 * output[2];\n    HSLToRGB(hsl2, output);\n    output.map(computeLuminance);\n    const lum2 = 0.2126 * output[0] + 0.7152 * output[1] + 0.0722 * output[2];\n    return lum1 > lum2 ? (lum1 + 0.05) / (lum2 + 0.05) : (lum2 + 0.05) / (lum1 + 0.05);\n}\nconst contrastCache = /* @__PURE__ */ new Map();\nfunction findContrastColor(baseColor, fixedColor) {\n    const key = baseColor[0] + baseColor[1] * 256 + baseColor[2] * 65536 + fixedColor[0] * 16777216 + fixedColor[1] * 4294967296 + fixedColor[2] * 1099511627776;\n    let cachedValue = contrastCache.get(key);\n    if (cachedValue) {\n        return cachedValue;\n    }\n    const array = new Float32Array(9);\n    const output = array.subarray(0, 3);\n    const baseHSL = array.subarray(3, 6);\n    RGBToHSL(baseColor, baseHSL);\n    const fixedHSL = array.subarray(6, 9);\n    RGBToHSL(fixedColor, fixedHSL);\n    const isFixedColorDark = fixedHSL[2] < 0.5;\n    const minContrast = isFixedColorDark ? 12 : 4.5;\n    baseHSL[2] = isFixedColorDark ? Math.sqrt(baseHSL[2]) : 1 - Math.sqrt(1 - baseHSL[2]);\n    if (contrastRatio(baseHSL, fixedHSL, output) < minContrast) {\n        let start, end;\n        if (isFixedColorDark) {\n            start = baseHSL[2];\n            end = 1;\n        } else {\n            start = 0;\n            end = baseHSL[2];\n        }\n        const PRECISION = 5e-3;\n        while(end - start > PRECISION){\n            const mid = baseHSL[2] = (start + end) / 2;\n            if (isFixedColorDark === contrastRatio(baseHSL, fixedHSL, output) < minContrast) {\n                start = mid;\n            } else {\n                end = mid;\n            }\n        }\n        baseHSL[2] = isFixedColorDark ? end : start;\n    }\n    HSLToRGB(baseHSL, output);\n    cachedValue = Util.makeHexColor(Math.round(output[0] * 255), Math.round(output[1] * 255), Math.round(output[2] * 255));\n    contrastCache.set(key, cachedValue);\n    return cachedValue;\n}\nfunction renderRichText({ html, dir, className }, container) {\n    const fragment = document.createDocumentFragment();\n    if (typeof html === \"string\") {\n        const p = document.createElement(\"p\");\n        p.dir = dir || \"auto\";\n        const lines = html.split(/(?:\\r\\n?|\\n)/);\n        for(let i = 0, ii = lines.length; i < ii; ++i){\n            const line = lines[i];\n            p.append(document.createTextNode(line));\n            if (i < ii - 1) {\n                p.append(document.createElement(\"br\"));\n            }\n        }\n        fragment.append(p);\n    } else {\n        XfaLayer.render({\n            xfaHtml: html,\n            div: fragment,\n            intent: \"richText\"\n        });\n    }\n    fragment.firstChild.classList.add(\"richText\", className);\n    container.append(fragment);\n}\n__nested_webpack_require_192967__(4972);\n__nested_webpack_require_192967__(4628);\n__nested_webpack_require_192967__(7642);\n__nested_webpack_require_192967__(8004);\n__nested_webpack_require_192967__(3853);\n__nested_webpack_require_192967__(5876);\n__nested_webpack_require_192967__(2475);\n__nested_webpack_require_192967__(5024);\n__nested_webpack_require_192967__(1698);\n__nested_webpack_require_192967__(9314);\n__nested_webpack_require_192967__(1148);\n__nested_webpack_require_192967__(3579);\n__nested_webpack_require_192967__(8335);\nclass EditorToolbar {\n    #toolbar;\n    #colorPicker;\n    #editor;\n    #buttons;\n    #altText;\n    #comment;\n    #commentButtonDivider;\n    #signatureDescriptionButton;\n    static #l10nRemove = null;\n    constructor(editor){\n        this.#toolbar = null;\n        this.#colorPicker = null;\n        this.#buttons = null;\n        this.#altText = null;\n        this.#comment = null;\n        this.#commentButtonDivider = null;\n        this.#signatureDescriptionButton = null;\n        this.#editor = editor;\n        EditorToolbar.#l10nRemove ||= Object.freeze({\n            freetext: \"pdfjs-editor-remove-freetext-button\",\n            highlight: \"pdfjs-editor-remove-highlight-button\",\n            ink: \"pdfjs-editor-remove-ink-button\",\n            stamp: \"pdfjs-editor-remove-stamp-button\",\n            signature: \"pdfjs-editor-remove-signature-button\"\n        });\n    }\n    render() {\n        const editToolbar = this.#toolbar = document.createElement(\"div\");\n        editToolbar.classList.add(\"editToolbar\", \"hidden\");\n        editToolbar.setAttribute(\"role\", \"toolbar\");\n        const signal = this.#editor._uiManager._signal;\n        if (signal instanceof AbortSignal && !signal.aborted) {\n            editToolbar.addEventListener(\"contextmenu\", noContextMenu, {\n                signal\n            });\n            editToolbar.addEventListener(\"pointerdown\", EditorToolbar.#pointerDown, {\n                signal\n            });\n        }\n        const buttons = this.#buttons = document.createElement(\"div\");\n        buttons.className = \"buttons\";\n        editToolbar.append(buttons);\n        const position = this.#editor.toolbarPosition;\n        if (position) {\n            const { style } = editToolbar;\n            const x = this.#editor._uiManager.direction === \"ltr\" ? 1 - position[0] : position[0];\n            style.insetInlineEnd = `${100 * x}%`;\n            style.top = `calc(${100 * position[1]}% + var(--editor-toolbar-vert-offset))`;\n        }\n        return editToolbar;\n    }\n    get div() {\n        return this.#toolbar;\n    }\n    static #pointerDown(e) {\n        e.stopPropagation();\n    }\n    #focusIn(e) {\n        this.#editor._focusEventsAllowed = false;\n        stopEvent(e);\n    }\n    #focusOut(e) {\n        this.#editor._focusEventsAllowed = true;\n        stopEvent(e);\n    }\n    #addListenersToElement(element) {\n        const signal = this.#editor._uiManager._signal;\n        if (!(signal instanceof AbortSignal) || signal.aborted) {\n            return false;\n        }\n        element.addEventListener(\"focusin\", this.#focusIn.bind(this), {\n            capture: true,\n            signal\n        });\n        element.addEventListener(\"focusout\", this.#focusOut.bind(this), {\n            capture: true,\n            signal\n        });\n        element.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        return true;\n    }\n    hide() {\n        this.#toolbar.classList.add(\"hidden\");\n        this.#colorPicker?.hideDropdown();\n    }\n    show() {\n        this.#toolbar.classList.remove(\"hidden\");\n        this.#altText?.shown();\n        this.#comment?.shown();\n    }\n    addDeleteButton() {\n        const { editorType, _uiManager } = this.#editor;\n        const button = document.createElement(\"button\");\n        button.classList.add(\"basic\", \"deleteButton\");\n        button.tabIndex = 0;\n        button.setAttribute(\"data-l10n-id\", EditorToolbar.#l10nRemove[editorType]);\n        if (this.#addListenersToElement(button)) {\n            button.addEventListener(\"click\", (e)=>{\n                _uiManager.delete();\n            }, {\n                signal: _uiManager._signal\n            });\n        }\n        this.#buttons.append(button);\n    }\n    get #divider() {\n        const divider = document.createElement(\"div\");\n        divider.className = \"divider\";\n        return divider;\n    }\n    async addAltText(altText) {\n        const button = await altText.render();\n        this.#addListenersToElement(button);\n        this.#buttons.append(button, this.#divider);\n        this.#altText = altText;\n    }\n    addComment(comment, beforeElement = null) {\n        if (this.#comment) {\n            return;\n        }\n        const button = comment.renderForToolbar();\n        if (!button) {\n            return;\n        }\n        this.#addListenersToElement(button);\n        const divider = this.#commentButtonDivider = this.#divider;\n        if (!beforeElement) {\n            this.#buttons.append(button, divider);\n        } else {\n            this.#buttons.insertBefore(button, beforeElement);\n            this.#buttons.insertBefore(divider, beforeElement);\n        }\n        this.#comment = comment;\n        comment.toolbar = this;\n    }\n    addColorPicker(colorPicker) {\n        if (this.#colorPicker) {\n            return;\n        }\n        this.#colorPicker = colorPicker;\n        const button = colorPicker.renderButton();\n        this.#addListenersToElement(button);\n        this.#buttons.append(button, this.#divider);\n    }\n    async addEditSignatureButton(signatureManager) {\n        const button = this.#signatureDescriptionButton = await signatureManager.renderEditButton(this.#editor);\n        this.#addListenersToElement(button);\n        this.#buttons.append(button, this.#divider);\n    }\n    removeButton(name) {\n        switch(name){\n            case \"comment\":\n                this.#comment?.removeToolbarCommentButton();\n                this.#comment = null;\n                this.#commentButtonDivider?.remove();\n                this.#commentButtonDivider = null;\n                break;\n        }\n    }\n    async addButton(name, tool) {\n        switch(name){\n            case \"colorPicker\":\n                this.addColorPicker(tool);\n                break;\n            case \"altText\":\n                await this.addAltText(tool);\n                break;\n            case \"editSignature\":\n                await this.addEditSignatureButton(tool);\n                break;\n            case \"delete\":\n                this.addDeleteButton();\n                break;\n            case \"comment\":\n                this.addComment(tool);\n                break;\n        }\n    }\n    async addButtonBefore(name, tool, beforeSelector) {\n        const beforeElement = this.#buttons.querySelector(beforeSelector);\n        if (!beforeElement) {\n            return;\n        }\n        if (name === \"comment\") {\n            this.addComment(tool, beforeElement);\n        }\n    }\n    updateEditSignatureButton(description) {\n        if (this.#signatureDescriptionButton) {\n            this.#signatureDescriptionButton.title = description;\n        }\n    }\n    remove() {\n        this.#toolbar.remove();\n        this.#colorPicker?.destroy();\n        this.#colorPicker = null;\n    }\n}\nclass FloatingToolbar {\n    #buttons;\n    #toolbar;\n    #uiManager;\n    constructor(uiManager){\n        this.#buttons = null;\n        this.#toolbar = null;\n        this.#uiManager = uiManager;\n    }\n    #render() {\n        const editToolbar = this.#toolbar = document.createElement(\"div\");\n        editToolbar.className = \"editToolbar\";\n        editToolbar.setAttribute(\"role\", \"toolbar\");\n        const signal = this.#uiManager._signal;\n        if (signal instanceof AbortSignal && !signal.aborted) {\n            editToolbar.addEventListener(\"contextmenu\", noContextMenu, {\n                signal\n            });\n        }\n        const buttons = this.#buttons = document.createElement(\"div\");\n        buttons.className = \"buttons\";\n        editToolbar.append(buttons);\n        if (this.#uiManager.hasCommentManager()) {\n            this.#makeButton(\"commentButton\", `pdfjs-comment-floating-button`, \"pdfjs-comment-floating-button-label\", ()=>{\n                this.#uiManager.commentSelection(\"floating_button\");\n            });\n        }\n        this.#makeButton(\"highlightButton\", `pdfjs-highlight-floating-button1`, \"pdfjs-highlight-floating-button-label\", ()=>{\n            this.#uiManager.highlightSelection(\"floating_button\");\n        });\n        return editToolbar;\n    }\n    #getLastPoint(boxes, isLTR) {\n        let lastY = 0;\n        let lastX = 0;\n        for (const box of boxes){\n            const y = box.y + box.height;\n            if (y < lastY) {\n                continue;\n            }\n            const x = box.x + (isLTR ? box.width : 0);\n            if (y > lastY) {\n                lastX = x;\n                lastY = y;\n                continue;\n            }\n            if (isLTR) {\n                if (x > lastX) {\n                    lastX = x;\n                }\n            } else if (x < lastX) {\n                lastX = x;\n            }\n        }\n        return [\n            isLTR ? 1 - lastX : lastX,\n            lastY\n        ];\n    }\n    show(parent, boxes, isLTR) {\n        const [x, y] = this.#getLastPoint(boxes, isLTR);\n        const { style } = this.#toolbar ||= this.#render();\n        parent.append(this.#toolbar);\n        style.insetInlineEnd = `${100 * x}%`;\n        style.top = `calc(${100 * y}% + var(--editor-toolbar-vert-offset))`;\n    }\n    hide() {\n        this.#toolbar.remove();\n    }\n    #makeButton(buttonClass, l10nId, labelL10nId, clickHandler) {\n        const button = document.createElement(\"button\");\n        button.classList.add(\"basic\", buttonClass);\n        button.tabIndex = 0;\n        button.setAttribute(\"data-l10n-id\", l10nId);\n        const span = document.createElement(\"span\");\n        button.append(span);\n        span.className = \"visuallyHidden\";\n        span.setAttribute(\"data-l10n-id\", labelL10nId);\n        const signal = this.#uiManager._signal;\n        if (signal instanceof AbortSignal && !signal.aborted) {\n            button.addEventListener(\"contextmenu\", noContextMenu, {\n                signal\n            });\n            button.addEventListener(\"click\", clickHandler, {\n                signal\n            });\n        }\n        this.#buttons.append(button);\n    }\n}\nfunction bindEvents(obj, element, names) {\n    for (const name of names){\n        element.addEventListener(name, obj[name].bind(obj));\n    }\n}\nclass IdManager {\n    #id;\n    get id() {\n        return `${AnnotationEditorPrefix}${this.#id++}`;\n    }\n    constructor(){\n        this.#id = 0;\n    }\n}\nclass ImageManager {\n    #baseId;\n    #id;\n    #cache;\n    static get _isSVGFittingCanvas() {\n        const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`;\n        const canvas = new OffscreenCanvas(1, 3);\n        const ctx = canvas.getContext(\"2d\", {\n            willReadFrequently: true\n        });\n        const image = new Image();\n        image.src = svg;\n        const promise = image.decode().then(()=>{\n            ctx.drawImage(image, 0, 0, 1, 1, 0, 0, 1, 3);\n            return new Uint32Array(ctx.getImageData(0, 0, 1, 1).data.buffer)[0] === 0;\n        });\n        return shadow(this, \"_isSVGFittingCanvas\", promise);\n    }\n    async #get(key, rawData) {\n        this.#cache ||= /* @__PURE__ */ new Map();\n        let data = this.#cache.get(key);\n        if (data === null) {\n            return null;\n        }\n        if (data?.bitmap) {\n            data.refCounter += 1;\n            return data;\n        }\n        try {\n            data ||= {\n                bitmap: null,\n                id: `image_${this.#baseId}_${this.#id++}`,\n                refCounter: 0,\n                isSvg: false\n            };\n            let image;\n            if (typeof rawData === \"string\") {\n                data.url = rawData;\n                image = await fetchData(rawData, \"blob\");\n            } else if (rawData instanceof File) {\n                image = data.file = rawData;\n            } else if (rawData instanceof Blob) {\n                image = rawData;\n            }\n            if (image.type === \"image/svg+xml\") {\n                const mustRemoveAspectRatioPromise = ImageManager._isSVGFittingCanvas;\n                const fileReader = new FileReader();\n                const imageElement = new Image();\n                const imagePromise = new Promise((resolve, reject)=>{\n                    imageElement.onload = ()=>{\n                        data.bitmap = imageElement;\n                        data.isSvg = true;\n                        resolve();\n                    };\n                    fileReader.onload = async ()=>{\n                        const url = data.svgUrl = fileReader.result;\n                        imageElement.src = await mustRemoveAspectRatioPromise ? `${url}#svgView(preserveAspectRatio(none))` : url;\n                    };\n                    imageElement.onerror = fileReader.onerror = reject;\n                });\n                fileReader.readAsDataURL(image);\n                await imagePromise;\n            } else {\n                data.bitmap = await createImageBitmap(image);\n            }\n            data.refCounter = 1;\n        } catch (e) {\n            warn(e);\n            data = null;\n        }\n        this.#cache.set(key, data);\n        if (data) {\n            this.#cache.set(data.id, data);\n        }\n        return data;\n    }\n    async getFromFile(file) {\n        const { lastModified, name, size, type } = file;\n        return this.#get(`${lastModified}_${name}_${size}_${type}`, file);\n    }\n    async getFromUrl(url) {\n        return this.#get(url, url);\n    }\n    async getFromBlob(id, blobPromise) {\n        const blob = await blobPromise;\n        return this.#get(id, blob);\n    }\n    async getFromId(id) {\n        this.#cache ||= /* @__PURE__ */ new Map();\n        const data = this.#cache.get(id);\n        if (!data) {\n            return null;\n        }\n        if (data.bitmap) {\n            data.refCounter += 1;\n            return data;\n        }\n        if (data.file) {\n            return this.getFromFile(data.file);\n        }\n        if (data.blobPromise) {\n            const { blobPromise } = data;\n            delete data.blobPromise;\n            return this.getFromBlob(data.id, blobPromise);\n        }\n        return this.getFromUrl(data.url);\n    }\n    getFromCanvas(id, canvas) {\n        this.#cache ||= /* @__PURE__ */ new Map();\n        let data = this.#cache.get(id);\n        if (data?.bitmap) {\n            data.refCounter += 1;\n            return data;\n        }\n        const offscreen = new OffscreenCanvas(canvas.width, canvas.height);\n        const ctx = offscreen.getContext(\"2d\");\n        ctx.drawImage(canvas, 0, 0);\n        data = {\n            bitmap: offscreen.transferToImageBitmap(),\n            id: `image_${this.#baseId}_${this.#id++}`,\n            refCounter: 1,\n            isSvg: false\n        };\n        this.#cache.set(id, data);\n        this.#cache.set(data.id, data);\n        return data;\n    }\n    getSvgUrl(id) {\n        const data = this.#cache.get(id);\n        if (!data?.isSvg) {\n            return null;\n        }\n        return data.svgUrl;\n    }\n    deleteId(id) {\n        this.#cache ||= /* @__PURE__ */ new Map();\n        const data = this.#cache.get(id);\n        if (!data) {\n            return;\n        }\n        data.refCounter -= 1;\n        if (data.refCounter !== 0) {\n            return;\n        }\n        const { bitmap } = data;\n        if (!data.url && !data.file) {\n            const canvas = new OffscreenCanvas(bitmap.width, bitmap.height);\n            const ctx = canvas.getContext(\"bitmaprenderer\");\n            ctx.transferFromImageBitmap(bitmap);\n            data.blobPromise = canvas.convertToBlob();\n        }\n        bitmap.close?.();\n        data.bitmap = null;\n    }\n    isValidId(id) {\n        return id.startsWith(`image_${this.#baseId}_`);\n    }\n    constructor(){\n        this.#baseId = getUuid();\n        this.#id = 0;\n        this.#cache = null;\n    }\n}\nclass CommandManager {\n    #commands;\n    #locked;\n    #maxSize;\n    #position;\n    constructor(maxSize = 128){\n        this.#commands = [];\n        this.#locked = false;\n        this.#position = -1;\n        this.#maxSize = maxSize;\n    }\n    add({ cmd, undo, post, mustExec, type = NaN, overwriteIfSameType = false, keepUndo = false }) {\n        if (mustExec) {\n            cmd();\n        }\n        if (this.#locked) {\n            return;\n        }\n        const save = {\n            cmd,\n            undo,\n            post,\n            type\n        };\n        if (this.#position === -1) {\n            if (this.#commands.length > 0) {\n                this.#commands.length = 0;\n            }\n            this.#position = 0;\n            this.#commands.push(save);\n            return;\n        }\n        if (overwriteIfSameType && this.#commands[this.#position].type === type) {\n            if (keepUndo) {\n                save.undo = this.#commands[this.#position].undo;\n            }\n            this.#commands[this.#position] = save;\n            return;\n        }\n        const next = this.#position + 1;\n        if (next === this.#maxSize) {\n            this.#commands.splice(0, 1);\n        } else {\n            this.#position = next;\n            if (next < this.#commands.length) {\n                this.#commands.splice(next);\n            }\n        }\n        this.#commands.push(save);\n    }\n    undo() {\n        if (this.#position === -1) {\n            return;\n        }\n        this.#locked = true;\n        const { undo, post } = this.#commands[this.#position];\n        undo();\n        post?.();\n        this.#locked = false;\n        this.#position -= 1;\n    }\n    redo() {\n        if (this.#position < this.#commands.length - 1) {\n            this.#position += 1;\n            this.#locked = true;\n            const { cmd, post } = this.#commands[this.#position];\n            cmd();\n            post?.();\n            this.#locked = false;\n        }\n    }\n    hasSomethingToUndo() {\n        return this.#position !== -1;\n    }\n    hasSomethingToRedo() {\n        return this.#position < this.#commands.length - 1;\n    }\n    cleanType(type) {\n        if (this.#position === -1) {\n            return;\n        }\n        for(let i = this.#position; i >= 0; i--){\n            if (this.#commands[i].type !== type) {\n                this.#commands.splice(i + 1, this.#position - i);\n                this.#position = i;\n                return;\n            }\n        }\n        this.#commands.length = 0;\n        this.#position = -1;\n    }\n    destroy() {\n        this.#commands = null;\n    }\n}\nclass KeyboardManager {\n    constructor(callbacks){\n        this.buffer = [];\n        this.callbacks = /* @__PURE__ */ new Map();\n        this.allKeys = /* @__PURE__ */ new Set();\n        const { isMac } = util_FeatureTest.platform;\n        for (const [keys, callback, options = {}] of callbacks){\n            for (const key of keys){\n                const isMacKey = key.startsWith(\"mac+\");\n                if (isMac && isMacKey) {\n                    this.callbacks.set(key.slice(4), {\n                        callback,\n                        options\n                    });\n                    this.allKeys.add(key.split(\"+\").at(-1));\n                } else if (!isMac && !isMacKey) {\n                    this.callbacks.set(key, {\n                        callback,\n                        options\n                    });\n                    this.allKeys.add(key.split(\"+\").at(-1));\n                }\n            }\n        }\n    }\n    #serialize(event) {\n        if (event.altKey) {\n            this.buffer.push(\"alt\");\n        }\n        if (event.ctrlKey) {\n            this.buffer.push(\"ctrl\");\n        }\n        if (event.metaKey) {\n            this.buffer.push(\"meta\");\n        }\n        if (event.shiftKey) {\n            this.buffer.push(\"shift\");\n        }\n        this.buffer.push(event.key);\n        const str = this.buffer.join(\"+\");\n        this.buffer.length = 0;\n        return str;\n    }\n    exec(self2, event) {\n        if (!this.allKeys.has(event.key)) {\n            return;\n        }\n        const info2 = this.callbacks.get(this.#serialize(event));\n        if (!info2) {\n            return;\n        }\n        const { callback, options: { bubbles = false, args = [], checker = null } } = info2;\n        if (checker && !checker(self2, event)) {\n            return;\n        }\n        callback.bind(self2, ...args, event)();\n        if (!bubbles) {\n            stopEvent(event);\n        }\n    }\n}\nclass ColorManager {\n    static{\n        this._colorsMapping = /* @__PURE__ */ new Map([\n            [\n                \"CanvasText\",\n                [\n                    0,\n                    0,\n                    0\n                ]\n            ],\n            [\n                \"Canvas\",\n                [\n                    255,\n                    255,\n                    255\n                ]\n            ]\n        ]);\n    }\n    get _colors() {\n        const colors = /* @__PURE__ */ new Map([\n            [\n                \"CanvasText\",\n                null\n            ],\n            [\n                \"Canvas\",\n                null\n            ]\n        ]);\n        getColorValues(colors);\n        return shadow(this, \"_colors\", colors);\n    }\n    convert(color) {\n        const rgb = getRGB(color);\n        if (!window.matchMedia(\"(forced-colors: active)\").matches) {\n            return rgb;\n        }\n        for (const [name, RGB] of this._colors){\n            if (RGB.every((x, i)=>x === rgb[i])) {\n                return ColorManager._colorsMapping.get(name);\n            }\n        }\n        return rgb;\n    }\n    getHexCode(name) {\n        const rgb = this._colors.get(name);\n        if (!rgb) {\n            return name;\n        }\n        return Util.makeHexColor(...rgb);\n    }\n}\nclass AnnotationEditorUIManager {\n    #abortController;\n    #activeEditor;\n    #allEditableAnnotations;\n    #allEditors;\n    #allLayers;\n    #altTextManager;\n    #annotationStorage;\n    #changedExistingAnnotations;\n    #commandManager;\n    #commentManager;\n    #copyPasteAC;\n    #currentDrawingSession;\n    #currentPageIndex;\n    #deletedAnnotationsElementIds;\n    #draggingEditors;\n    #editorTypes;\n    #editorsToRescale;\n    #enableHighlightFloatingButton;\n    #enableUpdatedAddImage;\n    #enableNewAltTextWhenAddingImage;\n    #filterFactory;\n    #focusMainContainerTimeoutId;\n    #focusManagerAC;\n    #highlightColors;\n    #highlightWhenShiftUp;\n    #floatingToolbar;\n    #idManager;\n    #isEnabled;\n    #isPointerDown;\n    #isWaiting;\n    #keyboardManagerAC;\n    #lastActiveElement;\n    #mainHighlightColorPicker;\n    #missingCanvases;\n    #mlManager;\n    #mode;\n    #selectedEditors;\n    #selectedTextNode;\n    #signatureManager;\n    #pageColors;\n    #showAllStates;\n    #pdfDocument;\n    #previousStates;\n    #translation;\n    #translationTimeoutId;\n    #container;\n    #viewer;\n    #viewerAlert;\n    #updateModeCapability;\n    static{\n        this.TRANSLATE_SMALL = 1;\n    }\n    static{\n        this.TRANSLATE_BIG = 10;\n    }\n    static get _keyboardManager() {\n        const proto = AnnotationEditorUIManager.prototype;\n        const arrowChecker = (self2)=>self2.#container.contains(document.activeElement) && document.activeElement.tagName !== \"BUTTON\" && self2.hasSomethingToControl();\n        const textInputChecker = (_self, { target: el })=>{\n            if (el instanceof HTMLInputElement) {\n                const { type } = el;\n                return type !== \"text\" && type !== \"number\";\n            }\n            return true;\n        };\n        const small = this.TRANSLATE_SMALL;\n        const big = this.TRANSLATE_BIG;\n        return shadow(this, \"_keyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"ctrl+a\",\n                    \"mac+meta+a\"\n                ],\n                proto.selectAll,\n                {\n                    checker: textInputChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+z\",\n                    \"mac+meta+z\"\n                ],\n                proto.undo,\n                {\n                    checker: textInputChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+y\",\n                    \"ctrl+shift+z\",\n                    \"mac+meta+shift+z\",\n                    \"ctrl+shift+Z\",\n                    \"mac+meta+shift+Z\"\n                ],\n                proto.redo,\n                {\n                    checker: textInputChecker\n                }\n            ],\n            [\n                [\n                    \"Backspace\",\n                    \"alt+Backspace\",\n                    \"ctrl+Backspace\",\n                    \"shift+Backspace\",\n                    \"mac+Backspace\",\n                    \"mac+alt+Backspace\",\n                    \"mac+ctrl+Backspace\",\n                    \"Delete\",\n                    \"ctrl+Delete\",\n                    \"shift+Delete\",\n                    \"mac+Delete\"\n                ],\n                proto.delete,\n                {\n                    checker: textInputChecker\n                }\n            ],\n            [\n                [\n                    \"Enter\",\n                    \"mac+Enter\"\n                ],\n                proto.addNewEditorFromKeyboard,\n                {\n                    checker: (self2, { target: el })=>!(el instanceof HTMLButtonElement) && self2.#container.contains(el) && !self2.isEnterHandled\n                }\n            ],\n            [\n                [\n                    \" \",\n                    \"mac+ \"\n                ],\n                proto.addNewEditorFromKeyboard,\n                {\n                    checker: (self2, { target: el })=>!(el instanceof HTMLButtonElement) && self2.#container.contains(document.activeElement)\n                }\n            ],\n            [\n                [\n                    \"Escape\",\n                    \"mac+Escape\"\n                ],\n                proto.unselectAll\n            ],\n            [\n                [\n                    \"ArrowLeft\",\n                    \"mac+ArrowLeft\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        -small,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowLeft\",\n                    \"mac+shift+ArrowLeft\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        -big,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowRight\",\n                    \"mac+ArrowRight\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        small,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowRight\",\n                    \"mac+shift+ArrowRight\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        big,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"mac+ArrowUp\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        0,\n                        -small\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowUp\",\n                    \"mac+shift+ArrowUp\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        0,\n                        -big\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"mac+ArrowDown\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        0,\n                        small\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowDown\",\n                    \"mac+shift+ArrowDown\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        0,\n                        big\n                    ],\n                    checker: arrowChecker\n                }\n            ]\n        ]));\n    }\n    constructor(container, viewer, viewerAlert, altTextManager, commentManager, signatureManager, eventBus, pdfDocument, pageColors, highlightColors, enableHighlightFloatingButton, enableUpdatedAddImage, enableNewAltTextWhenAddingImage, mlManager, editorUndoBar, supportsPinchToZoom){\n        this.#abortController = new AbortController();\n        this.#activeEditor = null;\n        this.#allEditableAnnotations = null;\n        this.#allEditors = /* @__PURE__ */ new Map();\n        this.#allLayers = /* @__PURE__ */ new Map();\n        this.#altTextManager = null;\n        this.#annotationStorage = null;\n        this.#changedExistingAnnotations = null;\n        this.#commandManager = new CommandManager();\n        this.#commentManager = null;\n        this.#copyPasteAC = null;\n        this.#currentDrawingSession = null;\n        this.#currentPageIndex = 0;\n        this.#deletedAnnotationsElementIds = /* @__PURE__ */ new Set();\n        this.#draggingEditors = null;\n        this.#editorTypes = null;\n        this.#editorsToRescale = /* @__PURE__ */ new Set();\n        this._editorUndoBar = null;\n        this.#enableHighlightFloatingButton = false;\n        this.#enableUpdatedAddImage = false;\n        this.#enableNewAltTextWhenAddingImage = false;\n        this.#filterFactory = null;\n        this.#focusMainContainerTimeoutId = null;\n        this.#focusManagerAC = null;\n        this.#highlightColors = null;\n        this.#highlightWhenShiftUp = false;\n        this.#floatingToolbar = null;\n        this.#idManager = new IdManager();\n        this.#isEnabled = false;\n        this.#isPointerDown = false;\n        this.#isWaiting = false;\n        this.#keyboardManagerAC = null;\n        this.#lastActiveElement = null;\n        this.#mainHighlightColorPicker = null;\n        this.#missingCanvases = null;\n        this.#mlManager = null;\n        this.#mode = AnnotationEditorType.NONE;\n        this.#selectedEditors = /* @__PURE__ */ new Set();\n        this.#selectedTextNode = null;\n        this.#signatureManager = null;\n        this.#pageColors = null;\n        this.#showAllStates = null;\n        this.#pdfDocument = null;\n        this.#previousStates = {\n            isEditing: false,\n            isEmpty: true,\n            hasSomethingToUndo: false,\n            hasSomethingToRedo: false,\n            hasSelectedEditor: false,\n            hasSelectedText: false\n        };\n        this.#translation = [\n            0,\n            0\n        ];\n        this.#translationTimeoutId = null;\n        this.#container = null;\n        this.#viewer = null;\n        this.#viewerAlert = null;\n        this.#updateModeCapability = null;\n        const signal = this._signal = this.#abortController.signal;\n        this.#container = container;\n        this.#viewer = viewer;\n        this.#viewerAlert = viewerAlert;\n        this.#altTextManager = altTextManager;\n        this.#commentManager = commentManager;\n        this.#signatureManager = signatureManager;\n        this.#pdfDocument = pdfDocument;\n        this._eventBus = eventBus;\n        eventBus._on(\"editingaction\", this.onEditingAction.bind(this), {\n            signal\n        });\n        eventBus._on(\"pagechanging\", this.onPageChanging.bind(this), {\n            signal\n        });\n        eventBus._on(\"scalechanging\", this.onScaleChanging.bind(this), {\n            signal\n        });\n        eventBus._on(\"rotationchanging\", this.onRotationChanging.bind(this), {\n            signal\n        });\n        eventBus._on(\"setpreference\", this.onSetPreference.bind(this), {\n            signal\n        });\n        eventBus._on(\"switchannotationeditorparams\", (evt)=>this.updateParams(evt.type, evt.value), {\n            signal\n        });\n        window.addEventListener(\"pointerdown\", ()=>{\n            this.#isPointerDown = true;\n        }, {\n            capture: true,\n            signal\n        });\n        window.addEventListener(\"pointerup\", ()=>{\n            this.#isPointerDown = false;\n        }, {\n            capture: true,\n            signal\n        });\n        this.#addSelectionListener();\n        this.#addDragAndDropListeners();\n        this.#addKeyboardManager();\n        this.#annotationStorage = pdfDocument.annotationStorage;\n        this.#filterFactory = pdfDocument.filterFactory;\n        this.#pageColors = pageColors;\n        this.#highlightColors = highlightColors || null;\n        this.#enableHighlightFloatingButton = enableHighlightFloatingButton;\n        this.#enableUpdatedAddImage = enableUpdatedAddImage;\n        this.#enableNewAltTextWhenAddingImage = enableNewAltTextWhenAddingImage;\n        this.#mlManager = mlManager || null;\n        this.viewParameters = {\n            realScale: PixelsPerInch.PDF_TO_CSS_UNITS,\n            rotation: 0\n        };\n        this.isShiftKeyDown = false;\n        this._editorUndoBar = editorUndoBar || null;\n        this._supportsPinchToZoom = supportsPinchToZoom !== false;\n        commentManager?.setSidebarUiManager(this);\n    }\n    destroy() {\n        this.#updateModeCapability?.resolve();\n        this.#updateModeCapability = null;\n        this.#abortController?.abort();\n        this.#abortController = null;\n        this._signal = null;\n        for (const layer of this.#allLayers.values()){\n            layer.destroy();\n        }\n        this.#allLayers.clear();\n        this.#allEditors.clear();\n        this.#editorsToRescale.clear();\n        this.#missingCanvases?.clear();\n        this.#activeEditor = null;\n        this.#selectedEditors.clear();\n        this.#commandManager.destroy();\n        this.#altTextManager?.destroy();\n        this.#commentManager?.destroy();\n        this.#signatureManager?.destroy();\n        this.#floatingToolbar?.hide();\n        this.#floatingToolbar = null;\n        this.#mainHighlightColorPicker?.destroy();\n        this.#mainHighlightColorPicker = null;\n        this.#allEditableAnnotations = null;\n        if (this.#focusMainContainerTimeoutId) {\n            clearTimeout(this.#focusMainContainerTimeoutId);\n            this.#focusMainContainerTimeoutId = null;\n        }\n        if (this.#translationTimeoutId) {\n            clearTimeout(this.#translationTimeoutId);\n            this.#translationTimeoutId = null;\n        }\n        this._editorUndoBar?.destroy();\n        this.#pdfDocument = null;\n    }\n    combinedSignal(ac) {\n        return AbortSignal.any([\n            this._signal,\n            ac.signal\n        ]);\n    }\n    get mlManager() {\n        return this.#mlManager;\n    }\n    get useNewAltTextFlow() {\n        return this.#enableUpdatedAddImage;\n    }\n    get useNewAltTextWhenAddingImage() {\n        return this.#enableNewAltTextWhenAddingImage;\n    }\n    get hcmFilter() {\n        return shadow(this, \"hcmFilter\", this.#pageColors ? this.#filterFactory.addHCMFilter(this.#pageColors.foreground, this.#pageColors.background) : \"none\");\n    }\n    get direction() {\n        return shadow(this, \"direction\", getComputedStyle(this.#container).direction);\n    }\n    get _highlightColors() {\n        return shadow(this, \"_highlightColors\", this.#highlightColors ? new Map(this.#highlightColors.split(\",\").map((pair)=>{\n            pair = pair.split(\"=\").map((x)=>x.trim());\n            pair[1] = pair[1].toUpperCase();\n            return pair;\n        })) : null);\n    }\n    get highlightColors() {\n        const { _highlightColors } = this;\n        if (!_highlightColors) {\n            return shadow(this, \"highlightColors\", null);\n        }\n        const map = /* @__PURE__ */ new Map();\n        const hasHCM = !!this.#pageColors;\n        for (const [name, color] of _highlightColors){\n            const isNameForHCM = name.endsWith(\"_HCM\");\n            if (hasHCM && isNameForHCM) {\n                map.set(name.replace(\"_HCM\", \"\"), color);\n                continue;\n            }\n            if (!hasHCM && !isNameForHCM) {\n                map.set(name, color);\n            }\n        }\n        return shadow(this, \"highlightColors\", map);\n    }\n    get highlightColorNames() {\n        return shadow(this, \"highlightColorNames\", this.highlightColors ? new Map(Array.from(this.highlightColors, (e)=>e.reverse())) : null);\n    }\n    getNonHCMColor(color) {\n        if (!this._highlightColors) {\n            return color;\n        }\n        const colorName = this.highlightColorNames.get(color);\n        return this._highlightColors.get(colorName) || color;\n    }\n    getNonHCMColorName(color) {\n        return this.highlightColorNames.get(color) || color;\n    }\n    setCurrentDrawingSession(layer) {\n        if (layer) {\n            this.unselectAll();\n            this.disableUserSelect(true);\n        } else {\n            this.disableUserSelect(false);\n        }\n        this.#currentDrawingSession = layer;\n    }\n    setMainHighlightColorPicker(colorPicker) {\n        this.#mainHighlightColorPicker = colorPicker;\n    }\n    editAltText(editor, firstTime = false) {\n        this.#altTextManager?.editAltText(this, editor, firstTime);\n    }\n    hasCommentManager() {\n        return !!this.#commentManager;\n    }\n    editComment(editor, posX, posY, options) {\n        this.#commentManager?.showDialog(this, editor, posX, posY, options);\n    }\n    selectComment(pageIndex, uid) {\n        const layer = this.#allLayers.get(pageIndex);\n        const editor = layer?.getEditorByUID(uid);\n        editor?.toggleComment(true, true);\n    }\n    updateComment(editor) {\n        this.#commentManager?.updateComment(editor.getData());\n    }\n    updatePopupColor(editor) {\n        this.#commentManager?.updatePopupColor(editor);\n    }\n    removeComment(editor) {\n        this.#commentManager?.removeComments([\n            editor.uid\n        ]);\n    }\n    toggleComment(editor, isSelected, visibility = void 0) {\n        this.#commentManager?.toggleCommentPopup(editor, isSelected, visibility);\n    }\n    makeCommentColor(color, opacity) {\n        return color && this.#commentManager?.makeCommentColor(color, opacity) || null;\n    }\n    getCommentDialogElement() {\n        return this.#commentManager?.dialogElement || null;\n    }\n    async waitForEditorsRendered(pageNumber) {\n        if (this.#allLayers.has(pageNumber - 1)) {\n            return;\n        }\n        const { resolve, promise } = Promise.withResolvers();\n        const onEditorsRendered = (evt)=>{\n            if (evt.pageNumber === pageNumber) {\n                this._eventBus._off(\"editorsrendered\", onEditorsRendered);\n                resolve();\n            }\n        };\n        this._eventBus.on(\"editorsrendered\", onEditorsRendered);\n        await promise;\n    }\n    getSignature(editor) {\n        this.#signatureManager?.getSignature({\n            uiManager: this,\n            editor\n        });\n    }\n    get signatureManager() {\n        return this.#signatureManager;\n    }\n    switchToMode(mode, callback) {\n        this._eventBus.on(\"annotationeditormodechanged\", callback, {\n            once: true,\n            signal: this._signal\n        });\n        this._eventBus.dispatch(\"showannotationeditorui\", {\n            source: this,\n            mode\n        });\n    }\n    setPreference(name, value1) {\n        this._eventBus.dispatch(\"setpreference\", {\n            source: this,\n            name,\n            value: value1\n        });\n    }\n    onSetPreference({ name, value: value1 }) {\n        switch(name){\n            case \"enableNewAltTextWhenAddingImage\":\n                this.#enableNewAltTextWhenAddingImage = value1;\n                break;\n        }\n    }\n    onPageChanging({ pageNumber }) {\n        this.#currentPageIndex = pageNumber - 1;\n    }\n    focusMainContainer() {\n        this.#container.focus();\n    }\n    findParent(x, y) {\n        for (const layer of this.#allLayers.values()){\n            const { x: layerX, y: layerY, width, height } = layer.div.getBoundingClientRect();\n            if (x >= layerX && x <= layerX + width && y >= layerY && y <= layerY + height) {\n                return layer;\n            }\n        }\n        return null;\n    }\n    disableUserSelect(value1 = false) {\n        this.#viewer.classList.toggle(\"noUserSelect\", value1);\n    }\n    addShouldRescale(editor) {\n        this.#editorsToRescale.add(editor);\n    }\n    removeShouldRescale(editor) {\n        this.#editorsToRescale.delete(editor);\n    }\n    onScaleChanging({ scale }) {\n        this.commitOrRemove();\n        this.viewParameters.realScale = scale * PixelsPerInch.PDF_TO_CSS_UNITS;\n        for (const editor of this.#editorsToRescale){\n            editor.onScaleChanging();\n        }\n        this.#currentDrawingSession?.onScaleChanging();\n    }\n    onRotationChanging({ pagesRotation }) {\n        this.commitOrRemove();\n        this.viewParameters.rotation = pagesRotation;\n    }\n    #getAnchorElementForSelection({ anchorNode }) {\n        return anchorNode.nodeType === Node.TEXT_NODE ? anchorNode.parentElement : anchorNode;\n    }\n    #getLayerForTextLayer(textLayer) {\n        const { currentLayer } = this;\n        if (currentLayer.hasTextLayer(textLayer)) {\n            return currentLayer;\n        }\n        for (const layer of this.#allLayers.values()){\n            if (layer.hasTextLayer(textLayer)) {\n                return layer;\n            }\n        }\n        return null;\n    }\n    highlightSelection(methodOfCreation = \"\", comment = false) {\n        const selection = document.getSelection();\n        if (!selection || selection.isCollapsed) {\n            return;\n        }\n        const { anchorNode, anchorOffset, focusNode, focusOffset } = selection;\n        const text = selection.toString();\n        const anchorElement = this.#getAnchorElementForSelection(selection);\n        const textLayer = anchorElement.closest(\".textLayer\");\n        const boxes = this.getSelectionBoxes(textLayer);\n        if (!boxes) {\n            return;\n        }\n        selection.empty();\n        const layer = this.#getLayerForTextLayer(textLayer);\n        const isNoneMode = this.#mode === AnnotationEditorType.NONE;\n        const callback = ()=>{\n            const editor = layer?.createAndAddNewEditor({\n                x: 0,\n                y: 0\n            }, false, {\n                methodOfCreation,\n                boxes,\n                anchorNode,\n                anchorOffset,\n                focusNode,\n                focusOffset,\n                text\n            });\n            if (isNoneMode) {\n                this.showAllEditors(\"highlight\", true, true);\n            }\n            if (comment) {\n                editor?.editComment();\n            }\n        };\n        if (isNoneMode) {\n            this.switchToMode(AnnotationEditorType.HIGHLIGHT, callback);\n            return;\n        }\n        callback();\n    }\n    commentSelection(methodOfCreation = \"\") {\n        this.highlightSelection(methodOfCreation, true);\n    }\n    #displayFloatingToolbar() {\n        const selection = document.getSelection();\n        if (!selection || selection.isCollapsed) {\n            return;\n        }\n        const anchorElement = this.#getAnchorElementForSelection(selection);\n        const textLayer = anchorElement.closest(\".textLayer\");\n        const boxes = this.getSelectionBoxes(textLayer);\n        if (!boxes) {\n            return;\n        }\n        this.#floatingToolbar ||= new FloatingToolbar(this);\n        this.#floatingToolbar.show(textLayer, boxes, this.direction === \"ltr\");\n    }\n    getAndRemoveDataFromAnnotationStorage(annotationId) {\n        if (!this.#annotationStorage) {\n            return null;\n        }\n        const key = `${AnnotationEditorPrefix}${annotationId}`;\n        const storedValue = this.#annotationStorage.getRawValue(key);\n        if (storedValue) {\n            this.#annotationStorage.remove(key);\n        }\n        return storedValue;\n    }\n    addToAnnotationStorage(editor) {\n        if (!editor.isEmpty() && this.#annotationStorage && !this.#annotationStorage.has(editor.id)) {\n            this.#annotationStorage.setValue(editor.id, editor);\n        }\n    }\n    a11yAlert(messageId, args = null) {\n        const viewerAlert = this.#viewerAlert;\n        if (!viewerAlert) {\n            return;\n        }\n        viewerAlert.setAttribute(\"data-l10n-id\", messageId);\n        if (args) {\n            viewerAlert.setAttribute(\"data-l10n-args\", JSON.stringify(args));\n        } else {\n            viewerAlert.removeAttribute(\"data-l10n-args\");\n        }\n    }\n    #selectionChange() {\n        const selection = document.getSelection();\n        if (!selection || selection.isCollapsed) {\n            if (this.#selectedTextNode) {\n                this.#floatingToolbar?.hide();\n                this.#selectedTextNode = null;\n                this.#dispatchUpdateStates({\n                    hasSelectedText: false\n                });\n            }\n            return;\n        }\n        const { anchorNode } = selection;\n        if (anchorNode === this.#selectedTextNode) {\n            return;\n        }\n        const anchorElement = this.#getAnchorElementForSelection(selection);\n        const textLayer = anchorElement.closest(\".textLayer\");\n        if (!textLayer) {\n            if (this.#selectedTextNode) {\n                this.#floatingToolbar?.hide();\n                this.#selectedTextNode = null;\n                this.#dispatchUpdateStates({\n                    hasSelectedText: false\n                });\n            }\n            return;\n        }\n        this.#floatingToolbar?.hide();\n        this.#selectedTextNode = anchorNode;\n        this.#dispatchUpdateStates({\n            hasSelectedText: true\n        });\n        if (this.#mode !== AnnotationEditorType.HIGHLIGHT && this.#mode !== AnnotationEditorType.NONE) {\n            return;\n        }\n        if (this.#mode === AnnotationEditorType.HIGHLIGHT) {\n            this.showAllEditors(\"highlight\", true, true);\n        }\n        this.#highlightWhenShiftUp = this.isShiftKeyDown;\n        if (!this.isShiftKeyDown) {\n            const activeLayer = this.#mode === AnnotationEditorType.HIGHLIGHT ? this.#getLayerForTextLayer(textLayer) : null;\n            activeLayer?.toggleDrawing();\n            if (this.#isPointerDown) {\n                const ac = new AbortController();\n                const signal = this.combinedSignal(ac);\n                const pointerup = (e)=>{\n                    if (e.type === \"pointerup\" && e.button !== 0) {\n                        return;\n                    }\n                    ac.abort();\n                    activeLayer?.toggleDrawing(true);\n                    if (e.type === \"pointerup\") {\n                        this.#onSelectEnd(\"main_toolbar\");\n                    }\n                };\n                window.addEventListener(\"pointerup\", pointerup, {\n                    signal\n                });\n                window.addEventListener(\"blur\", pointerup, {\n                    signal\n                });\n            } else {\n                activeLayer?.toggleDrawing(true);\n                this.#onSelectEnd(\"main_toolbar\");\n            }\n        }\n    }\n    #onSelectEnd(methodOfCreation = \"\") {\n        if (this.#mode === AnnotationEditorType.HIGHLIGHT) {\n            this.highlightSelection(methodOfCreation);\n        } else if (this.#enableHighlightFloatingButton) {\n            this.#displayFloatingToolbar();\n        }\n    }\n    #addSelectionListener() {\n        document.addEventListener(\"selectionchange\", this.#selectionChange.bind(this), {\n            signal: this._signal\n        });\n    }\n    #addFocusManager() {\n        if (this.#focusManagerAC) {\n            return;\n        }\n        this.#focusManagerAC = new AbortController();\n        const signal = this.combinedSignal(this.#focusManagerAC);\n        window.addEventListener(\"focus\", this.focus.bind(this), {\n            signal\n        });\n        window.addEventListener(\"blur\", this.blur.bind(this), {\n            signal\n        });\n    }\n    #removeFocusManager() {\n        this.#focusManagerAC?.abort();\n        this.#focusManagerAC = null;\n    }\n    blur() {\n        this.isShiftKeyDown = false;\n        if (this.#highlightWhenShiftUp) {\n            this.#highlightWhenShiftUp = false;\n            this.#onSelectEnd(\"main_toolbar\");\n        }\n        if (!this.hasSelection) {\n            return;\n        }\n        const { activeElement } = document;\n        for (const editor of this.#selectedEditors){\n            if (editor.div.contains(activeElement)) {\n                this.#lastActiveElement = [\n                    editor,\n                    activeElement\n                ];\n                editor._focusEventsAllowed = false;\n                break;\n            }\n        }\n    }\n    focus() {\n        if (!this.#lastActiveElement) {\n            return;\n        }\n        const [lastEditor, lastActiveElement] = this.#lastActiveElement;\n        this.#lastActiveElement = null;\n        lastActiveElement.addEventListener(\"focusin\", ()=>{\n            lastEditor._focusEventsAllowed = true;\n        }, {\n            once: true,\n            signal: this._signal\n        });\n        lastActiveElement.focus();\n    }\n    #addKeyboardManager() {\n        if (this.#keyboardManagerAC) {\n            return;\n        }\n        this.#keyboardManagerAC = new AbortController();\n        const signal = this.combinedSignal(this.#keyboardManagerAC);\n        window.addEventListener(\"keydown\", this.keydown.bind(this), {\n            signal\n        });\n        window.addEventListener(\"keyup\", this.keyup.bind(this), {\n            signal\n        });\n    }\n    #removeKeyboardManager() {\n        this.#keyboardManagerAC?.abort();\n        this.#keyboardManagerAC = null;\n    }\n    #addCopyPasteListeners() {\n        if (this.#copyPasteAC) {\n            return;\n        }\n        this.#copyPasteAC = new AbortController();\n        const signal = this.combinedSignal(this.#copyPasteAC);\n        document.addEventListener(\"copy\", this.copy.bind(this), {\n            signal\n        });\n        document.addEventListener(\"cut\", this.cut.bind(this), {\n            signal\n        });\n        document.addEventListener(\"paste\", this.paste.bind(this), {\n            signal\n        });\n    }\n    #removeCopyPasteListeners() {\n        this.#copyPasteAC?.abort();\n        this.#copyPasteAC = null;\n    }\n    #addDragAndDropListeners() {\n        const signal = this._signal;\n        document.addEventListener(\"dragover\", this.dragOver.bind(this), {\n            signal\n        });\n        document.addEventListener(\"drop\", this.drop.bind(this), {\n            signal\n        });\n    }\n    addEditListeners() {\n        this.#addKeyboardManager();\n        this.#addCopyPasteListeners();\n    }\n    removeEditListeners() {\n        this.#removeKeyboardManager();\n        this.#removeCopyPasteListeners();\n    }\n    dragOver(event) {\n        for (const { type } of event.dataTransfer.items){\n            for (const editorType of this.#editorTypes){\n                if (editorType.isHandlingMimeForPasting(type)) {\n                    event.dataTransfer.dropEffect = \"copy\";\n                    event.preventDefault();\n                    return;\n                }\n            }\n        }\n    }\n    drop(event) {\n        for (const item of event.dataTransfer.items){\n            for (const editorType of this.#editorTypes){\n                if (editorType.isHandlingMimeForPasting(item.type)) {\n                    editorType.paste(item, this.currentLayer);\n                    event.preventDefault();\n                    return;\n                }\n            }\n        }\n    }\n    copy(event) {\n        event.preventDefault();\n        this.#activeEditor?.commitOrRemove();\n        if (!this.hasSelection) {\n            return;\n        }\n        const editors = [];\n        for (const editor of this.#selectedEditors){\n            const serialized = editor.serialize(true);\n            if (serialized) {\n                editors.push(serialized);\n            }\n        }\n        if (editors.length === 0) {\n            return;\n        }\n        event.clipboardData.setData(\"application/pdfjs\", JSON.stringify(editors));\n    }\n    cut(event) {\n        this.copy(event);\n        this.delete();\n    }\n    async paste(event) {\n        event.preventDefault();\n        const { clipboardData } = event;\n        for (const item of clipboardData.items){\n            for (const editorType of this.#editorTypes){\n                if (editorType.isHandlingMimeForPasting(item.type)) {\n                    editorType.paste(item, this.currentLayer);\n                    return;\n                }\n            }\n        }\n        let data = clipboardData.getData(\"application/pdfjs\");\n        if (!data) {\n            return;\n        }\n        try {\n            data = JSON.parse(data);\n        } catch (ex) {\n            warn(`paste: \"${ex.message}\".`);\n            return;\n        }\n        if (!Array.isArray(data)) {\n            return;\n        }\n        this.unselectAll();\n        const layer = this.currentLayer;\n        try {\n            const newEditors = [];\n            for (const editor of data){\n                const deserializedEditor = await layer.deserialize(editor);\n                if (!deserializedEditor) {\n                    return;\n                }\n                newEditors.push(deserializedEditor);\n            }\n            const cmd = ()=>{\n                for (const editor of newEditors){\n                    this.#addEditorToLayer(editor);\n                }\n                this.#selectEditors(newEditors);\n            };\n            const undo = ()=>{\n                for (const editor of newEditors){\n                    editor.remove();\n                }\n            };\n            this.addCommands({\n                cmd,\n                undo,\n                mustExec: true\n            });\n        } catch (ex) {\n            warn(`paste: \"${ex.message}\".`);\n        }\n    }\n    keydown(event) {\n        if (!this.isShiftKeyDown && event.key === \"Shift\") {\n            this.isShiftKeyDown = true;\n        }\n        if (this.#mode !== AnnotationEditorType.NONE && !this.isEditorHandlingKeyboard) {\n            AnnotationEditorUIManager._keyboardManager.exec(this, event);\n        }\n    }\n    keyup(event) {\n        if (this.isShiftKeyDown && event.key === \"Shift\") {\n            this.isShiftKeyDown = false;\n            if (this.#highlightWhenShiftUp) {\n                this.#highlightWhenShiftUp = false;\n                this.#onSelectEnd(\"main_toolbar\");\n            }\n        }\n    }\n    onEditingAction({ name }) {\n        switch(name){\n            case \"undo\":\n            case \"redo\":\n            case \"delete\":\n            case \"selectAll\":\n                this[name]();\n                break;\n            case \"highlightSelection\":\n                this.highlightSelection(\"context_menu\");\n                break;\n            case \"commentSelection\":\n                this.commentSelection(\"context_menu\");\n                break;\n        }\n    }\n    #dispatchUpdateStates(details) {\n        const hasChanged = Object.entries(details).some(([key, value1])=>this.#previousStates[key] !== value1);\n        if (hasChanged) {\n            this._eventBus.dispatch(\"annotationeditorstateschanged\", {\n                source: this,\n                details: Object.assign(this.#previousStates, details)\n            });\n            if (this.#mode === AnnotationEditorType.HIGHLIGHT && details.hasSelectedEditor === false) {\n                this.#dispatchUpdateUI([\n                    [\n                        AnnotationEditorParamsType.HIGHLIGHT_FREE,\n                        true\n                    ]\n                ]);\n            }\n        }\n    }\n    #dispatchUpdateUI(details) {\n        this._eventBus.dispatch(\"annotationeditorparamschanged\", {\n            source: this,\n            details\n        });\n    }\n    setEditingState(isEditing) {\n        if (isEditing) {\n            this.#addFocusManager();\n            this.#addCopyPasteListeners();\n            this.#dispatchUpdateStates({\n                isEditing: this.#mode !== AnnotationEditorType.NONE,\n                isEmpty: this.#isEmpty(),\n                hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),\n                hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),\n                hasSelectedEditor: false\n            });\n        } else {\n            this.#removeFocusManager();\n            this.#removeCopyPasteListeners();\n            this.#dispatchUpdateStates({\n                isEditing: false\n            });\n            this.disableUserSelect(false);\n        }\n    }\n    registerEditorTypes(types) {\n        if (this.#editorTypes) {\n            return;\n        }\n        this.#editorTypes = types;\n        for (const editorType of this.#editorTypes){\n            this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);\n        }\n    }\n    getId() {\n        return this.#idManager.id;\n    }\n    get currentLayer() {\n        return this.#allLayers.get(this.#currentPageIndex);\n    }\n    getLayer(pageIndex) {\n        return this.#allLayers.get(pageIndex);\n    }\n    get currentPageIndex() {\n        return this.#currentPageIndex;\n    }\n    addLayer(layer) {\n        this.#allLayers.set(layer.pageIndex, layer);\n        if (this.#isEnabled) {\n            layer.enable();\n        } else {\n            layer.disable();\n        }\n    }\n    removeLayer(layer) {\n        this.#allLayers.delete(layer.pageIndex);\n    }\n    async updateMode(mode, editId = null, isFromKeyboard = false, mustEnterInEditMode = false, editComment = false) {\n        if (this.#mode === mode) {\n            return;\n        }\n        if (this.#updateModeCapability) {\n            await this.#updateModeCapability.promise;\n            if (!this.#updateModeCapability) {\n                return;\n            }\n        }\n        this.#updateModeCapability = Promise.withResolvers();\n        this.#currentDrawingSession?.commitOrRemove();\n        if (this.#mode === AnnotationEditorType.POPUP) {\n            this.#commentManager?.hideSidebar();\n        }\n        this.#commentManager?.destroyPopup();\n        this.#mode = mode;\n        if (mode === AnnotationEditorType.NONE) {\n            this.setEditingState(false);\n            this.#disableAll();\n            for (const editor of this.#allEditors.values()){\n                editor.hideStandaloneCommentButton();\n            }\n            this._editorUndoBar?.hide();\n            this.toggleComment(null);\n            this.#updateModeCapability.resolve();\n            return;\n        }\n        for (const editor of this.#allEditors.values()){\n            editor.addStandaloneCommentButton();\n        }\n        if (mode === AnnotationEditorType.SIGNATURE) {\n            await this.#signatureManager?.loadSignatures();\n        }\n        this.setEditingState(true);\n        await this.#enableAll();\n        this.unselectAll();\n        for (const layer of this.#allLayers.values()){\n            layer.updateMode(mode);\n        }\n        if (mode === AnnotationEditorType.POPUP) {\n            this.#allEditableAnnotations ||= await this.#pdfDocument.getAnnotationsByType(new Set(this.#editorTypes.map((editorClass)=>editorClass._editorType)));\n            const elementIds = /* @__PURE__ */ new Set();\n            const allComments = [];\n            for (const editor of this.#allEditors.values()){\n                const { annotationElementId, hasComment, deleted } = editor;\n                if (annotationElementId) {\n                    elementIds.add(annotationElementId);\n                }\n                if (hasComment && !deleted) {\n                    allComments.push(editor.getData());\n                }\n            }\n            for (const annotation of this.#allEditableAnnotations){\n                const { id, popupRef, contentsObj } = annotation;\n                if (popupRef && contentsObj?.str && !elementIds.has(id) && !this.#deletedAnnotationsElementIds.has(id)) {\n                    allComments.push(annotation);\n                }\n            }\n            this.#commentManager?.showSidebar(allComments);\n        }\n        if (!editId) {\n            if (isFromKeyboard) {\n                this.addNewEditorFromKeyboard();\n            }\n            this.#updateModeCapability.resolve();\n            return;\n        }\n        for (const editor of this.#allEditors.values()){\n            if (editor.uid === editId) {\n                this.setSelected(editor);\n                if (editComment) {\n                    editor.editComment();\n                } else if (mustEnterInEditMode) {\n                    editor.enterInEditMode();\n                } else {\n                    editor.focus();\n                }\n            } else {\n                editor.unselect();\n            }\n        }\n        this.#updateModeCapability.resolve();\n    }\n    addNewEditorFromKeyboard() {\n        if (this.currentLayer.canCreateNewEmptyEditor()) {\n            this.currentLayer.addNewEditor();\n        }\n    }\n    updateToolbar(options) {\n        if (options.mode === this.#mode) {\n            return;\n        }\n        this._eventBus.dispatch(\"switchannotationeditormode\", {\n            source: this,\n            ...options\n        });\n    }\n    updateParams(type, value1) {\n        if (!this.#editorTypes) {\n            return;\n        }\n        switch(type){\n            case AnnotationEditorParamsType.CREATE:\n                this.currentLayer.addNewEditor(value1);\n                return;\n            case AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL:\n                this._eventBus.dispatch(\"reporttelemetry\", {\n                    source: this,\n                    details: {\n                        type: \"editing\",\n                        data: {\n                            type: \"highlight\",\n                            action: \"toggle_visibility\"\n                        }\n                    }\n                });\n                (this.#showAllStates ||= /* @__PURE__ */ new Map()).set(type, value1);\n                this.showAllEditors(\"highlight\", value1);\n                break;\n        }\n        if (this.hasSelection) {\n            for (const editor of this.#selectedEditors){\n                editor.updateParams(type, value1);\n            }\n        } else {\n            for (const editorType of this.#editorTypes){\n                editorType.updateDefaultParams(type, value1);\n            }\n        }\n    }\n    showAllEditors(type, visible, updateButton = false) {\n        for (const editor of this.#allEditors.values()){\n            if (editor.editorType === type) {\n                editor.show(visible);\n            }\n        }\n        const state = this.#showAllStates?.get(AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL) ?? true;\n        if (state !== visible) {\n            this.#dispatchUpdateUI([\n                [\n                    AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL,\n                    visible\n                ]\n            ]);\n        }\n    }\n    enableWaiting(mustWait = false) {\n        if (this.#isWaiting === mustWait) {\n            return;\n        }\n        this.#isWaiting = mustWait;\n        for (const layer of this.#allLayers.values()){\n            if (mustWait) {\n                layer.disableClick();\n            } else {\n                layer.enableClick();\n            }\n            layer.div.classList.toggle(\"waiting\", mustWait);\n        }\n    }\n    async #enableAll() {\n        if (!this.#isEnabled) {\n            this.#isEnabled = true;\n            const promises = [];\n            for (const layer of this.#allLayers.values()){\n                promises.push(layer.enable());\n            }\n            await Promise.all(promises);\n            for (const editor of this.#allEditors.values()){\n                editor.enable();\n            }\n        }\n    }\n    #disableAll() {\n        this.unselectAll();\n        if (this.#isEnabled) {\n            this.#isEnabled = false;\n            for (const layer of this.#allLayers.values()){\n                layer.disable();\n            }\n            for (const editor of this.#allEditors.values()){\n                editor.disable();\n            }\n        }\n    }\n    *getEditors(pageIndex) {\n        for (const editor of this.#allEditors.values()){\n            if (editor.pageIndex === pageIndex) {\n                yield editor;\n            }\n        }\n    }\n    getEditor(id) {\n        return this.#allEditors.get(id);\n    }\n    addEditor(editor) {\n        this.#allEditors.set(editor.id, editor);\n    }\n    removeEditor(editor) {\n        if (editor.div.contains(document.activeElement)) {\n            if (this.#focusMainContainerTimeoutId) {\n                clearTimeout(this.#focusMainContainerTimeoutId);\n            }\n            this.#focusMainContainerTimeoutId = setTimeout(()=>{\n                this.focusMainContainer();\n                this.#focusMainContainerTimeoutId = null;\n            }, 0);\n        }\n        this.#allEditors.delete(editor.id);\n        if (editor.annotationElementId) {\n            this.#missingCanvases?.delete(editor.annotationElementId);\n        }\n        this.unselect(editor);\n        if (!editor.annotationElementId || !this.#deletedAnnotationsElementIds.has(editor.annotationElementId)) {\n            this.#annotationStorage?.remove(editor.id);\n        }\n    }\n    addDeletedAnnotationElement(editor) {\n        this.#deletedAnnotationsElementIds.add(editor.annotationElementId);\n        this.addChangedExistingAnnotation(editor);\n        editor.deleted = true;\n    }\n    isDeletedAnnotationElement(annotationElementId) {\n        return this.#deletedAnnotationsElementIds.has(annotationElementId);\n    }\n    removeDeletedAnnotationElement(editor) {\n        this.#deletedAnnotationsElementIds.delete(editor.annotationElementId);\n        this.removeChangedExistingAnnotation(editor);\n        editor.deleted = false;\n    }\n    #addEditorToLayer(editor) {\n        const layer = this.#allLayers.get(editor.pageIndex);\n        if (layer) {\n            layer.addOrRebuild(editor);\n        } else {\n            this.addEditor(editor);\n            this.addToAnnotationStorage(editor);\n        }\n    }\n    setActiveEditor(editor) {\n        if (this.#activeEditor === editor) {\n            return;\n        }\n        this.#activeEditor = editor;\n        if (editor) {\n            this.#dispatchUpdateUI(editor.propertiesToUpdate);\n        }\n    }\n    get #lastSelectedEditor() {\n        let ed = null;\n        for (ed of this.#selectedEditors){}\n        return ed;\n    }\n    updateUI(editor) {\n        if (this.#lastSelectedEditor === editor) {\n            this.#dispatchUpdateUI(editor.propertiesToUpdate);\n        }\n    }\n    updateUIForDefaultProperties(editorType) {\n        this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);\n    }\n    toggleSelected(editor) {\n        if (this.#selectedEditors.has(editor)) {\n            this.#selectedEditors.delete(editor);\n            editor.unselect();\n            this.#dispatchUpdateStates({\n                hasSelectedEditor: this.hasSelection\n            });\n            return;\n        }\n        this.#selectedEditors.add(editor);\n        editor.select();\n        this.#dispatchUpdateUI(editor.propertiesToUpdate);\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: true\n        });\n    }\n    setSelected(editor) {\n        this.updateToolbar({\n            mode: editor.mode,\n            editId: editor.id\n        });\n        this.#currentDrawingSession?.commitOrRemove();\n        for (const ed of this.#selectedEditors){\n            if (ed !== editor) {\n                ed.unselect();\n            }\n        }\n        this.#selectedEditors.clear();\n        this.#selectedEditors.add(editor);\n        editor.select();\n        this.#dispatchUpdateUI(editor.propertiesToUpdate);\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: true\n        });\n    }\n    isSelected(editor) {\n        return this.#selectedEditors.has(editor);\n    }\n    get firstSelectedEditor() {\n        return this.#selectedEditors.values().next().value;\n    }\n    unselect(editor) {\n        editor.unselect();\n        this.#selectedEditors.delete(editor);\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: this.hasSelection\n        });\n    }\n    get hasSelection() {\n        return this.#selectedEditors.size !== 0;\n    }\n    get isEnterHandled() {\n        return this.#selectedEditors.size === 1 && this.firstSelectedEditor.isEnterHandled;\n    }\n    undo() {\n        this.#commandManager.undo();\n        this.#dispatchUpdateStates({\n            hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),\n            hasSomethingToRedo: true,\n            isEmpty: this.#isEmpty()\n        });\n        this._editorUndoBar?.hide();\n    }\n    redo() {\n        this.#commandManager.redo();\n        this.#dispatchUpdateStates({\n            hasSomethingToUndo: true,\n            hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),\n            isEmpty: this.#isEmpty()\n        });\n    }\n    addCommands(params) {\n        this.#commandManager.add(params);\n        this.#dispatchUpdateStates({\n            hasSomethingToUndo: true,\n            hasSomethingToRedo: false,\n            isEmpty: this.#isEmpty()\n        });\n    }\n    cleanUndoStack(type) {\n        this.#commandManager.cleanType(type);\n    }\n    #isEmpty() {\n        if (this.#allEditors.size === 0) {\n            return true;\n        }\n        if (this.#allEditors.size === 1) {\n            for (const editor of this.#allEditors.values()){\n                return editor.isEmpty();\n            }\n        }\n        return false;\n    }\n    delete() {\n        this.commitOrRemove();\n        const drawingEditor = this.currentLayer?.endDrawingSession(true);\n        if (!this.hasSelection && !drawingEditor) {\n            return;\n        }\n        const editors = drawingEditor ? [\n            drawingEditor\n        ] : [\n            ...this.#selectedEditors\n        ];\n        const cmd = ()=>{\n            this._editorUndoBar?.show(undo, editors.length === 1 ? editors[0].editorType : editors.length);\n            for (const editor of editors){\n                editor.remove();\n            }\n        };\n        const undo = ()=>{\n            for (const editor of editors){\n                this.#addEditorToLayer(editor);\n            }\n        };\n        this.addCommands({\n            cmd,\n            undo,\n            mustExec: true\n        });\n    }\n    commitOrRemove() {\n        this.#activeEditor?.commitOrRemove();\n    }\n    hasSomethingToControl() {\n        return this.#activeEditor || this.hasSelection;\n    }\n    #selectEditors(editors) {\n        for (const editor of this.#selectedEditors){\n            editor.unselect();\n        }\n        this.#selectedEditors.clear();\n        for (const editor of editors){\n            if (editor.isEmpty()) {\n                continue;\n            }\n            this.#selectedEditors.add(editor);\n            editor.select();\n        }\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: this.hasSelection\n        });\n    }\n    selectAll() {\n        for (const editor of this.#selectedEditors){\n            editor.commit();\n        }\n        this.#selectEditors(this.#allEditors.values());\n    }\n    unselectAll() {\n        if (this.#activeEditor) {\n            this.#activeEditor.commitOrRemove();\n            if (this.#mode !== AnnotationEditorType.NONE) {\n                return;\n            }\n        }\n        if (this.#currentDrawingSession?.commitOrRemove()) {\n            return;\n        }\n        if (!this.hasSelection) {\n            return;\n        }\n        for (const editor of this.#selectedEditors){\n            editor.unselect();\n        }\n        this.#selectedEditors.clear();\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: false\n        });\n    }\n    translateSelectedEditors(x, y, noCommit = false) {\n        if (!noCommit) {\n            this.commitOrRemove();\n        }\n        if (!this.hasSelection) {\n            return;\n        }\n        this.#translation[0] += x;\n        this.#translation[1] += y;\n        const [totalX, totalY] = this.#translation;\n        const editors = [\n            ...this.#selectedEditors\n        ];\n        const TIME_TO_WAIT = 1e3;\n        if (this.#translationTimeoutId) {\n            clearTimeout(this.#translationTimeoutId);\n        }\n        this.#translationTimeoutId = setTimeout(()=>{\n            this.#translationTimeoutId = null;\n            this.#translation[0] = this.#translation[1] = 0;\n            this.addCommands({\n                cmd: ()=>{\n                    for (const editor of editors){\n                        if (this.#allEditors.has(editor.id)) {\n                            editor.translateInPage(totalX, totalY);\n                            editor.translationDone();\n                        }\n                    }\n                },\n                undo: ()=>{\n                    for (const editor of editors){\n                        if (this.#allEditors.has(editor.id)) {\n                            editor.translateInPage(-totalX, -totalY);\n                            editor.translationDone();\n                        }\n                    }\n                },\n                mustExec: false\n            });\n        }, TIME_TO_WAIT);\n        for (const editor of editors){\n            editor.translateInPage(x, y);\n            editor.translationDone();\n        }\n    }\n    setUpDragSession() {\n        if (!this.hasSelection) {\n            return;\n        }\n        this.disableUserSelect(true);\n        this.#draggingEditors = /* @__PURE__ */ new Map();\n        for (const editor of this.#selectedEditors){\n            this.#draggingEditors.set(editor, {\n                savedX: editor.x,\n                savedY: editor.y,\n                savedPageIndex: editor.pageIndex,\n                newX: 0,\n                newY: 0,\n                newPageIndex: -1\n            });\n        }\n    }\n    endDragSession() {\n        if (!this.#draggingEditors) {\n            return false;\n        }\n        this.disableUserSelect(false);\n        const map = this.#draggingEditors;\n        this.#draggingEditors = null;\n        let mustBeAddedInUndoStack = false;\n        for (const [{ x, y, pageIndex }, value1] of map){\n            value1.newX = x;\n            value1.newY = y;\n            value1.newPageIndex = pageIndex;\n            mustBeAddedInUndoStack ||= x !== value1.savedX || y !== value1.savedY || pageIndex !== value1.savedPageIndex;\n        }\n        if (!mustBeAddedInUndoStack) {\n            return false;\n        }\n        const move = (editor, x, y, pageIndex)=>{\n            if (this.#allEditors.has(editor.id)) {\n                const parent = this.#allLayers.get(pageIndex);\n                if (parent) {\n                    editor._setParentAndPosition(parent, x, y);\n                } else {\n                    editor.pageIndex = pageIndex;\n                    editor.x = x;\n                    editor.y = y;\n                }\n            }\n        };\n        this.addCommands({\n            cmd: ()=>{\n                for (const [editor, { newX, newY, newPageIndex }] of map){\n                    move(editor, newX, newY, newPageIndex);\n                }\n            },\n            undo: ()=>{\n                for (const [editor, { savedX, savedY, savedPageIndex }] of map){\n                    move(editor, savedX, savedY, savedPageIndex);\n                }\n            },\n            mustExec: true\n        });\n        return true;\n    }\n    dragSelectedEditors(tx, ty) {\n        if (!this.#draggingEditors) {\n            return;\n        }\n        for (const editor of this.#draggingEditors.keys()){\n            editor.drag(tx, ty);\n        }\n    }\n    rebuild(editor) {\n        if (editor.parent === null) {\n            const parent = this.getLayer(editor.pageIndex);\n            if (parent) {\n                parent.changeParent(editor);\n                parent.addOrRebuild(editor);\n            } else {\n                this.addEditor(editor);\n                this.addToAnnotationStorage(editor);\n                editor.rebuild();\n            }\n        } else {\n            editor.parent.addOrRebuild(editor);\n        }\n    }\n    get isEditorHandlingKeyboard() {\n        return this.getActive()?.shouldGetKeyboardEvents() || this.#selectedEditors.size === 1 && this.firstSelectedEditor.shouldGetKeyboardEvents();\n    }\n    isActive(editor) {\n        return this.#activeEditor === editor;\n    }\n    getActive() {\n        return this.#activeEditor;\n    }\n    getMode() {\n        return this.#mode;\n    }\n    isEditingMode() {\n        return this.#mode !== AnnotationEditorType.NONE;\n    }\n    get imageManager() {\n        return shadow(this, \"imageManager\", new ImageManager());\n    }\n    getSelectionBoxes(textLayer) {\n        if (!textLayer) {\n            return null;\n        }\n        const selection = document.getSelection();\n        for(let i = 0, ii = selection.rangeCount; i < ii; i++){\n            if (!textLayer.contains(selection.getRangeAt(i).commonAncestorContainer)) {\n                return null;\n            }\n        }\n        const { x: layerX, y: layerY, width: parentWidth, height: parentHeight } = textLayer.getBoundingClientRect();\n        let rotator;\n        switch(textLayer.getAttribute(\"data-main-rotation\")){\n            case \"90\":\n                rotator = (x, y, w, h)=>({\n                        x: (y - layerY) / parentHeight,\n                        y: 1 - (x + w - layerX) / parentWidth,\n                        width: h / parentHeight,\n                        height: w / parentWidth\n                    });\n                break;\n            case \"180\":\n                rotator = (x, y, w, h)=>({\n                        x: 1 - (x + w - layerX) / parentWidth,\n                        y: 1 - (y + h - layerY) / parentHeight,\n                        width: w / parentWidth,\n                        height: h / parentHeight\n                    });\n                break;\n            case \"270\":\n                rotator = (x, y, w, h)=>({\n                        x: 1 - (y + h - layerY) / parentHeight,\n                        y: (x - layerX) / parentWidth,\n                        width: h / parentHeight,\n                        height: w / parentWidth\n                    });\n                break;\n            default:\n                rotator = (x, y, w, h)=>({\n                        x: (x - layerX) / parentWidth,\n                        y: (y - layerY) / parentHeight,\n                        width: w / parentWidth,\n                        height: h / parentHeight\n                    });\n                break;\n        }\n        const boxes = [];\n        for(let i = 0, ii = selection.rangeCount; i < ii; i++){\n            const range = selection.getRangeAt(i);\n            if (range.collapsed) {\n                continue;\n            }\n            for (const { x, y, width, height } of range.getClientRects()){\n                if (width === 0 || height === 0) {\n                    continue;\n                }\n                boxes.push(rotator(x, y, width, height));\n            }\n        }\n        return boxes.length === 0 ? null : boxes;\n    }\n    addChangedExistingAnnotation({ annotationElementId, id }) {\n        (this.#changedExistingAnnotations ||= /* @__PURE__ */ new Map()).set(annotationElementId, id);\n    }\n    removeChangedExistingAnnotation({ annotationElementId }) {\n        this.#changedExistingAnnotations?.delete(annotationElementId);\n    }\n    renderAnnotationElement(annotation) {\n        const editorId = this.#changedExistingAnnotations?.get(annotation.data.id);\n        if (!editorId) {\n            return;\n        }\n        const editor = this.#annotationStorage.getRawValue(editorId);\n        if (!editor) {\n            return;\n        }\n        if (this.#mode === AnnotationEditorType.NONE && !editor.hasBeenModified) {\n            return;\n        }\n        editor.renderAnnotationElement(annotation);\n    }\n    setMissingCanvas(annotationId, annotationElementId, canvas) {\n        const editor = this.#missingCanvases?.get(annotationId);\n        if (!editor) {\n            return;\n        }\n        editor.setCanvas(annotationElementId, canvas);\n        this.#missingCanvases.delete(annotationId);\n    }\n    addMissingCanvas(annotationId, editor) {\n        (this.#missingCanvases ||= /* @__PURE__ */ new Map()).set(annotationId, editor);\n    }\n}\nclass AltText {\n    #altText;\n    #altTextDecorative;\n    #altTextButton;\n    #altTextButtonLabel;\n    #altTextTooltip;\n    #altTextTooltipTimeout;\n    #altTextWasFromKeyBoard;\n    #badge;\n    #editor;\n    #guessedText;\n    #textWithDisclaimer;\n    #useNewAltTextFlow;\n    static #l10nNewButton = null;\n    static{\n        this._l10n = null;\n    }\n    constructor(editor){\n        this.#altText = null;\n        this.#altTextDecorative = false;\n        this.#altTextButton = null;\n        this.#altTextButtonLabel = null;\n        this.#altTextTooltip = null;\n        this.#altTextTooltipTimeout = null;\n        this.#altTextWasFromKeyBoard = false;\n        this.#badge = null;\n        this.#editor = null;\n        this.#guessedText = null;\n        this.#textWithDisclaimer = null;\n        this.#useNewAltTextFlow = false;\n        this.#editor = editor;\n        this.#useNewAltTextFlow = editor._uiManager.useNewAltTextFlow;\n        AltText.#l10nNewButton ||= Object.freeze({\n            added: \"pdfjs-editor-new-alt-text-added-button\",\n            \"added-label\": \"pdfjs-editor-new-alt-text-added-button-label\",\n            missing: \"pdfjs-editor-new-alt-text-missing-button\",\n            \"missing-label\": \"pdfjs-editor-new-alt-text-missing-button-label\",\n            review: \"pdfjs-editor-new-alt-text-to-review-button\",\n            \"review-label\": \"pdfjs-editor-new-alt-text-to-review-button-label\"\n        });\n    }\n    static initialize(l10n) {\n        AltText._l10n ??= l10n;\n    }\n    async render() {\n        const altText = this.#altTextButton = document.createElement(\"button\");\n        altText.className = \"altText\";\n        altText.tabIndex = \"0\";\n        const label = this.#altTextButtonLabel = document.createElement(\"span\");\n        altText.append(label);\n        if (this.#useNewAltTextFlow) {\n            altText.classList.add(\"new\");\n            altText.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton.missing);\n            label.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton[\"missing-label\"]);\n        } else {\n            altText.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-button\");\n            label.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-button-label\");\n        }\n        const signal = this.#editor._uiManager._signal;\n        altText.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        altText.addEventListener(\"pointerdown\", (event)=>event.stopPropagation(), {\n            signal\n        });\n        const onClick = (event)=>{\n            event.preventDefault();\n            this.#editor._uiManager.editAltText(this.#editor);\n            if (this.#useNewAltTextFlow) {\n                this.#editor._reportTelemetry({\n                    action: \"pdfjs.image.alt_text.image_status_label_clicked\",\n                    data: {\n                        label: this.#label\n                    }\n                });\n            }\n        };\n        altText.addEventListener(\"click\", onClick, {\n            capture: true,\n            signal\n        });\n        altText.addEventListener(\"keydown\", (event)=>{\n            if (event.target === altText && event.key === \"Enter\") {\n                this.#altTextWasFromKeyBoard = true;\n                onClick(event);\n            }\n        }, {\n            signal\n        });\n        await this.#setState();\n        return altText;\n    }\n    get #label() {\n        return this.#altText && \"added\" || this.#altText === null && this.guessedText && \"review\" || \"missing\";\n    }\n    finish() {\n        if (!this.#altTextButton) {\n            return;\n        }\n        this.#altTextButton.focus({\n            focusVisible: this.#altTextWasFromKeyBoard\n        });\n        this.#altTextWasFromKeyBoard = false;\n    }\n    isEmpty() {\n        if (this.#useNewAltTextFlow) {\n            return this.#altText === null;\n        }\n        return !this.#altText && !this.#altTextDecorative;\n    }\n    hasData() {\n        if (this.#useNewAltTextFlow) {\n            return this.#altText !== null || !!this.#guessedText;\n        }\n        return this.isEmpty();\n    }\n    get guessedText() {\n        return this.#guessedText;\n    }\n    async setGuessedText(guessedText) {\n        if (this.#altText !== null) {\n            return;\n        }\n        this.#guessedText = guessedText;\n        this.#textWithDisclaimer = await AltText._l10n.get(\"pdfjs-editor-new-alt-text-generated-alt-text-with-disclaimer\", {\n            generatedAltText: guessedText\n        });\n        this.#setState();\n    }\n    toggleAltTextBadge(visibility = false) {\n        if (!this.#useNewAltTextFlow || this.#altText) {\n            this.#badge?.remove();\n            this.#badge = null;\n            return;\n        }\n        if (!this.#badge) {\n            const badge = this.#badge = document.createElement(\"div\");\n            badge.className = \"noAltTextBadge\";\n            this.#editor.div.append(badge);\n        }\n        this.#badge.classList.toggle(\"hidden\", !visibility);\n    }\n    serialize(isForCopying) {\n        let altText = this.#altText;\n        if (!isForCopying && this.#guessedText === altText) {\n            altText = this.#textWithDisclaimer;\n        }\n        return {\n            altText,\n            decorative: this.#altTextDecorative,\n            guessedText: this.#guessedText,\n            textWithDisclaimer: this.#textWithDisclaimer\n        };\n    }\n    get data() {\n        return {\n            altText: this.#altText,\n            decorative: this.#altTextDecorative\n        };\n    }\n    set data({ altText, decorative, guessedText, textWithDisclaimer, cancel = false }) {\n        if (guessedText) {\n            this.#guessedText = guessedText;\n            this.#textWithDisclaimer = textWithDisclaimer;\n        }\n        if (this.#altText === altText && this.#altTextDecorative === decorative) {\n            return;\n        }\n        if (!cancel) {\n            this.#altText = altText;\n            this.#altTextDecorative = decorative;\n        }\n        this.#setState();\n    }\n    toggle(enabled = false) {\n        if (!this.#altTextButton) {\n            return;\n        }\n        if (!enabled && this.#altTextTooltipTimeout) {\n            clearTimeout(this.#altTextTooltipTimeout);\n            this.#altTextTooltipTimeout = null;\n        }\n        this.#altTextButton.disabled = !enabled;\n    }\n    shown() {\n        this.#editor._reportTelemetry({\n            action: \"pdfjs.image.alt_text.image_status_label_displayed\",\n            data: {\n                label: this.#label\n            }\n        });\n    }\n    destroy() {\n        this.#altTextButton?.remove();\n        this.#altTextButton = null;\n        this.#altTextButtonLabel = null;\n        this.#altTextTooltip = null;\n        this.#badge?.remove();\n        this.#badge = null;\n    }\n    async #setState() {\n        const button = this.#altTextButton;\n        if (!button) {\n            return;\n        }\n        if (this.#useNewAltTextFlow) {\n            button.classList.toggle(\"done\", !!this.#altText);\n            button.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton[this.#label]);\n            this.#altTextButtonLabel?.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton[`${this.#label}-label`]);\n            if (!this.#altText) {\n                this.#altTextTooltip?.remove();\n                return;\n            }\n        } else {\n            if (!this.#altText && !this.#altTextDecorative) {\n                button.classList.remove(\"done\");\n                this.#altTextTooltip?.remove();\n                return;\n            }\n            button.classList.add(\"done\");\n            button.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-edit-button\");\n        }\n        let tooltip = this.#altTextTooltip;\n        if (!tooltip) {\n            this.#altTextTooltip = tooltip = document.createElement(\"span\");\n            tooltip.className = \"tooltip\";\n            tooltip.setAttribute(\"role\", \"tooltip\");\n            tooltip.id = `alt-text-tooltip-${this.#editor.id}`;\n            const DELAY_TO_SHOW_TOOLTIP = 100;\n            const signal = this.#editor._uiManager._signal;\n            signal.addEventListener(\"abort\", ()=>{\n                clearTimeout(this.#altTextTooltipTimeout);\n                this.#altTextTooltipTimeout = null;\n            }, {\n                once: true\n            });\n            button.addEventListener(\"mouseenter\", ()=>{\n                this.#altTextTooltipTimeout = setTimeout(()=>{\n                    this.#altTextTooltipTimeout = null;\n                    this.#altTextTooltip.classList.add(\"show\");\n                    this.#editor._reportTelemetry({\n                        action: \"alt_text_tooltip\"\n                    });\n                }, DELAY_TO_SHOW_TOOLTIP);\n            }, {\n                signal\n            });\n            button.addEventListener(\"mouseleave\", ()=>{\n                if (this.#altTextTooltipTimeout) {\n                    clearTimeout(this.#altTextTooltipTimeout);\n                    this.#altTextTooltipTimeout = null;\n                }\n                this.#altTextTooltip?.classList.remove(\"show\");\n            }, {\n                signal\n            });\n        }\n        if (this.#altTextDecorative) {\n            tooltip.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-decorative-tooltip\");\n        } else {\n            tooltip.removeAttribute(\"data-l10n-id\");\n            tooltip.textContent = this.#altText;\n        }\n        if (!tooltip.parentNode) {\n            button.append(tooltip);\n        }\n        const element = this.#editor.getElementForAltText();\n        element?.setAttribute(\"aria-describedby\", tooltip.id);\n    }\n}\nclass Comment {\n    #commentStandaloneButton;\n    #commentToolbarButton;\n    #commentWasFromKeyBoard;\n    #editor;\n    #initialText;\n    #richText;\n    #text;\n    #date;\n    #deleted;\n    #popupPosition;\n    constructor(editor){\n        this.#commentStandaloneButton = null;\n        this.#commentToolbarButton = null;\n        this.#commentWasFromKeyBoard = false;\n        this.#editor = null;\n        this.#initialText = null;\n        this.#richText = null;\n        this.#text = null;\n        this.#date = null;\n        this.#deleted = false;\n        this.#popupPosition = null;\n        this.#editor = editor;\n    }\n    renderForToolbar() {\n        const button = this.#commentToolbarButton = document.createElement(\"button\");\n        button.className = \"comment\";\n        return this.#render(button, false);\n    }\n    renderForStandalone() {\n        const button = this.#commentStandaloneButton = document.createElement(\"button\");\n        button.className = \"annotationCommentButton\";\n        const position = this.#editor.commentButtonPosition;\n        if (position) {\n            const { style } = button;\n            style.insetInlineEnd = `calc(${100 * (this.#editor._uiManager.direction === \"ltr\" ? 1 - position[0] : position[0])}% - var(--comment-button-dim))`;\n            style.top = `calc(${100 * position[1]}% - var(--comment-button-dim))`;\n            const color = this.#editor.commentButtonColor;\n            if (color) {\n                style.backgroundColor = color;\n            }\n        }\n        return this.#render(button, true);\n    }\n    focusButton() {\n        setTimeout(()=>{\n            (this.#commentStandaloneButton ?? this.#commentToolbarButton)?.focus();\n        }, 0);\n    }\n    onUpdatedColor() {\n        if (!this.#commentStandaloneButton) {\n            return;\n        }\n        const color = this.#editor.commentButtonColor;\n        if (color) {\n            this.#commentStandaloneButton.style.backgroundColor = color;\n        }\n        this.#editor._uiManager.updatePopupColor(this.#editor);\n    }\n    get commentButtonWidth() {\n        return (this.#commentStandaloneButton?.getBoundingClientRect().width ?? 0) / this.#editor.parent.boundingClientRect.width;\n    }\n    get commentPopupPositionInLayer() {\n        if (this.#popupPosition) {\n            return this.#popupPosition;\n        }\n        if (!this.#commentStandaloneButton) {\n            return null;\n        }\n        const { x, y, height } = this.#commentStandaloneButton.getBoundingClientRect();\n        const { x: parentX, y: parentY, width: parentWidth, height: parentHeight } = this.#editor.parent.boundingClientRect;\n        return [\n            (x - parentX) / parentWidth,\n            (y + height - parentY) / parentHeight\n        ];\n    }\n    set commentPopupPositionInLayer(pos) {\n        this.#popupPosition = pos;\n    }\n    hasDefaultPopupPosition() {\n        return this.#popupPosition === null;\n    }\n    removeStandaloneCommentButton() {\n        this.#commentStandaloneButton?.remove();\n        this.#commentStandaloneButton = null;\n    }\n    removeToolbarCommentButton() {\n        this.#commentToolbarButton?.remove();\n        this.#commentToolbarButton = null;\n    }\n    setCommentButtonStates({ selected, hasPopup }) {\n        if (!this.#commentStandaloneButton) {\n            return;\n        }\n        this.#commentStandaloneButton.classList.toggle(\"selected\", selected);\n        this.#commentStandaloneButton.ariaExpanded = hasPopup;\n    }\n    #render(comment, isStandalone) {\n        if (!this.#editor._uiManager.hasCommentManager()) {\n            return null;\n        }\n        comment.tabIndex = \"0\";\n        comment.ariaHasPopup = \"dialog\";\n        if (isStandalone) {\n            comment.ariaControls = \"commentPopup\";\n            comment.setAttribute(\"data-l10n-id\", \"pdfjs-show-comment-button\");\n        } else {\n            comment.ariaControlsElements = [\n                this.#editor._uiManager.getCommentDialogElement()\n            ];\n            comment.setAttribute(\"data-l10n-id\", \"pdfjs-editor-edit-comment-button\");\n        }\n        const signal = this.#editor._uiManager._signal;\n        if (!(signal instanceof AbortSignal) || signal.aborted) {\n            return comment;\n        }\n        comment.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        if (isStandalone) {\n            comment.addEventListener(\"focusin\", (e)=>{\n                this.#editor._focusEventsAllowed = false;\n                stopEvent(e);\n            }, {\n                capture: true,\n                signal\n            });\n            comment.addEventListener(\"focusout\", (e)=>{\n                this.#editor._focusEventsAllowed = true;\n                stopEvent(e);\n            }, {\n                capture: true,\n                signal\n            });\n        }\n        comment.addEventListener(\"pointerdown\", (event)=>event.stopPropagation(), {\n            signal\n        });\n        const onClick = (event)=>{\n            event.preventDefault();\n            if (comment === this.#commentToolbarButton) {\n                this.edit();\n            } else {\n                this.#editor.toggleComment(true);\n            }\n        };\n        comment.addEventListener(\"click\", onClick, {\n            capture: true,\n            signal\n        });\n        comment.addEventListener(\"keydown\", (event)=>{\n            if (event.target === comment && event.key === \"Enter\") {\n                this.#commentWasFromKeyBoard = true;\n                onClick(event);\n            }\n        }, {\n            signal\n        });\n        comment.addEventListener(\"pointerenter\", ()=>{\n            this.#editor.toggleComment(false, true);\n        }, {\n            signal\n        });\n        comment.addEventListener(\"pointerleave\", ()=>{\n            this.#editor.toggleComment(false, false);\n        }, {\n            signal\n        });\n        return comment;\n    }\n    edit(options) {\n        const position = this.commentPopupPositionInLayer;\n        let posX, posY;\n        if (position) {\n            [posX, posY] = position;\n        } else {\n            [posX, posY] = this.#editor.commentButtonPosition;\n            const { width, height, x, y } = this.#editor;\n            posX = x + posX * width;\n            posY = y + posY * height;\n        }\n        const parentDimensions = this.#editor.parent.boundingClientRect;\n        const { x: parentX, y: parentY, width: parentWidth, height: parentHeight } = parentDimensions;\n        this.#editor._uiManager.editComment(this.#editor, parentX + posX * parentWidth, parentY + posY * parentHeight, {\n            ...options,\n            parentDimensions\n        });\n    }\n    finish() {\n        if (!this.#commentToolbarButton) {\n            return;\n        }\n        this.#commentToolbarButton.focus({\n            focusVisible: this.#commentWasFromKeyBoard\n        });\n        this.#commentWasFromKeyBoard = false;\n    }\n    isDeleted() {\n        return this.#deleted || this.#text === \"\";\n    }\n    isEmpty() {\n        return this.#text === null;\n    }\n    hasBeenEdited() {\n        return this.isDeleted() || this.#text !== this.#initialText;\n    }\n    serialize() {\n        return this.data;\n    }\n    get data() {\n        return {\n            text: this.#text,\n            richText: this.#richText,\n            date: this.#date,\n            deleted: this.isDeleted()\n        };\n    }\n    set data(text) {\n        if (text !== this.#text) {\n            this.#richText = null;\n        }\n        if (text === null) {\n            this.#text = \"\";\n            this.#deleted = true;\n            return;\n        }\n        this.#text = text;\n        this.#date = /* @__PURE__ */ new Date();\n        this.#deleted = false;\n    }\n    setInitialText(text, richText = null) {\n        this.#initialText = text;\n        this.data = text;\n        this.#date = null;\n        this.#richText = richText;\n    }\n    shown() {}\n    destroy() {\n        this.#commentToolbarButton?.remove();\n        this.#commentToolbarButton = null;\n        this.#commentStandaloneButton?.remove();\n        this.#commentStandaloneButton = null;\n        this.#text = \"\";\n        this.#richText = null;\n        this.#date = null;\n        this.#editor = null;\n        this.#commentWasFromKeyBoard = false;\n        this.#deleted = false;\n    }\n}\nclass TouchManager {\n    #container;\n    #isPinching;\n    #isPinchingStopped;\n    #isPinchingDisabled;\n    #onPinchStart;\n    #onPinching;\n    #onPinchEnd;\n    #pointerDownAC;\n    #signal;\n    #touchInfo;\n    #touchManagerAC;\n    #touchMoveAC;\n    constructor({ container, isPinchingDisabled = null, isPinchingStopped = null, onPinchStart = null, onPinching = null, onPinchEnd = null, signal }){\n        this.#isPinching = false;\n        this.#isPinchingStopped = null;\n        this.#pointerDownAC = null;\n        this.#touchInfo = null;\n        this.#touchMoveAC = null;\n        this.#container = container;\n        this.#isPinchingStopped = isPinchingStopped;\n        this.#isPinchingDisabled = isPinchingDisabled;\n        this.#onPinchStart = onPinchStart;\n        this.#onPinching = onPinching;\n        this.#onPinchEnd = onPinchEnd;\n        this.#touchManagerAC = new AbortController();\n        this.#signal = AbortSignal.any([\n            signal,\n            this.#touchManagerAC.signal\n        ]);\n        container.addEventListener(\"touchstart\", this.#onTouchStart.bind(this), {\n            passive: false,\n            signal: this.#signal\n        });\n    }\n    get MIN_TOUCH_DISTANCE_TO_PINCH() {\n        return 35 / OutputScale.pixelRatio;\n    }\n    #onTouchStart(evt) {\n        if (this.#isPinchingDisabled?.()) {\n            return;\n        }\n        if (evt.touches.length === 1) {\n            if (this.#pointerDownAC) {\n                return;\n            }\n            const pointerDownAC = this.#pointerDownAC = new AbortController();\n            const signal = AbortSignal.any([\n                this.#signal,\n                pointerDownAC.signal\n            ]);\n            const container = this.#container;\n            const opts = {\n                capture: true,\n                signal,\n                passive: false\n            };\n            const cancelPointerDown = (e)=>{\n                if (e.pointerType === \"touch\") {\n                    this.#pointerDownAC?.abort();\n                    this.#pointerDownAC = null;\n                }\n            };\n            container.addEventListener(\"pointerdown\", (e)=>{\n                if (e.pointerType === \"touch\") {\n                    stopEvent(e);\n                    cancelPointerDown(e);\n                }\n            }, opts);\n            container.addEventListener(\"pointerup\", cancelPointerDown, opts);\n            container.addEventListener(\"pointercancel\", cancelPointerDown, opts);\n            return;\n        }\n        if (!this.#touchMoveAC) {\n            this.#touchMoveAC = new AbortController();\n            const signal = AbortSignal.any([\n                this.#signal,\n                this.#touchMoveAC.signal\n            ]);\n            const container = this.#container;\n            const opt = {\n                signal,\n                capture: false,\n                passive: false\n            };\n            container.addEventListener(\"touchmove\", this.#onTouchMove.bind(this), opt);\n            const onTouchEnd = this.#onTouchEnd.bind(this);\n            container.addEventListener(\"touchend\", onTouchEnd, opt);\n            container.addEventListener(\"touchcancel\", onTouchEnd, opt);\n            opt.capture = true;\n            container.addEventListener(\"pointerdown\", stopEvent, opt);\n            container.addEventListener(\"pointermove\", stopEvent, opt);\n            container.addEventListener(\"pointercancel\", stopEvent, opt);\n            container.addEventListener(\"pointerup\", stopEvent, opt);\n            this.#onPinchStart?.();\n        }\n        stopEvent(evt);\n        if (evt.touches.length !== 2 || this.#isPinchingStopped?.()) {\n            this.#touchInfo = null;\n            return;\n        }\n        let [touch0, touch1] = evt.touches;\n        if (touch0.identifier > touch1.identifier) {\n            [touch0, touch1] = [\n                touch1,\n                touch0\n            ];\n        }\n        this.#touchInfo = {\n            touch0X: touch0.screenX,\n            touch0Y: touch0.screenY,\n            touch1X: touch1.screenX,\n            touch1Y: touch1.screenY\n        };\n    }\n    #onTouchMove(evt) {\n        if (!this.#touchInfo || evt.touches.length !== 2) {\n            return;\n        }\n        stopEvent(evt);\n        let [touch0, touch1] = evt.touches;\n        if (touch0.identifier > touch1.identifier) {\n            [touch0, touch1] = [\n                touch1,\n                touch0\n            ];\n        }\n        const { screenX: screen0X, screenY: screen0Y } = touch0;\n        const { screenX: screen1X, screenY: screen1Y } = touch1;\n        const touchInfo = this.#touchInfo;\n        const { touch0X: pTouch0X, touch0Y: pTouch0Y, touch1X: pTouch1X, touch1Y: pTouch1Y } = touchInfo;\n        const prevGapX = pTouch1X - pTouch0X;\n        const prevGapY = pTouch1Y - pTouch0Y;\n        const currGapX = screen1X - screen0X;\n        const currGapY = screen1Y - screen0Y;\n        const distance = Math.hypot(currGapX, currGapY) || 1;\n        const pDistance = Math.hypot(prevGapX, prevGapY) || 1;\n        if (!this.#isPinching && Math.abs(pDistance - distance) <= TouchManager.MIN_TOUCH_DISTANCE_TO_PINCH) {\n            return;\n        }\n        touchInfo.touch0X = screen0X;\n        touchInfo.touch0Y = screen0Y;\n        touchInfo.touch1X = screen1X;\n        touchInfo.touch1Y = screen1Y;\n        if (!this.#isPinching) {\n            this.#isPinching = true;\n            return;\n        }\n        const origin = [\n            (screen0X + screen1X) / 2,\n            (screen0Y + screen1Y) / 2\n        ];\n        this.#onPinching?.(origin, pDistance, distance);\n    }\n    #onTouchEnd(evt) {\n        if (evt.touches.length >= 2) {\n            return;\n        }\n        if (this.#touchMoveAC) {\n            this.#touchMoveAC.abort();\n            this.#touchMoveAC = null;\n            this.#onPinchEnd?.();\n        }\n        if (!this.#touchInfo) {\n            return;\n        }\n        stopEvent(evt);\n        this.#touchInfo = null;\n        this.#isPinching = false;\n    }\n    destroy() {\n        this.#touchManagerAC?.abort();\n        this.#touchManagerAC = null;\n        this.#pointerDownAC?.abort();\n        this.#pointerDownAC = null;\n    }\n}\nclass AnnotationEditor {\n    #accessibilityData;\n    #allResizerDivs;\n    #altText;\n    #comment;\n    #commentStandaloneButton;\n    #disabled;\n    #dragPointerId;\n    #dragPointerType;\n    #resizersDiv;\n    #lastPointerCoords;\n    #savedDimensions;\n    #fakeAnnotation;\n    #focusAC;\n    #focusedResizerName;\n    #hasBeenClicked;\n    #initialRect;\n    #isEditing;\n    #isInEditMode;\n    #isResizerEnabledForKeyboard;\n    #moveInDOMTimeout;\n    #prevDragX;\n    #prevDragY;\n    #telemetryTimeouts;\n    #touchManager;\n    static{\n        this._l10n = null;\n    }\n    static{\n        this._l10nResizer = null;\n    }\n    #isDraggable;\n    #zIndex;\n    static{\n        this._borderLineWidth = -1;\n    }\n    static{\n        this._colorManager = new ColorManager();\n    }\n    static{\n        this._zIndex = 1;\n    }\n    static{\n        this._telemetryTimeout = 1e3;\n    }\n    static get _resizerKeyboardManager() {\n        const resize = AnnotationEditor.prototype._resizeWithKeyboard;\n        const small = AnnotationEditorUIManager.TRANSLATE_SMALL;\n        const big = AnnotationEditorUIManager.TRANSLATE_BIG;\n        return shadow(this, \"_resizerKeyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"ArrowLeft\",\n                    \"mac+ArrowLeft\"\n                ],\n                resize,\n                {\n                    args: [\n                        -small,\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowLeft\",\n                    \"mac+shift+ArrowLeft\"\n                ],\n                resize,\n                {\n                    args: [\n                        -big,\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowRight\",\n                    \"mac+ArrowRight\"\n                ],\n                resize,\n                {\n                    args: [\n                        small,\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowRight\",\n                    \"mac+shift+ArrowRight\"\n                ],\n                resize,\n                {\n                    args: [\n                        big,\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"mac+ArrowUp\"\n                ],\n                resize,\n                {\n                    args: [\n                        0,\n                        -small\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowUp\",\n                    \"mac+shift+ArrowUp\"\n                ],\n                resize,\n                {\n                    args: [\n                        0,\n                        -big\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"mac+ArrowDown\"\n                ],\n                resize,\n                {\n                    args: [\n                        0,\n                        small\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowDown\",\n                    \"mac+shift+ArrowDown\"\n                ],\n                resize,\n                {\n                    args: [\n                        0,\n                        big\n                    ]\n                }\n            ],\n            [\n                [\n                    \"Escape\",\n                    \"mac+Escape\"\n                ],\n                AnnotationEditor.prototype._stopResizingWithKeyboard\n            ]\n        ]));\n    }\n    constructor(parameters){\n        this.#accessibilityData = null;\n        this.#allResizerDivs = null;\n        this.#altText = null;\n        this.#comment = null;\n        this.#commentStandaloneButton = null;\n        this.#disabled = false;\n        this.#dragPointerId = null;\n        this.#dragPointerType = \"\";\n        this.#resizersDiv = null;\n        this.#lastPointerCoords = null;\n        this.#savedDimensions = null;\n        this.#fakeAnnotation = null;\n        this.#focusAC = null;\n        this.#focusedResizerName = \"\";\n        this.#hasBeenClicked = false;\n        this.#initialRect = null;\n        this.#isEditing = false;\n        this.#isInEditMode = false;\n        this.#isResizerEnabledForKeyboard = false;\n        this.#moveInDOMTimeout = null;\n        this.#prevDragX = 0;\n        this.#prevDragY = 0;\n        this.#telemetryTimeouts = null;\n        this.#touchManager = null;\n        this.isSelected = false;\n        this._isCopy = false;\n        this._editToolbar = null;\n        this._initialOptions = /* @__PURE__ */ Object.create(null);\n        this._initialData = null;\n        this._isVisible = true;\n        this._uiManager = null;\n        this._focusEventsAllowed = true;\n        this.#isDraggable = false;\n        this.#zIndex = AnnotationEditor._zIndex++;\n        this.parent = parameters.parent;\n        this.id = parameters.id;\n        this.width = this.height = null;\n        this.pageIndex = parameters.parent.pageIndex;\n        this.name = parameters.name;\n        this.div = null;\n        this._uiManager = parameters.uiManager;\n        this.annotationElementId = null;\n        this._willKeepAspectRatio = false;\n        this._initialOptions.isCentered = parameters.isCentered;\n        this._structTreeParentId = null;\n        this.annotationElementId = parameters.annotationElementId || null;\n        this.creationDate = parameters.creationDate || /* @__PURE__ */ new Date();\n        this.modificationDate = parameters.modificationDate || null;\n        const { rotation, rawDims: { pageWidth, pageHeight, pageX, pageY } } = this.parent.viewport;\n        this.rotation = rotation;\n        this.pageRotation = (360 + rotation - this._uiManager.viewParameters.rotation) % 360;\n        this.pageDimensions = [\n            pageWidth,\n            pageHeight\n        ];\n        this.pageTranslation = [\n            pageX,\n            pageY\n        ];\n        const [width, height] = this.parentDimensions;\n        this.x = parameters.x / width;\n        this.y = parameters.y / height;\n        this.isAttachedToDOM = false;\n        this.deleted = false;\n    }\n    get editorType() {\n        return Object.getPrototypeOf(this).constructor._type;\n    }\n    get mode() {\n        return Object.getPrototypeOf(this).constructor._editorType;\n    }\n    static get isDrawer() {\n        return false;\n    }\n    static get _defaultLineColor() {\n        return shadow(this, \"_defaultLineColor\", this._colorManager.getHexCode(\"CanvasText\"));\n    }\n    static deleteAnnotationElement(editor) {\n        const fakeEditor = new FakeEditor({\n            id: editor.parent.getNextId(),\n            parent: editor.parent,\n            uiManager: editor._uiManager\n        });\n        fakeEditor.annotationElementId = editor.annotationElementId;\n        fakeEditor.deleted = true;\n        fakeEditor._uiManager.addToAnnotationStorage(fakeEditor);\n    }\n    static initialize(l10n, _uiManager) {\n        AnnotationEditor._l10n ??= l10n;\n        AnnotationEditor._l10nResizer ||= Object.freeze({\n            topLeft: \"pdfjs-editor-resizer-top-left\",\n            topMiddle: \"pdfjs-editor-resizer-top-middle\",\n            topRight: \"pdfjs-editor-resizer-top-right\",\n            middleRight: \"pdfjs-editor-resizer-middle-right\",\n            bottomRight: \"pdfjs-editor-resizer-bottom-right\",\n            bottomMiddle: \"pdfjs-editor-resizer-bottom-middle\",\n            bottomLeft: \"pdfjs-editor-resizer-bottom-left\",\n            middleLeft: \"pdfjs-editor-resizer-middle-left\"\n        });\n        if (AnnotationEditor._borderLineWidth !== -1) {\n            return;\n        }\n        const style = getComputedStyle(document.documentElement);\n        AnnotationEditor._borderLineWidth = parseFloat(style.getPropertyValue(\"--outline-width\")) || 0;\n    }\n    static updateDefaultParams(_type, _value) {}\n    static get defaultPropertiesToUpdate() {\n        return [];\n    }\n    static isHandlingMimeForPasting(mime) {\n        return false;\n    }\n    static paste(item, parent) {\n        unreachable(\"Not implemented\");\n    }\n    get propertiesToUpdate() {\n        return [];\n    }\n    get _isDraggable() {\n        return this.#isDraggable;\n    }\n    set _isDraggable(value1) {\n        this.#isDraggable = value1;\n        this.div?.classList.toggle(\"draggable\", value1);\n    }\n    get uid() {\n        return this.annotationElementId || this.id;\n    }\n    get isEnterHandled() {\n        return true;\n    }\n    center() {\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        switch(this.parentRotation){\n            case 90:\n                this.x -= this.height * pageHeight / (pageWidth * 2);\n                this.y += this.width * pageWidth / (pageHeight * 2);\n                break;\n            case 180:\n                this.x += this.width / 2;\n                this.y += this.height / 2;\n                break;\n            case 270:\n                this.x += this.height * pageHeight / (pageWidth * 2);\n                this.y -= this.width * pageWidth / (pageHeight * 2);\n                break;\n            default:\n                this.x -= this.width / 2;\n                this.y -= this.height / 2;\n                break;\n        }\n        this.fixAndSetPosition();\n    }\n    addCommands(params) {\n        this._uiManager.addCommands(params);\n    }\n    get currentLayer() {\n        return this._uiManager.currentLayer;\n    }\n    setInBackground() {\n        this.div.style.zIndex = 0;\n    }\n    setInForeground() {\n        this.div.style.zIndex = this.#zIndex;\n    }\n    setParent(parent) {\n        if (parent !== null) {\n            this.pageIndex = parent.pageIndex;\n            this.pageDimensions = parent.pageDimensions;\n        } else {\n            this.#stopResizing();\n            this.#fakeAnnotation?.remove();\n            this.#fakeAnnotation = null;\n        }\n        this.parent = parent;\n    }\n    focusin(event) {\n        if (!this._focusEventsAllowed) {\n            return;\n        }\n        if (!this.#hasBeenClicked) {\n            this.parent.setSelected(this);\n        } else {\n            this.#hasBeenClicked = false;\n        }\n    }\n    focusout(event) {\n        if (!this._focusEventsAllowed) {\n            return;\n        }\n        if (!this.isAttachedToDOM) {\n            return;\n        }\n        const target = event.relatedTarget;\n        if (target?.closest(`#${this.id}`)) {\n            return;\n        }\n        event.preventDefault();\n        if (!this.parent?.isMultipleSelection) {\n            this.commitOrRemove();\n        }\n    }\n    commitOrRemove() {\n        if (this.isEmpty()) {\n            this.remove();\n        } else {\n            this.commit();\n        }\n    }\n    commit() {\n        if (!this.isInEditMode()) {\n            return;\n        }\n        this.addToAnnotationStorage();\n    }\n    addToAnnotationStorage() {\n        this._uiManager.addToAnnotationStorage(this);\n    }\n    setAt(x, y, tx, ty) {\n        const [width, height] = this.parentDimensions;\n        [tx, ty] = this.screenToPageTranslation(tx, ty);\n        this.x = (x + tx) / width;\n        this.y = (y + ty) / height;\n        this.fixAndSetPosition();\n    }\n    _moveAfterPaste(baseX, baseY) {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);\n        this._onTranslated();\n    }\n    #translate([width, height], x, y) {\n        [x, y] = this.screenToPageTranslation(x, y);\n        this.x += x / width;\n        this.y += y / height;\n        this._onTranslating(this.x, this.y);\n        this.fixAndSetPosition();\n    }\n    translate(x, y) {\n        this.#translate(this.parentDimensions, x, y);\n    }\n    translateInPage(x, y) {\n        this.#initialRect ||= [\n            this.x,\n            this.y,\n            this.width,\n            this.height\n        ];\n        this.#translate(this.pageDimensions, x, y);\n        this.div.scrollIntoView({\n            block: \"nearest\"\n        });\n    }\n    translationDone() {\n        this._onTranslated(this.x, this.y);\n    }\n    drag(tx, ty) {\n        this.#initialRect ||= [\n            this.x,\n            this.y,\n            this.width,\n            this.height\n        ];\n        const { div, parentDimensions: [parentWidth, parentHeight] } = this;\n        this.x += tx / parentWidth;\n        this.y += ty / parentHeight;\n        if (this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {\n            const { x: x2, y: y2 } = this.div.getBoundingClientRect();\n            if (this.parent.findNewParent(this, x2, y2)) {\n                this.x -= Math.floor(this.x);\n                this.y -= Math.floor(this.y);\n            }\n        }\n        let { x, y } = this;\n        const [bx, by] = this.getBaseTranslation();\n        x += bx;\n        y += by;\n        const { style } = div;\n        style.left = `${(100 * x).toFixed(2)}%`;\n        style.top = `${(100 * y).toFixed(2)}%`;\n        this._onTranslating(x, y);\n        div.scrollIntoView({\n            block: \"nearest\"\n        });\n    }\n    _onTranslating(x, y) {}\n    _onTranslated(x, y) {}\n    get _hasBeenMoved() {\n        return !!this.#initialRect && (this.#initialRect[0] !== this.x || this.#initialRect[1] !== this.y);\n    }\n    get _hasBeenResized() {\n        return !!this.#initialRect && (this.#initialRect[2] !== this.width || this.#initialRect[3] !== this.height);\n    }\n    getBaseTranslation() {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        const { _borderLineWidth } = AnnotationEditor;\n        const x = _borderLineWidth / parentWidth;\n        const y = _borderLineWidth / parentHeight;\n        switch(this.rotation){\n            case 90:\n                return [\n                    -x,\n                    y\n                ];\n            case 180:\n                return [\n                    x,\n                    y\n                ];\n            case 270:\n                return [\n                    x,\n                    -y\n                ];\n            default:\n                return [\n                    -x,\n                    -y\n                ];\n        }\n    }\n    get _mustFixPosition() {\n        return true;\n    }\n    fixAndSetPosition(rotation = this.rotation) {\n        const { div: { style }, pageDimensions: [pageWidth, pageHeight] } = this;\n        let { x, y, width, height } = this;\n        width *= pageWidth;\n        height *= pageHeight;\n        x *= pageWidth;\n        y *= pageHeight;\n        if (this._mustFixPosition) {\n            switch(rotation){\n                case 0:\n                    x = MathClamp(x, 0, pageWidth - width);\n                    y = MathClamp(y, 0, pageHeight - height);\n                    break;\n                case 90:\n                    x = MathClamp(x, 0, pageWidth - height);\n                    y = MathClamp(y, width, pageHeight);\n                    break;\n                case 180:\n                    x = MathClamp(x, width, pageWidth);\n                    y = MathClamp(y, height, pageHeight);\n                    break;\n                case 270:\n                    x = MathClamp(x, height, pageWidth);\n                    y = MathClamp(y, 0, pageHeight - width);\n                    break;\n            }\n        }\n        this.x = x /= pageWidth;\n        this.y = y /= pageHeight;\n        const [bx, by] = this.getBaseTranslation();\n        x += bx;\n        y += by;\n        style.left = `${(100 * x).toFixed(2)}%`;\n        style.top = `${(100 * y).toFixed(2)}%`;\n        this.moveInDOM();\n    }\n    static #rotatePoint(x, y, angle) {\n        switch(angle){\n            case 90:\n                return [\n                    y,\n                    -x\n                ];\n            case 180:\n                return [\n                    -x,\n                    -y\n                ];\n            case 270:\n                return [\n                    -y,\n                    x\n                ];\n            default:\n                return [\n                    x,\n                    y\n                ];\n        }\n    }\n    screenToPageTranslation(x, y) {\n        return AnnotationEditor.#rotatePoint(x, y, this.parentRotation);\n    }\n    pageTranslationToScreen(x, y) {\n        return AnnotationEditor.#rotatePoint(x, y, 360 - this.parentRotation);\n    }\n    #getRotationMatrix(rotation) {\n        switch(rotation){\n            case 90:\n                {\n                    const [pageWidth, pageHeight] = this.pageDimensions;\n                    return [\n                        0,\n                        -pageWidth / pageHeight,\n                        pageHeight / pageWidth,\n                        0\n                    ];\n                }\n            case 180:\n                return [\n                    -1,\n                    0,\n                    0,\n                    -1\n                ];\n            case 270:\n                {\n                    const [pageWidth, pageHeight] = this.pageDimensions;\n                    return [\n                        0,\n                        pageWidth / pageHeight,\n                        -pageHeight / pageWidth,\n                        0\n                    ];\n                }\n            default:\n                return [\n                    1,\n                    0,\n                    0,\n                    1\n                ];\n        }\n    }\n    get parentScale() {\n        return this._uiManager.viewParameters.realScale;\n    }\n    get parentRotation() {\n        return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;\n    }\n    get parentDimensions() {\n        const { parentScale, pageDimensions: [pageWidth, pageHeight] } = this;\n        return [\n            pageWidth * parentScale,\n            pageHeight * parentScale\n        ];\n    }\n    setDims() {\n        const { div: { style }, width, height } = this;\n        style.width = `${(100 * width).toFixed(2)}%`;\n        style.height = `${(100 * height).toFixed(2)}%`;\n    }\n    getInitialTranslation() {\n        return [\n            0,\n            0\n        ];\n    }\n    #createResizers() {\n        if (this.#resizersDiv) {\n            return;\n        }\n        this.#resizersDiv = document.createElement(\"div\");\n        this.#resizersDiv.classList.add(\"resizers\");\n        const classes = this._willKeepAspectRatio ? [\n            \"topLeft\",\n            \"topRight\",\n            \"bottomRight\",\n            \"bottomLeft\"\n        ] : [\n            \"topLeft\",\n            \"topMiddle\",\n            \"topRight\",\n            \"middleRight\",\n            \"bottomRight\",\n            \"bottomMiddle\",\n            \"bottomLeft\",\n            \"middleLeft\"\n        ];\n        const signal = this._uiManager._signal;\n        for (const name of classes){\n            const div = document.createElement(\"div\");\n            this.#resizersDiv.append(div);\n            div.classList.add(\"resizer\", name);\n            div.setAttribute(\"data-resizer-name\", name);\n            div.addEventListener(\"pointerdown\", this.#resizerPointerdown.bind(this, name), {\n                signal\n            });\n            div.addEventListener(\"contextmenu\", noContextMenu, {\n                signal\n            });\n            div.tabIndex = -1;\n        }\n        this.div.prepend(this.#resizersDiv);\n    }\n    #resizerPointerdown(name, event) {\n        event.preventDefault();\n        const { isMac } = util_FeatureTest.platform;\n        if (event.button !== 0 || event.ctrlKey && isMac) {\n            return;\n        }\n        this.#altText?.toggle(false);\n        const savedDraggable = this._isDraggable;\n        this._isDraggable = false;\n        this.#lastPointerCoords = [\n            event.screenX,\n            event.screenY\n        ];\n        const ac = new AbortController();\n        const signal = this._uiManager.combinedSignal(ac);\n        this.parent.togglePointerEvents(false);\n        window.addEventListener(\"pointermove\", this.#resizerPointermove.bind(this, name), {\n            passive: true,\n            capture: true,\n            signal\n        });\n        window.addEventListener(\"touchmove\", stopEvent, {\n            passive: false,\n            signal\n        });\n        window.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        this.#savedDimensions = {\n            savedX: this.x,\n            savedY: this.y,\n            savedWidth: this.width,\n            savedHeight: this.height\n        };\n        const savedParentCursor = this.parent.div.style.cursor;\n        const savedCursor = this.div.style.cursor;\n        this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(event.target).cursor;\n        const pointerUpCallback = ()=>{\n            ac.abort();\n            this.parent.togglePointerEvents(true);\n            this.#altText?.toggle(true);\n            this._isDraggable = savedDraggable;\n            this.parent.div.style.cursor = savedParentCursor;\n            this.div.style.cursor = savedCursor;\n            this.#addResizeToUndoStack();\n        };\n        window.addEventListener(\"pointerup\", pointerUpCallback, {\n            signal\n        });\n        window.addEventListener(\"blur\", pointerUpCallback, {\n            signal\n        });\n    }\n    #resize(x, y, width, height) {\n        this.width = width;\n        this.height = height;\n        this.x = x;\n        this.y = y;\n        this.setDims();\n        this.fixAndSetPosition();\n        this._onResized();\n    }\n    _onResized() {}\n    #addResizeToUndoStack() {\n        if (!this.#savedDimensions) {\n            return;\n        }\n        const { savedX, savedY, savedWidth, savedHeight } = this.#savedDimensions;\n        this.#savedDimensions = null;\n        const newX = this.x;\n        const newY = this.y;\n        const newWidth = this.width;\n        const newHeight = this.height;\n        if (newX === savedX && newY === savedY && newWidth === savedWidth && newHeight === savedHeight) {\n            return;\n        }\n        this.addCommands({\n            cmd: this.#resize.bind(this, newX, newY, newWidth, newHeight),\n            undo: this.#resize.bind(this, savedX, savedY, savedWidth, savedHeight),\n            mustExec: true\n        });\n    }\n    static _round(x) {\n        return Math.round(x * 1e4) / 1e4;\n    }\n    #resizerPointermove(name, event) {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        const savedX = this.x;\n        const savedY = this.y;\n        const savedWidth = this.width;\n        const savedHeight = this.height;\n        const minWidth = AnnotationEditor.MIN_SIZE / parentWidth;\n        const minHeight = AnnotationEditor.MIN_SIZE / parentHeight;\n        const rotationMatrix = this.#getRotationMatrix(this.rotation);\n        const transf = (x, y)=>[\n                rotationMatrix[0] * x + rotationMatrix[2] * y,\n                rotationMatrix[1] * x + rotationMatrix[3] * y\n            ];\n        const invRotationMatrix = this.#getRotationMatrix(360 - this.rotation);\n        const invTransf = (x, y)=>[\n                invRotationMatrix[0] * x + invRotationMatrix[2] * y,\n                invRotationMatrix[1] * x + invRotationMatrix[3] * y\n            ];\n        let getPoint;\n        let getOpposite;\n        let isDiagonal = false;\n        let isHorizontal = false;\n        switch(name){\n            case \"topLeft\":\n                isDiagonal = true;\n                getPoint = (w, h)=>[\n                        0,\n                        0\n                    ];\n                getOpposite = (w, h)=>[\n                        w,\n                        h\n                    ];\n                break;\n            case \"topMiddle\":\n                getPoint = (w, h)=>[\n                        w / 2,\n                        0\n                    ];\n                getOpposite = (w, h)=>[\n                        w / 2,\n                        h\n                    ];\n                break;\n            case \"topRight\":\n                isDiagonal = true;\n                getPoint = (w, h)=>[\n                        w,\n                        0\n                    ];\n                getOpposite = (w, h)=>[\n                        0,\n                        h\n                    ];\n                break;\n            case \"middleRight\":\n                isHorizontal = true;\n                getPoint = (w, h)=>[\n                        w,\n                        h / 2\n                    ];\n                getOpposite = (w, h)=>[\n                        0,\n                        h / 2\n                    ];\n                break;\n            case \"bottomRight\":\n                isDiagonal = true;\n                getPoint = (w, h)=>[\n                        w,\n                        h\n                    ];\n                getOpposite = (w, h)=>[\n                        0,\n                        0\n                    ];\n                break;\n            case \"bottomMiddle\":\n                getPoint = (w, h)=>[\n                        w / 2,\n                        h\n                    ];\n                getOpposite = (w, h)=>[\n                        w / 2,\n                        0\n                    ];\n                break;\n            case \"bottomLeft\":\n                isDiagonal = true;\n                getPoint = (w, h)=>[\n                        0,\n                        h\n                    ];\n                getOpposite = (w, h)=>[\n                        w,\n                        0\n                    ];\n                break;\n            case \"middleLeft\":\n                isHorizontal = true;\n                getPoint = (w, h)=>[\n                        0,\n                        h / 2\n                    ];\n                getOpposite = (w, h)=>[\n                        w,\n                        h / 2\n                    ];\n                break;\n        }\n        const point = getPoint(savedWidth, savedHeight);\n        const oppositePoint = getOpposite(savedWidth, savedHeight);\n        let transfOppositePoint = transf(...oppositePoint);\n        const oppositeX = AnnotationEditor._round(savedX + transfOppositePoint[0]);\n        const oppositeY = AnnotationEditor._round(savedY + transfOppositePoint[1]);\n        let ratioX = 1;\n        let ratioY = 1;\n        let deltaX, deltaY;\n        if (!event.fromKeyboard) {\n            const { screenX, screenY } = event;\n            const [lastScreenX, lastScreenY] = this.#lastPointerCoords;\n            [deltaX, deltaY] = this.screenToPageTranslation(screenX - lastScreenX, screenY - lastScreenY);\n            this.#lastPointerCoords[0] = screenX;\n            this.#lastPointerCoords[1] = screenY;\n        } else {\n            ({ deltaX, deltaY } = event);\n        }\n        [deltaX, deltaY] = invTransf(deltaX / parentWidth, deltaY / parentHeight);\n        if (isDiagonal) {\n            const oldDiag = Math.hypot(savedWidth, savedHeight);\n            ratioX = ratioY = Math.max(Math.min(Math.hypot(oppositePoint[0] - point[0] - deltaX, oppositePoint[1] - point[1] - deltaY) / oldDiag, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);\n        } else if (isHorizontal) {\n            ratioX = MathClamp(Math.abs(oppositePoint[0] - point[0] - deltaX), minWidth, 1) / savedWidth;\n        } else {\n            ratioY = MathClamp(Math.abs(oppositePoint[1] - point[1] - deltaY), minHeight, 1) / savedHeight;\n        }\n        const newWidth = AnnotationEditor._round(savedWidth * ratioX);\n        const newHeight = AnnotationEditor._round(savedHeight * ratioY);\n        transfOppositePoint = transf(...getOpposite(newWidth, newHeight));\n        const newX = oppositeX - transfOppositePoint[0];\n        const newY = oppositeY - transfOppositePoint[1];\n        this.#initialRect ||= [\n            this.x,\n            this.y,\n            this.width,\n            this.height\n        ];\n        this.width = newWidth;\n        this.height = newHeight;\n        this.x = newX;\n        this.y = newY;\n        this.setDims();\n        this.fixAndSetPosition();\n        this._onResizing();\n    }\n    _onResizing() {}\n    altTextFinish() {\n        this.#altText?.finish();\n    }\n    get toolbarButtons() {\n        return null;\n    }\n    async addEditToolbar() {\n        if (this._editToolbar || this.#isInEditMode) {\n            return this._editToolbar;\n        }\n        this._editToolbar = new EditorToolbar(this);\n        this.div.append(this._editToolbar.render());\n        const { toolbarButtons } = this;\n        if (toolbarButtons) {\n            for (const [name, tool] of toolbarButtons){\n                await this._editToolbar.addButton(name, tool);\n            }\n        }\n        if (!this.hasComment) {\n            this._editToolbar.addButton(\"comment\", this.addCommentButton());\n        }\n        this._editToolbar.addButton(\"delete\");\n        return this._editToolbar;\n    }\n    addCommentButtonInToolbar() {\n        this._editToolbar?.addButtonBefore(\"comment\", this.addCommentButton(), \".deleteButton\");\n    }\n    removeCommentButtonFromToolbar() {\n        this._editToolbar?.removeButton(\"comment\");\n    }\n    removeEditToolbar() {\n        this._editToolbar?.remove();\n        this._editToolbar = null;\n        this.#altText?.destroy();\n    }\n    addContainer(container) {\n        const editToolbarDiv = this._editToolbar?.div;\n        if (editToolbarDiv) {\n            editToolbarDiv.before(container);\n        } else {\n            this.div.append(container);\n        }\n    }\n    getClientDimensions() {\n        return this.div.getBoundingClientRect();\n    }\n    createAltText() {\n        if (!this.#altText) {\n            AltText.initialize(AnnotationEditor._l10n);\n            this.#altText = new AltText(this);\n            if (this.#accessibilityData) {\n                this.#altText.data = this.#accessibilityData;\n                this.#accessibilityData = null;\n            }\n        }\n        return this.#altText;\n    }\n    get altTextData() {\n        return this.#altText?.data;\n    }\n    set altTextData(data) {\n        if (!this.#altText) {\n            return;\n        }\n        this.#altText.data = data;\n    }\n    get guessedAltText() {\n        return this.#altText?.guessedText;\n    }\n    async setGuessedAltText(text) {\n        await this.#altText?.setGuessedText(text);\n    }\n    serializeAltText(isForCopying) {\n        return this.#altText?.serialize(isForCopying);\n    }\n    hasAltText() {\n        return !!this.#altText && !this.#altText.isEmpty();\n    }\n    hasAltTextData() {\n        return this.#altText?.hasData() ?? false;\n    }\n    focusCommentButton() {\n        this.#comment?.focusButton();\n    }\n    addCommentButton() {\n        return this.#comment ||= new Comment(this);\n    }\n    addStandaloneCommentButton() {\n        if (this.#commentStandaloneButton) {\n            if (this._uiManager.isEditingMode()) {\n                this.#commentStandaloneButton.classList.remove(\"hidden\");\n            }\n            return;\n        }\n        if (!this.hasComment) {\n            return;\n        }\n        this.#commentStandaloneButton = this.#comment.renderForStandalone();\n        this.div.append(this.#commentStandaloneButton);\n    }\n    removeStandaloneCommentButton() {\n        this.#comment.removeStandaloneCommentButton();\n        this.#commentStandaloneButton = null;\n    }\n    hideStandaloneCommentButton() {\n        this.#commentStandaloneButton?.classList.add(\"hidden\");\n    }\n    get comment() {\n        const { data: { richText, text, date, deleted } } = this.#comment;\n        return {\n            text,\n            richText,\n            date,\n            deleted,\n            color: this.getNonHCMColor(),\n            opacity: this.opacity ?? 1\n        };\n    }\n    set comment(text) {\n        this.#comment ||= new Comment(this);\n        this.#comment.data = text;\n        if (this.hasComment) {\n            this.removeCommentButtonFromToolbar();\n            this.addStandaloneCommentButton();\n            this._uiManager.updateComment(this);\n        } else {\n            this.addCommentButtonInToolbar();\n            this.removeStandaloneCommentButton();\n            this._uiManager.removeComment(this);\n        }\n    }\n    setCommentData({ comment, popupRef, richText }) {\n        if (!popupRef) {\n            return;\n        }\n        this.#comment ||= new Comment(this);\n        this.#comment.setInitialText(comment, richText);\n        if (!this.annotationElementId) {\n            return;\n        }\n        const storedData = this._uiManager.getAndRemoveDataFromAnnotationStorage(this.annotationElementId);\n        if (storedData) {\n            this.updateFromAnnotationLayer(storedData);\n        }\n    }\n    get hasEditedComment() {\n        return this.#comment?.hasBeenEdited();\n    }\n    get hasDeletedComment() {\n        return this.#comment?.isDeleted();\n    }\n    get hasComment() {\n        return !!this.#comment && !this.#comment.isEmpty() && !this.#comment.isDeleted();\n    }\n    async editComment(options) {\n        this.#comment ||= new Comment(this);\n        this.#comment.edit(options);\n    }\n    toggleComment(isSelected, visibility = void 0) {\n        if (this.hasComment) {\n            this._uiManager.toggleComment(this, isSelected, visibility);\n        }\n    }\n    setSelectedCommentButton(selected) {\n        this.#comment.setSelectedButton(selected);\n    }\n    addComment(serialized) {\n        if (this.hasEditedComment) {\n            const DEFAULT_POPUP_WIDTH = 180;\n            const DEFAULT_POPUP_HEIGHT = 100;\n            const [, , , trY] = serialized.rect;\n            const [pageWidth] = this.pageDimensions;\n            const [pageX] = this.pageTranslation;\n            const blX = pageX + pageWidth + 1;\n            const blY = trY - DEFAULT_POPUP_HEIGHT;\n            const trX = blX + DEFAULT_POPUP_WIDTH;\n            serialized.popup = {\n                contents: this.comment.text,\n                deleted: this.comment.deleted,\n                rect: [\n                    blX,\n                    blY,\n                    trX,\n                    trY\n                ]\n            };\n        }\n    }\n    updateFromAnnotationLayer({ popup: { contents, deleted } }) {\n        this.#comment.data = deleted ? null : contents;\n    }\n    get parentBoundingClientRect() {\n        return this.parent.boundingClientRect;\n    }\n    render() {\n        const div = this.div = document.createElement(\"div\");\n        div.setAttribute(\"data-editor-rotation\", (360 - this.rotation) % 360);\n        div.className = this.name;\n        div.setAttribute(\"id\", this.id);\n        div.tabIndex = this.#disabled ? -1 : 0;\n        div.setAttribute(\"role\", \"application\");\n        if (this.defaultL10nId) {\n            div.setAttribute(\"data-l10n-id\", this.defaultL10nId);\n        }\n        if (!this._isVisible) {\n            div.classList.add(\"hidden\");\n        }\n        this.setInForeground();\n        this.#addFocusListeners();\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        if (this.parentRotation % 180 !== 0) {\n            div.style.maxWidth = `${(100 * parentHeight / parentWidth).toFixed(2)}%`;\n            div.style.maxHeight = `${(100 * parentWidth / parentHeight).toFixed(2)}%`;\n        }\n        const [tx, ty] = this.getInitialTranslation();\n        this.translate(tx, ty);\n        bindEvents(this, div, [\n            \"keydown\",\n            \"pointerdown\",\n            \"dblclick\"\n        ]);\n        if (this.isResizable && this._uiManager._supportsPinchToZoom) {\n            this.#touchManager ||= new TouchManager({\n                container: div,\n                isPinchingDisabled: ()=>!this.isSelected,\n                onPinchStart: this.#touchPinchStartCallback.bind(this),\n                onPinching: this.#touchPinchCallback.bind(this),\n                onPinchEnd: this.#touchPinchEndCallback.bind(this),\n                signal: this._uiManager._signal\n            });\n        }\n        this.addStandaloneCommentButton();\n        this._uiManager._editorUndoBar?.hide();\n        return div;\n    }\n    #touchPinchStartCallback() {\n        this.#savedDimensions = {\n            savedX: this.x,\n            savedY: this.y,\n            savedWidth: this.width,\n            savedHeight: this.height\n        };\n        this.#altText?.toggle(false);\n        this.parent.togglePointerEvents(false);\n    }\n    #touchPinchCallback(_origin, prevDistance, distance) {\n        const slowDownFactor = 0.7;\n        let factor = slowDownFactor * (distance / prevDistance) + 1 - slowDownFactor;\n        if (factor === 1) {\n            return;\n        }\n        const rotationMatrix = this.#getRotationMatrix(this.rotation);\n        const transf = (x, y)=>[\n                rotationMatrix[0] * x + rotationMatrix[2] * y,\n                rotationMatrix[1] * x + rotationMatrix[3] * y\n            ];\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        const savedX = this.x;\n        const savedY = this.y;\n        const savedWidth = this.width;\n        const savedHeight = this.height;\n        const minWidth = AnnotationEditor.MIN_SIZE / parentWidth;\n        const minHeight = AnnotationEditor.MIN_SIZE / parentHeight;\n        factor = Math.max(Math.min(factor, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);\n        const newWidth = AnnotationEditor._round(savedWidth * factor);\n        const newHeight = AnnotationEditor._round(savedHeight * factor);\n        if (newWidth === savedWidth && newHeight === savedHeight) {\n            return;\n        }\n        this.#initialRect ||= [\n            savedX,\n            savedY,\n            savedWidth,\n            savedHeight\n        ];\n        const transfCenterPoint = transf(savedWidth / 2, savedHeight / 2);\n        const centerX = AnnotationEditor._round(savedX + transfCenterPoint[0]);\n        const centerY = AnnotationEditor._round(savedY + transfCenterPoint[1]);\n        const newTransfCenterPoint = transf(newWidth / 2, newHeight / 2);\n        this.x = centerX - newTransfCenterPoint[0];\n        this.y = centerY - newTransfCenterPoint[1];\n        this.width = newWidth;\n        this.height = newHeight;\n        this.setDims();\n        this.fixAndSetPosition();\n        this._onResizing();\n    }\n    #touchPinchEndCallback() {\n        this.#altText?.toggle(true);\n        this.parent.togglePointerEvents(true);\n        this.#addResizeToUndoStack();\n    }\n    pointerdown(event) {\n        const { isMac } = util_FeatureTest.platform;\n        if (event.button !== 0 || event.ctrlKey && isMac) {\n            event.preventDefault();\n            return;\n        }\n        this.#hasBeenClicked = true;\n        if (this._isDraggable) {\n            this.#setUpDragSession(event);\n            return;\n        }\n        this.#selectOnPointerEvent(event);\n    }\n    #selectOnPointerEvent(event) {\n        const { isMac } = util_FeatureTest.platform;\n        if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) {\n            this.parent.toggleSelected(this);\n        } else {\n            this.parent.setSelected(this);\n        }\n    }\n    #setUpDragSession(event) {\n        const { isSelected } = this;\n        this._uiManager.setUpDragSession();\n        let hasDraggingStarted = false;\n        const ac = new AbortController();\n        const signal = this._uiManager.combinedSignal(ac);\n        const opts = {\n            capture: true,\n            passive: false,\n            signal\n        };\n        const cancelDrag = (e)=>{\n            ac.abort();\n            this.#dragPointerId = null;\n            this.#hasBeenClicked = false;\n            if (!this._uiManager.endDragSession()) {\n                this.#selectOnPointerEvent(e);\n            }\n            if (hasDraggingStarted) {\n                this._onStopDragging();\n            }\n        };\n        if (isSelected) {\n            this.#prevDragX = event.clientX;\n            this.#prevDragY = event.clientY;\n            this.#dragPointerId = event.pointerId;\n            this.#dragPointerType = event.pointerType;\n            window.addEventListener(\"pointermove\", (e)=>{\n                if (!hasDraggingStarted) {\n                    hasDraggingStarted = true;\n                    this._uiManager.toggleComment(this, true, false);\n                    this._onStartDragging();\n                }\n                const { clientX: x, clientY: y, pointerId } = e;\n                if (pointerId !== this.#dragPointerId) {\n                    stopEvent(e);\n                    return;\n                }\n                const [tx, ty] = this.screenToPageTranslation(x - this.#prevDragX, y - this.#prevDragY);\n                this.#prevDragX = x;\n                this.#prevDragY = y;\n                this._uiManager.dragSelectedEditors(tx, ty);\n            }, opts);\n            window.addEventListener(\"touchmove\", stopEvent, opts);\n            window.addEventListener(\"pointerdown\", (e)=>{\n                if (e.pointerType === this.#dragPointerType) {\n                    if (this.#touchManager || e.isPrimary) {\n                        cancelDrag(e);\n                    }\n                }\n                stopEvent(e);\n            }, opts);\n        }\n        const pointerUpCallback = (e)=>{\n            if (!this.#dragPointerId || this.#dragPointerId === e.pointerId) {\n                cancelDrag(e);\n                return;\n            }\n            stopEvent(e);\n        };\n        window.addEventListener(\"pointerup\", pointerUpCallback, {\n            signal\n        });\n        window.addEventListener(\"blur\", pointerUpCallback, {\n            signal\n        });\n    }\n    _onStartDragging() {}\n    _onStopDragging() {}\n    moveInDOM() {\n        if (this.#moveInDOMTimeout) {\n            clearTimeout(this.#moveInDOMTimeout);\n        }\n        this.#moveInDOMTimeout = setTimeout(()=>{\n            this.#moveInDOMTimeout = null;\n            this.parent?.moveEditorInDOM(this);\n        }, 0);\n    }\n    _setParentAndPosition(parent, x, y) {\n        parent.changeParent(this);\n        this.x = x;\n        this.y = y;\n        this.fixAndSetPosition();\n        this._onTranslated();\n    }\n    getRect(tx, ty, rotation = this.rotation) {\n        const scale = this.parentScale;\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        const [pageX, pageY] = this.pageTranslation;\n        const shiftX = tx / scale;\n        const shiftY = ty / scale;\n        const x = this.x * pageWidth;\n        const y = this.y * pageHeight;\n        const width = this.width * pageWidth;\n        const height = this.height * pageHeight;\n        switch(rotation){\n            case 0:\n                return [\n                    x + shiftX + pageX,\n                    pageHeight - y - shiftY - height + pageY,\n                    x + shiftX + width + pageX,\n                    pageHeight - y - shiftY + pageY\n                ];\n            case 90:\n                return [\n                    x + shiftY + pageX,\n                    pageHeight - y + shiftX + pageY,\n                    x + shiftY + height + pageX,\n                    pageHeight - y + shiftX + width + pageY\n                ];\n            case 180:\n                return [\n                    x - shiftX - width + pageX,\n                    pageHeight - y + shiftY + pageY,\n                    x - shiftX + pageX,\n                    pageHeight - y + shiftY + height + pageY\n                ];\n            case 270:\n                return [\n                    x - shiftY - height + pageX,\n                    pageHeight - y - shiftX - width + pageY,\n                    x - shiftY + pageX,\n                    pageHeight - y - shiftX + pageY\n                ];\n            default:\n                throw new Error(\"Invalid rotation\");\n        }\n    }\n    getRectInCurrentCoords(rect, pageHeight) {\n        const [x1, y1, x2, y2] = rect;\n        const width = x2 - x1;\n        const height = y2 - y1;\n        switch(this.rotation){\n            case 0:\n                return [\n                    x1,\n                    pageHeight - y2,\n                    width,\n                    height\n                ];\n            case 90:\n                return [\n                    x1,\n                    pageHeight - y1,\n                    height,\n                    width\n                ];\n            case 180:\n                return [\n                    x2,\n                    pageHeight - y1,\n                    width,\n                    height\n                ];\n            case 270:\n                return [\n                    x2,\n                    pageHeight - y2,\n                    height,\n                    width\n                ];\n            default:\n                throw new Error(\"Invalid rotation\");\n        }\n    }\n    getPDFRect() {\n        return this.getRect(0, 0);\n    }\n    getNonHCMColor() {\n        return this.color && AnnotationEditor._colorManager.convert(this._uiManager.getNonHCMColor(this.color));\n    }\n    onUpdatedColor() {\n        this.#comment?.onUpdatedColor();\n    }\n    getData() {\n        const { comment: { text: str, color, date, opacity, deleted, richText }, uid: id, pageIndex, creationDate, modificationDate } = this;\n        return {\n            id,\n            pageIndex,\n            rect: this.getPDFRect(),\n            richText,\n            contentsObj: {\n                str\n            },\n            creationDate,\n            modificationDate: date || modificationDate,\n            popupRef: !deleted,\n            color,\n            opacity\n        };\n    }\n    onceAdded(focus) {}\n    isEmpty() {\n        return false;\n    }\n    enableEditMode() {\n        if (this.isInEditMode()) {\n            return false;\n        }\n        this.parent.setEditingState(false);\n        this.#isInEditMode = true;\n        return true;\n    }\n    disableEditMode() {\n        if (!this.isInEditMode()) {\n            return false;\n        }\n        this.parent.setEditingState(true);\n        this.#isInEditMode = false;\n        return true;\n    }\n    isInEditMode() {\n        return this.#isInEditMode;\n    }\n    shouldGetKeyboardEvents() {\n        return this.#isResizerEnabledForKeyboard;\n    }\n    needsToBeRebuilt() {\n        return this.div && !this.isAttachedToDOM;\n    }\n    get isOnScreen() {\n        const { top, left, bottom, right } = this.getClientDimensions();\n        const { innerHeight, innerWidth } = window;\n        return left < innerWidth && right > 0 && top < innerHeight && bottom > 0;\n    }\n    #addFocusListeners() {\n        if (this.#focusAC || !this.div) {\n            return;\n        }\n        this.#focusAC = new AbortController();\n        const signal = this._uiManager.combinedSignal(this.#focusAC);\n        this.div.addEventListener(\"focusin\", this.focusin.bind(this), {\n            signal\n        });\n        this.div.addEventListener(\"focusout\", this.focusout.bind(this), {\n            signal\n        });\n    }\n    rebuild() {\n        this.#addFocusListeners();\n    }\n    rotate(_angle) {}\n    resize() {}\n    serializeDeleted() {\n        return {\n            id: this.annotationElementId,\n            deleted: true,\n            pageIndex: this.pageIndex,\n            popupRef: this._initialData?.popupRef || \"\"\n        };\n    }\n    serialize(isForCopying = false, context = null) {\n        return {\n            annotationType: this.mode,\n            pageIndex: this.pageIndex,\n            rect: this.getPDFRect(),\n            rotation: this.rotation,\n            structTreeParentId: this._structTreeParentId,\n            popupRef: this._initialData?.popupRef || \"\"\n        };\n    }\n    static async deserialize(data, parent, uiManager) {\n        const editor = new this.prototype.constructor({\n            parent,\n            id: parent.getNextId(),\n            uiManager,\n            annotationElementId: data.annotationElementId,\n            creationDate: data.creationDate,\n            modificationDate: data.modificationDate\n        });\n        editor.rotation = data.rotation;\n        editor.#accessibilityData = data.accessibilityData;\n        editor._isCopy = data.isCopy || false;\n        const [pageWidth, pageHeight] = editor.pageDimensions;\n        const [x, y, width, height] = editor.getRectInCurrentCoords(data.rect, pageHeight);\n        editor.x = x / pageWidth;\n        editor.y = y / pageHeight;\n        editor.width = width / pageWidth;\n        editor.height = height / pageHeight;\n        return editor;\n    }\n    get hasBeenModified() {\n        return !!this.annotationElementId && (this.deleted || this.serialize() !== null);\n    }\n    remove() {\n        this.#focusAC?.abort();\n        this.#focusAC = null;\n        if (!this.isEmpty()) {\n            this.commit();\n        }\n        if (this.parent) {\n            this.parent.remove(this);\n        } else {\n            this._uiManager.removeEditor(this);\n        }\n        if (this.#moveInDOMTimeout) {\n            clearTimeout(this.#moveInDOMTimeout);\n            this.#moveInDOMTimeout = null;\n        }\n        this.#stopResizing();\n        this.removeEditToolbar();\n        if (this.#telemetryTimeouts) {\n            for (const timeout of this.#telemetryTimeouts.values()){\n                clearTimeout(timeout);\n            }\n            this.#telemetryTimeouts = null;\n        }\n        this.parent = null;\n        this.#touchManager?.destroy();\n        this.#touchManager = null;\n    }\n    get isResizable() {\n        return false;\n    }\n    makeResizable() {\n        if (this.isResizable) {\n            this.#createResizers();\n            this.#resizersDiv.classList.remove(\"hidden\");\n        }\n    }\n    get toolbarPosition() {\n        return null;\n    }\n    get commentButtonPosition() {\n        return this._uiManager.direction === \"ltr\" ? [\n            1,\n            0\n        ] : [\n            0,\n            0\n        ];\n    }\n    get commentButtonPositionInPage() {\n        const { commentButtonPosition: [posX, posY] } = this;\n        const [blX, blY, trX, trY] = this.getPDFRect();\n        return [\n            AnnotationEditor._round(blX + (trX - blX) * posX),\n            AnnotationEditor._round(blY + (trY - blY) * (1 - posY))\n        ];\n    }\n    get commentButtonColor() {\n        return this._uiManager.makeCommentColor(this.getNonHCMColor(), this.opacity);\n    }\n    get commentPopupPosition() {\n        return this.#comment.commentPopupPositionInLayer;\n    }\n    set commentPopupPosition(pos) {\n        this.#comment.commentPopupPositionInLayer = pos;\n    }\n    hasDefaultPopupPosition() {\n        return this.#comment.hasDefaultPopupPosition();\n    }\n    get commentButtonWidth() {\n        return this.#comment.commentButtonWidth;\n    }\n    get elementBeforePopup() {\n        return this.div;\n    }\n    setCommentButtonStates(options) {\n        this.#comment.setCommentButtonStates(options);\n    }\n    keydown(event) {\n        if (!this.isResizable || event.target !== this.div || event.key !== \"Enter\") {\n            return;\n        }\n        this._uiManager.setSelected(this);\n        this.#savedDimensions = {\n            savedX: this.x,\n            savedY: this.y,\n            savedWidth: this.width,\n            savedHeight: this.height\n        };\n        const children = this.#resizersDiv.children;\n        if (!this.#allResizerDivs) {\n            this.#allResizerDivs = Array.from(children);\n            const boundResizerKeydown = this.#resizerKeydown.bind(this);\n            const boundResizerBlur = this.#resizerBlur.bind(this);\n            const signal = this._uiManager._signal;\n            for (const div of this.#allResizerDivs){\n                const name = div.getAttribute(\"data-resizer-name\");\n                div.setAttribute(\"role\", \"spinbutton\");\n                div.addEventListener(\"keydown\", boundResizerKeydown, {\n                    signal\n                });\n                div.addEventListener(\"blur\", boundResizerBlur, {\n                    signal\n                });\n                div.addEventListener(\"focus\", this.#resizerFocus.bind(this, name), {\n                    signal\n                });\n                div.setAttribute(\"data-l10n-id\", AnnotationEditor._l10nResizer[name]);\n            }\n        }\n        const first = this.#allResizerDivs[0];\n        let firstPosition = 0;\n        for (const div of children){\n            if (div === first) {\n                break;\n            }\n            firstPosition++;\n        }\n        const nextFirstPosition = (360 - this.rotation + this.parentRotation) % 360 / 90 * (this.#allResizerDivs.length / 4);\n        if (nextFirstPosition !== firstPosition) {\n            if (nextFirstPosition < firstPosition) {\n                for(let i2 = 0; i2 < firstPosition - nextFirstPosition; i2++){\n                    this.#resizersDiv.append(this.#resizersDiv.firstChild);\n                }\n            } else if (nextFirstPosition > firstPosition) {\n                for(let i2 = 0; i2 < nextFirstPosition - firstPosition; i2++){\n                    this.#resizersDiv.firstChild.before(this.#resizersDiv.lastChild);\n                }\n            }\n            let i = 0;\n            for (const child of children){\n                const div = this.#allResizerDivs[i++];\n                const name = div.getAttribute(\"data-resizer-name\");\n                child.setAttribute(\"data-l10n-id\", AnnotationEditor._l10nResizer[name]);\n            }\n        }\n        this.#setResizerTabIndex(0);\n        this.#isResizerEnabledForKeyboard = true;\n        this.#resizersDiv.firstChild.focus({\n            focusVisible: true\n        });\n        event.preventDefault();\n        event.stopImmediatePropagation();\n    }\n    #resizerKeydown(event) {\n        AnnotationEditor._resizerKeyboardManager.exec(this, event);\n    }\n    #resizerBlur(event) {\n        if (this.#isResizerEnabledForKeyboard && event.relatedTarget?.parentNode !== this.#resizersDiv) {\n            this.#stopResizing();\n        }\n    }\n    #resizerFocus(name) {\n        this.#focusedResizerName = this.#isResizerEnabledForKeyboard ? name : \"\";\n    }\n    #setResizerTabIndex(value1) {\n        if (!this.#allResizerDivs) {\n            return;\n        }\n        for (const div of this.#allResizerDivs){\n            div.tabIndex = value1;\n        }\n    }\n    _resizeWithKeyboard(x, y) {\n        if (!this.#isResizerEnabledForKeyboard) {\n            return;\n        }\n        this.#resizerPointermove(this.#focusedResizerName, {\n            deltaX: x,\n            deltaY: y,\n            fromKeyboard: true\n        });\n    }\n    #stopResizing() {\n        this.#isResizerEnabledForKeyboard = false;\n        this.#setResizerTabIndex(-1);\n        this.#addResizeToUndoStack();\n    }\n    _stopResizingWithKeyboard() {\n        this.#stopResizing();\n        this.div.focus();\n    }\n    select() {\n        if (this.isSelected && this._editToolbar) {\n            this._editToolbar.show();\n            return;\n        }\n        this.isSelected = true;\n        this.makeResizable();\n        this.div?.classList.add(\"selectedEditor\");\n        if (!this._editToolbar) {\n            this.addEditToolbar().then(()=>{\n                if (this.div?.classList.contains(\"selectedEditor\")) {\n                    this._editToolbar?.show();\n                }\n            });\n            return;\n        }\n        this._editToolbar?.show();\n        this.#altText?.toggleAltTextBadge(false);\n    }\n    focus() {\n        if (this.div && !this.div.contains(document.activeElement)) {\n            setTimeout(()=>this.div?.focus({\n                    preventScroll: true\n                }), 0);\n        }\n    }\n    unselect() {\n        if (!this.isSelected) {\n            return;\n        }\n        this.isSelected = false;\n        this.#resizersDiv?.classList.add(\"hidden\");\n        this.div?.classList.remove(\"selectedEditor\");\n        if (this.div?.contains(document.activeElement)) {\n            this._uiManager.currentLayer.div.focus({\n                preventScroll: true\n            });\n        }\n        this._editToolbar?.hide();\n        this.#altText?.toggleAltTextBadge(true);\n        if (this.hasComment) {\n            this._uiManager.toggleComment(this, false, false);\n        }\n    }\n    updateParams(type, value1) {}\n    disableEditing() {}\n    enableEditing() {}\n    get canChangeContent() {\n        return false;\n    }\n    enterInEditMode() {\n        if (!this.canChangeContent) {\n            return;\n        }\n        this.enableEditMode();\n        this.div.focus();\n    }\n    dblclick(event) {\n        if (event.target.nodeName === \"BUTTON\") {\n            return;\n        }\n        this.enterInEditMode();\n        this.parent.updateToolbar({\n            mode: this.constructor._editorType,\n            editId: this.id\n        });\n    }\n    getElementForAltText() {\n        return this.div;\n    }\n    get contentDiv() {\n        return this.div;\n    }\n    get isEditing() {\n        return this.#isEditing;\n    }\n    set isEditing(value1) {\n        this.#isEditing = value1;\n        if (!this.parent) {\n            return;\n        }\n        if (value1) {\n            this.parent.setSelected(this);\n            this.parent.setActiveEditor(this);\n        } else {\n            this.parent.setActiveEditor(null);\n        }\n    }\n    static get MIN_SIZE() {\n        return 16;\n    }\n    static canCreateNewEmptyEditor() {\n        return true;\n    }\n    get telemetryInitialData() {\n        return {\n            action: \"added\"\n        };\n    }\n    get telemetryFinalData() {\n        return null;\n    }\n    _reportTelemetry(data, mustWait = false) {\n        if (mustWait) {\n            this.#telemetryTimeouts ||= /* @__PURE__ */ new Map();\n            const { action } = data;\n            let timeout = this.#telemetryTimeouts.get(action);\n            if (timeout) {\n                clearTimeout(timeout);\n            }\n            timeout = setTimeout(()=>{\n                this._reportTelemetry(data);\n                this.#telemetryTimeouts.delete(action);\n                if (this.#telemetryTimeouts.size === 0) {\n                    this.#telemetryTimeouts = null;\n                }\n            }, AnnotationEditor._telemetryTimeout);\n            this.#telemetryTimeouts.set(action, timeout);\n            return;\n        }\n        data.type ||= this.editorType;\n        this._uiManager._eventBus.dispatch(\"reporttelemetry\", {\n            source: this,\n            details: {\n                type: \"editing\",\n                data\n            }\n        });\n    }\n    show(visible = this._isVisible) {\n        this.div.classList.toggle(\"hidden\", !visible);\n        this._isVisible = visible;\n    }\n    enable() {\n        if (this.div) {\n            this.div.tabIndex = 0;\n        }\n        this.#disabled = false;\n    }\n    disable() {\n        if (this.div) {\n            this.div.tabIndex = -1;\n        }\n        this.#disabled = true;\n    }\n    updateFakeAnnotationElement(annotationLayer) {\n        if (!this.#fakeAnnotation && !this.deleted) {\n            this.#fakeAnnotation = annotationLayer.addFakeAnnotation(this);\n            return;\n        }\n        if (this.deleted) {\n            this.#fakeAnnotation.remove();\n            this.#fakeAnnotation = null;\n            return;\n        }\n        if (this.hasEditedComment || this._hasBeenMoved || this._hasBeenResized) {\n            this.#fakeAnnotation.updateEdited({\n                rect: this.getPDFRect(),\n                popup: this.comment\n            });\n        }\n    }\n    renderAnnotationElement(annotation) {\n        if (this.deleted) {\n            annotation.hide();\n            return null;\n        }\n        let content = annotation.container.querySelector(\".annotationContent\");\n        if (!content) {\n            content = document.createElement(\"div\");\n            content.classList.add(\"annotationContent\", this.editorType);\n            annotation.container.prepend(content);\n        } else if (content.nodeName === \"CANVAS\") {\n            const canvas = content;\n            content = document.createElement(\"div\");\n            content.classList.add(\"annotationContent\", this.editorType);\n            canvas.before(content);\n        }\n        return content;\n    }\n    resetAnnotationElement(annotation) {\n        const { firstChild } = annotation.container;\n        if (firstChild?.nodeName === \"DIV\" && firstChild.classList.contains(\"annotationContent\")) {\n            firstChild.remove();\n        }\n    }\n}\nclass FakeEditor extends AnnotationEditor {\n    constructor(params){\n        super(params);\n        this.annotationElementId = params.annotationElementId;\n        this.deleted = true;\n    }\n    serialize() {\n        return this.serializeDeleted();\n    }\n}\nconst SEED = 3285377520;\nconst MASK_HIGH = 4294901760;\nconst MASK_LOW = 65535;\nclass MurmurHash3_64 {\n    constructor(seed){\n        this.h1 = seed ? seed & 4294967295 : SEED;\n        this.h2 = seed ? seed & 4294967295 : SEED;\n    }\n    update(input) {\n        let data, length;\n        if (typeof input === \"string\") {\n            data = new Uint8Array(input.length * 2);\n            length = 0;\n            for(let i = 0, ii = input.length; i < ii; i++){\n                const code = input.charCodeAt(i);\n                if (code <= 255) {\n                    data[length++] = code;\n                } else {\n                    data[length++] = code >>> 8;\n                    data[length++] = code & 255;\n                }\n            }\n        } else if (ArrayBuffer.isView(input)) {\n            data = input.slice();\n            length = data.byteLength;\n        } else {\n            throw new Error(\"Invalid data format, must be a string or TypedArray.\");\n        }\n        const blockCounts = length >> 2;\n        const tailLength = length - blockCounts * 4;\n        const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);\n        let k1 = 0, k2 = 0;\n        let h1 = this.h1, h2 = this.h2;\n        const C1 = 3432918353, C2 = 461845907;\n        const C1_LOW = C1 & MASK_LOW, C2_LOW = C2 & MASK_LOW;\n        for(let i = 0; i < blockCounts; i++){\n            if (i & 1) {\n                k1 = dataUint32[i];\n                k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n                k1 = k1 << 15 | k1 >>> 17;\n                k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n                h1 ^= k1;\n                h1 = h1 << 13 | h1 >>> 19;\n                h1 = h1 * 5 + 3864292196;\n            } else {\n                k2 = dataUint32[i];\n                k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;\n                k2 = k2 << 15 | k2 >>> 17;\n                k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;\n                h2 ^= k2;\n                h2 = h2 << 13 | h2 >>> 19;\n                h2 = h2 * 5 + 3864292196;\n            }\n        }\n        k1 = 0;\n        switch(tailLength){\n            case 3:\n                k1 ^= data[blockCounts * 4 + 2] << 16;\n            case 2:\n                k1 ^= data[blockCounts * 4 + 1] << 8;\n            case 1:\n                k1 ^= data[blockCounts * 4];\n                k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n                k1 = k1 << 15 | k1 >>> 17;\n                k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n                if (blockCounts & 1) {\n                    h1 ^= k1;\n                } else {\n                    h2 ^= k1;\n                }\n        }\n        this.h1 = h1;\n        this.h2 = h2;\n    }\n    hexdigest() {\n        let h1 = this.h1, h2 = this.h2;\n        h1 ^= h2 >>> 1;\n        h1 = h1 * 3981806797 & MASK_HIGH | h1 * 36045 & MASK_LOW;\n        h2 = h2 * 4283543511 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 2950163797 & MASK_HIGH) >>> 16;\n        h1 ^= h2 >>> 1;\n        h1 = h1 * 444984403 & MASK_HIGH | h1 * 60499 & MASK_LOW;\n        h2 = h2 * 3301882366 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 3120437893 & MASK_HIGH) >>> 16;\n        h1 ^= h2 >>> 1;\n        return (h1 >>> 0).toString(16).padStart(8, \"0\") + (h2 >>> 0).toString(16).padStart(8, \"0\");\n    }\n}\nconst SerializableEmpty = Object.freeze({\n    map: null,\n    hash: \"\",\n    transfer: void 0\n});\nclass AnnotationStorage {\n    #modified;\n    #modifiedIds;\n    #editorsMap;\n    #storage;\n    constructor(){\n        this.#modified = false;\n        this.#modifiedIds = null;\n        this.#editorsMap = null;\n        this.#storage = /* @__PURE__ */ new Map();\n        this.onSetModified = null;\n        this.onResetModified = null;\n        this.onAnnotationEditor = null;\n    }\n    getValue(key, defaultValue) {\n        const value1 = this.#storage.get(key);\n        if (value1 === void 0) {\n            return defaultValue;\n        }\n        return Object.assign(defaultValue, value1);\n    }\n    getRawValue(key) {\n        return this.#storage.get(key);\n    }\n    remove(key) {\n        const storedValue = this.#storage.get(key);\n        if (storedValue === void 0) {\n            return;\n        }\n        if (storedValue instanceof AnnotationEditor) {\n            this.#editorsMap.delete(storedValue.annotationElementId);\n        }\n        this.#storage.delete(key);\n        if (this.#storage.size === 0) {\n            this.resetModified();\n        }\n        if (typeof this.onAnnotationEditor === \"function\") {\n            for (const value1 of this.#storage.values()){\n                if (value1 instanceof AnnotationEditor) {\n                    return;\n                }\n            }\n            this.onAnnotationEditor(null);\n        }\n    }\n    setValue(key, value1) {\n        const obj = this.#storage.get(key);\n        let modified = false;\n        if (obj !== void 0) {\n            for (const [entry, val] of Object.entries(value1)){\n                if (obj[entry] !== val) {\n                    modified = true;\n                    obj[entry] = val;\n                }\n            }\n        } else {\n            modified = true;\n            this.#storage.set(key, value1);\n        }\n        if (modified) {\n            this.#setModified();\n        }\n        if (value1 instanceof AnnotationEditor) {\n            (this.#editorsMap ||= /* @__PURE__ */ new Map()).set(value1.annotationElementId, value1);\n            if (typeof this.onAnnotationEditor === \"function\") {\n                this.onAnnotationEditor(value1.constructor._type);\n            }\n        }\n    }\n    has(key) {\n        return this.#storage.has(key);\n    }\n    get size() {\n        return this.#storage.size;\n    }\n    #setModified() {\n        if (!this.#modified) {\n            this.#modified = true;\n            if (typeof this.onSetModified === \"function\") {\n                this.onSetModified();\n            }\n        }\n    }\n    resetModified() {\n        if (this.#modified) {\n            this.#modified = false;\n            if (typeof this.onResetModified === \"function\") {\n                this.onResetModified();\n            }\n        }\n    }\n    get print() {\n        return new PrintAnnotationStorage(this);\n    }\n    get serializable() {\n        if (this.#storage.size === 0) {\n            return SerializableEmpty;\n        }\n        const map = /* @__PURE__ */ new Map(), hash = new MurmurHash3_64(), transfer = [];\n        const context = /* @__PURE__ */ Object.create(null);\n        let hasBitmap = false;\n        for (const [key, val] of this.#storage){\n            const serialized = val instanceof AnnotationEditor ? val.serialize(false, context) : val;\n            if (serialized) {\n                map.set(key, serialized);\n                hash.update(`${key}:${JSON.stringify(serialized)}`);\n                hasBitmap ||= !!serialized.bitmap;\n            }\n        }\n        if (hasBitmap) {\n            for (const value1 of map.values()){\n                if (value1.bitmap) {\n                    transfer.push(value1.bitmap);\n                }\n            }\n        }\n        return map.size > 0 ? {\n            map,\n            hash: hash.hexdigest(),\n            transfer\n        } : SerializableEmpty;\n    }\n    get editorStats() {\n        let stats = null;\n        const typeToEditor = /* @__PURE__ */ new Map();\n        let numberOfEditedComments = 0;\n        let numberOfDeletedComments = 0;\n        for (const value1 of this.#storage.values()){\n            if (!(value1 instanceof AnnotationEditor)) {\n                if (value1.popup) {\n                    if (value1.popup.deleted) {\n                        numberOfDeletedComments += 1;\n                    } else {\n                        numberOfEditedComments += 1;\n                    }\n                }\n                continue;\n            }\n            if (value1.isCommentDeleted) {\n                numberOfDeletedComments += 1;\n            } else if (value1.hasEditedComment) {\n                numberOfEditedComments += 1;\n            }\n            const editorStats = value1.telemetryFinalData;\n            if (!editorStats) {\n                continue;\n            }\n            const { type } = editorStats;\n            if (!typeToEditor.has(type)) {\n                typeToEditor.set(type, Object.getPrototypeOf(value1).constructor);\n            }\n            stats ||= /* @__PURE__ */ Object.create(null);\n            const map = stats[type] ||= /* @__PURE__ */ new Map();\n            for (const [key, val] of Object.entries(editorStats)){\n                if (key === \"type\") {\n                    continue;\n                }\n                let counters = map.get(key);\n                if (!counters) {\n                    counters = /* @__PURE__ */ new Map();\n                    map.set(key, counters);\n                }\n                const count = counters.get(val) ?? 0;\n                counters.set(val, count + 1);\n            }\n        }\n        if (numberOfDeletedComments > 0 || numberOfEditedComments > 0) {\n            stats ||= /* @__PURE__ */ Object.create(null);\n            stats.comments = {\n                deleted: numberOfDeletedComments,\n                edited: numberOfEditedComments\n            };\n        }\n        if (!stats) {\n            return null;\n        }\n        for (const [type, editor] of typeToEditor){\n            stats[type] = editor.computeTelemetryFinalData(stats[type]);\n        }\n        return stats;\n    }\n    resetModifiedIds() {\n        this.#modifiedIds = null;\n    }\n    updateEditor(annotationId, data) {\n        const value1 = this.#editorsMap?.get(annotationId);\n        if (value1) {\n            value1.updateFromAnnotationLayer(data);\n            return true;\n        }\n        return false;\n    }\n    getEditor(annotationId) {\n        return this.#editorsMap?.get(annotationId) || null;\n    }\n    get modifiedIds() {\n        if (this.#modifiedIds) {\n            return this.#modifiedIds;\n        }\n        const ids = [];\n        if (this.#editorsMap) {\n            for (const value1 of this.#editorsMap.values()){\n                if (!value1.serialize()) {\n                    continue;\n                }\n                ids.push(value1.annotationElementId);\n            }\n        }\n        return this.#modifiedIds = {\n            ids: new Set(ids),\n            hash: ids.join(\",\")\n        };\n    }\n    [Symbol.iterator]() {\n        return this.#storage.entries();\n    }\n}\nclass PrintAnnotationStorage extends AnnotationStorage {\n    #serializable;\n    constructor(parent){\n        super();\n        const { map, hash, transfer } = parent.serializable;\n        const clone = structuredClone(map, transfer ? {\n            transfer\n        } : null);\n        this.#serializable = {\n            map: clone,\n            hash,\n            transfer\n        };\n    }\n    get print() {\n        unreachable(\"Should not call PrintAnnotationStorage.print\");\n    }\n    get serializable() {\n        return this.#serializable;\n    }\n    get modifiedIds() {\n        return shadow(this, \"modifiedIds\", {\n            ids: /* @__PURE__ */ new Set(),\n            hash: \"\"\n        });\n    }\n}\nclass FontLoader {\n    #systemFonts;\n    constructor({ ownerDocument = globalThis.document, styleElement = null }){\n        this.#systemFonts = /* @__PURE__ */ new Set();\n        this._document = ownerDocument;\n        this.nativeFontFaces = /* @__PURE__ */ new Set();\n        this.styleElement = null;\n        this.loadingRequests = [];\n        this.loadTestFontId = 0;\n    }\n    addNativeFontFace(nativeFontFace) {\n        this.nativeFontFaces.add(nativeFontFace);\n        this._document.fonts.add(nativeFontFace);\n    }\n    removeNativeFontFace(nativeFontFace) {\n        this.nativeFontFaces.delete(nativeFontFace);\n        this._document.fonts.delete(nativeFontFace);\n    }\n    insertRule(rule) {\n        if (!this.styleElement) {\n            this.styleElement = this._document.createElement(\"style\");\n            this._document.documentElement.getElementsByTagName(\"head\")[0].append(this.styleElement);\n        }\n        const styleSheet = this.styleElement.sheet;\n        styleSheet.insertRule(rule, styleSheet.cssRules.length);\n    }\n    clear() {\n        for (const nativeFontFace of this.nativeFontFaces){\n            this._document.fonts.delete(nativeFontFace);\n        }\n        this.nativeFontFaces.clear();\n        this.#systemFonts.clear();\n        if (this.styleElement) {\n            this.styleElement.remove();\n            this.styleElement = null;\n        }\n    }\n    async loadSystemFont({ systemFontInfo: info2, disableFontFace, _inspectFont }) {\n        if (!info2 || this.#systemFonts.has(info2.loadedName)) {\n            return;\n        }\n        assert(!disableFontFace, \"loadSystemFont shouldn't be called when `disableFontFace` is set.\");\n        if (this.isFontLoadingAPISupported) {\n            const { loadedName, src, style } = info2;\n            const fontFace = new FontFace(loadedName, src, style);\n            this.addNativeFontFace(fontFace);\n            try {\n                await fontFace.load();\n                this.#systemFonts.add(loadedName);\n                _inspectFont?.(info2);\n            } catch  {\n                warn(`Cannot load system font: ${info2.baseFontName}, installing it could help to improve PDF rendering.`);\n                this.removeNativeFontFace(fontFace);\n            }\n            return;\n        }\n        unreachable(\"Not implemented: loadSystemFont without the Font Loading API.\");\n    }\n    async bind(font) {\n        if (font.attached || font.missingFile && !font.systemFontInfo) {\n            return;\n        }\n        font.attached = true;\n        if (font.systemFontInfo) {\n            await this.loadSystemFont(font);\n            return;\n        }\n        if (this.isFontLoadingAPISupported) {\n            const nativeFontFace = font.createNativeFontFace();\n            if (nativeFontFace) {\n                this.addNativeFontFace(nativeFontFace);\n                try {\n                    await nativeFontFace.loaded;\n                } catch (ex) {\n                    warn(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);\n                    font.disableFontFace = true;\n                    throw ex;\n                }\n            }\n            return;\n        }\n        const rule = font.createFontFaceRule();\n        if (rule) {\n            this.insertRule(rule);\n            if (this.isSyncFontLoadingSupported) {\n                return;\n            }\n            await new Promise((resolve)=>{\n                const request = this._queueLoadingCallback(resolve);\n                this._prepareFontLoadEvent(font, request);\n            });\n        }\n    }\n    get isFontLoadingAPISupported() {\n        const hasFonts = !!this._document?.fonts;\n        return shadow(this, \"isFontLoadingAPISupported\", hasFonts);\n    }\n    get isSyncFontLoadingSupported() {\n        return shadow(this, \"isSyncFontLoadingSupported\", isNodeJS || util_FeatureTest.platform.isFirefox);\n    }\n    _queueLoadingCallback(callback) {\n        function completeRequest() {\n            assert(!request.done, \"completeRequest() cannot be called twice.\");\n            request.done = true;\n            while(loadingRequests.length > 0 && loadingRequests[0].done){\n                const otherRequest = loadingRequests.shift();\n                setTimeout(otherRequest.callback, 0);\n            }\n        }\n        const { loadingRequests } = this;\n        const request = {\n            done: false,\n            complete: completeRequest,\n            callback\n        };\n        loadingRequests.push(request);\n        return request;\n    }\n    get _loadTestFont() {\n        const testFont = atob(\"T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==\");\n        return shadow(this, \"_loadTestFont\", testFont);\n    }\n    _prepareFontLoadEvent(font, request) {\n        function int32(data2, offset) {\n            return data2.charCodeAt(offset) << 24 | data2.charCodeAt(offset + 1) << 16 | data2.charCodeAt(offset + 2) << 8 | data2.charCodeAt(offset + 3) & 255;\n        }\n        function spliceString(s, offset, remove, insert) {\n            const chunk1 = s.substring(0, offset);\n            const chunk2 = s.substring(offset + remove);\n            return chunk1 + insert + chunk2;\n        }\n        let i, ii;\n        const canvas = this._document.createElement(\"canvas\");\n        canvas.width = 1;\n        canvas.height = 1;\n        const ctx = canvas.getContext(\"2d\");\n        let called = 0;\n        function isFontReady(name, callback) {\n            if (++called > 30) {\n                warn(\"Load test font never loaded.\");\n                callback();\n                return;\n            }\n            ctx.font = \"30px \" + name;\n            ctx.fillText(\".\", 0, 20);\n            const imageData = ctx.getImageData(0, 0, 1, 1);\n            if (imageData.data[3] > 0) {\n                callback();\n                return;\n            }\n            setTimeout(isFontReady.bind(null, name, callback));\n        }\n        const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;\n        let data = this._loadTestFont;\n        const COMMENT_OFFSET = 976;\n        data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);\n        const CFF_CHECKSUM_OFFSET = 16;\n        const XXXX_VALUE = 1482184792;\n        let checksum = int32(data, CFF_CHECKSUM_OFFSET);\n        for(i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4){\n            checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;\n        }\n        if (i < loadTestFontId.length) {\n            checksum = checksum - XXXX_VALUE + int32(loadTestFontId + \"XXX\", i) | 0;\n        }\n        data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, string32(checksum));\n        const url = `url(data:font/opentype;base64,${btoa(data)});`;\n        const rule = `@font-face {font-family:\"${loadTestFontId}\";src:${url}}`;\n        this.insertRule(rule);\n        const div = this._document.createElement(\"div\");\n        div.style.visibility = \"hidden\";\n        div.style.width = div.style.height = \"10px\";\n        div.style.position = \"absolute\";\n        div.style.top = div.style.left = \"0px\";\n        for (const name of [\n            font.loadedName,\n            loadTestFontId\n        ]){\n            const span = this._document.createElement(\"span\");\n            span.textContent = \"Hi\";\n            span.style.fontFamily = name;\n            div.append(span);\n        }\n        this._document.body.append(div);\n        isFontReady(loadTestFontId, ()=>{\n            div.remove();\n            request.complete();\n        });\n    }\n}\nclass FontFaceObject {\n    #fontData;\n    constructor(translatedData, inspectFont = null, extra, charProcOperatorList){\n        this.compiledGlyphs = /* @__PURE__ */ Object.create(null);\n        this.#fontData = translatedData;\n        this._inspectFont = inspectFont;\n        if (extra) {\n            Object.assign(this, extra);\n        }\n        if (charProcOperatorList) {\n            this.charProcOperatorList = charProcOperatorList;\n        }\n    }\n    createNativeFontFace() {\n        if (!this.data || this.disableFontFace) {\n            return null;\n        }\n        let nativeFontFace;\n        if (!this.cssFontInfo) {\n            nativeFontFace = new FontFace(this.loadedName, this.data, {});\n        } else {\n            const css = {\n                weight: this.cssFontInfo.fontWeight\n            };\n            if (this.cssFontInfo.italicAngle) {\n                css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;\n            }\n            nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);\n        }\n        this._inspectFont?.(this);\n        return nativeFontFace;\n    }\n    createFontFaceRule() {\n        if (!this.data || this.disableFontFace) {\n            return null;\n        }\n        const url = `url(data:${this.mimetype};base64,${toBase64Util(this.data)});`;\n        let rule;\n        if (!this.cssFontInfo) {\n            rule = `@font-face {font-family:\"${this.loadedName}\";src:${url}}`;\n        } else {\n            let css = `font-weight: ${this.cssFontInfo.fontWeight};`;\n            if (this.cssFontInfo.italicAngle) {\n                css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;\n            }\n            rule = `@font-face {font-family:\"${this.cssFontInfo.fontFamily}\";${css}src:${url}}`;\n        }\n        this._inspectFont?.(this, url);\n        return rule;\n    }\n    getPathGenerator(objs, character) {\n        if (this.compiledGlyphs[character] !== void 0) {\n            return this.compiledGlyphs[character];\n        }\n        const objId = this.loadedName + \"_path_\" + character;\n        let cmds;\n        try {\n            cmds = objs.get(objId);\n        } catch (ex) {\n            warn(`getPathGenerator - ignoring character: \"${ex}\".`);\n        }\n        const path = new Path2D(cmds || \"\");\n        if (!this.fontExtraProperties) {\n            objs.delete(objId);\n        }\n        return this.compiledGlyphs[character] = path;\n    }\n    get black() {\n        return this.#fontData.black;\n    }\n    get bold() {\n        return this.#fontData.bold;\n    }\n    get disableFontFace() {\n        return this.#fontData.disableFontFace ?? false;\n    }\n    get fontExtraProperties() {\n        return this.#fontData.fontExtraProperties ?? false;\n    }\n    get isInvalidPDFjsFont() {\n        return this.#fontData.isInvalidPDFjsFont;\n    }\n    get isType3Font() {\n        return this.#fontData.isType3Font;\n    }\n    get italic() {\n        return this.#fontData.italic;\n    }\n    get missingFile() {\n        return this.#fontData.missingFile;\n    }\n    get remeasure() {\n        return this.#fontData.remeasure;\n    }\n    get vertical() {\n        return this.#fontData.vertical;\n    }\n    get ascent() {\n        return this.#fontData.ascent;\n    }\n    get defaultWidth() {\n        return this.#fontData.defaultWidth;\n    }\n    get descent() {\n        return this.#fontData.descent;\n    }\n    get bbox() {\n        return this.#fontData.bbox;\n    }\n    get fontMatrix() {\n        return this.#fontData.fontMatrix;\n    }\n    get fallbackName() {\n        return this.#fontData.fallbackName;\n    }\n    get loadedName() {\n        return this.#fontData.loadedName;\n    }\n    get mimetype() {\n        return this.#fontData.mimetype;\n    }\n    get name() {\n        return this.#fontData.name;\n    }\n    get data() {\n        return this.#fontData.data;\n    }\n    clearData() {\n        this.#fontData.clearData();\n    }\n    get cssFontInfo() {\n        return this.#fontData.cssFontInfo;\n    }\n    get systemFontInfo() {\n        return this.#fontData.systemFontInfo;\n    }\n    get defaultVMetrics() {\n        return this.#fontData.defaultVMetrics;\n    }\n}\nfunction getUrlProp(val) {\n    if (val instanceof URL) {\n        return val.href;\n    }\n    if (typeof val === \"string\") {\n        if (isNodeJS) {\n            return val;\n        }\n        const url = URL.parse(val, window.location);\n        if (url) {\n            return url.href;\n        }\n    }\n    throw new Error(\"Invalid PDF url data: either string or URL-object is expected in the url property.\");\n}\nfunction getDataProp(val) {\n    if (isNodeJS && typeof Buffer !== \"undefined\" && val instanceof Buffer) {\n        throw new Error(\"Please provide binary data as `Uint8Array`, rather than `Buffer`.\");\n    }\n    if (val instanceof Uint8Array && val.byteLength === val.buffer.byteLength) {\n        return val;\n    }\n    if (typeof val === \"string\") {\n        return stringToBytes(val);\n    }\n    if (val instanceof ArrayBuffer || ArrayBuffer.isView(val) || typeof val === \"object\" && !isNaN(val?.length)) {\n        return new Uint8Array(val);\n    }\n    throw new Error(\"Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.\");\n}\nfunction getFactoryUrlProp(val) {\n    if (typeof val !== \"string\") {\n        return null;\n    }\n    if (val.endsWith(\"/\")) {\n        return val;\n    }\n    throw new Error(`Invalid factory url: \"${val}\" must include trailing slash.`);\n}\nconst isRefProxy = (v)=>typeof v === \"object\" && Number.isInteger(v?.num) && v.num >= 0 && Number.isInteger(v?.gen) && v.gen >= 0;\nconst isNameProxy = (v)=>typeof v === \"object\" && typeof v?.name === \"string\";\nconst isValidExplicitDest = _isValidExplicitDest.bind(null, isRefProxy, isNameProxy);\nclass LoopbackPort {\n    #listeners;\n    #deferred;\n    postMessage(obj, transfer) {\n        const event = {\n            data: structuredClone(obj, transfer ? {\n                transfer\n            } : null)\n        };\n        this.#deferred.then(()=>{\n            for (const [listener] of this.#listeners){\n                listener.call(this, event);\n            }\n        });\n    }\n    addEventListener(name, listener, options = null) {\n        let rmAbort = null;\n        if (options?.signal instanceof AbortSignal) {\n            const { signal } = options;\n            if (signal.aborted) {\n                warn(\"LoopbackPort - cannot use an `aborted` signal.\");\n                return;\n            }\n            const onAbort = ()=>this.removeEventListener(name, listener);\n            rmAbort = ()=>signal.removeEventListener(\"abort\", onAbort);\n            signal.addEventListener(\"abort\", onAbort);\n        }\n        this.#listeners.set(listener, rmAbort);\n    }\n    removeEventListener(name, listener) {\n        const rmAbort = this.#listeners.get(listener);\n        rmAbort?.();\n        this.#listeners.delete(listener);\n    }\n    terminate() {\n        for (const [, rmAbort] of this.#listeners){\n            rmAbort?.();\n        }\n        this.#listeners.clear();\n    }\n    constructor(){\n        this.#listeners = /* @__PURE__ */ new Map();\n        this.#deferred = Promise.resolve();\n    }\n}\nconst CallbackKind = {\n    DATA: 1,\n    ERROR: 2\n};\nconst StreamKind = {\n    CANCEL: 1,\n    CANCEL_COMPLETE: 2,\n    CLOSE: 3,\n    ENQUEUE: 4,\n    ERROR: 5,\n    PULL: 6,\n    PULL_COMPLETE: 7,\n    START_COMPLETE: 8\n};\nfunction onFn() {}\nfunction wrapReason(ex) {\n    if (ex instanceof AbortException || ex instanceof InvalidPDFException || ex instanceof PasswordException || ex instanceof ResponseException || ex instanceof UnknownErrorException) {\n        return ex;\n    }\n    if (!(ex instanceof Error || typeof ex === \"object\" && ex !== null)) {\n        unreachable('wrapReason: Expected \"reason\" to be a (possibly cloned) Error.');\n    }\n    switch(ex.name){\n        case \"AbortException\":\n            return new AbortException(ex.message);\n        case \"InvalidPDFException\":\n            return new InvalidPDFException(ex.message);\n        case \"PasswordException\":\n            return new PasswordException(ex.message, ex.code);\n        case \"ResponseException\":\n            return new ResponseException(ex.message, ex.status, ex.missing);\n        case \"UnknownErrorException\":\n            return new UnknownErrorException(ex.message, ex.details);\n    }\n    return new UnknownErrorException(ex.message, ex.toString());\n}\nclass MessageHandler {\n    #messageAC;\n    constructor(sourceName, targetName, comObj){\n        this.#messageAC = new AbortController();\n        this.sourceName = sourceName;\n        this.targetName = targetName;\n        this.comObj = comObj;\n        this.callbackId = 1;\n        this.streamId = 1;\n        this.streamSinks = /* @__PURE__ */ Object.create(null);\n        this.streamControllers = /* @__PURE__ */ Object.create(null);\n        this.callbackCapabilities = /* @__PURE__ */ Object.create(null);\n        this.actionHandler = /* @__PURE__ */ Object.create(null);\n        comObj.addEventListener(\"message\", this.#onMessage.bind(this), {\n            signal: this.#messageAC.signal\n        });\n    }\n    #onMessage({ data }) {\n        if (data.targetName !== this.sourceName) {\n            return;\n        }\n        if (data.stream) {\n            this.#processStreamMessage(data);\n            return;\n        }\n        if (data.callback) {\n            const callbackId = data.callbackId;\n            const capability = this.callbackCapabilities[callbackId];\n            if (!capability) {\n                throw new Error(`Cannot resolve callback ${callbackId}`);\n            }\n            delete this.callbackCapabilities[callbackId];\n            if (data.callback === CallbackKind.DATA) {\n                capability.resolve(data.data);\n            } else if (data.callback === CallbackKind.ERROR) {\n                capability.reject(wrapReason(data.reason));\n            } else {\n                throw new Error(\"Unexpected callback case\");\n            }\n            return;\n        }\n        const action = this.actionHandler[data.action];\n        if (!action) {\n            throw new Error(`Unknown action from worker: ${data.action}`);\n        }\n        if (data.callbackId) {\n            const sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;\n            Promise.try(action, data.data).then(function(result) {\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    callback: CallbackKind.DATA,\n                    callbackId: data.callbackId,\n                    data: result\n                });\n            }, function(reason) {\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    callback: CallbackKind.ERROR,\n                    callbackId: data.callbackId,\n                    reason: wrapReason(reason)\n                });\n            });\n            return;\n        }\n        if (data.streamId) {\n            this.#createStreamSink(data);\n            return;\n        }\n        action(data.data);\n    }\n    on(actionName, handler) {\n        const ah = this.actionHandler;\n        if (ah[actionName]) {\n            throw new Error(`There is already an actionName called \"${actionName}\"`);\n        }\n        ah[actionName] = handler;\n    }\n    send(actionName, data, transfers) {\n        this.comObj.postMessage({\n            sourceName: this.sourceName,\n            targetName: this.targetName,\n            action: actionName,\n            data\n        }, transfers);\n    }\n    sendWithPromise(actionName, data, transfers) {\n        const callbackId = this.callbackId++;\n        const capability = Promise.withResolvers();\n        this.callbackCapabilities[callbackId] = capability;\n        try {\n            this.comObj.postMessage({\n                sourceName: this.sourceName,\n                targetName: this.targetName,\n                action: actionName,\n                callbackId,\n                data\n            }, transfers);\n        } catch (ex) {\n            capability.reject(ex);\n        }\n        return capability.promise;\n    }\n    sendWithStream(actionName, data, queueingStrategy, transfers) {\n        const streamId = this.streamId++, sourceName = this.sourceName, targetName = this.targetName, comObj = this.comObj;\n        return new ReadableStream({\n            start: (controller)=>{\n                const startCapability = Promise.withResolvers();\n                this.streamControllers[streamId] = {\n                    controller,\n                    startCall: startCapability,\n                    pullCall: null,\n                    cancelCall: null,\n                    isClosed: false\n                };\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    action: actionName,\n                    streamId,\n                    data,\n                    desiredSize: controller.desiredSize\n                }, transfers);\n                return startCapability.promise;\n            },\n            pull: (controller)=>{\n                const pullCapability = Promise.withResolvers();\n                this.streamControllers[streamId].pullCall = pullCapability;\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.PULL,\n                    streamId,\n                    desiredSize: controller.desiredSize\n                });\n                return pullCapability.promise;\n            },\n            cancel: (reason)=>{\n                assert(reason instanceof Error, \"cancel must have a valid reason\");\n                const cancelCapability = Promise.withResolvers();\n                this.streamControllers[streamId].cancelCall = cancelCapability;\n                this.streamControllers[streamId].isClosed = true;\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.CANCEL,\n                    streamId,\n                    reason: wrapReason(reason)\n                });\n                return cancelCapability.promise;\n            }\n        }, queueingStrategy);\n    }\n    #createStreamSink(data) {\n        const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;\n        const self2 = this, action = this.actionHandler[data.action];\n        const streamSink = {\n            enqueue (chunk, size = 1, transfers) {\n                if (this.isCancelled) {\n                    return;\n                }\n                const lastDesiredSize = this.desiredSize;\n                this.desiredSize -= size;\n                if (lastDesiredSize > 0 && this.desiredSize <= 0) {\n                    this.sinkCapability = Promise.withResolvers();\n                    this.ready = this.sinkCapability.promise;\n                }\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.ENQUEUE,\n                    streamId,\n                    chunk\n                }, transfers);\n            },\n            close () {\n                if (this.isCancelled) {\n                    return;\n                }\n                this.isCancelled = true;\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.CLOSE,\n                    streamId\n                });\n                delete self2.streamSinks[streamId];\n            },\n            error (reason) {\n                assert(reason instanceof Error, \"error must have a valid reason\");\n                if (this.isCancelled) {\n                    return;\n                }\n                this.isCancelled = true;\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.ERROR,\n                    streamId,\n                    reason: wrapReason(reason)\n                });\n            },\n            sinkCapability: Promise.withResolvers(),\n            onPull: null,\n            onCancel: null,\n            isCancelled: false,\n            desiredSize: data.desiredSize,\n            ready: null\n        };\n        streamSink.sinkCapability.resolve();\n        streamSink.ready = streamSink.sinkCapability.promise;\n        this.streamSinks[streamId] = streamSink;\n        Promise.try(action, data.data, streamSink).then(function() {\n            comObj.postMessage({\n                sourceName,\n                targetName,\n                stream: StreamKind.START_COMPLETE,\n                streamId,\n                success: true\n            });\n        }, function(reason) {\n            comObj.postMessage({\n                sourceName,\n                targetName,\n                stream: StreamKind.START_COMPLETE,\n                streamId,\n                reason: wrapReason(reason)\n            });\n        });\n    }\n    #processStreamMessage(data) {\n        const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;\n        const streamController = this.streamControllers[streamId], streamSink = this.streamSinks[streamId];\n        switch(data.stream){\n            case StreamKind.START_COMPLETE:\n                if (data.success) {\n                    streamController.startCall.resolve();\n                } else {\n                    streamController.startCall.reject(wrapReason(data.reason));\n                }\n                break;\n            case StreamKind.PULL_COMPLETE:\n                if (data.success) {\n                    streamController.pullCall.resolve();\n                } else {\n                    streamController.pullCall.reject(wrapReason(data.reason));\n                }\n                break;\n            case StreamKind.PULL:\n                if (!streamSink) {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.PULL_COMPLETE,\n                        streamId,\n                        success: true\n                    });\n                    break;\n                }\n                if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {\n                    streamSink.sinkCapability.resolve();\n                }\n                streamSink.desiredSize = data.desiredSize;\n                Promise.try(streamSink.onPull || onFn).then(function() {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.PULL_COMPLETE,\n                        streamId,\n                        success: true\n                    });\n                }, function(reason) {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.PULL_COMPLETE,\n                        streamId,\n                        reason: wrapReason(reason)\n                    });\n                });\n                break;\n            case StreamKind.ENQUEUE:\n                assert(streamController, \"enqueue should have stream controller\");\n                if (streamController.isClosed) {\n                    break;\n                }\n                streamController.controller.enqueue(data.chunk);\n                break;\n            case StreamKind.CLOSE:\n                assert(streamController, \"close should have stream controller\");\n                if (streamController.isClosed) {\n                    break;\n                }\n                streamController.isClosed = true;\n                streamController.controller.close();\n                this.#deleteStreamController(streamController, streamId);\n                break;\n            case StreamKind.ERROR:\n                assert(streamController, \"error should have stream controller\");\n                streamController.controller.error(wrapReason(data.reason));\n                this.#deleteStreamController(streamController, streamId);\n                break;\n            case StreamKind.CANCEL_COMPLETE:\n                if (data.success) {\n                    streamController.cancelCall.resolve();\n                } else {\n                    streamController.cancelCall.reject(wrapReason(data.reason));\n                }\n                this.#deleteStreamController(streamController, streamId);\n                break;\n            case StreamKind.CANCEL:\n                if (!streamSink) {\n                    break;\n                }\n                const dataReason = wrapReason(data.reason);\n                Promise.try(streamSink.onCancel || onFn, dataReason).then(function() {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.CANCEL_COMPLETE,\n                        streamId,\n                        success: true\n                    });\n                }, function(reason) {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.CANCEL_COMPLETE,\n                        streamId,\n                        reason: wrapReason(reason)\n                    });\n                });\n                streamSink.sinkCapability.reject(dataReason);\n                streamSink.isCancelled = true;\n                delete this.streamSinks[streamId];\n                break;\n            default:\n                throw new Error(\"Unexpected stream case\");\n        }\n    }\n    async #deleteStreamController(streamController, streamId) {\n        await Promise.allSettled([\n            streamController.startCall?.promise,\n            streamController.pullCall?.promise,\n            streamController.cancelCall?.promise\n        ]);\n        delete this.streamControllers[streamId];\n    }\n    destroy() {\n        this.#messageAC?.abort();\n        this.#messageAC = null;\n    }\n}\nclass BaseCanvasFactory {\n    #enableHWA;\n    constructor({ enableHWA = false }){\n        this.#enableHWA = false;\n        this.#enableHWA = enableHWA;\n    }\n    create(width, height) {\n        if (width <= 0 || height <= 0) {\n            throw new Error(\"Invalid canvas size\");\n        }\n        const canvas = this._createCanvas(width, height);\n        return {\n            canvas,\n            context: canvas.getContext(\"2d\", {\n                willReadFrequently: !this.#enableHWA\n            })\n        };\n    }\n    reset(canvasAndContext, width, height) {\n        if (!canvasAndContext.canvas) {\n            throw new Error(\"Canvas is not specified\");\n        }\n        if (width <= 0 || height <= 0) {\n            throw new Error(\"Invalid canvas size\");\n        }\n        canvasAndContext.canvas.width = width;\n        canvasAndContext.canvas.height = height;\n    }\n    destroy(canvasAndContext) {\n        if (!canvasAndContext.canvas) {\n            throw new Error(\"Canvas is not specified\");\n        }\n        canvasAndContext.canvas.width = 0;\n        canvasAndContext.canvas.height = 0;\n        canvasAndContext.canvas = null;\n        canvasAndContext.context = null;\n    }\n    _createCanvas(width, height) {\n        unreachable(\"Abstract method `_createCanvas` called.\");\n    }\n}\nclass DOMCanvasFactory extends BaseCanvasFactory {\n    constructor({ ownerDocument = globalThis.document, enableHWA = false }){\n        super({\n            enableHWA\n        });\n        this._document = ownerDocument;\n    }\n    _createCanvas(width, height) {\n        const canvas = this._document.createElement(\"canvas\");\n        canvas.width = width;\n        canvas.height = height;\n        return canvas;\n    }\n}\nclass BaseCMapReaderFactory {\n    constructor({ baseUrl = null, isCompressed = true }){\n        this.baseUrl = baseUrl;\n        this.isCompressed = isCompressed;\n    }\n    async fetch({ name }) {\n        if (!this.baseUrl) {\n            throw new Error(\"Ensure that the `cMapUrl` and `cMapPacked` API parameters are provided.\");\n        }\n        if (!name) {\n            throw new Error(\"CMap name must be specified.\");\n        }\n        const url = this.baseUrl + name + (this.isCompressed ? \".bcmap\" : \"\");\n        return this._fetch(url).then((cMapData)=>({\n                cMapData,\n                isCompressed: this.isCompressed\n            })).catch((reason)=>{\n            throw new Error(`Unable to load ${this.isCompressed ? \"binary \" : \"\"}CMap at: ${url}`);\n        });\n    }\n    async _fetch(url) {\n        unreachable(\"Abstract method `_fetch` called.\");\n    }\n}\nclass DOMCMapReaderFactory extends BaseCMapReaderFactory {\n    async _fetch(url) {\n        const data = await fetchData(url, this.isCompressed ? \"arraybuffer\" : \"text\");\n        return data instanceof ArrayBuffer ? new Uint8Array(data) : stringToBytes(data);\n    }\n}\n__nested_webpack_require_192967__(2489);\nclass BaseFilterFactory {\n    addFilter(maps) {\n        return \"none\";\n    }\n    addHCMFilter(fgColor, bgColor) {\n        return \"none\";\n    }\n    addAlphaFilter(map) {\n        return \"none\";\n    }\n    addLuminosityFilter(map) {\n        return \"none\";\n    }\n    addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {\n        return \"none\";\n    }\n    destroy(keepHCM = false) {}\n}\nclass DOMFilterFactory extends BaseFilterFactory {\n    #baseUrl;\n    #_cache;\n    #_defs;\n    #docId;\n    #document;\n    #_hcmCache;\n    #id;\n    constructor({ docId, ownerDocument = globalThis.document }){\n        super();\n        this.#id = 0;\n        this.#docId = docId;\n        this.#document = ownerDocument;\n    }\n    get #cache() {\n        return this.#_cache ||= /* @__PURE__ */ new Map();\n    }\n    get #hcmCache() {\n        return this.#_hcmCache ||= /* @__PURE__ */ new Map();\n    }\n    get #defs() {\n        if (!this.#_defs) {\n            const div = this.#document.createElement(\"div\");\n            const { style } = div;\n            style.visibility = \"hidden\";\n            style.contain = \"strict\";\n            style.width = style.height = 0;\n            style.position = \"absolute\";\n            style.top = style.left = 0;\n            style.zIndex = -1;\n            const svg = this.#document.createElementNS(SVG_NS, \"svg\");\n            svg.setAttribute(\"width\", 0);\n            svg.setAttribute(\"height\", 0);\n            this.#_defs = this.#document.createElementNS(SVG_NS, \"defs\");\n            div.append(svg);\n            svg.append(this.#_defs);\n            this.#document.body.append(div);\n        }\n        return this.#_defs;\n    }\n    #createTables(maps) {\n        if (maps.length === 1) {\n            const mapR2 = maps[0];\n            const buffer = new Array(256);\n            for(let i = 0; i < 256; i++){\n                buffer[i] = mapR2[i] / 255;\n            }\n            const table = buffer.join(\",\");\n            return [\n                table,\n                table,\n                table\n            ];\n        }\n        const [mapR, mapG, mapB] = maps;\n        const bufferR = new Array(256);\n        const bufferG = new Array(256);\n        const bufferB = new Array(256);\n        for(let i = 0; i < 256; i++){\n            bufferR[i] = mapR[i] / 255;\n            bufferG[i] = mapG[i] / 255;\n            bufferB[i] = mapB[i] / 255;\n        }\n        return [\n            bufferR.join(\",\"),\n            bufferG.join(\",\"),\n            bufferB.join(\",\")\n        ];\n    }\n    #createUrl(id) {\n        if (this.#baseUrl === void 0) {\n            this.#baseUrl = \"\";\n            const url = this.#document.URL;\n            if (url !== this.#document.baseURI) {\n                if (isDataScheme(url)) {\n                    warn('#createUrl: ignore \"data:\"-URL for performance reasons.');\n                } else {\n                    this.#baseUrl = updateUrlHash(url, \"\");\n                }\n            }\n        }\n        return `url(${this.#baseUrl}#${id})`;\n    }\n    addFilter(maps) {\n        if (!maps) {\n            return \"none\";\n        }\n        let value1 = this.#cache.get(maps);\n        if (value1) {\n            return value1;\n        }\n        const [tableR, tableG, tableB] = this.#createTables(maps);\n        const key = maps.length === 1 ? tableR : `${tableR}${tableG}${tableB}`;\n        value1 = this.#cache.get(key);\n        if (value1) {\n            this.#cache.set(maps, value1);\n            return value1;\n        }\n        const id = `g_${this.#docId}_transfer_map_${this.#id++}`;\n        const url = this.#createUrl(id);\n        this.#cache.set(maps, url);\n        this.#cache.set(key, url);\n        const filter = this.#createFilter(id);\n        this.#addTransferMapConversion(tableR, tableG, tableB, filter);\n        return url;\n    }\n    addHCMFilter(fgColor, bgColor) {\n        const key = `${fgColor}-${bgColor}`;\n        const filterName = \"base\";\n        let info2 = this.#hcmCache.get(filterName);\n        if (info2?.key === key) {\n            return info2.url;\n        }\n        if (info2) {\n            info2.filter?.remove();\n            info2.key = key;\n            info2.url = \"none\";\n            info2.filter = null;\n        } else {\n            info2 = {\n                key,\n                url: \"none\",\n                filter: null\n            };\n            this.#hcmCache.set(filterName, info2);\n        }\n        if (!fgColor || !bgColor) {\n            return info2.url;\n        }\n        const fgRGB = this.#getRGB(fgColor);\n        fgColor = Util.makeHexColor(...fgRGB);\n        const bgRGB = this.#getRGB(bgColor);\n        bgColor = Util.makeHexColor(...bgRGB);\n        this.#defs.style.color = \"\";\n        if (fgColor === \"#000000\" && bgColor === \"#ffffff\" || fgColor === bgColor) {\n            return info2.url;\n        }\n        const map = new Array(256);\n        for(let i = 0; i <= 255; i++){\n            const x = i / 255;\n            map[i] = x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;\n        }\n        const table = map.join(\",\");\n        const id = `g_${this.#docId}_hcm_filter`;\n        const filter = info2.filter = this.#createFilter(id);\n        this.#addTransferMapConversion(table, table, table, filter);\n        this.#addGrayConversion(filter);\n        const getSteps = (c, n)=>{\n            const start = fgRGB[c] / 255;\n            const end = bgRGB[c] / 255;\n            const arr = new Array(n + 1);\n            for(let i = 0; i <= n; i++){\n                arr[i] = start + i / n * (end - start);\n            }\n            return arr.join(\",\");\n        };\n        this.#addTransferMapConversion(getSteps(0, 5), getSteps(1, 5), getSteps(2, 5), filter);\n        info2.url = this.#createUrl(id);\n        return info2.url;\n    }\n    addAlphaFilter(map) {\n        let value1 = this.#cache.get(map);\n        if (value1) {\n            return value1;\n        }\n        const [tableA] = this.#createTables([\n            map\n        ]);\n        const key = `alpha_${tableA}`;\n        value1 = this.#cache.get(key);\n        if (value1) {\n            this.#cache.set(map, value1);\n            return value1;\n        }\n        const id = `g_${this.#docId}_alpha_map_${this.#id++}`;\n        const url = this.#createUrl(id);\n        this.#cache.set(map, url);\n        this.#cache.set(key, url);\n        const filter = this.#createFilter(id);\n        this.#addTransferMapAlphaConversion(tableA, filter);\n        return url;\n    }\n    addLuminosityFilter(map) {\n        let value1 = this.#cache.get(map || \"luminosity\");\n        if (value1) {\n            return value1;\n        }\n        let tableA, key;\n        if (map) {\n            [tableA] = this.#createTables([\n                map\n            ]);\n            key = `luminosity_${tableA}`;\n        } else {\n            key = \"luminosity\";\n        }\n        value1 = this.#cache.get(key);\n        if (value1) {\n            this.#cache.set(map, value1);\n            return value1;\n        }\n        const id = `g_${this.#docId}_luminosity_map_${this.#id++}`;\n        const url = this.#createUrl(id);\n        this.#cache.set(map, url);\n        this.#cache.set(key, url);\n        const filter = this.#createFilter(id);\n        this.#addLuminosityConversion(filter);\n        if (map) {\n            this.#addTransferMapAlphaConversion(tableA, filter);\n        }\n        return url;\n    }\n    addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {\n        const key = `${fgColor}-${bgColor}-${newFgColor}-${newBgColor}`;\n        let info2 = this.#hcmCache.get(filterName);\n        if (info2?.key === key) {\n            return info2.url;\n        }\n        if (info2) {\n            info2.filter?.remove();\n            info2.key = key;\n            info2.url = \"none\";\n            info2.filter = null;\n        } else {\n            info2 = {\n                key,\n                url: \"none\",\n                filter: null\n            };\n            this.#hcmCache.set(filterName, info2);\n        }\n        if (!fgColor || !bgColor) {\n            return info2.url;\n        }\n        const [fgRGB, bgRGB] = [\n            fgColor,\n            bgColor\n        ].map(this.#getRGB.bind(this));\n        let fgGray = Math.round(0.2126 * fgRGB[0] + 0.7152 * fgRGB[1] + 0.0722 * fgRGB[2]);\n        let bgGray = Math.round(0.2126 * bgRGB[0] + 0.7152 * bgRGB[1] + 0.0722 * bgRGB[2]);\n        let [newFgRGB, newBgRGB] = [\n            newFgColor,\n            newBgColor\n        ].map(this.#getRGB.bind(this));\n        if (bgGray < fgGray) {\n            [fgGray, bgGray, newFgRGB, newBgRGB] = [\n                bgGray,\n                fgGray,\n                newBgRGB,\n                newFgRGB\n            ];\n        }\n        this.#defs.style.color = \"\";\n        const getSteps = (fg, bg, n)=>{\n            const arr = new Array(256);\n            const step = (bgGray - fgGray) / n;\n            const newStart = fg / 255;\n            const newStep = (bg - fg) / (255 * n);\n            let prev = 0;\n            for(let i = 0; i <= n; i++){\n                const k = Math.round(fgGray + i * step);\n                const value1 = newStart + i * newStep;\n                for(let j = prev; j <= k; j++){\n                    arr[j] = value1;\n                }\n                prev = k + 1;\n            }\n            for(let i = prev; i < 256; i++){\n                arr[i] = arr[prev - 1];\n            }\n            return arr.join(\",\");\n        };\n        const id = `g_${this.#docId}_hcm_${filterName}_filter`;\n        const filter = info2.filter = this.#createFilter(id);\n        this.#addGrayConversion(filter);\n        this.#addTransferMapConversion(getSteps(newFgRGB[0], newBgRGB[0], 5), getSteps(newFgRGB[1], newBgRGB[1], 5), getSteps(newFgRGB[2], newBgRGB[2], 5), filter);\n        info2.url = this.#createUrl(id);\n        return info2.url;\n    }\n    destroy(keepHCM = false) {\n        if (keepHCM && this.#_hcmCache?.size) {\n            return;\n        }\n        this.#_defs?.parentNode.parentNode.remove();\n        this.#_defs = null;\n        this.#_cache?.clear();\n        this.#_cache = null;\n        this.#_hcmCache?.clear();\n        this.#_hcmCache = null;\n        this.#id = 0;\n    }\n    #addLuminosityConversion(filter) {\n        const feColorMatrix = this.#document.createElementNS(SVG_NS, \"feColorMatrix\");\n        feColorMatrix.setAttribute(\"type\", \"matrix\");\n        feColorMatrix.setAttribute(\"values\", \"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0.59 0.11 0 0\");\n        filter.append(feColorMatrix);\n    }\n    #addGrayConversion(filter) {\n        const feColorMatrix = this.#document.createElementNS(SVG_NS, \"feColorMatrix\");\n        feColorMatrix.setAttribute(\"type\", \"matrix\");\n        feColorMatrix.setAttribute(\"values\", \"0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0\");\n        filter.append(feColorMatrix);\n    }\n    #createFilter(id) {\n        const filter = this.#document.createElementNS(SVG_NS, \"filter\");\n        filter.setAttribute(\"color-interpolation-filters\", \"sRGB\");\n        filter.setAttribute(\"id\", id);\n        this.#defs.append(filter);\n        return filter;\n    }\n    #appendFeFunc(feComponentTransfer, func, table) {\n        const feFunc = this.#document.createElementNS(SVG_NS, func);\n        feFunc.setAttribute(\"type\", \"discrete\");\n        feFunc.setAttribute(\"tableValues\", table);\n        feComponentTransfer.append(feFunc);\n    }\n    #addTransferMapConversion(rTable, gTable, bTable, filter) {\n        const feComponentTransfer = this.#document.createElementNS(SVG_NS, \"feComponentTransfer\");\n        filter.append(feComponentTransfer);\n        this.#appendFeFunc(feComponentTransfer, \"feFuncR\", rTable);\n        this.#appendFeFunc(feComponentTransfer, \"feFuncG\", gTable);\n        this.#appendFeFunc(feComponentTransfer, \"feFuncB\", bTable);\n    }\n    #addTransferMapAlphaConversion(aTable, filter) {\n        const feComponentTransfer = this.#document.createElementNS(SVG_NS, \"feComponentTransfer\");\n        filter.append(feComponentTransfer);\n        this.#appendFeFunc(feComponentTransfer, \"feFuncA\", aTable);\n    }\n    #getRGB(color) {\n        this.#defs.style.color = color;\n        return getRGB(getComputedStyle(this.#defs).getPropertyValue(\"color\"));\n    }\n}\nclass BaseStandardFontDataFactory {\n    constructor({ baseUrl = null }){\n        this.baseUrl = baseUrl;\n    }\n    async fetch({ filename }) {\n        if (!this.baseUrl) {\n            throw new Error(\"Ensure that the `standardFontDataUrl` API parameter is provided.\");\n        }\n        if (!filename) {\n            throw new Error(\"Font filename must be specified.\");\n        }\n        const url = `${this.baseUrl}${filename}`;\n        return this._fetch(url).catch((reason)=>{\n            throw new Error(`Unable to load font data at: ${url}`);\n        });\n    }\n    async _fetch(url) {\n        unreachable(\"Abstract method `_fetch` called.\");\n    }\n}\nclass DOMStandardFontDataFactory extends BaseStandardFontDataFactory {\n    async _fetch(url) {\n        const data = await fetchData(url, \"arraybuffer\");\n        return new Uint8Array(data);\n    }\n}\nclass BaseWasmFactory {\n    constructor({ baseUrl = null }){\n        this.baseUrl = baseUrl;\n    }\n    async fetch({ filename }) {\n        if (!this.baseUrl) {\n            throw new Error(\"Ensure that the `wasmUrl` API parameter is provided.\");\n        }\n        if (!filename) {\n            throw new Error(\"Wasm filename must be specified.\");\n        }\n        const url = `${this.baseUrl}${filename}`;\n        return this._fetch(url).catch((reason)=>{\n            throw new Error(`Unable to load wasm data at: ${url}`);\n        });\n    }\n    async _fetch(url) {\n        unreachable(\"Abstract method `_fetch` called.\");\n    }\n}\nclass DOMWasmFactory extends BaseWasmFactory {\n    async _fetch(url) {\n        const data = await fetchData(url, \"arraybuffer\");\n        return new Uint8Array(data);\n    }\n}\nif (isNodeJS) {\n    let canvas;\n    try {\n        const require$1 = process.getBuiltinModule(\"module\").createRequire(typeof document === \"undefined\" ? (__webpack_require__(/*! url */ \"url\").pathToFileURL)(__filename).href : _documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === \"SCRIPT\" && _documentCurrentScript.src || new URL(\"index.cjs\", document.baseURI).href);\n        try {\n            canvas = require$1(\"@napi-rs/canvas\");\n        } catch (ex) {\n            warn(`Cannot load \"@napi-rs/canvas\" package: \"${ex}\".`);\n        }\n    } catch (ex) {\n        warn(`Cannot access the \\`require\\` function: \"${ex}\".`);\n    }\n    if (!globalThis.DOMMatrix) {\n        if (canvas?.DOMMatrix) {\n            globalThis.DOMMatrix = canvas.DOMMatrix;\n        } else {\n            warn(\"Cannot polyfill `DOMMatrix`, rendering may be broken.\");\n        }\n    }\n    if (!globalThis.ImageData) {\n        if (canvas?.ImageData) {\n            globalThis.ImageData = canvas.ImageData;\n        } else {\n            warn(\"Cannot polyfill `ImageData`, rendering may be broken.\");\n        }\n    }\n    if (!globalThis.Path2D) {\n        if (canvas?.Path2D) {\n            globalThis.Path2D = canvas.Path2D;\n        } else {\n            warn(\"Cannot polyfill `Path2D`, rendering may be broken.\");\n        }\n    }\n    if (!globalThis.navigator?.language) {\n        globalThis.navigator = {\n            language: \"en-US\",\n            platform: \"\",\n            userAgent: \"\"\n        };\n    }\n}\nasync function node_utils_fetchData(url) {\n    const fs = process.getBuiltinModule(\"fs\");\n    const data = await fs.promises.readFile(url);\n    return new Uint8Array(data);\n}\nclass NodeFilterFactory extends BaseFilterFactory {\n}\nclass NodeCanvasFactory extends BaseCanvasFactory {\n    _createCanvas(width, height) {\n        const require$1 = process.getBuiltinModule(\"module\").createRequire(typeof document === \"undefined\" ? (__webpack_require__(/*! url */ \"url\").pathToFileURL)(__filename).href : _documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === \"SCRIPT\" && _documentCurrentScript.src || new URL(\"index.cjs\", document.baseURI).href);\n        const canvas = require$1(\"@napi-rs/canvas\");\n        return canvas.createCanvas(width, height);\n    }\n}\nclass NodeCMapReaderFactory extends BaseCMapReaderFactory {\n    async _fetch(url) {\n        return node_utils_fetchData(url);\n    }\n}\nclass NodeStandardFontDataFactory extends BaseStandardFontDataFactory {\n    async _fetch(url) {\n        return node_utils_fetchData(url);\n    }\n}\nclass NodeWasmFactory extends BaseWasmFactory {\n    async _fetch(url) {\n        return node_utils_fetchData(url);\n    }\n}\n__nested_webpack_require_192967__(7588);\nconst FORCED_DEPENDENCY_LABEL = \"__forcedDependency\";\nconst { floor, ceil } = Math;\nfunction expandBBox(array, index, minX, minY, maxX, maxY) {\n    array[index * 4 + 0] = Math.min(array[index * 4 + 0], minX);\n    array[index * 4 + 1] = Math.min(array[index * 4 + 1], minY);\n    array[index * 4 + 2] = Math.max(array[index * 4 + 2], maxX);\n    array[index * 4 + 3] = Math.max(array[index * 4 + 3], maxY);\n}\nconst EMPTY_BBOX = new Uint32Array(new Uint8Array([\n    255,\n    255,\n    0,\n    0\n]).buffer)[0];\nclass BBoxReader {\n    #bboxes;\n    #coords;\n    constructor(bboxes, coords){\n        this.#bboxes = bboxes;\n        this.#coords = coords;\n    }\n    get length() {\n        return this.#bboxes.length;\n    }\n    isEmpty(i) {\n        return this.#bboxes[i] === EMPTY_BBOX;\n    }\n    minX(i) {\n        return this.#coords[i * 4 + 0] / 256;\n    }\n    minY(i) {\n        return this.#coords[i * 4 + 1] / 256;\n    }\n    maxX(i) {\n        return (this.#coords[i * 4 + 2] + 1) / 256;\n    }\n    maxY(i) {\n        return (this.#coords[i * 4 + 3] + 1) / 256;\n    }\n}\nconst ensureDebugMetadata = (map, key)=>{\n    if (!map) {\n        return void 0;\n    }\n    let value1 = map.get(key);\n    if (!value1) {\n        value1 = {\n            dependencies: /* @__PURE__ */ new Set(),\n            isRenderingOperation: false\n        };\n        map.set(key, value1);\n    }\n    return value1;\n};\nclass CanvasDependencyTracker {\n    #simple;\n    #incremental;\n    #namedDependencies;\n    #savesStack;\n    #markedContentStack;\n    #baseTransformStack;\n    #clipBox;\n    #pendingBBox;\n    #pendingBBoxIdx;\n    #pendingDependencies;\n    #operations;\n    #fontBBoxTrustworthy;\n    #canvasWidth;\n    #canvasHeight;\n    #bboxesCoords;\n    #bboxes;\n    #debugMetadata;\n    constructor(canvas, operationsCount, recordDebugMetadata = false){\n        this.#simple = {\n            __proto__: null\n        };\n        this.#incremental = {\n            __proto__: null,\n            transform: [],\n            moveText: [],\n            sameLineText: [],\n            [FORCED_DEPENDENCY_LABEL]: []\n        };\n        this.#namedDependencies = /* @__PURE__ */ new Map();\n        this.#savesStack = [];\n        this.#markedContentStack = [];\n        this.#baseTransformStack = [\n            [\n                1,\n                0,\n                0,\n                1,\n                0,\n                0\n            ]\n        ];\n        this.#clipBox = [\n            -Infinity,\n            -Infinity,\n            Infinity,\n            Infinity\n        ];\n        this.#pendingBBox = new Float64Array([\n            Infinity,\n            Infinity,\n            -Infinity,\n            -Infinity\n        ]);\n        this.#pendingBBoxIdx = -1;\n        this.#pendingDependencies = /* @__PURE__ */ new Set();\n        this.#operations = /* @__PURE__ */ new Map();\n        this.#fontBBoxTrustworthy = /* @__PURE__ */ new Map();\n        this.#canvasWidth = canvas.width;\n        this.#canvasHeight = canvas.height;\n        this.#initializeBBoxes(operationsCount);\n        if (recordDebugMetadata) {\n            this.#debugMetadata = /* @__PURE__ */ new Map();\n        }\n    }\n    growOperationsCount(operationsCount) {\n        if (operationsCount >= this.#bboxes.length) {\n            this.#initializeBBoxes(operationsCount, this.#bboxes);\n        }\n    }\n    #initializeBBoxes(operationsCount, oldBBoxes) {\n        const buffer = new ArrayBuffer(operationsCount * 4);\n        this.#bboxesCoords = new Uint8ClampedArray(buffer);\n        this.#bboxes = new Uint32Array(buffer);\n        if (oldBBoxes && oldBBoxes.length > 0) {\n            this.#bboxes.set(oldBBoxes);\n            this.#bboxes.fill(EMPTY_BBOX, oldBBoxes.length);\n        } else {\n            this.#bboxes.fill(EMPTY_BBOX);\n        }\n    }\n    save(opIdx) {\n        this.#simple = {\n            __proto__: this.#simple\n        };\n        this.#incremental = {\n            __proto__: this.#incremental,\n            transform: {\n                __proto__: this.#incremental.transform\n            },\n            moveText: {\n                __proto__: this.#incremental.moveText\n            },\n            sameLineText: {\n                __proto__: this.#incremental.sameLineText\n            },\n            [FORCED_DEPENDENCY_LABEL]: {\n                __proto__: this.#incremental[FORCED_DEPENDENCY_LABEL]\n            }\n        };\n        this.#clipBox = {\n            __proto__: this.#clipBox\n        };\n        this.#savesStack.push(opIdx);\n        return this;\n    }\n    restore(opIdx) {\n        const previous = Object.getPrototypeOf(this.#simple);\n        if (previous === null) {\n            return this;\n        }\n        this.#simple = previous;\n        this.#incremental = Object.getPrototypeOf(this.#incremental);\n        this.#clipBox = Object.getPrototypeOf(this.#clipBox);\n        const lastSave = this.#savesStack.pop();\n        if (lastSave !== void 0) {\n            ensureDebugMetadata(this.#debugMetadata, opIdx)?.dependencies.add(lastSave);\n            this.#bboxes[opIdx] = this.#bboxes[lastSave];\n        }\n        return this;\n    }\n    recordOpenMarker(idx) {\n        this.#savesStack.push(idx);\n        return this;\n    }\n    getOpenMarker() {\n        if (this.#savesStack.length === 0) {\n            return null;\n        }\n        return this.#savesStack.at(-1);\n    }\n    recordCloseMarker(opIdx) {\n        const lastSave = this.#savesStack.pop();\n        if (lastSave !== void 0) {\n            ensureDebugMetadata(this.#debugMetadata, opIdx)?.dependencies.add(lastSave);\n            this.#bboxes[opIdx] = this.#bboxes[lastSave];\n        }\n        return this;\n    }\n    beginMarkedContent(opIdx) {\n        this.#markedContentStack.push(opIdx);\n        return this;\n    }\n    endMarkedContent(opIdx) {\n        const lastSave = this.#markedContentStack.pop();\n        if (lastSave !== void 0) {\n            ensureDebugMetadata(this.#debugMetadata, opIdx)?.dependencies.add(lastSave);\n            this.#bboxes[opIdx] = this.#bboxes[lastSave];\n        }\n        return this;\n    }\n    pushBaseTransform(ctx) {\n        this.#baseTransformStack.push(Util.multiplyByDOMMatrix(this.#baseTransformStack.at(-1), ctx.getTransform()));\n        return this;\n    }\n    popBaseTransform() {\n        if (this.#baseTransformStack.length > 1) {\n            this.#baseTransformStack.pop();\n        }\n        return this;\n    }\n    recordSimpleData(name, idx) {\n        this.#simple[name] = idx;\n        return this;\n    }\n    recordIncrementalData(name, idx) {\n        this.#incremental[name].push(idx);\n        return this;\n    }\n    resetIncrementalData(name, idx) {\n        this.#incremental[name].length = 0;\n        return this;\n    }\n    recordNamedData(name, idx) {\n        this.#namedDependencies.set(name, idx);\n        return this;\n    }\n    recordSimpleDataFromNamed(name, depName, fallbackIdx) {\n        this.#simple[name] = this.#namedDependencies.get(depName) ?? fallbackIdx;\n    }\n    recordFutureForcedDependency(name, idx) {\n        this.recordIncrementalData(FORCED_DEPENDENCY_LABEL, idx);\n        return this;\n    }\n    inheritSimpleDataAsFutureForcedDependencies(names) {\n        for (const name of names){\n            if (name in this.#simple) {\n                this.recordFutureForcedDependency(name, this.#simple[name]);\n            }\n        }\n        return this;\n    }\n    inheritPendingDependenciesAsFutureForcedDependencies() {\n        for (const dep of this.#pendingDependencies){\n            this.recordFutureForcedDependency(FORCED_DEPENDENCY_LABEL, dep);\n        }\n        return this;\n    }\n    resetBBox(idx) {\n        if (this.#pendingBBoxIdx !== idx) {\n            this.#pendingBBoxIdx = idx;\n            this.#pendingBBox[0] = Infinity;\n            this.#pendingBBox[1] = Infinity;\n            this.#pendingBBox[2] = -Infinity;\n            this.#pendingBBox[3] = -Infinity;\n        }\n        return this;\n    }\n    recordClipBox(idx, ctx, minX, maxX, minY, maxY) {\n        const transform = Util.multiplyByDOMMatrix(this.#baseTransformStack.at(-1), ctx.getTransform());\n        const clipBox = [\n            Infinity,\n            Infinity,\n            -Infinity,\n            -Infinity\n        ];\n        Util.axialAlignedBoundingBox([\n            minX,\n            minY,\n            maxX,\n            maxY\n        ], transform, clipBox);\n        const intersection = Util.intersect(this.#clipBox, clipBox);\n        if (intersection) {\n            this.#clipBox[0] = intersection[0];\n            this.#clipBox[1] = intersection[1];\n            this.#clipBox[2] = intersection[2];\n            this.#clipBox[3] = intersection[3];\n        } else {\n            this.#clipBox[0] = this.#clipBox[1] = Infinity;\n            this.#clipBox[2] = this.#clipBox[3] = -Infinity;\n        }\n        return this;\n    }\n    recordBBox(idx, ctx, minX, maxX, minY, maxY) {\n        const clipBox = this.#clipBox;\n        if (clipBox[0] === Infinity) {\n            return this;\n        }\n        const transform = Util.multiplyByDOMMatrix(this.#baseTransformStack.at(-1), ctx.getTransform());\n        if (clipBox[0] === -Infinity) {\n            Util.axialAlignedBoundingBox([\n                minX,\n                minY,\n                maxX,\n                maxY\n            ], transform, this.#pendingBBox);\n            return this;\n        }\n        const bbox = [\n            Infinity,\n            Infinity,\n            -Infinity,\n            -Infinity\n        ];\n        Util.axialAlignedBoundingBox([\n            minX,\n            minY,\n            maxX,\n            maxY\n        ], transform, bbox);\n        this.#pendingBBox[0] = Math.min(this.#pendingBBox[0], Math.max(bbox[0], clipBox[0]));\n        this.#pendingBBox[1] = Math.min(this.#pendingBBox[1], Math.max(bbox[1], clipBox[1]));\n        this.#pendingBBox[2] = Math.max(this.#pendingBBox[2], Math.min(bbox[2], clipBox[2]));\n        this.#pendingBBox[3] = Math.max(this.#pendingBBox[3], Math.min(bbox[3], clipBox[3]));\n        return this;\n    }\n    recordCharacterBBox(idx, ctx, font, scale = 1, x = 0, y = 0, getMeasure) {\n        const fontBBox = font.bbox;\n        let isBBoxTrustworthy;\n        let computedBBox;\n        if (fontBBox) {\n            isBBoxTrustworthy = fontBBox[2] !== fontBBox[0] && fontBBox[3] !== fontBBox[1] && this.#fontBBoxTrustworthy.get(font);\n            if (isBBoxTrustworthy !== false) {\n                computedBBox = [\n                    0,\n                    0,\n                    0,\n                    0\n                ];\n                Util.axialAlignedBoundingBox(fontBBox, font.fontMatrix, computedBBox);\n                if (scale !== 1 || x !== 0 || y !== 0) {\n                    Util.scaleMinMax([\n                        scale,\n                        0,\n                        0,\n                        -scale,\n                        x,\n                        y\n                    ], computedBBox);\n                }\n                if (isBBoxTrustworthy) {\n                    return this.recordBBox(idx, ctx, computedBBox[0], computedBBox[2], computedBBox[1], computedBBox[3]);\n                }\n            }\n        }\n        if (!getMeasure) {\n            return this.recordFullPageBBox(idx);\n        }\n        const measure = getMeasure();\n        if (fontBBox && computedBBox && isBBoxTrustworthy === void 0) {\n            isBBoxTrustworthy = computedBBox[0] <= x - measure.actualBoundingBoxLeft && computedBBox[2] >= x + measure.actualBoundingBoxRight && computedBBox[1] <= y - measure.actualBoundingBoxAscent && computedBBox[3] >= y + measure.actualBoundingBoxDescent;\n            this.#fontBBoxTrustworthy.set(font, isBBoxTrustworthy);\n            if (isBBoxTrustworthy) {\n                return this.recordBBox(idx, ctx, computedBBox[0], computedBBox[2], computedBBox[1], computedBBox[3]);\n            }\n        }\n        return this.recordBBox(idx, ctx, x - measure.actualBoundingBoxLeft, x + measure.actualBoundingBoxRight, y - measure.actualBoundingBoxAscent, y + measure.actualBoundingBoxDescent);\n    }\n    recordFullPageBBox(idx) {\n        this.#pendingBBox[0] = Math.max(0, this.#clipBox[0]);\n        this.#pendingBBox[1] = Math.max(0, this.#clipBox[1]);\n        this.#pendingBBox[2] = Math.min(this.#canvasWidth, this.#clipBox[2]);\n        this.#pendingBBox[3] = Math.min(this.#canvasHeight, this.#clipBox[3]);\n        return this;\n    }\n    getSimpleIndex(dependencyName) {\n        return this.#simple[dependencyName];\n    }\n    recordDependencies(idx, dependencyNames) {\n        const pendingDependencies = this.#pendingDependencies;\n        const simple = this.#simple;\n        const incremental = this.#incremental;\n        for (const name of dependencyNames){\n            if (name in this.#simple) {\n                pendingDependencies.add(simple[name]);\n            } else if (name in incremental) {\n                incremental[name].forEach(pendingDependencies.add, pendingDependencies);\n            }\n        }\n        return this;\n    }\n    recordNamedDependency(idx, name) {\n        if (this.#namedDependencies.has(name)) {\n            this.#pendingDependencies.add(this.#namedDependencies.get(name));\n        }\n        return this;\n    }\n    recordOperation(idx, preserve = false) {\n        this.recordDependencies(idx, [\n            FORCED_DEPENDENCY_LABEL\n        ]);\n        if (this.#debugMetadata) {\n            const metadata = ensureDebugMetadata(this.#debugMetadata, idx);\n            const { dependencies } = metadata;\n            this.#pendingDependencies.forEach(dependencies.add, dependencies);\n            this.#savesStack.forEach(dependencies.add, dependencies);\n            this.#markedContentStack.forEach(dependencies.add, dependencies);\n            dependencies.delete(idx);\n            metadata.isRenderingOperation = true;\n        }\n        if (this.#pendingBBoxIdx === idx) {\n            const minX = floor(this.#pendingBBox[0] * 256 / this.#canvasWidth);\n            const minY = floor(this.#pendingBBox[1] * 256 / this.#canvasHeight);\n            const maxX = ceil(this.#pendingBBox[2] * 256 / this.#canvasWidth);\n            const maxY = ceil(this.#pendingBBox[3] * 256 / this.#canvasHeight);\n            expandBBox(this.#bboxesCoords, idx, minX, minY, maxX, maxY);\n            for (const depIdx of this.#pendingDependencies){\n                if (depIdx !== idx) {\n                    expandBBox(this.#bboxesCoords, depIdx, minX, minY, maxX, maxY);\n                }\n            }\n            for (const saveIdx of this.#savesStack){\n                if (saveIdx !== idx) {\n                    expandBBox(this.#bboxesCoords, saveIdx, minX, minY, maxX, maxY);\n                }\n            }\n            for (const saveIdx of this.#markedContentStack){\n                if (saveIdx !== idx) {\n                    expandBBox(this.#bboxesCoords, saveIdx, minX, minY, maxX, maxY);\n                }\n            }\n            if (!preserve) {\n                this.#pendingDependencies.clear();\n                this.#pendingBBoxIdx = -1;\n            }\n        }\n        return this;\n    }\n    recordShowTextOperation(idx, preserve = false) {\n        const deps = Array.from(this.#pendingDependencies);\n        this.recordOperation(idx, preserve);\n        this.recordIncrementalData(\"sameLineText\", idx);\n        for (const dep of deps){\n            this.recordIncrementalData(\"sameLineText\", dep);\n        }\n        return this;\n    }\n    bboxToClipBoxDropOperation(idx, preserve = false) {\n        if (this.#pendingBBoxIdx === idx) {\n            this.#pendingBBoxIdx = -1;\n            this.#clipBox[0] = Math.max(this.#clipBox[0], this.#pendingBBox[0]);\n            this.#clipBox[1] = Math.max(this.#clipBox[1], this.#pendingBBox[1]);\n            this.#clipBox[2] = Math.min(this.#clipBox[2], this.#pendingBBox[2]);\n            this.#clipBox[3] = Math.min(this.#clipBox[3], this.#pendingBBox[3]);\n            if (!preserve) {\n                this.#pendingDependencies.clear();\n            }\n        }\n        return this;\n    }\n    _takePendingDependencies() {\n        const pendingDependencies = this.#pendingDependencies;\n        this.#pendingDependencies = /* @__PURE__ */ new Set();\n        return pendingDependencies;\n    }\n    _extractOperation(idx) {\n        const operation = this.#operations.get(idx);\n        this.#operations.delete(idx);\n        return operation;\n    }\n    _pushPendingDependencies(dependencies) {\n        for (const dep of dependencies){\n            this.#pendingDependencies.add(dep);\n        }\n    }\n    take() {\n        this.#fontBBoxTrustworthy.clear();\n        return new BBoxReader(this.#bboxes, this.#bboxesCoords);\n    }\n    takeDebugMetadata() {\n        return this.#debugMetadata;\n    }\n}\nclass CanvasNestedDependencyTracker {\n    #dependencyTracker;\n    #opIdx;\n    #ignoreBBoxes;\n    #nestingLevel;\n    #savesLevel;\n    constructor(dependencyTracker, opIdx, ignoreBBoxes){\n        this.#nestingLevel = 0;\n        this.#savesLevel = 0;\n        if (dependencyTracker instanceof CanvasNestedDependencyTracker && dependencyTracker.#ignoreBBoxes === !!ignoreBBoxes) {\n            return dependencyTracker;\n        }\n        this.#dependencyTracker = dependencyTracker;\n        this.#opIdx = opIdx;\n        this.#ignoreBBoxes = !!ignoreBBoxes;\n    }\n    growOperationsCount() {\n        throw new Error(\"Unreachable\");\n    }\n    save(opIdx) {\n        this.#savesLevel++;\n        this.#dependencyTracker.save(this.#opIdx);\n        return this;\n    }\n    restore(opIdx) {\n        if (this.#savesLevel > 0) {\n            this.#dependencyTracker.restore(this.#opIdx);\n            this.#savesLevel--;\n        }\n        return this;\n    }\n    recordOpenMarker(idx) {\n        this.#nestingLevel++;\n        return this;\n    }\n    getOpenMarker() {\n        return this.#nestingLevel > 0 ? this.#opIdx : this.#dependencyTracker.getOpenMarker();\n    }\n    recordCloseMarker(idx) {\n        this.#nestingLevel--;\n        return this;\n    }\n    beginMarkedContent(opIdx) {\n        return this;\n    }\n    endMarkedContent(opIdx) {\n        return this;\n    }\n    pushBaseTransform(ctx) {\n        this.#dependencyTracker.pushBaseTransform(ctx);\n        return this;\n    }\n    popBaseTransform() {\n        this.#dependencyTracker.popBaseTransform();\n        return this;\n    }\n    recordSimpleData(name, idx) {\n        this.#dependencyTracker.recordSimpleData(name, this.#opIdx);\n        return this;\n    }\n    recordIncrementalData(name, idx) {\n        this.#dependencyTracker.recordIncrementalData(name, this.#opIdx);\n        return this;\n    }\n    resetIncrementalData(name, idx) {\n        this.#dependencyTracker.resetIncrementalData(name, this.#opIdx);\n        return this;\n    }\n    recordNamedData(name, idx) {\n        return this;\n    }\n    recordSimpleDataFromNamed(name, depName, fallbackIdx) {\n        this.#dependencyTracker.recordSimpleDataFromNamed(name, depName, this.#opIdx);\n        return this;\n    }\n    recordFutureForcedDependency(name, idx) {\n        this.#dependencyTracker.recordFutureForcedDependency(name, this.#opIdx);\n        return this;\n    }\n    inheritSimpleDataAsFutureForcedDependencies(names) {\n        this.#dependencyTracker.inheritSimpleDataAsFutureForcedDependencies(names);\n        return this;\n    }\n    inheritPendingDependenciesAsFutureForcedDependencies() {\n        this.#dependencyTracker.inheritPendingDependenciesAsFutureForcedDependencies();\n        return this;\n    }\n    resetBBox(idx) {\n        if (!this.#ignoreBBoxes) {\n            this.#dependencyTracker.resetBBox(this.#opIdx);\n        }\n        return this;\n    }\n    recordClipBox(idx, ctx, minX, maxX, minY, maxY) {\n        if (!this.#ignoreBBoxes) {\n            this.#dependencyTracker.recordClipBox(this.#opIdx, ctx, minX, maxX, minY, maxY);\n        }\n        return this;\n    }\n    recordBBox(idx, ctx, minX, maxX, minY, maxY) {\n        if (!this.#ignoreBBoxes) {\n            this.#dependencyTracker.recordBBox(this.#opIdx, ctx, minX, maxX, minY, maxY);\n        }\n        return this;\n    }\n    recordCharacterBBox(idx, ctx, font, scale, x, y, getMeasure) {\n        if (!this.#ignoreBBoxes) {\n            this.#dependencyTracker.recordCharacterBBox(this.#opIdx, ctx, font, scale, x, y, getMeasure);\n        }\n        return this;\n    }\n    recordFullPageBBox(idx) {\n        if (!this.#ignoreBBoxes) {\n            this.#dependencyTracker.recordFullPageBBox(this.#opIdx);\n        }\n        return this;\n    }\n    getSimpleIndex(dependencyName) {\n        return this.#dependencyTracker.getSimpleIndex(dependencyName);\n    }\n    recordDependencies(idx, dependencyNames) {\n        this.#dependencyTracker.recordDependencies(this.#opIdx, dependencyNames);\n        return this;\n    }\n    recordNamedDependency(idx, name) {\n        this.#dependencyTracker.recordNamedDependency(this.#opIdx, name);\n        return this;\n    }\n    recordOperation(idx) {\n        this.#dependencyTracker.recordOperation(this.#opIdx, true);\n        return this;\n    }\n    recordShowTextOperation(idx) {\n        this.#dependencyTracker.recordShowTextOperation(this.#opIdx, true);\n        return this;\n    }\n    bboxToClipBoxDropOperation(idx) {\n        if (!this.#ignoreBBoxes) {\n            this.#dependencyTracker.bboxToClipBoxDropOperation(this.#opIdx, true);\n        }\n        return this;\n    }\n    take() {\n        throw new Error(\"Unreachable\");\n    }\n    takeDebugMetadata() {\n        throw new Error(\"Unreachable\");\n    }\n}\nconst Dependencies = {\n    stroke: [\n        \"path\",\n        \"transform\",\n        \"filter\",\n        \"strokeColor\",\n        \"strokeAlpha\",\n        \"lineWidth\",\n        \"lineCap\",\n        \"lineJoin\",\n        \"miterLimit\",\n        \"dash\"\n    ],\n    fill: [\n        \"path\",\n        \"transform\",\n        \"filter\",\n        \"fillColor\",\n        \"fillAlpha\",\n        \"globalCompositeOperation\",\n        \"SMask\"\n    ],\n    imageXObject: [\n        \"transform\",\n        \"SMask\",\n        \"filter\",\n        \"fillAlpha\",\n        \"strokeAlpha\",\n        \"globalCompositeOperation\"\n    ],\n    rawFillPath: [\n        \"filter\",\n        \"fillColor\",\n        \"fillAlpha\"\n    ],\n    showText: [\n        \"transform\",\n        \"leading\",\n        \"charSpacing\",\n        \"wordSpacing\",\n        \"hScale\",\n        \"textRise\",\n        \"moveText\",\n        \"textMatrix\",\n        \"font\",\n        \"fontObj\",\n        \"filter\",\n        \"fillColor\",\n        \"textRenderingMode\",\n        \"SMask\",\n        \"fillAlpha\",\n        \"strokeAlpha\",\n        \"globalCompositeOperation\",\n        \"sameLineText\"\n    ],\n    transform: [\n        \"transform\"\n    ],\n    transformAndFill: [\n        \"transform\",\n        \"fillColor\"\n    ]\n};\nconst PathType = {\n    FILL: \"Fill\",\n    STROKE: \"Stroke\",\n    SHADING: \"Shading\"\n};\nfunction applyBoundingBox(ctx, bbox) {\n    if (!bbox) {\n        return;\n    }\n    const width = bbox[2] - bbox[0];\n    const height = bbox[3] - bbox[1];\n    const region = new Path2D();\n    region.rect(bbox[0], bbox[1], width, height);\n    ctx.clip(region);\n}\nclass BaseShadingPattern {\n    isModifyingCurrentTransform() {\n        return false;\n    }\n    getPattern() {\n        unreachable(\"Abstract method `getPattern` called.\");\n    }\n}\nclass RadialAxialShadingPattern extends BaseShadingPattern {\n    constructor(IR){\n        super();\n        this._type = IR[1];\n        this._bbox = IR[2];\n        this._colorStops = IR[3];\n        this._p0 = IR[4];\n        this._p1 = IR[5];\n        this._r0 = IR[6];\n        this._r1 = IR[7];\n        this.matrix = null;\n    }\n    _createGradient(ctx) {\n        let grad;\n        if (this._type === \"axial\") {\n            grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);\n        } else if (this._type === \"radial\") {\n            grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);\n        }\n        for (const colorStop of this._colorStops){\n            grad.addColorStop(colorStop[0], colorStop[1]);\n        }\n        return grad;\n    }\n    getPattern(ctx, owner, inverse, pathType) {\n        let pattern;\n        if (pathType === PathType.STROKE || pathType === PathType.FILL) {\n            const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, getCurrentTransform(ctx)) || [\n                0,\n                0,\n                0,\n                0\n            ];\n            const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;\n            const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;\n            const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", width, height);\n            const tmpCtx = tmpCanvas.context;\n            tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n            tmpCtx.beginPath();\n            tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n            tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);\n            inverse = Util.transform(inverse, [\n                1,\n                0,\n                0,\n                1,\n                ownerBBox[0],\n                ownerBBox[1]\n            ]);\n            tmpCtx.transform(...owner.baseTransform);\n            if (this.matrix) {\n                tmpCtx.transform(...this.matrix);\n            }\n            applyBoundingBox(tmpCtx, this._bbox);\n            tmpCtx.fillStyle = this._createGradient(tmpCtx);\n            tmpCtx.fill();\n            pattern = ctx.createPattern(tmpCanvas.canvas, \"no-repeat\");\n            const domMatrix = new DOMMatrix(inverse);\n            pattern.setTransform(domMatrix);\n        } else {\n            applyBoundingBox(ctx, this._bbox);\n            pattern = this._createGradient(ctx);\n        }\n        return pattern;\n    }\n}\nfunction drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {\n    const coords = context.coords, colors = context.colors;\n    const bytes = data.data, rowSize = data.width * 4;\n    let tmp;\n    if (coords[p1 + 1] > coords[p2 + 1]) {\n        tmp = p1;\n        p1 = p2;\n        p2 = tmp;\n        tmp = c1;\n        c1 = c2;\n        c2 = tmp;\n    }\n    if (coords[p2 + 1] > coords[p3 + 1]) {\n        tmp = p2;\n        p2 = p3;\n        p3 = tmp;\n        tmp = c2;\n        c2 = c3;\n        c3 = tmp;\n    }\n    if (coords[p1 + 1] > coords[p2 + 1]) {\n        tmp = p1;\n        p1 = p2;\n        p2 = tmp;\n        tmp = c1;\n        c1 = c2;\n        c2 = tmp;\n    }\n    const x1 = (coords[p1] + context.offsetX) * context.scaleX;\n    const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;\n    const x2 = (coords[p2] + context.offsetX) * context.scaleX;\n    const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;\n    const x3 = (coords[p3] + context.offsetX) * context.scaleX;\n    const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;\n    if (y1 >= y3) {\n        return;\n    }\n    const c1r = colors[c1], c1g = colors[c1 + 1], c1b = colors[c1 + 2];\n    const c2r = colors[c2], c2g = colors[c2 + 1], c2b = colors[c2 + 2];\n    const c3r = colors[c3], c3g = colors[c3 + 1], c3b = colors[c3 + 2];\n    const minY = Math.round(y1), maxY = Math.round(y3);\n    let xa, car, cag, cab;\n    let xb, cbr, cbg, cbb;\n    for(let y = minY; y <= maxY; y++){\n        if (y < y2) {\n            const k2 = y < y1 ? 0 : (y1 - y) / (y1 - y2);\n            xa = x1 - (x1 - x2) * k2;\n            car = c1r - (c1r - c2r) * k2;\n            cag = c1g - (c1g - c2g) * k2;\n            cab = c1b - (c1b - c2b) * k2;\n        } else {\n            let k2;\n            if (y > y3) {\n                k2 = 1;\n            } else if (y2 === y3) {\n                k2 = 0;\n            } else {\n                k2 = (y2 - y) / (y2 - y3);\n            }\n            xa = x2 - (x2 - x3) * k2;\n            car = c2r - (c2r - c3r) * k2;\n            cag = c2g - (c2g - c3g) * k2;\n            cab = c2b - (c2b - c3b) * k2;\n        }\n        let k;\n        if (y < y1) {\n            k = 0;\n        } else if (y > y3) {\n            k = 1;\n        } else {\n            k = (y1 - y) / (y1 - y3);\n        }\n        xb = x1 - (x1 - x3) * k;\n        cbr = c1r - (c1r - c3r) * k;\n        cbg = c1g - (c1g - c3g) * k;\n        cbb = c1b - (c1b - c3b) * k;\n        const x1_ = Math.round(Math.min(xa, xb));\n        const x2_ = Math.round(Math.max(xa, xb));\n        let j = rowSize * y + x1_ * 4;\n        for(let x = x1_; x <= x2_; x++){\n            k = (xa - x) / (xa - xb);\n            if (k < 0) {\n                k = 0;\n            } else if (k > 1) {\n                k = 1;\n            }\n            bytes[j++] = car - (car - cbr) * k | 0;\n            bytes[j++] = cag - (cag - cbg) * k | 0;\n            bytes[j++] = cab - (cab - cbb) * k | 0;\n            bytes[j++] = 255;\n        }\n    }\n}\nfunction drawFigure(data, figure, context) {\n    const ps = figure.coords;\n    const cs = figure.colors;\n    let i, ii;\n    switch(figure.type){\n        case \"lattice\":\n            const verticesPerRow = figure.verticesPerRow;\n            const rows = Math.floor(ps.length / verticesPerRow) - 1;\n            const cols = verticesPerRow - 1;\n            for(i = 0; i < rows; i++){\n                let q = i * verticesPerRow;\n                for(let j = 0; j < cols; j++, q++){\n                    drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);\n                    drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);\n                }\n            }\n            break;\n        case \"triangles\":\n            for(i = 0, ii = ps.length; i < ii; i += 3){\n                drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);\n            }\n            break;\n        default:\n            throw new Error(\"illegal figure\");\n    }\n}\nclass MeshShadingPattern extends BaseShadingPattern {\n    constructor(IR){\n        super();\n        this._coords = IR[2];\n        this._colors = IR[3];\n        this._figures = IR[4];\n        this._bounds = IR[5];\n        this._bbox = IR[6];\n        this._background = IR[7];\n        this.matrix = null;\n    }\n    _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {\n        const EXPECTED_SCALE = 1.1;\n        const MAX_PATTERN_SIZE = 3e3;\n        const BORDER_SIZE = 2;\n        const offsetX = Math.floor(this._bounds[0]);\n        const offsetY = Math.floor(this._bounds[1]);\n        const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;\n        const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;\n        const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n        const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n        const scaleX = boundsWidth / width;\n        const scaleY = boundsHeight / height;\n        const context = {\n            coords: this._coords,\n            colors: this._colors,\n            offsetX: -offsetX,\n            offsetY: -offsetY,\n            scaleX: 1 / scaleX,\n            scaleY: 1 / scaleY\n        };\n        const paddedWidth = width + BORDER_SIZE * 2;\n        const paddedHeight = height + BORDER_SIZE * 2;\n        const tmpCanvas = cachedCanvases.getCanvas(\"mesh\", paddedWidth, paddedHeight);\n        const tmpCtx = tmpCanvas.context;\n        const data = tmpCtx.createImageData(width, height);\n        if (backgroundColor) {\n            const bytes = data.data;\n            for(let i = 0, ii = bytes.length; i < ii; i += 4){\n                bytes[i] = backgroundColor[0];\n                bytes[i + 1] = backgroundColor[1];\n                bytes[i + 2] = backgroundColor[2];\n                bytes[i + 3] = 255;\n            }\n        }\n        for (const figure of this._figures){\n            drawFigure(data, figure, context);\n        }\n        tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);\n        const canvas = tmpCanvas.canvas;\n        return {\n            canvas,\n            offsetX: offsetX - BORDER_SIZE * scaleX,\n            offsetY: offsetY - BORDER_SIZE * scaleY,\n            scaleX,\n            scaleY\n        };\n    }\n    isModifyingCurrentTransform() {\n        return true;\n    }\n    getPattern(ctx, owner, inverse, pathType) {\n        applyBoundingBox(ctx, this._bbox);\n        const scale = new Float32Array(2);\n        if (pathType === PathType.SHADING) {\n            Util.singularValueDecompose2dScale(getCurrentTransform(ctx), scale);\n        } else if (this.matrix) {\n            Util.singularValueDecompose2dScale(this.matrix, scale);\n            const [matrixScaleX, matrixScaleY] = scale;\n            Util.singularValueDecompose2dScale(owner.baseTransform, scale);\n            scale[0] *= matrixScaleX;\n            scale[1] *= matrixScaleY;\n        } else {\n            Util.singularValueDecompose2dScale(owner.baseTransform, scale);\n        }\n        const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);\n        if (pathType !== PathType.SHADING) {\n            ctx.setTransform(...owner.baseTransform);\n            if (this.matrix) {\n                ctx.transform(...this.matrix);\n            }\n        }\n        ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n        ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);\n        return ctx.createPattern(temporaryPatternCanvas.canvas, \"no-repeat\");\n    }\n}\nclass DummyShadingPattern extends BaseShadingPattern {\n    getPattern() {\n        return \"hotpink\";\n    }\n}\nfunction getShadingPattern(IR) {\n    switch(IR[0]){\n        case \"RadialAxial\":\n            return new RadialAxialShadingPattern(IR);\n        case \"Mesh\":\n            return new MeshShadingPattern(IR);\n        case \"Dummy\":\n            return new DummyShadingPattern();\n    }\n    throw new Error(`Unknown IR type: ${IR[0]}`);\n}\nconst PaintType = {\n    COLORED: 1,\n    UNCOLORED: 2\n};\nclass TilingPattern {\n    static{\n        this.MAX_PATTERN_SIZE = 3e3;\n    }\n    constructor(IR, ctx, canvasGraphicsFactory, baseTransform){\n        this.color = IR[1];\n        this.operatorList = IR[2];\n        this.matrix = IR[3];\n        this.bbox = IR[4];\n        this.xstep = IR[5];\n        this.ystep = IR[6];\n        this.paintType = IR[7];\n        this.tilingType = IR[8];\n        this.ctx = ctx;\n        this.canvasGraphicsFactory = canvasGraphicsFactory;\n        this.baseTransform = baseTransform;\n    }\n    createPatternCanvas(owner, opIdx) {\n        const { bbox, operatorList, paintType, tilingType, color, canvasGraphicsFactory } = this;\n        let { xstep, ystep } = this;\n        xstep = Math.abs(xstep);\n        ystep = Math.abs(ystep);\n        info(\"TilingType: \" + tilingType);\n        const x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3];\n        const width = x1 - x0;\n        const height = y1 - y0;\n        const scale = new Float32Array(2);\n        Util.singularValueDecompose2dScale(this.matrix, scale);\n        const [matrixScaleX, matrixScaleY] = scale;\n        Util.singularValueDecompose2dScale(this.baseTransform, scale);\n        const combinedScaleX = matrixScaleX * scale[0];\n        const combinedScaleY = matrixScaleY * scale[1];\n        let canvasWidth = width, canvasHeight = height, redrawHorizontally = false, redrawVertically = false;\n        const xScaledStep = Math.ceil(xstep * combinedScaleX);\n        const yScaledStep = Math.ceil(ystep * combinedScaleY);\n        const xScaledWidth = Math.ceil(width * combinedScaleX);\n        const yScaledHeight = Math.ceil(height * combinedScaleY);\n        if (xScaledStep >= xScaledWidth) {\n            canvasWidth = xstep;\n        } else {\n            redrawHorizontally = true;\n        }\n        if (yScaledStep >= yScaledHeight) {\n            canvasHeight = ystep;\n        } else {\n            redrawVertically = true;\n        }\n        const dimx = this.getSizeAndScale(canvasWidth, this.ctx.canvas.width, combinedScaleX);\n        const dimy = this.getSizeAndScale(canvasHeight, this.ctx.canvas.height, combinedScaleY);\n        const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", dimx.size, dimy.size);\n        const tmpCtx = tmpCanvas.context;\n        const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx, opIdx);\n        graphics.groupLevel = owner.groupLevel;\n        this.setFillAndStrokeStyleToContext(graphics, paintType, color);\n        tmpCtx.translate(-dimx.scale * x0, -dimy.scale * y0);\n        graphics.transform(0, dimx.scale, 0, 0, dimy.scale, 0, 0);\n        tmpCtx.save();\n        graphics.dependencyTracker?.save();\n        this.clipBbox(graphics, x0, y0, x1, y1);\n        graphics.baseTransform = getCurrentTransform(graphics.ctx);\n        graphics.executeOperatorList(operatorList);\n        graphics.endDrawing();\n        graphics.dependencyTracker?.restore();\n        tmpCtx.restore();\n        if (redrawHorizontally || redrawVertically) {\n            const image = tmpCanvas.canvas;\n            if (redrawHorizontally) {\n                canvasWidth = xstep;\n            }\n            if (redrawVertically) {\n                canvasHeight = ystep;\n            }\n            const dimx2 = this.getSizeAndScale(canvasWidth, this.ctx.canvas.width, combinedScaleX);\n            const dimy2 = this.getSizeAndScale(canvasHeight, this.ctx.canvas.height, combinedScaleY);\n            const xSize = dimx2.size;\n            const ySize = dimy2.size;\n            const tmpCanvas2 = owner.cachedCanvases.getCanvas(\"pattern-workaround\", xSize, ySize);\n            const tmpCtx2 = tmpCanvas2.context;\n            const ii = redrawHorizontally ? Math.floor(width / xstep) : 0;\n            const jj = redrawVertically ? Math.floor(height / ystep) : 0;\n            for(let i = 0; i <= ii; i++){\n                for(let j = 0; j <= jj; j++){\n                    tmpCtx2.drawImage(image, xSize * i, ySize * j, xSize, ySize, 0, 0, xSize, ySize);\n                }\n            }\n            return {\n                canvas: tmpCanvas2.canvas,\n                scaleX: dimx2.scale,\n                scaleY: dimy2.scale,\n                offsetX: x0,\n                offsetY: y0\n            };\n        }\n        return {\n            canvas: tmpCanvas.canvas,\n            scaleX: dimx.scale,\n            scaleY: dimy.scale,\n            offsetX: x0,\n            offsetY: y0\n        };\n    }\n    getSizeAndScale(step, realOutputSize, scale) {\n        const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);\n        let size = Math.ceil(step * scale);\n        if (size >= maxSize) {\n            size = maxSize;\n        } else {\n            scale = size / step;\n        }\n        return {\n            scale,\n            size\n        };\n    }\n    clipBbox(graphics, x0, y0, x1, y1) {\n        const bboxWidth = x1 - x0;\n        const bboxHeight = y1 - y0;\n        graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);\n        Util.axialAlignedBoundingBox([\n            x0,\n            y0,\n            x1,\n            y1\n        ], getCurrentTransform(graphics.ctx), graphics.current.minMax);\n        graphics.clip();\n        graphics.endPath();\n    }\n    setFillAndStrokeStyleToContext(graphics, paintType, color) {\n        const context = graphics.ctx, current = graphics.current;\n        switch(paintType){\n            case PaintType.COLORED:\n                const { fillStyle, strokeStyle } = this.ctx;\n                context.fillStyle = current.fillColor = fillStyle;\n                context.strokeStyle = current.strokeColor = strokeStyle;\n                break;\n            case PaintType.UNCOLORED:\n                context.fillStyle = context.strokeStyle = color;\n                current.fillColor = current.strokeColor = color;\n                break;\n            default:\n                throw new FormatError(`Unsupported paint type: ${paintType}`);\n        }\n    }\n    isModifyingCurrentTransform() {\n        return false;\n    }\n    getPattern(ctx, owner, inverse, pathType, opIdx) {\n        let matrix = inverse;\n        if (pathType !== PathType.SHADING) {\n            matrix = Util.transform(matrix, owner.baseTransform);\n            if (this.matrix) {\n                matrix = Util.transform(matrix, this.matrix);\n            }\n        }\n        const temporaryPatternCanvas = this.createPatternCanvas(owner, opIdx);\n        let domMatrix = new DOMMatrix(matrix);\n        domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n        domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);\n        const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, \"repeat\");\n        pattern.setTransform(domMatrix);\n        return pattern;\n    }\n}\nfunction convertBlackAndWhiteToRGBA({ src, srcPos = 0, dest, width, height, nonBlackColor = 4294967295, inverseDecode = false }) {\n    const black = util_FeatureTest.isLittleEndian ? 4278190080 : 255;\n    const [zeroMapping, oneMapping] = inverseDecode ? [\n        nonBlackColor,\n        black\n    ] : [\n        black,\n        nonBlackColor\n    ];\n    const widthInSource = width >> 3;\n    const widthRemainder = width & 7;\n    const srcLength = src.length;\n    dest = new Uint32Array(dest.buffer);\n    let destPos = 0;\n    for(let i = 0; i < height; i++){\n        for(const max = srcPos + widthInSource; srcPos < max; srcPos++){\n            const elem2 = srcPos < srcLength ? src[srcPos] : 255;\n            dest[destPos++] = elem2 & 128 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem2 & 64 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem2 & 32 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem2 & 16 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem2 & 8 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem2 & 4 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem2 & 2 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem2 & 1 ? oneMapping : zeroMapping;\n        }\n        if (widthRemainder === 0) {\n            continue;\n        }\n        const elem = srcPos < srcLength ? src[srcPos++] : 255;\n        for(let j = 0; j < widthRemainder; j++){\n            dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;\n        }\n    }\n    return {\n        srcPos,\n        destPos\n    };\n}\nconst MIN_FONT_SIZE = 16;\nconst MAX_FONT_SIZE = 100;\nconst EXECUTION_TIME = 15;\nconst EXECUTION_STEPS = 10;\nconst FULL_CHUNK_HEIGHT = 16;\nconst SCALE_MATRIX = new DOMMatrix();\nconst XY = new Float32Array(2);\nconst MIN_MAX_INIT = new Float32Array([\n    Infinity,\n    Infinity,\n    -Infinity,\n    -Infinity\n]);\nfunction mirrorContextOperations(ctx, destCtx) {\n    if (ctx._removeMirroring) {\n        throw new Error(\"Context is already forwarding operations.\");\n    }\n    ctx.__originalSave = ctx.save;\n    ctx.__originalRestore = ctx.restore;\n    ctx.__originalRotate = ctx.rotate;\n    ctx.__originalScale = ctx.scale;\n    ctx.__originalTranslate = ctx.translate;\n    ctx.__originalTransform = ctx.transform;\n    ctx.__originalSetTransform = ctx.setTransform;\n    ctx.__originalResetTransform = ctx.resetTransform;\n    ctx.__originalClip = ctx.clip;\n    ctx.__originalMoveTo = ctx.moveTo;\n    ctx.__originalLineTo = ctx.lineTo;\n    ctx.__originalBezierCurveTo = ctx.bezierCurveTo;\n    ctx.__originalRect = ctx.rect;\n    ctx.__originalClosePath = ctx.closePath;\n    ctx.__originalBeginPath = ctx.beginPath;\n    ctx._removeMirroring = ()=>{\n        ctx.save = ctx.__originalSave;\n        ctx.restore = ctx.__originalRestore;\n        ctx.rotate = ctx.__originalRotate;\n        ctx.scale = ctx.__originalScale;\n        ctx.translate = ctx.__originalTranslate;\n        ctx.transform = ctx.__originalTransform;\n        ctx.setTransform = ctx.__originalSetTransform;\n        ctx.resetTransform = ctx.__originalResetTransform;\n        ctx.clip = ctx.__originalClip;\n        ctx.moveTo = ctx.__originalMoveTo;\n        ctx.lineTo = ctx.__originalLineTo;\n        ctx.bezierCurveTo = ctx.__originalBezierCurveTo;\n        ctx.rect = ctx.__originalRect;\n        ctx.closePath = ctx.__originalClosePath;\n        ctx.beginPath = ctx.__originalBeginPath;\n        delete ctx._removeMirroring;\n    };\n    ctx.save = function() {\n        destCtx.save();\n        this.__originalSave();\n    };\n    ctx.restore = function() {\n        destCtx.restore();\n        this.__originalRestore();\n    };\n    ctx.translate = function(x, y) {\n        destCtx.translate(x, y);\n        this.__originalTranslate(x, y);\n    };\n    ctx.scale = function(x, y) {\n        destCtx.scale(x, y);\n        this.__originalScale(x, y);\n    };\n    ctx.transform = function(a, b, c, d, e, f) {\n        destCtx.transform(a, b, c, d, e, f);\n        this.__originalTransform(a, b, c, d, e, f);\n    };\n    ctx.setTransform = function(a, b, c, d, e, f) {\n        destCtx.setTransform(a, b, c, d, e, f);\n        this.__originalSetTransform(a, b, c, d, e, f);\n    };\n    ctx.resetTransform = function() {\n        destCtx.resetTransform();\n        this.__originalResetTransform();\n    };\n    ctx.rotate = function(angle) {\n        destCtx.rotate(angle);\n        this.__originalRotate(angle);\n    };\n    ctx.clip = function(rule) {\n        destCtx.clip(rule);\n        this.__originalClip(rule);\n    };\n    ctx.moveTo = function(x, y) {\n        destCtx.moveTo(x, y);\n        this.__originalMoveTo(x, y);\n    };\n    ctx.lineTo = function(x, y) {\n        destCtx.lineTo(x, y);\n        this.__originalLineTo(x, y);\n    };\n    ctx.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {\n        destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n        this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n    };\n    ctx.rect = function(x, y, width, height) {\n        destCtx.rect(x, y, width, height);\n        this.__originalRect(x, y, width, height);\n    };\n    ctx.closePath = function() {\n        destCtx.closePath();\n        this.__originalClosePath();\n    };\n    ctx.beginPath = function() {\n        destCtx.beginPath();\n        this.__originalBeginPath();\n    };\n}\nclass CachedCanvases {\n    constructor(canvasFactory){\n        this.canvasFactory = canvasFactory;\n        this.cache = /* @__PURE__ */ Object.create(null);\n    }\n    getCanvas(id, width, height) {\n        let canvasEntry;\n        if (this.cache[id] !== void 0) {\n            canvasEntry = this.cache[id];\n            this.canvasFactory.reset(canvasEntry, width, height);\n        } else {\n            canvasEntry = this.canvasFactory.create(width, height);\n            this.cache[id] = canvasEntry;\n        }\n        return canvasEntry;\n    }\n    delete(id) {\n        delete this.cache[id];\n    }\n    clear() {\n        for(const id in this.cache){\n            const canvasEntry = this.cache[id];\n            this.canvasFactory.destroy(canvasEntry);\n            delete this.cache[id];\n        }\n    }\n}\nfunction drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {\n    const [a, b, c, d, tx, ty] = getCurrentTransform(ctx);\n    if (b === 0 && c === 0) {\n        const tlX = destX * a + tx;\n        const rTlX = Math.round(tlX);\n        const tlY = destY * d + ty;\n        const rTlY = Math.round(tlY);\n        const brX = (destX + destW) * a + tx;\n        const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;\n        const brY = (destY + destH) * d + ty;\n        const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;\n        ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);\n        ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);\n        ctx.setTransform(a, b, c, d, tx, ty);\n        return [\n            rWidth,\n            rHeight\n        ];\n    }\n    if (a === 0 && d === 0) {\n        const tlX = destY * c + tx;\n        const rTlX = Math.round(tlX);\n        const tlY = destX * b + ty;\n        const rTlY = Math.round(tlY);\n        const brX = (destY + destH) * c + tx;\n        const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;\n        const brY = (destX + destW) * b + ty;\n        const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;\n        ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);\n        ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);\n        ctx.setTransform(a, b, c, d, tx, ty);\n        return [\n            rHeight,\n            rWidth\n        ];\n    }\n    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);\n    const scaleX = Math.hypot(a, b);\n    const scaleY = Math.hypot(c, d);\n    return [\n        scaleX * destW,\n        scaleY * destH\n    ];\n}\nclass CanvasExtraState {\n    constructor(width, height, preInit){\n        this.alphaIsShape = false;\n        this.fontSize = 0;\n        this.fontSizeScale = 1;\n        this.textMatrix = null;\n        this.textMatrixScale = 1;\n        this.fontMatrix = FONT_IDENTITY_MATRIX;\n        this.leading = 0;\n        this.x = 0;\n        this.y = 0;\n        this.lineX = 0;\n        this.lineY = 0;\n        this.charSpacing = 0;\n        this.wordSpacing = 0;\n        this.textHScale = 1;\n        this.textRenderingMode = TextRenderingMode.FILL;\n        this.textRise = 0;\n        this.fillColor = \"#000000\";\n        this.strokeColor = \"#000000\";\n        this.patternFill = false;\n        this.patternStroke = false;\n        this.fillAlpha = 1;\n        this.strokeAlpha = 1;\n        this.lineWidth = 1;\n        this.activeSMask = null;\n        this.transferMaps = \"none\";\n        preInit?.(this);\n        this.clipBox = new Float32Array([\n            0,\n            0,\n            width,\n            height\n        ]);\n        this.minMax = MIN_MAX_INIT.slice();\n    }\n    clone() {\n        const clone = Object.create(this);\n        clone.clipBox = this.clipBox.slice();\n        clone.minMax = this.minMax.slice();\n        return clone;\n    }\n    getPathBoundingBox(pathType = PathType.FILL, transform = null) {\n        const box = this.minMax.slice();\n        if (pathType === PathType.STROKE) {\n            if (!transform) {\n                unreachable(\"Stroke bounding box must include transform.\");\n            }\n            Util.singularValueDecompose2dScale(transform, XY);\n            const xStrokePad = XY[0] * this.lineWidth / 2;\n            const yStrokePad = XY[1] * this.lineWidth / 2;\n            box[0] -= xStrokePad;\n            box[1] -= yStrokePad;\n            box[2] += xStrokePad;\n            box[3] += yStrokePad;\n        }\n        return box;\n    }\n    updateClipFromPath() {\n        const intersect = Util.intersect(this.clipBox, this.getPathBoundingBox());\n        this.startNewPathAndClipBox(intersect || [\n            0,\n            0,\n            0,\n            0\n        ]);\n    }\n    isEmptyClip() {\n        return this.minMax[0] === Infinity;\n    }\n    startNewPathAndClipBox(box) {\n        this.clipBox.set(box, 0);\n        this.minMax.set(MIN_MAX_INIT, 0);\n    }\n    getClippedPathBoundingBox(pathType = PathType.FILL, transform = null) {\n        return Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));\n    }\n}\nfunction putBinaryImageData(ctx, imgData) {\n    if (imgData instanceof ImageData) {\n        ctx.putImageData(imgData, 0, 0);\n        return;\n    }\n    const height = imgData.height, width = imgData.width;\n    const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n    const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n    const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n    const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n    let srcPos = 0, destPos;\n    const src = imgData.data;\n    const dest = chunkImgData.data;\n    let i, j, thisChunkHeight, elemsInThisChunk;\n    if (imgData.kind === util_ImageKind.GRAYSCALE_1BPP) {\n        const srcLength = src.byteLength;\n        const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);\n        const dest32DataLength = dest32.length;\n        const fullSrcDiff = width + 7 >> 3;\n        const white = 4294967295;\n        const black = util_FeatureTest.isLittleEndian ? 4278190080 : 255;\n        for(i = 0; i < totalChunks; i++){\n            thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n            destPos = 0;\n            for(j = 0; j < thisChunkHeight; j++){\n                const srcDiff = srcLength - srcPos;\n                let k = 0;\n                const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;\n                const kEndUnrolled = kEnd & -8;\n                let mask = 0;\n                let srcByte = 0;\n                for(; k < kEndUnrolled; k += 8){\n                    srcByte = src[srcPos++];\n                    dest32[destPos++] = srcByte & 128 ? white : black;\n                    dest32[destPos++] = srcByte & 64 ? white : black;\n                    dest32[destPos++] = srcByte & 32 ? white : black;\n                    dest32[destPos++] = srcByte & 16 ? white : black;\n                    dest32[destPos++] = srcByte & 8 ? white : black;\n                    dest32[destPos++] = srcByte & 4 ? white : black;\n                    dest32[destPos++] = srcByte & 2 ? white : black;\n                    dest32[destPos++] = srcByte & 1 ? white : black;\n                }\n                for(; k < kEnd; k++){\n                    if (mask === 0) {\n                        srcByte = src[srcPos++];\n                        mask = 128;\n                    }\n                    dest32[destPos++] = srcByte & mask ? white : black;\n                    mask >>= 1;\n                }\n            }\n            while(destPos < dest32DataLength){\n                dest32[destPos++] = 0;\n            }\n            ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n        }\n    } else if (imgData.kind === util_ImageKind.RGBA_32BPP) {\n        j = 0;\n        elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;\n        for(i = 0; i < fullChunks; i++){\n            dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n            srcPos += elemsInThisChunk;\n            ctx.putImageData(chunkImgData, 0, j);\n            j += FULL_CHUNK_HEIGHT;\n        }\n        if (i < totalChunks) {\n            elemsInThisChunk = width * partialChunkHeight * 4;\n            dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n            ctx.putImageData(chunkImgData, 0, j);\n        }\n    } else if (imgData.kind === util_ImageKind.RGB_24BPP) {\n        thisChunkHeight = FULL_CHUNK_HEIGHT;\n        elemsInThisChunk = width * thisChunkHeight;\n        for(i = 0; i < totalChunks; i++){\n            if (i >= fullChunks) {\n                thisChunkHeight = partialChunkHeight;\n                elemsInThisChunk = width * thisChunkHeight;\n            }\n            destPos = 0;\n            for(j = elemsInThisChunk; j--;){\n                dest[destPos++] = src[srcPos++];\n                dest[destPos++] = src[srcPos++];\n                dest[destPos++] = src[srcPos++];\n                dest[destPos++] = 255;\n            }\n            ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n        }\n    } else {\n        throw new Error(`bad image kind: ${imgData.kind}`);\n    }\n}\nfunction putBinaryImageMask(ctx, imgData) {\n    if (imgData.bitmap) {\n        ctx.drawImage(imgData.bitmap, 0, 0);\n        return;\n    }\n    const height = imgData.height, width = imgData.width;\n    const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n    const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n    const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n    const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n    let srcPos = 0;\n    const src = imgData.data;\n    const dest = chunkImgData.data;\n    for(let i = 0; i < totalChunks; i++){\n        const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n        ({ srcPos } = convertBlackAndWhiteToRGBA({\n            src,\n            srcPos,\n            dest,\n            width,\n            height: thisChunkHeight,\n            nonBlackColor: 0\n        }));\n        ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n    }\n}\nfunction copyCtxState(sourceCtx, destCtx) {\n    const properties = [\n        \"strokeStyle\",\n        \"fillStyle\",\n        \"fillRule\",\n        \"globalAlpha\",\n        \"lineWidth\",\n        \"lineCap\",\n        \"lineJoin\",\n        \"miterLimit\",\n        \"globalCompositeOperation\",\n        \"font\",\n        \"filter\"\n    ];\n    for (const property of properties){\n        if (sourceCtx[property] !== void 0) {\n            destCtx[property] = sourceCtx[property];\n        }\n    }\n    if (sourceCtx.setLineDash !== void 0) {\n        destCtx.setLineDash(sourceCtx.getLineDash());\n        destCtx.lineDashOffset = sourceCtx.lineDashOffset;\n    }\n}\nfunction resetCtxToDefault(ctx) {\n    ctx.strokeStyle = ctx.fillStyle = \"#000000\";\n    ctx.fillRule = \"nonzero\";\n    ctx.globalAlpha = 1;\n    ctx.lineWidth = 1;\n    ctx.lineCap = \"butt\";\n    ctx.lineJoin = \"miter\";\n    ctx.miterLimit = 10;\n    ctx.globalCompositeOperation = \"source-over\";\n    ctx.font = \"10px sans-serif\";\n    if (ctx.setLineDash !== void 0) {\n        ctx.setLineDash([]);\n        ctx.lineDashOffset = 0;\n    }\n    const { filter } = ctx;\n    if (filter !== \"none\" && filter !== \"\") {\n        ctx.filter = \"none\";\n    }\n}\nfunction getImageSmoothingEnabled(transform, interpolate) {\n    if (interpolate) {\n        return true;\n    }\n    Util.singularValueDecompose2dScale(transform, XY);\n    const actualScale = Math.fround(OutputScale.pixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);\n    return XY[0] <= actualScale && XY[1] <= actualScale;\n}\nconst LINE_CAP_STYLES = [\n    \"butt\",\n    \"round\",\n    \"square\"\n];\nconst LINE_JOIN_STYLES = [\n    \"miter\",\n    \"round\",\n    \"bevel\"\n];\nconst NORMAL_CLIP = {};\nconst EO_CLIP = {};\nclass CanvasGraphics {\n    constructor(canvasCtx, commonObjs, objs, canvasFactory, filterFactory, { optionalContentConfig, markedContentStack = null }, annotationCanvasMap, pageColors, dependencyTracker){\n        this.ctx = canvasCtx;\n        this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n        this.stateStack = [];\n        this.pendingClip = null;\n        this.pendingEOFill = false;\n        this.res = null;\n        this.xobjs = null;\n        this.commonObjs = commonObjs;\n        this.objs = objs;\n        this.canvasFactory = canvasFactory;\n        this.filterFactory = filterFactory;\n        this.groupStack = [];\n        this.baseTransform = null;\n        this.baseTransformStack = [];\n        this.groupLevel = 0;\n        this.smaskStack = [];\n        this.smaskCounter = 0;\n        this.tempSMask = null;\n        this.suspendedCtx = null;\n        this.contentVisible = true;\n        this.markedContentStack = markedContentStack || [];\n        this.optionalContentConfig = optionalContentConfig;\n        this.cachedCanvases = new CachedCanvases(this.canvasFactory);\n        this.cachedPatterns = /* @__PURE__ */ new Map();\n        this.annotationCanvasMap = annotationCanvasMap;\n        this.viewportScale = 1;\n        this.outputScaleX = 1;\n        this.outputScaleY = 1;\n        this.pageColors = pageColors;\n        this._cachedScaleForStroking = [\n            -1,\n            0\n        ];\n        this._cachedGetSinglePixelWidth = null;\n        this._cachedBitmapsMap = /* @__PURE__ */ new Map();\n        this.dependencyTracker = dependencyTracker ?? null;\n    }\n    getObject(opIdx, data, fallback = null) {\n        if (typeof data === \"string\") {\n            this.dependencyTracker?.recordNamedDependency(opIdx, data);\n            return data.startsWith(\"g_\") ? this.commonObjs.get(data) : this.objs.get(data);\n        }\n        return fallback;\n    }\n    beginDrawing({ transform, viewport, transparency = false, background = null }) {\n        const width = this.ctx.canvas.width;\n        const height = this.ctx.canvas.height;\n        const savedFillStyle = this.ctx.fillStyle;\n        this.ctx.fillStyle = background || \"#ffffff\";\n        this.ctx.fillRect(0, 0, width, height);\n        this.ctx.fillStyle = savedFillStyle;\n        if (transparency) {\n            const transparentCanvas = this.cachedCanvases.getCanvas(\"transparent\", width, height);\n            this.compositeCtx = this.ctx;\n            this.transparentCanvas = transparentCanvas.canvas;\n            this.ctx = transparentCanvas.context;\n            this.ctx.save();\n            this.ctx.transform(...getCurrentTransform(this.compositeCtx));\n        }\n        this.ctx.save();\n        resetCtxToDefault(this.ctx);\n        if (transform) {\n            this.ctx.transform(...transform);\n            this.outputScaleX = transform[0];\n            this.outputScaleY = transform[0];\n        }\n        this.ctx.transform(...viewport.transform);\n        this.viewportScale = viewport.scale;\n        this.baseTransform = getCurrentTransform(this.ctx);\n    }\n    executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper, operationsFilter) {\n        const argsArray = operatorList.argsArray;\n        const fnArray = operatorList.fnArray;\n        let i = executionStartIdx || 0;\n        const argsArrayLen = argsArray.length;\n        if (argsArrayLen === i) {\n            return i;\n        }\n        const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === \"function\";\n        const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;\n        let steps = 0;\n        const commonObjs = this.commonObjs;\n        const objs = this.objs;\n        let fnId, fnArgs;\n        while(true){\n            if (stepper !== void 0 && i === stepper.nextBreakPoint) {\n                stepper.breakIt(i, continueCallback);\n                return i;\n            }\n            if (!operationsFilter || operationsFilter(i)) {\n                fnId = fnArray[i];\n                fnArgs = argsArray[i] ?? null;\n                if (fnId !== OPS.dependency) {\n                    if (fnArgs === null) {\n                        this[fnId](i);\n                    } else {\n                        this[fnId](i, ...fnArgs);\n                    }\n                } else {\n                    for (const depObjId of fnArgs){\n                        this.dependencyTracker?.recordNamedData(depObjId, i);\n                        const objsPool = depObjId.startsWith(\"g_\") ? commonObjs : objs;\n                        if (!objsPool.has(depObjId)) {\n                            objsPool.get(depObjId, continueCallback);\n                            return i;\n                        }\n                    }\n                }\n            }\n            i++;\n            if (i === argsArrayLen) {\n                return i;\n            }\n            if (chunkOperations && ++steps > EXECUTION_STEPS) {\n                if (Date.now() > endTime) {\n                    continueCallback();\n                    return i;\n                }\n                steps = 0;\n            }\n        }\n    }\n    #restoreInitialState() {\n        while(this.stateStack.length || this.inSMaskMode){\n            this.restore();\n        }\n        this.current.activeSMask = null;\n        this.ctx.restore();\n        if (this.transparentCanvas) {\n            this.ctx = this.compositeCtx;\n            this.ctx.save();\n            this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n            this.ctx.drawImage(this.transparentCanvas, 0, 0);\n            this.ctx.restore();\n            this.transparentCanvas = null;\n        }\n    }\n    endDrawing() {\n        this.#restoreInitialState();\n        this.cachedCanvases.clear();\n        this.cachedPatterns.clear();\n        for (const cache of this._cachedBitmapsMap.values()){\n            for (const canvas of cache.values()){\n                if (typeof HTMLCanvasElement !== \"undefined\" && canvas instanceof HTMLCanvasElement) {\n                    canvas.width = canvas.height = 0;\n                }\n            }\n            cache.clear();\n        }\n        this._cachedBitmapsMap.clear();\n        this.#drawFilter();\n    }\n    #drawFilter() {\n        if (this.pageColors) {\n            const hcmFilterId = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);\n            if (hcmFilterId !== \"none\") {\n                const savedFilter = this.ctx.filter;\n                this.ctx.filter = hcmFilterId;\n                this.ctx.drawImage(this.ctx.canvas, 0, 0);\n                this.ctx.filter = savedFilter;\n            }\n        }\n    }\n    _scaleImage(img, inverseTransform) {\n        const width = img.width ?? img.displayWidth;\n        const height = img.height ?? img.displayHeight;\n        let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);\n        let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);\n        let paintWidth = width, paintHeight = height;\n        let tmpCanvasId = \"prescale1\";\n        let tmpCanvas, tmpCtx;\n        while(widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1){\n            let newWidth = paintWidth, newHeight = paintHeight;\n            if (widthScale > 2 && paintWidth > 1) {\n                newWidth = paintWidth >= 16384 ? Math.floor(paintWidth / 2) - 1 || 1 : Math.ceil(paintWidth / 2);\n                widthScale /= paintWidth / newWidth;\n            }\n            if (heightScale > 2 && paintHeight > 1) {\n                newHeight = paintHeight >= 16384 ? Math.floor(paintHeight / 2) - 1 || 1 : Math.ceil(paintHeight) / 2;\n                heightScale /= paintHeight / newHeight;\n            }\n            tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);\n            tmpCtx = tmpCanvas.context;\n            tmpCtx.clearRect(0, 0, newWidth, newHeight);\n            tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);\n            img = tmpCanvas.canvas;\n            paintWidth = newWidth;\n            paintHeight = newHeight;\n            tmpCanvasId = tmpCanvasId === \"prescale1\" ? \"prescale2\" : \"prescale1\";\n        }\n        return {\n            img,\n            paintWidth,\n            paintHeight\n        };\n    }\n    _createMaskCanvas(opIdx, img) {\n        const ctx = this.ctx;\n        const { width, height } = img;\n        const fillColor = this.current.fillColor;\n        const isPatternFill = this.current.patternFill;\n        const currentTransform = getCurrentTransform(ctx);\n        let cache, cacheKey, scaled, maskCanvas;\n        if ((img.bitmap || img.data) && img.count > 1) {\n            const mainKey = img.bitmap || img.data.buffer;\n            cacheKey = JSON.stringify(isPatternFill ? currentTransform : [\n                currentTransform.slice(0, 4),\n                fillColor\n            ]);\n            cache = this._cachedBitmapsMap.get(mainKey);\n            if (!cache) {\n                cache = /* @__PURE__ */ new Map();\n                this._cachedBitmapsMap.set(mainKey, cache);\n            }\n            const cachedImage = cache.get(cacheKey);\n            if (cachedImage && !isPatternFill) {\n                const offsetX2 = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);\n                const offsetY2 = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);\n                this.dependencyTracker?.recordDependencies(opIdx, Dependencies.transformAndFill);\n                return {\n                    canvas: cachedImage,\n                    offsetX: offsetX2,\n                    offsetY: offsetY2\n                };\n            }\n            scaled = cachedImage;\n        }\n        if (!scaled) {\n            maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n            putBinaryImageMask(maskCanvas.context, img);\n        }\n        let maskToCanvas = Util.transform(currentTransform, [\n            1 / width,\n            0,\n            0,\n            -1 / height,\n            0,\n            0\n        ]);\n        maskToCanvas = Util.transform(maskToCanvas, [\n            1,\n            0,\n            0,\n            1,\n            0,\n            -height\n        ]);\n        const minMax = MIN_MAX_INIT.slice();\n        Util.axialAlignedBoundingBox([\n            0,\n            0,\n            width,\n            height\n        ], maskToCanvas, minMax);\n        const [minX, minY, maxX, maxY] = minMax;\n        const drawnWidth = Math.round(maxX - minX) || 1;\n        const drawnHeight = Math.round(maxY - minY) || 1;\n        const fillCanvas = this.cachedCanvases.getCanvas(\"fillCanvas\", drawnWidth, drawnHeight);\n        const fillCtx = fillCanvas.context;\n        const offsetX = minX;\n        const offsetY = minY;\n        fillCtx.translate(-offsetX, -offsetY);\n        fillCtx.transform(...maskToCanvas);\n        if (!scaled) {\n            scaled = this._scaleImage(maskCanvas.canvas, getCurrentTransformInverse(fillCtx));\n            scaled = scaled.img;\n            if (cache && isPatternFill) {\n                cache.set(cacheKey, scaled);\n            }\n        }\n        fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(fillCtx), img.interpolate);\n        drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);\n        fillCtx.globalCompositeOperation = \"source-in\";\n        const inverse = Util.transform(getCurrentTransformInverse(fillCtx), [\n            1,\n            0,\n            0,\n            1,\n            -offsetX,\n            -offsetY\n        ]);\n        fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, PathType.FILL, opIdx) : fillColor;\n        fillCtx.fillRect(0, 0, width, height);\n        if (cache && !isPatternFill) {\n            this.cachedCanvases.delete(\"fillCanvas\");\n            cache.set(cacheKey, fillCanvas.canvas);\n        }\n        this.dependencyTracker?.recordDependencies(opIdx, Dependencies.transformAndFill);\n        return {\n            canvas: fillCanvas.canvas,\n            offsetX: Math.round(offsetX),\n            offsetY: Math.round(offsetY)\n        };\n    }\n    setLineWidth(opIdx, width) {\n        this.dependencyTracker?.recordSimpleData(\"lineWidth\", opIdx);\n        if (width !== this.current.lineWidth) {\n            this._cachedScaleForStroking[0] = -1;\n        }\n        this.current.lineWidth = width;\n        this.ctx.lineWidth = width;\n    }\n    setLineCap(opIdx, style) {\n        this.dependencyTracker?.recordSimpleData(\"lineCap\", opIdx);\n        this.ctx.lineCap = LINE_CAP_STYLES[style];\n    }\n    setLineJoin(opIdx, style) {\n        this.dependencyTracker?.recordSimpleData(\"lineJoin\", opIdx);\n        this.ctx.lineJoin = LINE_JOIN_STYLES[style];\n    }\n    setMiterLimit(opIdx, limit) {\n        this.dependencyTracker?.recordSimpleData(\"miterLimit\", opIdx);\n        this.ctx.miterLimit = limit;\n    }\n    setDash(opIdx, dashArray, dashPhase) {\n        this.dependencyTracker?.recordSimpleData(\"dash\", opIdx);\n        const ctx = this.ctx;\n        if (ctx.setLineDash !== void 0) {\n            ctx.setLineDash(dashArray);\n            ctx.lineDashOffset = dashPhase;\n        }\n    }\n    setRenderingIntent(opIdx, intent) {}\n    setFlatness(opIdx, flatness) {}\n    setGState(opIdx, states) {\n        for (const [key, value1] of states){\n            switch(key){\n                case \"LW\":\n                    this.setLineWidth(opIdx, value1);\n                    break;\n                case \"LC\":\n                    this.setLineCap(opIdx, value1);\n                    break;\n                case \"LJ\":\n                    this.setLineJoin(opIdx, value1);\n                    break;\n                case \"ML\":\n                    this.setMiterLimit(opIdx, value1);\n                    break;\n                case \"D\":\n                    this.setDash(opIdx, value1[0], value1[1]);\n                    break;\n                case \"RI\":\n                    this.setRenderingIntent(opIdx, value1);\n                    break;\n                case \"FL\":\n                    this.setFlatness(opIdx, value1);\n                    break;\n                case \"Font\":\n                    this.setFont(opIdx, value1[0], value1[1]);\n                    break;\n                case \"CA\":\n                    this.dependencyTracker?.recordSimpleData(\"strokeAlpha\", opIdx);\n                    this.current.strokeAlpha = value1;\n                    break;\n                case \"ca\":\n                    this.dependencyTracker?.recordSimpleData(\"fillAlpha\", opIdx);\n                    this.ctx.globalAlpha = this.current.fillAlpha = value1;\n                    break;\n                case \"BM\":\n                    this.dependencyTracker?.recordSimpleData(\"globalCompositeOperation\", opIdx);\n                    this.ctx.globalCompositeOperation = value1;\n                    break;\n                case \"SMask\":\n                    this.dependencyTracker?.recordSimpleData(\"SMask\", opIdx);\n                    this.current.activeSMask = value1 ? this.tempSMask : null;\n                    this.tempSMask = null;\n                    this.checkSMaskState();\n                    break;\n                case \"TR\":\n                    this.dependencyTracker?.recordSimpleData(\"filter\", opIdx);\n                    this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(value1);\n                    break;\n            }\n        }\n    }\n    get inSMaskMode() {\n        return !!this.suspendedCtx;\n    }\n    checkSMaskState() {\n        const inSMaskMode = this.inSMaskMode;\n        if (this.current.activeSMask && !inSMaskMode) {\n            this.beginSMaskMode();\n        } else if (!this.current.activeSMask && inSMaskMode) {\n            this.endSMaskMode();\n        }\n    }\n    beginSMaskMode(opIdx) {\n        if (this.inSMaskMode) {\n            throw new Error(\"beginSMaskMode called while already in smask mode\");\n        }\n        const drawnWidth = this.ctx.canvas.width;\n        const drawnHeight = this.ctx.canvas.height;\n        const cacheId = \"smaskGroupAt\" + this.groupLevel;\n        const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);\n        this.suspendedCtx = this.ctx;\n        const ctx = this.ctx = scratchCanvas.context;\n        ctx.setTransform(this.suspendedCtx.getTransform());\n        copyCtxState(this.suspendedCtx, ctx);\n        mirrorContextOperations(ctx, this.suspendedCtx);\n        this.setGState(opIdx, [\n            [\n                \"BM\",\n                \"source-over\"\n            ]\n        ]);\n    }\n    endSMaskMode() {\n        if (!this.inSMaskMode) {\n            throw new Error(\"endSMaskMode called while not in smask mode\");\n        }\n        this.ctx._removeMirroring();\n        copyCtxState(this.ctx, this.suspendedCtx);\n        this.ctx = this.suspendedCtx;\n        this.suspendedCtx = null;\n    }\n    compose(dirtyBox) {\n        if (!this.current.activeSMask) {\n            return;\n        }\n        if (!dirtyBox) {\n            dirtyBox = [\n                0,\n                0,\n                this.ctx.canvas.width,\n                this.ctx.canvas.height\n            ];\n        } else {\n            dirtyBox[0] = Math.floor(dirtyBox[0]);\n            dirtyBox[1] = Math.floor(dirtyBox[1]);\n            dirtyBox[2] = Math.ceil(dirtyBox[2]);\n            dirtyBox[3] = Math.ceil(dirtyBox[3]);\n        }\n        const smask = this.current.activeSMask;\n        const suspendedCtx = this.suspendedCtx;\n        this.composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);\n        this.ctx.save();\n        this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n        this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n        this.ctx.restore();\n    }\n    composeSMask(ctx, smask, layerCtx, layerBox) {\n        const layerOffsetX = layerBox[0];\n        const layerOffsetY = layerBox[1];\n        const layerWidth = layerBox[2] - layerOffsetX;\n        const layerHeight = layerBox[3] - layerOffsetY;\n        if (layerWidth === 0 || layerHeight === 0) {\n            return;\n        }\n        this.genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);\n        ctx.save();\n        ctx.globalAlpha = 1;\n        ctx.globalCompositeOperation = \"source-over\";\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.drawImage(layerCtx.canvas, 0, 0);\n        ctx.restore();\n    }\n    genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {\n        let maskCanvas = maskCtx.canvas;\n        let maskX = layerOffsetX - maskOffsetX;\n        let maskY = layerOffsetY - maskOffsetY;\n        if (backdrop) {\n            if (maskX < 0 || maskY < 0 || maskX + width > maskCanvas.width || maskY + height > maskCanvas.height) {\n                const canvas = this.cachedCanvases.getCanvas(\"maskExtension\", width, height);\n                const ctx = canvas.context;\n                ctx.drawImage(maskCanvas, -maskX, -maskY);\n                ctx.globalCompositeOperation = \"destination-atop\";\n                ctx.fillStyle = backdrop;\n                ctx.fillRect(0, 0, width, height);\n                ctx.globalCompositeOperation = \"source-over\";\n                maskCanvas = canvas.canvas;\n                maskX = maskY = 0;\n            } else {\n                maskCtx.save();\n                maskCtx.globalAlpha = 1;\n                maskCtx.setTransform(1, 0, 0, 1, 0, 0);\n                const clip2 = new Path2D();\n                clip2.rect(maskX, maskY, width, height);\n                maskCtx.clip(clip2);\n                maskCtx.globalCompositeOperation = \"destination-atop\";\n                maskCtx.fillStyle = backdrop;\n                maskCtx.fillRect(maskX, maskY, width, height);\n                maskCtx.restore();\n            }\n        }\n        layerCtx.save();\n        layerCtx.globalAlpha = 1;\n        layerCtx.setTransform(1, 0, 0, 1, 0, 0);\n        if (subtype === \"Alpha\" && transferMap) {\n            layerCtx.filter = this.filterFactory.addAlphaFilter(transferMap);\n        } else if (subtype === \"Luminosity\") {\n            layerCtx.filter = this.filterFactory.addLuminosityFilter(transferMap);\n        }\n        const clip = new Path2D();\n        clip.rect(layerOffsetX, layerOffsetY, width, height);\n        layerCtx.clip(clip);\n        layerCtx.globalCompositeOperation = \"destination-in\";\n        layerCtx.drawImage(maskCanvas, maskX, maskY, width, height, layerOffsetX, layerOffsetY, width, height);\n        layerCtx.restore();\n    }\n    save(opIdx) {\n        if (this.inSMaskMode) {\n            copyCtxState(this.ctx, this.suspendedCtx);\n        }\n        this.ctx.save();\n        const old = this.current;\n        this.stateStack.push(old);\n        this.current = old.clone();\n        this.dependencyTracker?.save(opIdx);\n    }\n    restore(opIdx) {\n        this.dependencyTracker?.restore(opIdx);\n        if (this.stateStack.length === 0) {\n            if (this.inSMaskMode) {\n                this.endSMaskMode();\n            }\n            return;\n        }\n        this.current = this.stateStack.pop();\n        this.ctx.restore();\n        if (this.inSMaskMode) {\n            copyCtxState(this.suspendedCtx, this.ctx);\n        }\n        this.checkSMaskState();\n        this.pendingClip = null;\n        this._cachedScaleForStroking[0] = -1;\n        this._cachedGetSinglePixelWidth = null;\n    }\n    transform(opIdx, a, b, c, d, e, f) {\n        this.dependencyTracker?.recordIncrementalData(\"transform\", opIdx);\n        this.ctx.transform(a, b, c, d, e, f);\n        this._cachedScaleForStroking[0] = -1;\n        this._cachedGetSinglePixelWidth = null;\n    }\n    constructPath(opIdx, op, data, minMax) {\n        let [path] = data;\n        if (!minMax) {\n            path ||= data[0] = new Path2D();\n            this[op](opIdx, path);\n            return;\n        }\n        if (this.dependencyTracker !== null) {\n            const outerExtraSize = op === OPS.stroke ? this.current.lineWidth / 2 : 0;\n            this.dependencyTracker.resetBBox(opIdx).recordBBox(opIdx, this.ctx, minMax[0] - outerExtraSize, minMax[2] + outerExtraSize, minMax[1] - outerExtraSize, minMax[3] + outerExtraSize).recordDependencies(opIdx, [\n                \"transform\"\n            ]);\n        }\n        if (!(path instanceof Path2D)) {\n            const path2d = data[0] = new Path2D();\n            for(let i = 0, ii = path.length; i < ii;){\n                switch(path[i++]){\n                    case DrawOPS.moveTo:\n                        path2d.moveTo(path[i++], path[i++]);\n                        break;\n                    case DrawOPS.lineTo:\n                        path2d.lineTo(path[i++], path[i++]);\n                        break;\n                    case DrawOPS.curveTo:\n                        path2d.bezierCurveTo(path[i++], path[i++], path[i++], path[i++], path[i++], path[i++]);\n                        break;\n                    case DrawOPS.closePath:\n                        path2d.closePath();\n                        break;\n                    default:\n                        warn(`Unrecognized drawing path operator: ${path[i - 1]}`);\n                        break;\n                }\n            }\n            path = path2d;\n        }\n        Util.axialAlignedBoundingBox(minMax, getCurrentTransform(this.ctx), this.current.minMax);\n        this[op](opIdx, path);\n        this._pathStartIdx = opIdx;\n    }\n    closePath(opIdx) {\n        this.ctx.closePath();\n    }\n    stroke(opIdx, path, consumePath = true) {\n        const ctx = this.ctx;\n        const strokeColor = this.current.strokeColor;\n        ctx.globalAlpha = this.current.strokeAlpha;\n        if (this.contentVisible) {\n            if (typeof strokeColor === \"object\" && strokeColor?.getPattern) {\n                const baseTransform = strokeColor.isModifyingCurrentTransform() ? ctx.getTransform() : null;\n                ctx.save();\n                ctx.strokeStyle = strokeColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.STROKE, opIdx);\n                if (baseTransform) {\n                    const newPath = new Path2D();\n                    newPath.addPath(path, ctx.getTransform().invertSelf().multiplySelf(baseTransform));\n                    path = newPath;\n                }\n                this.rescaleAndStroke(path, false);\n                ctx.restore();\n            } else {\n                this.rescaleAndStroke(path, true);\n            }\n        }\n        this.dependencyTracker?.recordDependencies(opIdx, Dependencies.stroke);\n        if (consumePath) {\n            this.consumePath(opIdx, path, this.current.getClippedPathBoundingBox(PathType.STROKE, getCurrentTransform(this.ctx)));\n        }\n        ctx.globalAlpha = this.current.fillAlpha;\n    }\n    closeStroke(opIdx, path) {\n        this.stroke(opIdx, path);\n    }\n    fill(opIdx, path, consumePath = true) {\n        const ctx = this.ctx;\n        const fillColor = this.current.fillColor;\n        const isPatternFill = this.current.patternFill;\n        let needRestore = false;\n        if (isPatternFill) {\n            const baseTransform = fillColor.isModifyingCurrentTransform() ? ctx.getTransform() : null;\n            this.dependencyTracker?.save(opIdx);\n            ctx.save();\n            ctx.fillStyle = fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL, opIdx);\n            if (baseTransform) {\n                const newPath = new Path2D();\n                newPath.addPath(path, ctx.getTransform().invertSelf().multiplySelf(baseTransform));\n                path = newPath;\n            }\n            needRestore = true;\n        }\n        const intersect = this.current.getClippedPathBoundingBox();\n        if (this.contentVisible && intersect !== null) {\n            if (this.pendingEOFill) {\n                ctx.fill(path, \"evenodd\");\n                this.pendingEOFill = false;\n            } else {\n                ctx.fill(path);\n            }\n        }\n        this.dependencyTracker?.recordDependencies(opIdx, Dependencies.fill);\n        if (needRestore) {\n            ctx.restore();\n            this.dependencyTracker?.restore(opIdx);\n        }\n        if (consumePath) {\n            this.consumePath(opIdx, path, intersect);\n        }\n    }\n    eoFill(opIdx, path) {\n        this.pendingEOFill = true;\n        this.fill(opIdx, path);\n    }\n    fillStroke(opIdx, path) {\n        this.fill(opIdx, path, false);\n        this.stroke(opIdx, path, false);\n        this.consumePath(opIdx, path);\n    }\n    eoFillStroke(opIdx, path) {\n        this.pendingEOFill = true;\n        this.fillStroke(opIdx, path);\n    }\n    closeFillStroke(opIdx, path) {\n        this.fillStroke(opIdx, path);\n    }\n    closeEOFillStroke(opIdx, path) {\n        this.pendingEOFill = true;\n        this.fillStroke(opIdx, path);\n    }\n    endPath(opIdx, path) {\n        this.consumePath(opIdx, path);\n    }\n    rawFillPath(opIdx, path) {\n        this.ctx.fill(path);\n        this.dependencyTracker?.recordDependencies(opIdx, Dependencies.rawFillPath).recordOperation(opIdx);\n    }\n    clip(opIdx) {\n        this.dependencyTracker?.recordFutureForcedDependency(\"clipMode\", opIdx);\n        this.pendingClip = NORMAL_CLIP;\n    }\n    eoClip(opIdx) {\n        this.dependencyTracker?.recordFutureForcedDependency(\"clipMode\", opIdx);\n        this.pendingClip = EO_CLIP;\n    }\n    beginText(opIdx) {\n        this.current.textMatrix = null;\n        this.current.textMatrixScale = 1;\n        this.current.x = this.current.lineX = 0;\n        this.current.y = this.current.lineY = 0;\n        this.dependencyTracker?.recordOpenMarker(opIdx).resetIncrementalData(\"sameLineText\").resetIncrementalData(\"moveText\", opIdx);\n    }\n    endText(opIdx) {\n        const paths = this.pendingTextPaths;\n        const ctx = this.ctx;\n        if (this.dependencyTracker) {\n            const { dependencyTracker } = this;\n            if (paths !== void 0) {\n                dependencyTracker.recordFutureForcedDependency(\"textClip\", dependencyTracker.getOpenMarker()).recordFutureForcedDependency(\"textClip\", opIdx);\n            }\n            dependencyTracker.recordCloseMarker(opIdx);\n        }\n        if (paths !== void 0) {\n            const newPath = new Path2D();\n            const invTransf = ctx.getTransform().invertSelf();\n            for (const { transform, x, y, fontSize, path } of paths){\n                if (!path) {\n                    continue;\n                }\n                newPath.addPath(path, new DOMMatrix(transform).preMultiplySelf(invTransf).translate(x, y).scale(fontSize, -fontSize));\n            }\n            ctx.clip(newPath);\n        }\n        delete this.pendingTextPaths;\n    }\n    setCharSpacing(opIdx, spacing) {\n        this.dependencyTracker?.recordSimpleData(\"charSpacing\", opIdx);\n        this.current.charSpacing = spacing;\n    }\n    setWordSpacing(opIdx, spacing) {\n        this.dependencyTracker?.recordSimpleData(\"wordSpacing\", opIdx);\n        this.current.wordSpacing = spacing;\n    }\n    setHScale(opIdx, scale) {\n        this.dependencyTracker?.recordSimpleData(\"hScale\", opIdx);\n        this.current.textHScale = scale / 100;\n    }\n    setLeading(opIdx, leading) {\n        this.dependencyTracker?.recordSimpleData(\"leading\", opIdx);\n        this.current.leading = -leading;\n    }\n    setFont(opIdx, fontRefName, size) {\n        this.dependencyTracker?.recordSimpleData(\"font\", opIdx).recordSimpleDataFromNamed(\"fontObj\", fontRefName, opIdx);\n        const fontObj = this.commonObjs.get(fontRefName);\n        const current = this.current;\n        if (!fontObj) {\n            throw new Error(`Can't find font for ${fontRefName}`);\n        }\n        current.fontMatrix = fontObj.fontMatrix || FONT_IDENTITY_MATRIX;\n        if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {\n            warn(\"Invalid font matrix for font \" + fontRefName);\n        }\n        if (size < 0) {\n            size = -size;\n            current.fontDirection = -1;\n        } else {\n            current.fontDirection = 1;\n        }\n        this.current.font = fontObj;\n        this.current.fontSize = size;\n        if (fontObj.isType3Font) {\n            return;\n        }\n        const name = fontObj.loadedName || \"sans-serif\";\n        const typeface = fontObj.systemFontInfo?.css || `\"${name}\", ${fontObj.fallbackName}`;\n        let bold = \"normal\";\n        if (fontObj.black) {\n            bold = \"900\";\n        } else if (fontObj.bold) {\n            bold = \"bold\";\n        }\n        const italic = fontObj.italic ? \"italic\" : \"normal\";\n        let browserFontSize = size;\n        if (size < MIN_FONT_SIZE) {\n            browserFontSize = MIN_FONT_SIZE;\n        } else if (size > MAX_FONT_SIZE) {\n            browserFontSize = MAX_FONT_SIZE;\n        }\n        this.current.fontSizeScale = size / browserFontSize;\n        this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;\n    }\n    setTextRenderingMode(opIdx, mode) {\n        this.dependencyTracker?.recordSimpleData(\"textRenderingMode\", opIdx);\n        this.current.textRenderingMode = mode;\n    }\n    setTextRise(opIdx, rise) {\n        this.dependencyTracker?.recordSimpleData(\"textRise\", opIdx);\n        this.current.textRise = rise;\n    }\n    moveText(opIdx, x, y) {\n        this.dependencyTracker?.resetIncrementalData(\"sameLineText\").recordIncrementalData(\"moveText\", opIdx);\n        this.current.x = this.current.lineX += x;\n        this.current.y = this.current.lineY += y;\n    }\n    setLeadingMoveText(opIdx, x, y) {\n        this.setLeading(opIdx, -y);\n        this.moveText(opIdx, x, y);\n    }\n    setTextMatrix(opIdx, matrix) {\n        this.dependencyTracker?.recordSimpleData(\"textMatrix\", opIdx);\n        const { current } = this;\n        current.textMatrix = matrix;\n        current.textMatrixScale = Math.hypot(matrix[0], matrix[1]);\n        current.x = current.lineX = 0;\n        current.y = current.lineY = 0;\n    }\n    nextLine(opIdx) {\n        this.moveText(opIdx, 0, this.current.leading);\n        this.dependencyTracker?.recordIncrementalData(\"moveText\", this.dependencyTracker.getSimpleIndex(\"leading\") ?? opIdx);\n    }\n    #getScaledPath(path, currentTransform, transform) {\n        const newPath = new Path2D();\n        newPath.addPath(path, new DOMMatrix(transform).invertSelf().multiplySelf(currentTransform));\n        return newPath;\n    }\n    paintChar(opIdx, character, x, y, patternFillTransform, patternStrokeTransform) {\n        const ctx = this.ctx;\n        const current = this.current;\n        const font = current.font;\n        const textRenderingMode = current.textRenderingMode;\n        const fontSize = current.fontSize / current.fontSizeScale;\n        const fillStrokeMode = textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;\n        const isAddToPathSet = !!(textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG);\n        const patternFill = current.patternFill && !font.missingFile;\n        const patternStroke = current.patternStroke && !font.missingFile;\n        let path;\n        if ((font.disableFontFace || isAddToPathSet || patternFill || patternStroke) && !font.missingFile) {\n            path = font.getPathGenerator(this.commonObjs, character);\n        }\n        if (path && (font.disableFontFace || patternFill || patternStroke)) {\n            ctx.save();\n            ctx.translate(x, y);\n            ctx.scale(fontSize, -fontSize);\n            this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font);\n            let currentTransform;\n            if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                if (patternFillTransform) {\n                    currentTransform = ctx.getTransform();\n                    ctx.setTransform(...patternFillTransform);\n                    const scaledPath = this.#getScaledPath(path, currentTransform, patternFillTransform);\n                    ctx.fill(scaledPath);\n                } else {\n                    ctx.fill(path);\n                }\n            }\n            if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                if (patternStrokeTransform) {\n                    currentTransform ||= ctx.getTransform();\n                    ctx.setTransform(...patternStrokeTransform);\n                    const { a, b, c, d } = currentTransform;\n                    const invPatternTransform = Util.inverseTransform(patternStrokeTransform);\n                    const transf = Util.transform([\n                        a,\n                        b,\n                        c,\n                        d,\n                        0,\n                        0\n                    ], invPatternTransform);\n                    Util.singularValueDecompose2dScale(transf, XY);\n                    ctx.lineWidth *= Math.max(XY[0], XY[1]) / fontSize;\n                    ctx.stroke(this.#getScaledPath(path, currentTransform, patternStrokeTransform));\n                } else {\n                    ctx.lineWidth /= fontSize;\n                    ctx.stroke(path);\n                }\n            }\n            ctx.restore();\n        } else {\n            if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                ctx.fillText(character, x, y);\n                this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font, fontSize, x, y, ()=>ctx.measureText(character));\n            }\n            if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                if (this.dependencyTracker) {\n                    this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font, fontSize, x, y, ()=>ctx.measureText(character)).recordDependencies(opIdx, Dependencies.stroke);\n                }\n                ctx.strokeText(character, x, y);\n            }\n        }\n        if (isAddToPathSet) {\n            const paths = this.pendingTextPaths ||= [];\n            paths.push({\n                transform: getCurrentTransform(ctx),\n                x,\n                y,\n                fontSize,\n                path\n            });\n            this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font, fontSize, x, y);\n        }\n    }\n    get isFontSubpixelAAEnabled() {\n        const { context: ctx } = this.cachedCanvases.getCanvas(\"isFontSubpixelAAEnabled\", 10, 10);\n        ctx.scale(1.5, 1);\n        ctx.fillText(\"I\", 0, 10);\n        const data = ctx.getImageData(0, 0, 10, 10).data;\n        let enabled = false;\n        for(let i = 3; i < data.length; i += 4){\n            if (data[i] > 0 && data[i] < 255) {\n                enabled = true;\n                break;\n            }\n        }\n        return shadow(this, \"isFontSubpixelAAEnabled\", enabled);\n    }\n    showText(opIdx, glyphs) {\n        if (this.dependencyTracker) {\n            this.dependencyTracker.recordDependencies(opIdx, Dependencies.showText).resetBBox(opIdx);\n            if (this.current.textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG) {\n                this.dependencyTracker.recordFutureForcedDependency(\"textClip\", opIdx).inheritPendingDependenciesAsFutureForcedDependencies();\n            }\n        }\n        const current = this.current;\n        const font = current.font;\n        if (font.isType3Font) {\n            this.showType3Text(opIdx, glyphs);\n            this.dependencyTracker?.recordShowTextOperation(opIdx);\n            return void 0;\n        }\n        const fontSize = current.fontSize;\n        if (fontSize === 0) {\n            this.dependencyTracker?.recordOperation(opIdx);\n            return void 0;\n        }\n        const ctx = this.ctx;\n        const fontSizeScale = current.fontSizeScale;\n        const charSpacing = current.charSpacing;\n        const wordSpacing = current.wordSpacing;\n        const fontDirection = current.fontDirection;\n        const textHScale = current.textHScale * fontDirection;\n        const glyphsLength = glyphs.length;\n        const vertical = font.vertical;\n        const spacingDir = vertical ? 1 : -1;\n        const defaultVMetrics = font.defaultVMetrics;\n        const widthAdvanceScale = fontSize * current.fontMatrix[0];\n        const simpleFillText = current.textRenderingMode === TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;\n        ctx.save();\n        if (current.textMatrix) {\n            ctx.transform(...current.textMatrix);\n        }\n        ctx.translate(current.x, current.y + current.textRise);\n        if (fontDirection > 0) {\n            ctx.scale(textHScale, -1);\n        } else {\n            ctx.scale(textHScale, 1);\n        }\n        let patternFillTransform, patternStrokeTransform;\n        if (current.patternFill) {\n            ctx.save();\n            const pattern = current.fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL, opIdx);\n            patternFillTransform = getCurrentTransform(ctx);\n            ctx.restore();\n            ctx.fillStyle = pattern;\n        }\n        if (current.patternStroke) {\n            ctx.save();\n            const pattern = current.strokeColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.STROKE, opIdx);\n            patternStrokeTransform = getCurrentTransform(ctx);\n            ctx.restore();\n            ctx.strokeStyle = pattern;\n        }\n        let lineWidth = current.lineWidth;\n        const scale = current.textMatrixScale;\n        if (scale === 0 || lineWidth === 0) {\n            const fillStrokeMode = current.textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;\n            if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                lineWidth = this.getSinglePixelWidth();\n            }\n        } else {\n            lineWidth /= scale;\n        }\n        if (fontSizeScale !== 1) {\n            ctx.scale(fontSizeScale, fontSizeScale);\n            lineWidth /= fontSizeScale;\n        }\n        ctx.lineWidth = lineWidth;\n        if (font.isInvalidPDFjsFont) {\n            const chars = [];\n            let width = 0;\n            for (const glyph of glyphs){\n                chars.push(glyph.unicode);\n                width += glyph.width;\n            }\n            const joinedChars = chars.join(\"\");\n            ctx.fillText(joinedChars, 0, 0);\n            if (this.dependencyTracker !== null) {\n                const measure = ctx.measureText(joinedChars);\n                this.dependencyTracker.recordBBox(opIdx, this.ctx, -measure.actualBoundingBoxLeft, measure.actualBoundingBoxRight, -measure.actualBoundingBoxAscent, measure.actualBoundingBoxDescent).recordShowTextOperation(opIdx);\n            }\n            current.x += width * widthAdvanceScale * textHScale;\n            ctx.restore();\n            this.compose();\n            return void 0;\n        }\n        let x = 0, i;\n        for(i = 0; i < glyphsLength; ++i){\n            const glyph = glyphs[i];\n            if (typeof glyph === \"number\") {\n                x += spacingDir * glyph * fontSize / 1e3;\n                continue;\n            }\n            let restoreNeeded = false;\n            const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n            const character = glyph.fontChar;\n            const accent = glyph.accent;\n            let scaledX, scaledY;\n            let width = glyph.width;\n            if (vertical) {\n                const vmetric = glyph.vmetric || defaultVMetrics;\n                const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;\n                const vy = vmetric[2] * widthAdvanceScale;\n                width = vmetric ? -vmetric[0] : width;\n                scaledX = vx / fontSizeScale;\n                scaledY = (x + vy) / fontSizeScale;\n            } else {\n                scaledX = x / fontSizeScale;\n                scaledY = 0;\n            }\n            let measure;\n            if (font.remeasure && width > 0) {\n                measure = ctx.measureText(character);\n                const measuredWidth = measure.width * 1e3 / fontSize * fontSizeScale;\n                if (width < measuredWidth && this.isFontSubpixelAAEnabled) {\n                    const characterScaleX = width / measuredWidth;\n                    restoreNeeded = true;\n                    ctx.save();\n                    ctx.scale(characterScaleX, 1);\n                    scaledX /= characterScaleX;\n                } else if (width !== measuredWidth) {\n                    scaledX += (width - measuredWidth) / 2e3 * fontSize / fontSizeScale;\n                }\n            }\n            if (this.contentVisible && (glyph.isInFont || font.missingFile)) {\n                if (simpleFillText && !accent) {\n                    ctx.fillText(character, scaledX, scaledY);\n                    this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, measure ? {\n                        bbox: null\n                    } : font, fontSize / fontSizeScale, scaledX, scaledY, ()=>measure ?? ctx.measureText(character));\n                } else {\n                    this.paintChar(opIdx, character, scaledX, scaledY, patternFillTransform, patternStrokeTransform);\n                    if (accent) {\n                        const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;\n                        const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;\n                        this.paintChar(opIdx, accent.fontChar, scaledAccentX, scaledAccentY, patternFillTransform, patternStrokeTransform);\n                    }\n                }\n            }\n            const charWidth = vertical ? width * widthAdvanceScale - spacing * fontDirection : width * widthAdvanceScale + spacing * fontDirection;\n            x += charWidth;\n            if (restoreNeeded) {\n                ctx.restore();\n            }\n        }\n        if (vertical) {\n            current.y -= x;\n        } else {\n            current.x += x * textHScale;\n        }\n        ctx.restore();\n        this.compose();\n        this.dependencyTracker?.recordShowTextOperation(opIdx);\n        return void 0;\n    }\n    showType3Text(opIdx, glyphs) {\n        const ctx = this.ctx;\n        const current = this.current;\n        const font = current.font;\n        const fontSize = current.fontSize;\n        const fontDirection = current.fontDirection;\n        const spacingDir = font.vertical ? 1 : -1;\n        const charSpacing = current.charSpacing;\n        const wordSpacing = current.wordSpacing;\n        const textHScale = current.textHScale * fontDirection;\n        const fontMatrix = current.fontMatrix || FONT_IDENTITY_MATRIX;\n        const glyphsLength = glyphs.length;\n        const isTextInvisible = current.textRenderingMode === TextRenderingMode.INVISIBLE;\n        let i, glyph, width, spacingLength;\n        if (isTextInvisible || fontSize === 0) {\n            return;\n        }\n        this._cachedScaleForStroking[0] = -1;\n        this._cachedGetSinglePixelWidth = null;\n        ctx.save();\n        if (current.textMatrix) {\n            ctx.transform(...current.textMatrix);\n        }\n        ctx.translate(current.x, current.y + current.textRise);\n        ctx.scale(textHScale, fontDirection);\n        const dependencyTracker = this.dependencyTracker;\n        this.dependencyTracker = dependencyTracker ? new CanvasNestedDependencyTracker(dependencyTracker, opIdx) : null;\n        for(i = 0; i < glyphsLength; ++i){\n            glyph = glyphs[i];\n            if (typeof glyph === \"number\") {\n                spacingLength = spacingDir * glyph * fontSize / 1e3;\n                this.ctx.translate(spacingLength, 0);\n                current.x += spacingLength * textHScale;\n                continue;\n            }\n            const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n            const operatorList = font.charProcOperatorList[glyph.operatorListId];\n            if (!operatorList) {\n                warn(`Type3 character \"${glyph.operatorListId}\" is not available.`);\n            } else if (this.contentVisible) {\n                this.save();\n                ctx.scale(fontSize, fontSize);\n                ctx.transform(...fontMatrix);\n                this.executeOperatorList(operatorList);\n                this.restore();\n            }\n            const p = [\n                glyph.width,\n                0\n            ];\n            Util.applyTransform(p, fontMatrix);\n            width = p[0] * fontSize + spacing;\n            ctx.translate(width, 0);\n            current.x += width * textHScale;\n        }\n        ctx.restore();\n        if (dependencyTracker) {\n            this.dependencyTracker = dependencyTracker;\n        }\n    }\n    setCharWidth(opIdx, xWidth, yWidth) {}\n    setCharWidthAndBounds(opIdx, xWidth, yWidth, llx, lly, urx, ury) {\n        const clip = new Path2D();\n        clip.rect(llx, lly, urx - llx, ury - lly);\n        this.ctx.clip(clip);\n        this.dependencyTracker?.recordBBox(opIdx, this.ctx, llx, urx, lly, ury).recordClipBox(opIdx, this.ctx, llx, urx, lly, ury);\n        this.endPath(opIdx);\n    }\n    getColorN_Pattern(opIdx, IR) {\n        let pattern;\n        if (IR[0] === \"TilingPattern\") {\n            const baseTransform = this.baseTransform || getCurrentTransform(this.ctx);\n            const canvasGraphicsFactory = {\n                createCanvasGraphics: (ctx, renderingOpIdx)=>new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {\n                        optionalContentConfig: this.optionalContentConfig,\n                        markedContentStack: this.markedContentStack\n                    }, void 0, void 0, this.dependencyTracker ? new CanvasNestedDependencyTracker(this.dependencyTracker, renderingOpIdx, true) : null)\n            };\n            pattern = new TilingPattern(IR, this.ctx, canvasGraphicsFactory, baseTransform);\n        } else {\n            pattern = this._getPattern(opIdx, IR[1], IR[2]);\n        }\n        return pattern;\n    }\n    setStrokeColorN(opIdx, ...args) {\n        this.dependencyTracker?.recordSimpleData(\"strokeColor\", opIdx);\n        this.current.strokeColor = this.getColorN_Pattern(opIdx, args);\n        this.current.patternStroke = true;\n    }\n    setFillColorN(opIdx, ...args) {\n        this.dependencyTracker?.recordSimpleData(\"fillColor\", opIdx);\n        this.current.fillColor = this.getColorN_Pattern(opIdx, args);\n        this.current.patternFill = true;\n    }\n    setStrokeRGBColor(opIdx, color) {\n        this.dependencyTracker?.recordSimpleData(\"strokeColor\", opIdx);\n        this.ctx.strokeStyle = this.current.strokeColor = color;\n        this.current.patternStroke = false;\n    }\n    setStrokeTransparent(opIdx) {\n        this.dependencyTracker?.recordSimpleData(\"strokeColor\", opIdx);\n        this.ctx.strokeStyle = this.current.strokeColor = \"transparent\";\n        this.current.patternStroke = false;\n    }\n    setFillRGBColor(opIdx, color) {\n        this.dependencyTracker?.recordSimpleData(\"fillColor\", opIdx);\n        this.ctx.fillStyle = this.current.fillColor = color;\n        this.current.patternFill = false;\n    }\n    setFillTransparent(opIdx) {\n        this.dependencyTracker?.recordSimpleData(\"fillColor\", opIdx);\n        this.ctx.fillStyle = this.current.fillColor = \"transparent\";\n        this.current.patternFill = false;\n    }\n    _getPattern(opIdx, objId, matrix = null) {\n        let pattern;\n        if (this.cachedPatterns.has(objId)) {\n            pattern = this.cachedPatterns.get(objId);\n        } else {\n            pattern = getShadingPattern(this.getObject(opIdx, objId));\n            this.cachedPatterns.set(objId, pattern);\n        }\n        if (matrix) {\n            pattern.matrix = matrix;\n        }\n        return pattern;\n    }\n    shadingFill(opIdx, objId) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const ctx = this.ctx;\n        this.save(opIdx);\n        const pattern = this._getPattern(opIdx, objId);\n        ctx.fillStyle = pattern.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.SHADING, opIdx);\n        const inv = getCurrentTransformInverse(ctx);\n        if (inv) {\n            const { width, height } = ctx.canvas;\n            const minMax = MIN_MAX_INIT.slice();\n            Util.axialAlignedBoundingBox([\n                0,\n                0,\n                width,\n                height\n            ], inv, minMax);\n            const [x0, y0, x1, y1] = minMax;\n            this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);\n        } else {\n            this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);\n        }\n        this.dependencyTracker?.resetBBox(opIdx).recordFullPageBBox(opIdx).recordDependencies(opIdx, Dependencies.transform).recordDependencies(opIdx, Dependencies.fill).recordOperation(opIdx);\n        this.compose(this.current.getClippedPathBoundingBox());\n        this.restore(opIdx);\n    }\n    beginInlineImage() {\n        unreachable(\"Should not call beginInlineImage\");\n    }\n    beginImageData() {\n        unreachable(\"Should not call beginImageData\");\n    }\n    paintFormXObjectBegin(opIdx, matrix, bbox) {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.save(opIdx);\n        this.baseTransformStack.push(this.baseTransform);\n        if (matrix) {\n            this.transform(opIdx, ...matrix);\n        }\n        this.baseTransform = getCurrentTransform(this.ctx);\n        if (bbox) {\n            Util.axialAlignedBoundingBox(bbox, this.baseTransform, this.current.minMax);\n            const [x0, y0, x1, y1] = bbox;\n            const clip = new Path2D();\n            clip.rect(x0, y0, x1 - x0, y1 - y0);\n            this.ctx.clip(clip);\n            this.dependencyTracker?.recordClipBox(opIdx, this.ctx, x0, x1, y0, y1);\n            this.endPath(opIdx);\n        }\n    }\n    paintFormXObjectEnd(opIdx) {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.restore(opIdx);\n        this.baseTransform = this.baseTransformStack.pop();\n    }\n    beginGroup(opIdx, group) {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.save(opIdx);\n        if (this.inSMaskMode) {\n            this.endSMaskMode();\n            this.current.activeSMask = null;\n        }\n        const currentCtx = this.ctx;\n        if (!group.isolated) {\n            info(\"TODO: Support non-isolated groups.\");\n        }\n        if (group.knockout) {\n            warn(\"Knockout groups not supported.\");\n        }\n        const currentTransform = getCurrentTransform(currentCtx);\n        if (group.matrix) {\n            currentCtx.transform(...group.matrix);\n        }\n        if (!group.bbox) {\n            throw new Error(\"Bounding box is required.\");\n        }\n        let bounds = MIN_MAX_INIT.slice();\n        Util.axialAlignedBoundingBox(group.bbox, getCurrentTransform(currentCtx), bounds);\n        const canvasBounds = [\n            0,\n            0,\n            currentCtx.canvas.width,\n            currentCtx.canvas.height\n        ];\n        bounds = Util.intersect(bounds, canvasBounds) || [\n            0,\n            0,\n            0,\n            0\n        ];\n        const offsetX = Math.floor(bounds[0]);\n        const offsetY = Math.floor(bounds[1]);\n        const drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);\n        const drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);\n        this.current.startNewPathAndClipBox([\n            0,\n            0,\n            drawnWidth,\n            drawnHeight\n        ]);\n        let cacheId = \"groupAt\" + this.groupLevel;\n        if (group.smask) {\n            cacheId += \"_smask_\" + this.smaskCounter++ % 2;\n        }\n        const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);\n        const groupCtx = scratchCanvas.context;\n        groupCtx.translate(-offsetX, -offsetY);\n        groupCtx.transform(...currentTransform);\n        let clip = new Path2D();\n        const [x0, y0, x1, y1] = group.bbox;\n        clip.rect(x0, y0, x1 - x0, y1 - y0);\n        if (group.matrix) {\n            const path = new Path2D();\n            path.addPath(clip, new DOMMatrix(group.matrix));\n            clip = path;\n        }\n        groupCtx.clip(clip);\n        if (group.smask) {\n            this.smaskStack.push({\n                canvas: scratchCanvas.canvas,\n                context: groupCtx,\n                offsetX,\n                offsetY,\n                subtype: group.smask.subtype,\n                backdrop: group.smask.backdrop,\n                transferMap: group.smask.transferMap || null,\n                startTransformInverse: null\n            });\n        }\n        if (!group.smask || this.dependencyTracker) {\n            currentCtx.setTransform(1, 0, 0, 1, 0, 0);\n            currentCtx.translate(offsetX, offsetY);\n            currentCtx.save();\n        }\n        copyCtxState(currentCtx, groupCtx);\n        this.ctx = groupCtx;\n        this.dependencyTracker?.inheritSimpleDataAsFutureForcedDependencies([\n            \"fillAlpha\",\n            \"strokeAlpha\",\n            \"globalCompositeOperation\"\n        ]).pushBaseTransform(currentCtx);\n        this.setGState(opIdx, [\n            [\n                \"BM\",\n                \"source-over\"\n            ],\n            [\n                \"ca\",\n                1\n            ],\n            [\n                \"CA\",\n                1\n            ]\n        ]);\n        this.groupStack.push(currentCtx);\n        this.groupLevel++;\n    }\n    endGroup(opIdx, group) {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.groupLevel--;\n        const groupCtx = this.ctx;\n        const ctx = this.groupStack.pop();\n        this.ctx = ctx;\n        this.ctx.imageSmoothingEnabled = false;\n        this.dependencyTracker?.popBaseTransform();\n        if (group.smask) {\n            this.tempSMask = this.smaskStack.pop();\n            this.restore(opIdx);\n            if (this.dependencyTracker) {\n                this.ctx.restore();\n            }\n        } else {\n            this.ctx.restore();\n            const currentMtx = getCurrentTransform(this.ctx);\n            this.restore(opIdx);\n            this.ctx.save();\n            this.ctx.setTransform(...currentMtx);\n            const dirtyBox = MIN_MAX_INIT.slice();\n            Util.axialAlignedBoundingBox([\n                0,\n                0,\n                groupCtx.canvas.width,\n                groupCtx.canvas.height\n            ], currentMtx, dirtyBox);\n            this.ctx.drawImage(groupCtx.canvas, 0, 0);\n            this.ctx.restore();\n            this.compose(dirtyBox);\n        }\n    }\n    beginAnnotation(opIdx, id, rect, transform, matrix, hasOwnCanvas) {\n        this.#restoreInitialState();\n        resetCtxToDefault(this.ctx);\n        this.ctx.save();\n        this.save(opIdx);\n        if (this.baseTransform) {\n            this.ctx.setTransform(...this.baseTransform);\n        }\n        if (rect) {\n            const width = rect[2] - rect[0];\n            const height = rect[3] - rect[1];\n            if (hasOwnCanvas && this.annotationCanvasMap) {\n                transform = transform.slice();\n                transform[4] -= rect[0];\n                transform[5] -= rect[1];\n                rect = rect.slice();\n                rect[0] = rect[1] = 0;\n                rect[2] = width;\n                rect[3] = height;\n                Util.singularValueDecompose2dScale(getCurrentTransform(this.ctx), XY);\n                const { viewportScale } = this;\n                const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);\n                const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);\n                this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);\n                const { canvas, context } = this.annotationCanvas;\n                this.annotationCanvasMap.set(id, canvas);\n                this.annotationCanvas.savedCtx = this.ctx;\n                this.ctx = context;\n                this.ctx.save();\n                this.ctx.setTransform(XY[0], 0, 0, -XY[1], 0, height * XY[1]);\n                resetCtxToDefault(this.ctx);\n            } else {\n                resetCtxToDefault(this.ctx);\n                this.endPath(opIdx);\n                const clip = new Path2D();\n                clip.rect(rect[0], rect[1], width, height);\n                this.ctx.clip(clip);\n            }\n        }\n        this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n        this.transform(opIdx, ...transform);\n        this.transform(opIdx, ...matrix);\n    }\n    endAnnotation(opIdx) {\n        if (this.annotationCanvas) {\n            this.ctx.restore();\n            this.#drawFilter();\n            this.ctx = this.annotationCanvas.savedCtx;\n            delete this.annotationCanvas.savedCtx;\n            delete this.annotationCanvas;\n        }\n    }\n    paintImageMaskXObject(opIdx, img) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const count = img.count;\n        img = this.getObject(opIdx, img.data, img);\n        img.count = count;\n        const ctx = this.ctx;\n        const mask = this._createMaskCanvas(opIdx, img);\n        const maskCanvas = mask.canvas;\n        ctx.save();\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);\n        this.dependencyTracker?.resetBBox(opIdx).recordBBox(opIdx, this.ctx, mask.offsetX, mask.offsetX + maskCanvas.width, mask.offsetY, mask.offsetY + maskCanvas.height).recordOperation(opIdx);\n        ctx.restore();\n        this.compose();\n    }\n    paintImageMaskXObjectRepeat(opIdx, img, scaleX, skewX = 0, skewY = 0, scaleY, positions) {\n        if (!this.contentVisible) {\n            return;\n        }\n        img = this.getObject(opIdx, img.data, img);\n        const ctx = this.ctx;\n        ctx.save();\n        const currentTransform = getCurrentTransform(ctx);\n        ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);\n        const mask = this._createMaskCanvas(opIdx, img);\n        ctx.setTransform(1, 0, 0, 1, mask.offsetX - currentTransform[4], mask.offsetY - currentTransform[5]);\n        this.dependencyTracker?.resetBBox(opIdx);\n        for(let i = 0, ii = positions.length; i < ii; i += 2){\n            const trans = Util.transform(currentTransform, [\n                scaleX,\n                skewX,\n                skewY,\n                scaleY,\n                positions[i],\n                positions[i + 1]\n            ]);\n            ctx.drawImage(mask.canvas, trans[4], trans[5]);\n            this.dependencyTracker?.recordBBox(opIdx, this.ctx, trans[4], trans[4] + mask.canvas.width, trans[5], trans[5] + mask.canvas.height);\n        }\n        ctx.restore();\n        this.compose();\n        this.dependencyTracker?.recordOperation(opIdx);\n    }\n    paintImageMaskXObjectGroup(opIdx, images) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const ctx = this.ctx;\n        const fillColor = this.current.fillColor;\n        const isPatternFill = this.current.patternFill;\n        this.dependencyTracker?.resetBBox(opIdx).recordDependencies(opIdx, Dependencies.transformAndFill);\n        for (const image of images){\n            const { data, width, height, transform } = image;\n            const maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n            const maskCtx = maskCanvas.context;\n            maskCtx.save();\n            const img = this.getObject(opIdx, data, image);\n            putBinaryImageMask(maskCtx, img);\n            maskCtx.globalCompositeOperation = \"source-in\";\n            maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, getCurrentTransformInverse(ctx), PathType.FILL, opIdx) : fillColor;\n            maskCtx.fillRect(0, 0, width, height);\n            maskCtx.restore();\n            ctx.save();\n            ctx.transform(...transform);\n            ctx.scale(1, -1);\n            drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);\n            this.dependencyTracker?.recordBBox(opIdx, ctx, 0, width, 0, height);\n            ctx.restore();\n        }\n        this.compose();\n        this.dependencyTracker?.recordOperation(opIdx);\n    }\n    paintImageXObject(opIdx, objId) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const imgData = this.getObject(opIdx, objId);\n        if (!imgData) {\n            warn(\"Dependent image isn't ready yet\");\n            return;\n        }\n        this.paintInlineImageXObject(opIdx, imgData);\n    }\n    paintImageXObjectRepeat(opIdx, objId, scaleX, scaleY, positions) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const imgData = this.getObject(opIdx, objId);\n        if (!imgData) {\n            warn(\"Dependent image isn't ready yet\");\n            return;\n        }\n        const width = imgData.width;\n        const height = imgData.height;\n        const map = [];\n        for(let i = 0, ii = positions.length; i < ii; i += 2){\n            map.push({\n                transform: [\n                    scaleX,\n                    0,\n                    0,\n                    scaleY,\n                    positions[i],\n                    positions[i + 1]\n                ],\n                x: 0,\n                y: 0,\n                w: width,\n                h: height\n            });\n        }\n        this.paintInlineImageXObjectGroup(opIdx, imgData, map);\n    }\n    applyTransferMapsToCanvas(ctx) {\n        if (this.current.transferMaps !== \"none\") {\n            ctx.filter = this.current.transferMaps;\n            ctx.drawImage(ctx.canvas, 0, 0);\n            ctx.filter = \"none\";\n        }\n        return ctx.canvas;\n    }\n    applyTransferMapsToBitmap(imgData) {\n        if (this.current.transferMaps === \"none\") {\n            return imgData.bitmap;\n        }\n        const { bitmap, width, height } = imgData;\n        const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n        const tmpCtx = tmpCanvas.context;\n        tmpCtx.filter = this.current.transferMaps;\n        tmpCtx.drawImage(bitmap, 0, 0);\n        tmpCtx.filter = \"none\";\n        return tmpCanvas.canvas;\n    }\n    paintInlineImageXObject(opIdx, imgData) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const width = imgData.width;\n        const height = imgData.height;\n        const ctx = this.ctx;\n        this.save(opIdx);\n        const { filter } = ctx;\n        if (filter !== \"none\" && filter !== \"\") {\n            ctx.filter = \"none\";\n        }\n        ctx.scale(1 / width, -1 / height);\n        let imgToPaint;\n        if (imgData.bitmap) {\n            imgToPaint = this.applyTransferMapsToBitmap(imgData);\n        } else if (typeof HTMLElement === \"function\" && imgData instanceof HTMLElement || !imgData.data) {\n            imgToPaint = imgData;\n        } else {\n            const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n            const tmpCtx = tmpCanvas.context;\n            putBinaryImageData(tmpCtx, imgData);\n            imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);\n        }\n        const scaled = this._scaleImage(imgToPaint, getCurrentTransformInverse(ctx));\n        ctx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(ctx), imgData.interpolate);\n        this.dependencyTracker?.resetBBox(opIdx).recordBBox(opIdx, ctx, 0, width, -height, 0).recordDependencies(opIdx, Dependencies.imageXObject).recordOperation(opIdx);\n        drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);\n        this.compose();\n        this.restore(opIdx);\n    }\n    paintInlineImageXObjectGroup(opIdx, imgData, map) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const ctx = this.ctx;\n        let imgToPaint;\n        if (imgData.bitmap) {\n            imgToPaint = imgData.bitmap;\n        } else {\n            const w = imgData.width;\n            const h = imgData.height;\n            const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", w, h);\n            const tmpCtx = tmpCanvas.context;\n            putBinaryImageData(tmpCtx, imgData);\n            imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);\n        }\n        this.dependencyTracker?.resetBBox(opIdx);\n        for (const entry of map){\n            ctx.save();\n            ctx.transform(...entry.transform);\n            ctx.scale(1, -1);\n            drawImageAtIntegerCoords(ctx, imgToPaint, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);\n            this.dependencyTracker?.recordBBox(opIdx, ctx, 0, 1, -1, 0);\n            ctx.restore();\n        }\n        this.dependencyTracker?.recordOperation(opIdx);\n        this.compose();\n    }\n    paintSolidColorImageMask(opIdx) {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.dependencyTracker?.resetBBox(opIdx).recordBBox(opIdx, this.ctx, 0, 1, 0, 1).recordDependencies(opIdx, Dependencies.fill).recordOperation(opIdx);\n        this.ctx.fillRect(0, 0, 1, 1);\n        this.compose();\n    }\n    markPoint(opIdx, tag) {}\n    markPointProps(opIdx, tag, properties) {}\n    beginMarkedContent(opIdx, tag) {\n        this.dependencyTracker?.beginMarkedContent(opIdx);\n        this.markedContentStack.push({\n            visible: true\n        });\n    }\n    beginMarkedContentProps(opIdx, tag, properties) {\n        this.dependencyTracker?.beginMarkedContent(opIdx);\n        if (tag === \"OC\") {\n            this.markedContentStack.push({\n                visible: this.optionalContentConfig.isVisible(properties)\n            });\n        } else {\n            this.markedContentStack.push({\n                visible: true\n            });\n        }\n        this.contentVisible = this.isContentVisible();\n    }\n    endMarkedContent(opIdx) {\n        this.dependencyTracker?.endMarkedContent(opIdx);\n        this.markedContentStack.pop();\n        this.contentVisible = this.isContentVisible();\n    }\n    beginCompat(opIdx) {}\n    endCompat(opIdx) {}\n    consumePath(opIdx, path, clipBox) {\n        const isEmpty = this.current.isEmptyClip();\n        if (this.pendingClip) {\n            this.current.updateClipFromPath();\n        }\n        if (!this.pendingClip) {\n            this.compose(clipBox);\n        }\n        const ctx = this.ctx;\n        if (this.pendingClip) {\n            if (!isEmpty) {\n                if (this.pendingClip === EO_CLIP) {\n                    ctx.clip(path, \"evenodd\");\n                } else {\n                    ctx.clip(path);\n                }\n            }\n            this.pendingClip = null;\n            this.dependencyTracker?.bboxToClipBoxDropOperation(opIdx).recordFutureForcedDependency(\"clipPath\", opIdx);\n        } else {\n            this.dependencyTracker?.recordOperation(opIdx);\n        }\n        this.current.startNewPathAndClipBox(this.current.clipBox);\n    }\n    getSinglePixelWidth() {\n        if (!this._cachedGetSinglePixelWidth) {\n            const m = getCurrentTransform(this.ctx);\n            if (m[1] === 0 && m[2] === 0) {\n                this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));\n            } else {\n                const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);\n                const normX = Math.hypot(m[0], m[2]);\n                const normY = Math.hypot(m[1], m[3]);\n                this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;\n            }\n        }\n        return this._cachedGetSinglePixelWidth;\n    }\n    getScaleForStroking() {\n        if (this._cachedScaleForStroking[0] === -1) {\n            const { lineWidth } = this.current;\n            const { a, b, c, d } = this.ctx.getTransform();\n            let scaleX, scaleY;\n            if (b === 0 && c === 0) {\n                const normX = Math.abs(a);\n                const normY = Math.abs(d);\n                if (normX === normY) {\n                    if (lineWidth === 0) {\n                        scaleX = scaleY = 1 / normX;\n                    } else {\n                        const scaledLineWidth = normX * lineWidth;\n                        scaleX = scaleY = scaledLineWidth < 1 ? 1 / scaledLineWidth : 1;\n                    }\n                } else if (lineWidth === 0) {\n                    scaleX = 1 / normX;\n                    scaleY = 1 / normY;\n                } else {\n                    const scaledXLineWidth = normX * lineWidth;\n                    const scaledYLineWidth = normY * lineWidth;\n                    scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;\n                    scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;\n                }\n            } else {\n                const absDet = Math.abs(a * d - b * c);\n                const normX = Math.hypot(a, b);\n                const normY = Math.hypot(c, d);\n                if (lineWidth === 0) {\n                    scaleX = normY / absDet;\n                    scaleY = normX / absDet;\n                } else {\n                    const baseArea = lineWidth * absDet;\n                    scaleX = normY > baseArea ? normY / baseArea : 1;\n                    scaleY = normX > baseArea ? normX / baseArea : 1;\n                }\n            }\n            this._cachedScaleForStroking[0] = scaleX;\n            this._cachedScaleForStroking[1] = scaleY;\n        }\n        return this._cachedScaleForStroking;\n    }\n    rescaleAndStroke(path, saveRestore) {\n        const { ctx, current: { lineWidth } } = this;\n        const [scaleX, scaleY] = this.getScaleForStroking();\n        if (scaleX === scaleY) {\n            ctx.lineWidth = (lineWidth || 1) * scaleX;\n            ctx.stroke(path);\n            return;\n        }\n        const dashes = ctx.getLineDash();\n        if (saveRestore) {\n            ctx.save();\n        }\n        ctx.scale(scaleX, scaleY);\n        SCALE_MATRIX.a = 1 / scaleX;\n        SCALE_MATRIX.d = 1 / scaleY;\n        const newPath = new Path2D();\n        newPath.addPath(path, SCALE_MATRIX);\n        if (dashes.length > 0) {\n            const scale = Math.max(scaleX, scaleY);\n            ctx.setLineDash(dashes.map((x)=>x / scale));\n            ctx.lineDashOffset /= scale;\n        }\n        ctx.lineWidth = lineWidth || 1;\n        ctx.stroke(newPath);\n        if (saveRestore) {\n            ctx.restore();\n        }\n    }\n    isContentVisible() {\n        for(let i = this.markedContentStack.length - 1; i >= 0; i--){\n            if (!this.markedContentStack[i].visible) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nfor(const op in OPS){\n    if (CanvasGraphics.prototype[op] !== void 0) {\n        CanvasGraphics.prototype[OPS[op]] = CanvasGraphics.prototype[op];\n    }\n}\nclass CssFontInfo {\n    #buffer;\n    #view;\n    #decoder;\n    static{\n        this.strings = [\n            \"fontFamily\",\n            \"fontWeight\",\n            \"italicAngle\"\n        ];\n    }\n    static write(info2) {\n        const encoder = new TextEncoder();\n        const encodedStrings = {};\n        let stringsLength = 0;\n        for (const prop of CssFontInfo.strings){\n            const encoded = encoder.encode(info2[prop]);\n            encodedStrings[prop] = encoded;\n            stringsLength += 4 + encoded.length;\n        }\n        const buffer = new ArrayBuffer(stringsLength);\n        const data = new Uint8Array(buffer);\n        const view = new DataView(buffer);\n        let offset = 0;\n        for (const prop of CssFontInfo.strings){\n            const encoded = encodedStrings[prop];\n            const length = encoded.length;\n            view.setUint32(offset, length);\n            data.set(encoded, offset + 4);\n            offset += 4 + length;\n        }\n        assert(offset === buffer.byteLength, \"CssFontInfo.write: Buffer overflow\");\n        return buffer;\n    }\n    constructor(buffer){\n        this.#buffer = buffer;\n        this.#view = new DataView(this.#buffer);\n        this.#decoder = new TextDecoder();\n    }\n    #readString(index) {\n        assert(index < CssFontInfo.strings.length, \"Invalid string index\");\n        let offset = 0;\n        for(let i = 0; i < index; i++){\n            offset += this.#view.getUint32(offset) + 4;\n        }\n        const length = this.#view.getUint32(offset);\n        return this.#decoder.decode(new Uint8Array(this.#buffer, offset + 4, length));\n    }\n    get fontFamily() {\n        return this.#readString(0);\n    }\n    get fontWeight() {\n        return this.#readString(1);\n    }\n    get italicAngle() {\n        return this.#readString(2);\n    }\n}\nclass SystemFontInfo {\n    #buffer;\n    #view;\n    #decoder;\n    static{\n        this.strings = [\n            \"css\",\n            \"loadedName\",\n            \"baseFontName\",\n            \"src\"\n        ];\n    }\n    static write(info2) {\n        const encoder = new TextEncoder();\n        const encodedStrings = {};\n        let stringsLength = 0;\n        for (const prop of SystemFontInfo.strings){\n            const encoded = encoder.encode(info2[prop]);\n            encodedStrings[prop] = encoded;\n            stringsLength += 4 + encoded.length;\n        }\n        stringsLength += 4;\n        let encodedStyleStyle, encodedStyleWeight, lengthEstimate = 1 + stringsLength;\n        if (info2.style) {\n            encodedStyleStyle = encoder.encode(info2.style.style);\n            encodedStyleWeight = encoder.encode(info2.style.weight);\n            lengthEstimate += 4 + encodedStyleStyle.length + 4 + encodedStyleWeight.length;\n        }\n        const buffer = new ArrayBuffer(lengthEstimate);\n        const data = new Uint8Array(buffer);\n        const view = new DataView(buffer);\n        let offset = 0;\n        view.setUint8(offset++, info2.guessFallback ? 1 : 0);\n        view.setUint32(offset, 0);\n        offset += 4;\n        stringsLength = 0;\n        for (const prop of SystemFontInfo.strings){\n            const encoded = encodedStrings[prop];\n            const length = encoded.length;\n            stringsLength += 4 + length;\n            view.setUint32(offset, length);\n            data.set(encoded, offset + 4);\n            offset += 4 + length;\n        }\n        view.setUint32(offset - stringsLength - 4, stringsLength);\n        if (info2.style) {\n            view.setUint32(offset, encodedStyleStyle.length);\n            data.set(encodedStyleStyle, offset + 4);\n            offset += 4 + encodedStyleStyle.length;\n            view.setUint32(offset, encodedStyleWeight.length);\n            data.set(encodedStyleWeight, offset + 4);\n            offset += 4 + encodedStyleWeight.length;\n        }\n        assert(offset <= buffer.byteLength, \"SubstitionInfo.write: Buffer overflow\");\n        return buffer.transferToFixedLength(offset);\n    }\n    constructor(buffer){\n        this.#buffer = buffer;\n        this.#view = new DataView(this.#buffer);\n        this.#decoder = new TextDecoder();\n    }\n    get guessFallback() {\n        return this.#view.getUint8(0) !== 0;\n    }\n    #readString(index) {\n        assert(index < SystemFontInfo.strings.length, \"Invalid string index\");\n        let offset = 5;\n        for(let i = 0; i < index; i++){\n            offset += this.#view.getUint32(offset) + 4;\n        }\n        const length = this.#view.getUint32(offset);\n        return this.#decoder.decode(new Uint8Array(this.#buffer, offset + 4, length));\n    }\n    get css() {\n        return this.#readString(0);\n    }\n    get loadedName() {\n        return this.#readString(1);\n    }\n    get baseFontName() {\n        return this.#readString(2);\n    }\n    get src() {\n        return this.#readString(3);\n    }\n    get style() {\n        let offset = 1;\n        offset += 4 + this.#view.getUint32(offset);\n        const styleLength = this.#view.getUint32(offset);\n        const style = this.#decoder.decode(new Uint8Array(this.#buffer, offset + 4, styleLength));\n        offset += 4 + styleLength;\n        const weightLength = this.#view.getUint32(offset);\n        const weight = this.#decoder.decode(new Uint8Array(this.#buffer, offset + 4, weightLength));\n        return {\n            style,\n            weight\n        };\n    }\n}\nclass FontInfo {\n    static{\n        this.bools = [\n            \"black\",\n            \"bold\",\n            \"disableFontFace\",\n            \"fontExtraProperties\",\n            \"isInvalidPDFjsFont\",\n            \"isType3Font\",\n            \"italic\",\n            \"missingFile\",\n            \"remeasure\",\n            \"vertical\"\n        ];\n    }\n    static{\n        this.numbers = [\n            \"ascent\",\n            \"defaultWidth\",\n            \"descent\"\n        ];\n    }\n    static{\n        this.strings = [\n            \"fallbackName\",\n            \"loadedName\",\n            \"mimetype\",\n            \"name\"\n        ];\n    }\n    static #OFFSET_NUMBERS = Math.ceil(this.bools.length * 2 / 8);\n    static #OFFSET_BBOX = this.#OFFSET_NUMBERS + this.numbers.length * 8;\n    static #OFFSET_FONT_MATRIX = this.#OFFSET_BBOX + 1 + 2 * 4;\n    static #OFFSET_DEFAULT_VMETRICS = this.#OFFSET_FONT_MATRIX + 1 + 8 * 6;\n    static #OFFSET_STRINGS = this.#OFFSET_DEFAULT_VMETRICS + 1 + 2 * 3;\n    #buffer;\n    #decoder;\n    #view;\n    constructor({ data, extra }){\n        this.#buffer = data;\n        this.#decoder = new TextDecoder();\n        this.#view = new DataView(this.#buffer);\n        if (extra) {\n            Object.assign(this, extra);\n        }\n    }\n    #readBoolean(index) {\n        assert(index < FontInfo.bools.length, \"Invalid boolean index\");\n        const byteOffset = Math.floor(index / 4);\n        const bitOffset = index * 2 % 8;\n        const value1 = this.#view.getUint8(byteOffset) >> bitOffset & 3;\n        return value1 === 0 ? void 0 : value1 === 2;\n    }\n    get black() {\n        return this.#readBoolean(0);\n    }\n    get bold() {\n        return this.#readBoolean(1);\n    }\n    get disableFontFace() {\n        return this.#readBoolean(2);\n    }\n    get fontExtraProperties() {\n        return this.#readBoolean(3);\n    }\n    get isInvalidPDFjsFont() {\n        return this.#readBoolean(4);\n    }\n    get isType3Font() {\n        return this.#readBoolean(5);\n    }\n    get italic() {\n        return this.#readBoolean(6);\n    }\n    get missingFile() {\n        return this.#readBoolean(7);\n    }\n    get remeasure() {\n        return this.#readBoolean(8);\n    }\n    get vertical() {\n        return this.#readBoolean(9);\n    }\n    #readNumber(index) {\n        assert(index < FontInfo.numbers.length, \"Invalid number index\");\n        return this.#view.getFloat64(FontInfo.#OFFSET_NUMBERS + index * 8);\n    }\n    get ascent() {\n        return this.#readNumber(0);\n    }\n    get defaultWidth() {\n        return this.#readNumber(1);\n    }\n    get descent() {\n        return this.#readNumber(2);\n    }\n    get bbox() {\n        let offset = FontInfo.#OFFSET_BBOX;\n        const numCoords = this.#view.getUint8(offset);\n        if (numCoords === 0) {\n            return void 0;\n        }\n        offset += 1;\n        const bbox = [];\n        for(let i = 0; i < 4; i++){\n            bbox.push(this.#view.getInt16(offset, true));\n            offset += 2;\n        }\n        return bbox;\n    }\n    get fontMatrix() {\n        let offset = FontInfo.#OFFSET_FONT_MATRIX;\n        const numPoints = this.#view.getUint8(offset);\n        if (numPoints === 0) {\n            return void 0;\n        }\n        offset += 1;\n        const fontMatrix = [];\n        for(let i = 0; i < 6; i++){\n            fontMatrix.push(this.#view.getFloat64(offset, true));\n            offset += 8;\n        }\n        return fontMatrix;\n    }\n    get defaultVMetrics() {\n        let offset = FontInfo.#OFFSET_DEFAULT_VMETRICS;\n        const numMetrics = this.#view.getUint8(offset);\n        if (numMetrics === 0) {\n            return void 0;\n        }\n        offset += 1;\n        const defaultVMetrics = [];\n        for(let i = 0; i < 3; i++){\n            defaultVMetrics.push(this.#view.getInt16(offset, true));\n            offset += 2;\n        }\n        return defaultVMetrics;\n    }\n    #readString(index) {\n        assert(index < FontInfo.strings.length, \"Invalid string index\");\n        let offset = FontInfo.#OFFSET_STRINGS + 4;\n        for(let i = 0; i < index; i++){\n            offset += this.#view.getUint32(offset) + 4;\n        }\n        const length = this.#view.getUint32(offset);\n        const stringData = new Uint8Array(length);\n        stringData.set(new Uint8Array(this.#buffer, offset + 4, length));\n        return this.#decoder.decode(stringData);\n    }\n    get fallbackName() {\n        return this.#readString(0);\n    }\n    get loadedName() {\n        return this.#readString(1);\n    }\n    get mimetype() {\n        return this.#readString(2);\n    }\n    get name() {\n        return this.#readString(3);\n    }\n    get data() {\n        let offset = FontInfo.#OFFSET_STRINGS;\n        const stringsLength = this.#view.getUint32(offset);\n        offset += 4 + stringsLength;\n        const systemFontInfoLength = this.#view.getUint32(offset);\n        offset += 4 + systemFontInfoLength;\n        const cssFontInfoLength = this.#view.getUint32(offset);\n        offset += 4 + cssFontInfoLength;\n        const length = this.#view.getUint32(offset);\n        if (length === 0) {\n            return void 0;\n        }\n        return new Uint8Array(this.#buffer, offset + 4, length);\n    }\n    clearData() {\n        let offset = FontInfo.#OFFSET_STRINGS;\n        const stringsLength = this.#view.getUint32(offset);\n        offset += 4 + stringsLength;\n        const systemFontInfoLength = this.#view.getUint32(offset);\n        offset += 4 + systemFontInfoLength;\n        const cssFontInfoLength = this.#view.getUint32(offset);\n        offset += 4 + cssFontInfoLength;\n        const length = this.#view.getUint32(offset);\n        const data = new Uint8Array(this.#buffer, offset + 4, length);\n        data.fill(0);\n        this.#view.setUint32(offset, 0);\n    }\n    get cssFontInfo() {\n        let offset = FontInfo.#OFFSET_STRINGS;\n        const stringsLength = this.#view.getUint32(offset);\n        offset += 4 + stringsLength;\n        const systemFontInfoLength = this.#view.getUint32(offset);\n        offset += 4 + systemFontInfoLength;\n        const cssFontInfoLength = this.#view.getUint32(offset);\n        if (cssFontInfoLength === 0) {\n            return null;\n        }\n        const cssFontInfoData = new Uint8Array(cssFontInfoLength);\n        cssFontInfoData.set(new Uint8Array(this.#buffer, offset + 4, cssFontInfoLength));\n        return new CssFontInfo(cssFontInfoData.buffer);\n    }\n    get systemFontInfo() {\n        let offset = FontInfo.#OFFSET_STRINGS;\n        const stringsLength = this.#view.getUint32(offset);\n        offset += 4 + stringsLength;\n        const systemFontInfoLength = this.#view.getUint32(offset);\n        if (systemFontInfoLength === 0) {\n            return null;\n        }\n        const systemFontInfoData = new Uint8Array(systemFontInfoLength);\n        systemFontInfoData.set(new Uint8Array(this.#buffer, offset + 4, systemFontInfoLength));\n        return new SystemFontInfo(systemFontInfoData.buffer);\n    }\n    static write(font) {\n        const systemFontInfoBuffer = font.systemFontInfo ? SystemFontInfo.write(font.systemFontInfo) : null;\n        const cssFontInfoBuffer = font.cssFontInfo ? CssFontInfo.write(font.cssFontInfo) : null;\n        const encoder = new TextEncoder();\n        const encodedStrings = {};\n        let stringsLength = 0;\n        for (const prop of FontInfo.strings){\n            encodedStrings[prop] = encoder.encode(font[prop]);\n            stringsLength += 4 + encodedStrings[prop].length;\n        }\n        const lengthEstimate = FontInfo.#OFFSET_STRINGS + 4 + stringsLength + 4 + (systemFontInfoBuffer ? systemFontInfoBuffer.byteLength : 0) + 4 + (cssFontInfoBuffer ? cssFontInfoBuffer.byteLength : 0) + 4 + (font.data ? font.data.length : 0);\n        const buffer = new ArrayBuffer(lengthEstimate);\n        const data = new Uint8Array(buffer);\n        const view = new DataView(buffer);\n        let offset = 0;\n        const numBools = FontInfo.bools.length;\n        let boolByte = 0, boolBit = 0;\n        for(let i = 0; i < numBools; i++){\n            const value1 = font[FontInfo.bools[i]];\n            const bits = value1 === void 0 ? 0 : value1 ? 2 : 1;\n            boolByte |= bits << boolBit;\n            boolBit += 2;\n            if (boolBit === 8 || i === numBools - 1) {\n                view.setUint8(offset++, boolByte);\n                boolByte = 0;\n                boolBit = 0;\n            }\n        }\n        assert(offset === FontInfo.#OFFSET_NUMBERS, \"FontInfo.write: Boolean properties offset mismatch\");\n        for (const prop of FontInfo.numbers){\n            view.setFloat64(offset, font[prop]);\n            offset += 8;\n        }\n        assert(offset === FontInfo.#OFFSET_BBOX, \"FontInfo.write: Number properties offset mismatch\");\n        if (font.bbox) {\n            view.setUint8(offset++, 4);\n            for (const coord of font.bbox){\n                view.setInt16(offset, coord, true);\n                offset += 2;\n            }\n        } else {\n            view.setUint8(offset++, 0);\n            offset += 2 * 4;\n        }\n        assert(offset === FontInfo.#OFFSET_FONT_MATRIX, \"FontInfo.write: BBox properties offset mismatch\");\n        if (font.fontMatrix) {\n            view.setUint8(offset++, 6);\n            for (const point of font.fontMatrix){\n                view.setFloat64(offset, point, true);\n                offset += 8;\n            }\n        } else {\n            view.setUint8(offset++, 0);\n            offset += 8 * 6;\n        }\n        assert(offset === FontInfo.#OFFSET_DEFAULT_VMETRICS, \"FontInfo.write: FontMatrix properties offset mismatch\");\n        if (font.defaultVMetrics) {\n            view.setUint8(offset++, 1);\n            for (const metric of font.defaultVMetrics){\n                view.setInt16(offset, metric, true);\n                offset += 2;\n            }\n        } else {\n            view.setUint8(offset++, 0);\n            offset += 3 * 2;\n        }\n        assert(offset === FontInfo.#OFFSET_STRINGS, \"FontInfo.write: DefaultVMetrics properties offset mismatch\");\n        view.setUint32(FontInfo.#OFFSET_STRINGS, 0);\n        offset += 4;\n        for (const prop of FontInfo.strings){\n            const encoded = encodedStrings[prop];\n            const length = encoded.length;\n            view.setUint32(offset, length);\n            data.set(encoded, offset + 4);\n            offset += 4 + length;\n        }\n        view.setUint32(FontInfo.#OFFSET_STRINGS, offset - FontInfo.#OFFSET_STRINGS - 4);\n        if (!systemFontInfoBuffer) {\n            view.setUint32(offset, 0);\n            offset += 4;\n        } else {\n            const length = systemFontInfoBuffer.byteLength;\n            view.setUint32(offset, length);\n            assert(offset + 4 + length <= buffer.byteLength, \"FontInfo.write: Buffer overflow at systemFontInfo\");\n            data.set(new Uint8Array(systemFontInfoBuffer), offset + 4);\n            offset += 4 + length;\n        }\n        if (!cssFontInfoBuffer) {\n            view.setUint32(offset, 0);\n            offset += 4;\n        } else {\n            const length = cssFontInfoBuffer.byteLength;\n            view.setUint32(offset, length);\n            assert(offset + 4 + length <= buffer.byteLength, \"FontInfo.write: Buffer overflow at cssFontInfo\");\n            data.set(new Uint8Array(cssFontInfoBuffer), offset + 4);\n            offset += 4 + length;\n        }\n        if (font.data === void 0) {\n            view.setUint32(offset, 0);\n            offset += 4;\n        } else {\n            view.setUint32(offset, font.data.length);\n            data.set(font.data, offset + 4);\n            offset += 4 + font.data.length;\n        }\n        assert(offset <= buffer.byteLength, \"FontInfo.write: Buffer overflow\");\n        return buffer.transferToFixedLength(offset);\n    }\n}\nclass GlobalWorkerOptions {\n    static #port = null;\n    static #src = \"\";\n    static get workerPort() {\n        return this.#port;\n    }\n    static set workerPort(val) {\n        if (!(typeof Worker !== \"undefined\" && val instanceof Worker) && val !== null) {\n            throw new Error(\"Invalid `workerPort` type.\");\n        }\n        this.#port = val;\n    }\n    static get workerSrc() {\n        return this.#src;\n    }\n    static set workerSrc(val) {\n        if (typeof val !== \"string\") {\n            throw new Error(\"Invalid `workerSrc` type.\");\n        }\n        this.#src = val;\n    }\n}\nclass Metadata {\n    #map;\n    #data;\n    constructor({ parsedData, rawData }){\n        this.#map = parsedData;\n        this.#data = rawData;\n    }\n    getRaw() {\n        return this.#data;\n    }\n    get(name) {\n        return this.#map.get(name) ?? null;\n    }\n    [Symbol.iterator]() {\n        return this.#map.entries();\n    }\n}\nconst INTERNAL = Symbol(\"INTERNAL\");\nclass OptionalContentGroup {\n    #isDisplay;\n    #isPrint;\n    #userSet;\n    #visible;\n    constructor(renderingIntent, { name, intent, usage, rbGroups }){\n        this.#isDisplay = false;\n        this.#isPrint = false;\n        this.#userSet = false;\n        this.#visible = true;\n        this.#isDisplay = !!(renderingIntent & RenderingIntentFlag.DISPLAY);\n        this.#isPrint = !!(renderingIntent & RenderingIntentFlag.PRINT);\n        this.name = name;\n        this.intent = intent;\n        this.usage = usage;\n        this.rbGroups = rbGroups;\n    }\n    get visible() {\n        if (this.#userSet) {\n            return this.#visible;\n        }\n        if (!this.#visible) {\n            return false;\n        }\n        const { print, view } = this.usage;\n        if (this.#isDisplay) {\n            return view?.viewState !== \"OFF\";\n        } else if (this.#isPrint) {\n            return print?.printState !== \"OFF\";\n        }\n        return true;\n    }\n    _setVisible(internal, visible, userSet = false) {\n        if (internal !== INTERNAL) {\n            unreachable(\"Internal method `_setVisible` called.\");\n        }\n        this.#userSet = userSet;\n        this.#visible = visible;\n    }\n}\nclass OptionalContentConfig {\n    #cachedGetHash;\n    #groups;\n    #initialHash;\n    #order;\n    constructor(data, renderingIntent = RenderingIntentFlag.DISPLAY){\n        this.#cachedGetHash = null;\n        this.#groups = /* @__PURE__ */ new Map();\n        this.#initialHash = null;\n        this.#order = null;\n        this.renderingIntent = renderingIntent;\n        this.name = null;\n        this.creator = null;\n        if (data === null) {\n            return;\n        }\n        this.name = data.name;\n        this.creator = data.creator;\n        this.#order = data.order;\n        for (const group of data.groups){\n            this.#groups.set(group.id, new OptionalContentGroup(renderingIntent, group));\n        }\n        if (data.baseState === \"OFF\") {\n            for (const group of this.#groups.values()){\n                group._setVisible(INTERNAL, false);\n            }\n        }\n        for (const on of data.on){\n            this.#groups.get(on)._setVisible(INTERNAL, true);\n        }\n        for (const off of data.off){\n            this.#groups.get(off)._setVisible(INTERNAL, false);\n        }\n        this.#initialHash = this.getHash();\n    }\n    #evaluateVisibilityExpression(array) {\n        const length = array.length;\n        if (length < 2) {\n            return true;\n        }\n        const operator = array[0];\n        for(let i = 1; i < length; i++){\n            const element = array[i];\n            let state;\n            if (Array.isArray(element)) {\n                state = this.#evaluateVisibilityExpression(element);\n            } else if (this.#groups.has(element)) {\n                state = this.#groups.get(element).visible;\n            } else {\n                warn(`Optional content group not found: ${element}`);\n                return true;\n            }\n            switch(operator){\n                case \"And\":\n                    if (!state) {\n                        return false;\n                    }\n                    break;\n                case \"Or\":\n                    if (state) {\n                        return true;\n                    }\n                    break;\n                case \"Not\":\n                    return !state;\n                default:\n                    return true;\n            }\n        }\n        return operator === \"And\";\n    }\n    isVisible(group) {\n        if (this.#groups.size === 0) {\n            return true;\n        }\n        if (!group) {\n            info(\"Optional content group not defined.\");\n            return true;\n        }\n        if (group.type === \"OCG\") {\n            if (!this.#groups.has(group.id)) {\n                warn(`Optional content group not found: ${group.id}`);\n                return true;\n            }\n            return this.#groups.get(group.id).visible;\n        } else if (group.type === \"OCMD\") {\n            if (group.expression) {\n                return this.#evaluateVisibilityExpression(group.expression);\n            }\n            if (!group.policy || group.policy === \"AnyOn\") {\n                for (const id of group.ids){\n                    if (!this.#groups.has(id)) {\n                        warn(`Optional content group not found: ${id}`);\n                        return true;\n                    }\n                    if (this.#groups.get(id).visible) {\n                        return true;\n                    }\n                }\n                return false;\n            } else if (group.policy === \"AllOn\") {\n                for (const id of group.ids){\n                    if (!this.#groups.has(id)) {\n                        warn(`Optional content group not found: ${id}`);\n                        return true;\n                    }\n                    if (!this.#groups.get(id).visible) {\n                        return false;\n                    }\n                }\n                return true;\n            } else if (group.policy === \"AnyOff\") {\n                for (const id of group.ids){\n                    if (!this.#groups.has(id)) {\n                        warn(`Optional content group not found: ${id}`);\n                        return true;\n                    }\n                    if (!this.#groups.get(id).visible) {\n                        return true;\n                    }\n                }\n                return false;\n            } else if (group.policy === \"AllOff\") {\n                for (const id of group.ids){\n                    if (!this.#groups.has(id)) {\n                        warn(`Optional content group not found: ${id}`);\n                        return true;\n                    }\n                    if (this.#groups.get(id).visible) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            warn(`Unknown optional content policy ${group.policy}.`);\n            return true;\n        }\n        warn(`Unknown group type ${group.type}.`);\n        return true;\n    }\n    setVisibility(id, visible = true, preserveRB = true) {\n        const group = this.#groups.get(id);\n        if (!group) {\n            warn(`Optional content group not found: ${id}`);\n            return;\n        }\n        if (preserveRB && visible && group.rbGroups.length) {\n            for (const rbGroup of group.rbGroups){\n                for (const otherId of rbGroup){\n                    if (otherId !== id) {\n                        this.#groups.get(otherId)?._setVisible(INTERNAL, false, true);\n                    }\n                }\n            }\n        }\n        group._setVisible(INTERNAL, !!visible, true);\n        this.#cachedGetHash = null;\n    }\n    setOCGState({ state, preserveRB }) {\n        let operator;\n        for (const elem of state){\n            switch(elem){\n                case \"ON\":\n                case \"OFF\":\n                case \"Toggle\":\n                    operator = elem;\n                    continue;\n            }\n            const group = this.#groups.get(elem);\n            if (!group) {\n                continue;\n            }\n            switch(operator){\n                case \"ON\":\n                    this.setVisibility(elem, true, preserveRB);\n                    break;\n                case \"OFF\":\n                    this.setVisibility(elem, false, preserveRB);\n                    break;\n                case \"Toggle\":\n                    this.setVisibility(elem, !group.visible, preserveRB);\n                    break;\n            }\n        }\n        this.#cachedGetHash = null;\n    }\n    get hasInitialVisibility() {\n        return this.#initialHash === null || this.getHash() === this.#initialHash;\n    }\n    getOrder() {\n        if (!this.#groups.size) {\n            return null;\n        }\n        if (this.#order) {\n            return this.#order.slice();\n        }\n        return [\n            ...this.#groups.keys()\n        ];\n    }\n    getGroup(id) {\n        return this.#groups.get(id) || null;\n    }\n    getHash() {\n        if (this.#cachedGetHash !== null) {\n            return this.#cachedGetHash;\n        }\n        const hash = new MurmurHash3_64();\n        for (const [id, group] of this.#groups){\n            hash.update(`${id}:${group.visible}`);\n        }\n        return this.#cachedGetHash = hash.hexdigest();\n    }\n    [Symbol.iterator]() {\n        return this.#groups.entries();\n    }\n}\nclass PDFDataTransportStream {\n    constructor(pdfDataRangeTransport, { disableRange = false, disableStream = false }){\n        assert(pdfDataRangeTransport, 'PDFDataTransportStream - missing required \"pdfDataRangeTransport\" argument.');\n        const { length, initialData, progressiveDone, contentDispositionFilename } = pdfDataRangeTransport;\n        this._queuedChunks = [];\n        this._progressiveDone = progressiveDone;\n        this._contentDispositionFilename = contentDispositionFilename;\n        if (initialData?.length > 0) {\n            const buffer = initialData instanceof Uint8Array && initialData.byteLength === initialData.buffer.byteLength ? initialData.buffer : new Uint8Array(initialData).buffer;\n            this._queuedChunks.push(buffer);\n        }\n        this._pdfDataRangeTransport = pdfDataRangeTransport;\n        this._isStreamingSupported = !disableStream;\n        this._isRangeSupported = !disableRange;\n        this._contentLength = length;\n        this._fullRequestReader = null;\n        this._rangeReaders = [];\n        pdfDataRangeTransport.addRangeListener((begin, chunk)=>{\n            this._onReceiveData({\n                begin,\n                chunk\n            });\n        });\n        pdfDataRangeTransport.addProgressListener((loaded, total)=>{\n            this._onProgress({\n                loaded,\n                total\n            });\n        });\n        pdfDataRangeTransport.addProgressiveReadListener((chunk)=>{\n            this._onReceiveData({\n                chunk\n            });\n        });\n        pdfDataRangeTransport.addProgressiveDoneListener(()=>{\n            this._onProgressiveDone();\n        });\n        pdfDataRangeTransport.transportReady();\n    }\n    _onReceiveData({ begin, chunk }) {\n        const buffer = chunk instanceof Uint8Array && chunk.byteLength === chunk.buffer.byteLength ? chunk.buffer : new Uint8Array(chunk).buffer;\n        if (begin === void 0) {\n            if (this._fullRequestReader) {\n                this._fullRequestReader._enqueue(buffer);\n            } else {\n                this._queuedChunks.push(buffer);\n            }\n        } else {\n            const found = this._rangeReaders.some(function(rangeReader) {\n                if (rangeReader._begin !== begin) {\n                    return false;\n                }\n                rangeReader._enqueue(buffer);\n                return true;\n            });\n            assert(found, \"_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.\");\n        }\n    }\n    get _progressiveDataLength() {\n        return this._fullRequestReader?._loaded ?? 0;\n    }\n    _onProgress(evt) {\n        if (evt.total === void 0) {\n            this._rangeReaders[0]?.onProgress?.({\n                loaded: evt.loaded\n            });\n        } else {\n            this._fullRequestReader?.onProgress?.({\n                loaded: evt.loaded,\n                total: evt.total\n            });\n        }\n    }\n    _onProgressiveDone() {\n        this._fullRequestReader?.progressiveDone();\n        this._progressiveDone = true;\n    }\n    _removeRangeReader(reader) {\n        const i = this._rangeReaders.indexOf(reader);\n        if (i >= 0) {\n            this._rangeReaders.splice(i, 1);\n        }\n    }\n    getFullReader() {\n        assert(!this._fullRequestReader, \"PDFDataTransportStream.getFullReader can only be called once.\");\n        const queuedChunks = this._queuedChunks;\n        this._queuedChunks = null;\n        return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);\n    }\n    getRangeReader(begin, end) {\n        if (end <= this._progressiveDataLength) {\n            return null;\n        }\n        const reader = new PDFDataTransportStreamRangeReader(this, begin, end);\n        this._pdfDataRangeTransport.requestDataRange(begin, end);\n        this._rangeReaders.push(reader);\n        return reader;\n    }\n    cancelAllRequests(reason) {\n        this._fullRequestReader?.cancel(reason);\n        for (const reader of this._rangeReaders.slice(0)){\n            reader.cancel(reason);\n        }\n        this._pdfDataRangeTransport.abort();\n    }\n}\nclass PDFDataTransportStreamReader {\n    constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null){\n        this._stream = stream;\n        this._done = progressiveDone || false;\n        this._filename = isPdfFile(contentDispositionFilename) ? contentDispositionFilename : null;\n        this._queuedChunks = queuedChunks || [];\n        this._loaded = 0;\n        for (const chunk of this._queuedChunks){\n            this._loaded += chunk.byteLength;\n        }\n        this._requests = [];\n        this._headersReady = Promise.resolve();\n        stream._fullRequestReader = this;\n        this.onProgress = null;\n    }\n    _enqueue(chunk) {\n        if (this._done) {\n            return;\n        }\n        if (this._requests.length > 0) {\n            const requestCapability = this._requests.shift();\n            requestCapability.resolve({\n                value: chunk,\n                done: false\n            });\n        } else {\n            this._queuedChunks.push(chunk);\n        }\n        this._loaded += chunk.byteLength;\n    }\n    get headersReady() {\n        return this._headersReady;\n    }\n    get filename() {\n        return this._filename;\n    }\n    get isRangeSupported() {\n        return this._stream._isRangeSupported;\n    }\n    get isStreamingSupported() {\n        return this._stream._isStreamingSupported;\n    }\n    get contentLength() {\n        return this._stream._contentLength;\n    }\n    async read() {\n        if (this._queuedChunks.length > 0) {\n            const chunk = this._queuedChunks.shift();\n            return {\n                value: chunk,\n                done: false\n            };\n        }\n        if (this._done) {\n            return {\n                value: void 0,\n                done: true\n            };\n        }\n        const requestCapability = Promise.withResolvers();\n        this._requests.push(requestCapability);\n        return requestCapability.promise;\n    }\n    cancel(reason) {\n        this._done = true;\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: void 0,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n    }\n    progressiveDone() {\n        if (this._done) {\n            return;\n        }\n        this._done = true;\n    }\n}\nclass PDFDataTransportStreamRangeReader {\n    constructor(stream, begin, end){\n        this._stream = stream;\n        this._begin = begin;\n        this._end = end;\n        this._queuedChunk = null;\n        this._requests = [];\n        this._done = false;\n        this.onProgress = null;\n    }\n    _enqueue(chunk) {\n        if (this._done) {\n            return;\n        }\n        if (this._requests.length === 0) {\n            this._queuedChunk = chunk;\n        } else {\n            const requestsCapability = this._requests.shift();\n            requestsCapability.resolve({\n                value: chunk,\n                done: false\n            });\n            for (const requestCapability of this._requests){\n                requestCapability.resolve({\n                    value: void 0,\n                    done: true\n                });\n            }\n            this._requests.length = 0;\n        }\n        this._done = true;\n        this._stream._removeRangeReader(this);\n    }\n    get isStreamingSupported() {\n        return false;\n    }\n    async read() {\n        if (this._queuedChunk) {\n            const chunk = this._queuedChunk;\n            this._queuedChunk = null;\n            return {\n                value: chunk,\n                done: false\n            };\n        }\n        if (this._done) {\n            return {\n                value: void 0,\n                done: true\n            };\n        }\n        const requestCapability = Promise.withResolvers();\n        this._requests.push(requestCapability);\n        return requestCapability.promise;\n    }\n    cancel(reason) {\n        this._done = true;\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: void 0,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n        this._stream._removeRangeReader(this);\n    }\n}\nfunction getFilenameFromContentDispositionHeader(contentDisposition) {\n    let needsEncodingFixup = true;\n    let tmp = toParamRegExp(\"filename\\\\*\", \"i\").exec(contentDisposition);\n    if (tmp) {\n        tmp = tmp[1];\n        let filename = rfc2616unquote(tmp);\n        filename = unescape(filename);\n        filename = rfc5987decode(filename);\n        filename = rfc2047decode(filename);\n        return fixupEncoding(filename);\n    }\n    tmp = rfc2231getparam(contentDisposition);\n    if (tmp) {\n        const filename = rfc2047decode(tmp);\n        return fixupEncoding(filename);\n    }\n    tmp = toParamRegExp(\"filename\", \"i\").exec(contentDisposition);\n    if (tmp) {\n        tmp = tmp[1];\n        let filename = rfc2616unquote(tmp);\n        filename = rfc2047decode(filename);\n        return fixupEncoding(filename);\n    }\n    function toParamRegExp(attributePattern, flags) {\n        return new RegExp(\"(?:^|;)\\\\s*\" + attributePattern + '\\\\s*=\\\\s*([^\";\\\\s][^;\\\\s]*|\"(?:[^\"\\\\\\\\]|\\\\\\\\\"?)+\"?)', flags);\n    }\n    function textdecode(encoding, value1) {\n        if (encoding) {\n            if (!/^[\\x00-\\xFF]+$/.test(value1)) {\n                return value1;\n            }\n            try {\n                const decoder = new TextDecoder(encoding, {\n                    fatal: true\n                });\n                const buffer = stringToBytes(value1);\n                value1 = decoder.decode(buffer);\n                needsEncodingFixup = false;\n            } catch  {}\n        }\n        return value1;\n    }\n    function fixupEncoding(value1) {\n        if (needsEncodingFixup && /[\\x80-\\xff]/.test(value1)) {\n            value1 = textdecode(\"utf-8\", value1);\n            if (needsEncodingFixup) {\n                value1 = textdecode(\"iso-8859-1\", value1);\n            }\n        }\n        return value1;\n    }\n    function rfc2231getparam(contentDispositionStr) {\n        const matches = [];\n        let match;\n        const iter = toParamRegExp(\"filename\\\\*((?!0\\\\d)\\\\d+)(\\\\*?)\", \"ig\");\n        while((match = iter.exec(contentDispositionStr)) !== null){\n            let [, n, quot, part] = match;\n            n = parseInt(n, 10);\n            if (n in matches) {\n                if (n === 0) {\n                    break;\n                }\n                continue;\n            }\n            matches[n] = [\n                quot,\n                part\n            ];\n        }\n        const parts = [];\n        for(let n = 0; n < matches.length; ++n){\n            if (!(n in matches)) {\n                break;\n            }\n            let [quot, part] = matches[n];\n            part = rfc2616unquote(part);\n            if (quot) {\n                part = unescape(part);\n                if (n === 0) {\n                    part = rfc5987decode(part);\n                }\n            }\n            parts.push(part);\n        }\n        return parts.join(\"\");\n    }\n    function rfc2616unquote(value1) {\n        if (value1.startsWith('\"')) {\n            const parts = value1.slice(1).split('\\\\\"');\n            for(let i = 0; i < parts.length; ++i){\n                const quotindex = parts[i].indexOf('\"');\n                if (quotindex !== -1) {\n                    parts[i] = parts[i].slice(0, quotindex);\n                    parts.length = i + 1;\n                }\n                parts[i] = parts[i].replaceAll(/\\\\(.)/g, \"$1\");\n            }\n            value1 = parts.join('\"');\n        }\n        return value1;\n    }\n    function rfc5987decode(extvalue) {\n        const encodingend = extvalue.indexOf(\"'\");\n        if (encodingend === -1) {\n            return extvalue;\n        }\n        const encoding = extvalue.slice(0, encodingend);\n        const langvalue = extvalue.slice(encodingend + 1);\n        const value1 = langvalue.replace(/^[^']*'/, \"\");\n        return textdecode(encoding, value1);\n    }\n    function rfc2047decode(value1) {\n        if (!value1.startsWith(\"=?\") || /[\\x00-\\x19\\x80-\\xff]/.test(value1)) {\n            return value1;\n        }\n        return value1.replaceAll(/=\\?([\\w-]*)\\?([QqBb])\\?((?:[^?]|\\?(?!=))*)\\?=/g, function(matches, charset, encoding, text) {\n            if (encoding === \"q\" || encoding === \"Q\") {\n                text = text.replaceAll(\"_\", \" \");\n                text = text.replaceAll(/=([0-9a-fA-F]{2})/g, function(match, hex) {\n                    return String.fromCharCode(parseInt(hex, 16));\n                });\n                return textdecode(charset, text);\n            }\n            try {\n                text = atob(text);\n            } catch  {}\n            return textdecode(charset, text);\n        });\n    }\n    return \"\";\n}\nfunction createHeaders(isHttp, httpHeaders) {\n    const headers = new Headers();\n    if (!isHttp || !httpHeaders || typeof httpHeaders !== \"object\") {\n        return headers;\n    }\n    for(const key in httpHeaders){\n        const val = httpHeaders[key];\n        if (val !== void 0) {\n            headers.append(key, val);\n        }\n    }\n    return headers;\n}\nfunction getResponseOrigin(url) {\n    return URL.parse(url)?.origin ?? null;\n}\nfunction validateRangeRequestCapabilities({ responseHeaders, isHttp, rangeChunkSize, disableRange }) {\n    const returnValues = {\n        allowRangeRequests: false,\n        suggestedLength: void 0\n    };\n    const length = parseInt(responseHeaders.get(\"Content-Length\"), 10);\n    if (!Number.isInteger(length)) {\n        return returnValues;\n    }\n    returnValues.suggestedLength = length;\n    if (length <= 2 * rangeChunkSize) {\n        return returnValues;\n    }\n    if (disableRange || !isHttp) {\n        return returnValues;\n    }\n    if (responseHeaders.get(\"Accept-Ranges\") !== \"bytes\") {\n        return returnValues;\n    }\n    const contentEncoding = responseHeaders.get(\"Content-Encoding\") || \"identity\";\n    if (contentEncoding !== \"identity\") {\n        return returnValues;\n    }\n    returnValues.allowRangeRequests = true;\n    return returnValues;\n}\nfunction extractFilenameFromHeader(responseHeaders) {\n    const contentDisposition = responseHeaders.get(\"Content-Disposition\");\n    if (contentDisposition) {\n        let filename = getFilenameFromContentDispositionHeader(contentDisposition);\n        if (filename.includes(\"%\")) {\n            try {\n                filename = decodeURIComponent(filename);\n            } catch  {}\n        }\n        if (isPdfFile(filename)) {\n            return filename;\n        }\n    }\n    return null;\n}\nfunction createResponseError(status, url) {\n    return new ResponseException(`Unexpected server response (${status}) while retrieving PDF \"${url}\".`, status, status === 404 || status === 0 && url.startsWith(\"file:\"));\n}\nfunction validateResponseStatus(status) {\n    return status === 200 || status === 206;\n}\nfunction createFetchOptions(headers, withCredentials, abortController) {\n    return {\n        method: \"GET\",\n        headers,\n        signal: abortController.signal,\n        mode: \"cors\",\n        credentials: withCredentials ? \"include\" : \"same-origin\",\n        redirect: \"follow\"\n    };\n}\nfunction getArrayBuffer(val) {\n    if (val instanceof Uint8Array) {\n        return val.buffer;\n    }\n    if (val instanceof ArrayBuffer) {\n        return val;\n    }\n    warn(`getArrayBuffer - unexpected data format: ${val}`);\n    return new Uint8Array(val).buffer;\n}\nclass PDFFetchStream {\n    constructor(source){\n        this._responseOrigin = null;\n        this.source = source;\n        this.isHttp = /^https?:/i.test(source.url);\n        this.headers = createHeaders(this.isHttp, source.httpHeaders);\n        this._fullRequestReader = null;\n        this._rangeRequestReaders = [];\n    }\n    get _progressiveDataLength() {\n        return this._fullRequestReader?._loaded ?? 0;\n    }\n    getFullReader() {\n        assert(!this._fullRequestReader, \"PDFFetchStream.getFullReader can only be called once.\");\n        this._fullRequestReader = new PDFFetchStreamReader(this);\n        return this._fullRequestReader;\n    }\n    getRangeReader(begin, end) {\n        if (end <= this._progressiveDataLength) {\n            return null;\n        }\n        const reader = new PDFFetchStreamRangeReader(this, begin, end);\n        this._rangeRequestReaders.push(reader);\n        return reader;\n    }\n    cancelAllRequests(reason) {\n        this._fullRequestReader?.cancel(reason);\n        for (const reader of this._rangeRequestReaders.slice(0)){\n            reader.cancel(reason);\n        }\n    }\n}\nclass PDFFetchStreamReader {\n    constructor(stream){\n        this._stream = stream;\n        this._reader = null;\n        this._loaded = 0;\n        this._filename = null;\n        const source = stream.source;\n        this._withCredentials = source.withCredentials || false;\n        this._contentLength = source.length;\n        this._headersCapability = Promise.withResolvers();\n        this._disableRange = source.disableRange || false;\n        this._rangeChunkSize = source.rangeChunkSize;\n        if (!this._rangeChunkSize && !this._disableRange) {\n            this._disableRange = true;\n        }\n        this._abortController = new AbortController();\n        this._isStreamingSupported = !source.disableStream;\n        this._isRangeSupported = !source.disableRange;\n        const headers = new Headers(stream.headers);\n        const url = source.url;\n        fetch(url, createFetchOptions(headers, this._withCredentials, this._abortController)).then((response)=>{\n            stream._responseOrigin = getResponseOrigin(response.url);\n            if (!validateResponseStatus(response.status)) {\n                throw createResponseError(response.status, url);\n            }\n            this._reader = response.body.getReader();\n            this._headersCapability.resolve();\n            const responseHeaders = response.headers;\n            const { allowRangeRequests, suggestedLength } = validateRangeRequestCapabilities({\n                responseHeaders,\n                isHttp: stream.isHttp,\n                rangeChunkSize: this._rangeChunkSize,\n                disableRange: this._disableRange\n            });\n            this._isRangeSupported = allowRangeRequests;\n            this._contentLength = suggestedLength || this._contentLength;\n            this._filename = extractFilenameFromHeader(responseHeaders);\n            if (!this._isStreamingSupported && this._isRangeSupported) {\n                this.cancel(new AbortException(\"Streaming is disabled.\"));\n            }\n        }).catch(this._headersCapability.reject);\n        this.onProgress = null;\n    }\n    get headersReady() {\n        return this._headersCapability.promise;\n    }\n    get filename() {\n        return this._filename;\n    }\n    get contentLength() {\n        return this._contentLength;\n    }\n    get isRangeSupported() {\n        return this._isRangeSupported;\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    async read() {\n        await this._headersCapability.promise;\n        const { value: value1, done } = await this._reader.read();\n        if (done) {\n            return {\n                value: value1,\n                done\n            };\n        }\n        this._loaded += value1.byteLength;\n        this.onProgress?.({\n            loaded: this._loaded,\n            total: this._contentLength\n        });\n        return {\n            value: getArrayBuffer(value1),\n            done: false\n        };\n    }\n    cancel(reason) {\n        this._reader?.cancel(reason);\n        this._abortController.abort();\n    }\n}\nclass PDFFetchStreamRangeReader {\n    constructor(stream, begin, end){\n        this._stream = stream;\n        this._reader = null;\n        this._loaded = 0;\n        const source = stream.source;\n        this._withCredentials = source.withCredentials || false;\n        this._readCapability = Promise.withResolvers();\n        this._isStreamingSupported = !source.disableStream;\n        this._abortController = new AbortController();\n        const headers = new Headers(stream.headers);\n        headers.append(\"Range\", `bytes=${begin}-${end - 1}`);\n        const url = source.url;\n        fetch(url, createFetchOptions(headers, this._withCredentials, this._abortController)).then((response)=>{\n            const responseOrigin = getResponseOrigin(response.url);\n            if (responseOrigin !== stream._responseOrigin) {\n                throw new Error(`Expected range response-origin \"${responseOrigin}\" to match \"${stream._responseOrigin}\".`);\n            }\n            if (!validateResponseStatus(response.status)) {\n                throw createResponseError(response.status, url);\n            }\n            this._readCapability.resolve();\n            this._reader = response.body.getReader();\n        }).catch(this._readCapability.reject);\n        this.onProgress = null;\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    async read() {\n        await this._readCapability.promise;\n        const { value: value1, done } = await this._reader.read();\n        if (done) {\n            return {\n                value: value1,\n                done\n            };\n        }\n        this._loaded += value1.byteLength;\n        this.onProgress?.({\n            loaded: this._loaded\n        });\n        return {\n            value: getArrayBuffer(value1),\n            done: false\n        };\n    }\n    cancel(reason) {\n        this._reader?.cancel(reason);\n        this._abortController.abort();\n    }\n}\nconst OK_RESPONSE = 200;\nconst PARTIAL_CONTENT_RESPONSE = 206;\nfunction network_getArrayBuffer(xhr) {\n    const data = xhr.response;\n    if (typeof data !== \"string\") {\n        return data;\n    }\n    return stringToBytes(data).buffer;\n}\nclass NetworkManager {\n    constructor({ url, httpHeaders, withCredentials }){\n        this._responseOrigin = null;\n        this.url = url;\n        this.isHttp = /^https?:/i.test(url);\n        this.headers = createHeaders(this.isHttp, httpHeaders);\n        this.withCredentials = withCredentials || false;\n        this.currXhrId = 0;\n        this.pendingRequests = /* @__PURE__ */ Object.create(null);\n    }\n    request(args) {\n        const xhr = new XMLHttpRequest();\n        const xhrId = this.currXhrId++;\n        const pendingRequest = this.pendingRequests[xhrId] = {\n            xhr\n        };\n        xhr.open(\"GET\", this.url);\n        xhr.withCredentials = this.withCredentials;\n        for (const [key, val] of this.headers){\n            xhr.setRequestHeader(key, val);\n        }\n        if (this.isHttp && \"begin\" in args && \"end\" in args) {\n            xhr.setRequestHeader(\"Range\", `bytes=${args.begin}-${args.end - 1}`);\n            pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;\n        } else {\n            pendingRequest.expectedStatus = OK_RESPONSE;\n        }\n        xhr.responseType = \"arraybuffer\";\n        assert(args.onError, \"Expected `onError` callback to be provided.\");\n        xhr.onerror = ()=>{\n            args.onError(xhr.status);\n        };\n        xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);\n        xhr.onprogress = this.onProgress.bind(this, xhrId);\n        pendingRequest.onHeadersReceived = args.onHeadersReceived;\n        pendingRequest.onDone = args.onDone;\n        pendingRequest.onError = args.onError;\n        pendingRequest.onProgress = args.onProgress;\n        xhr.send(null);\n        return xhrId;\n    }\n    onProgress(xhrId, evt) {\n        const pendingRequest = this.pendingRequests[xhrId];\n        if (!pendingRequest) {\n            return;\n        }\n        pendingRequest.onProgress?.(evt);\n    }\n    onStateChange(xhrId, evt) {\n        const pendingRequest = this.pendingRequests[xhrId];\n        if (!pendingRequest) {\n            return;\n        }\n        const xhr = pendingRequest.xhr;\n        if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {\n            pendingRequest.onHeadersReceived();\n            delete pendingRequest.onHeadersReceived;\n        }\n        if (xhr.readyState !== 4) {\n            return;\n        }\n        if (!(xhrId in this.pendingRequests)) {\n            return;\n        }\n        delete this.pendingRequests[xhrId];\n        if (xhr.status === 0 && this.isHttp) {\n            pendingRequest.onError(xhr.status);\n            return;\n        }\n        const xhrStatus = xhr.status || OK_RESPONSE;\n        const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;\n        if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {\n            pendingRequest.onError(xhr.status);\n            return;\n        }\n        const chunk = network_getArrayBuffer(xhr);\n        if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {\n            const rangeHeader = xhr.getResponseHeader(\"Content-Range\");\n            const matches = /bytes (\\d+)-(\\d+)\\/(\\d+)/.exec(rangeHeader);\n            if (matches) {\n                pendingRequest.onDone({\n                    begin: parseInt(matches[1], 10),\n                    chunk\n                });\n            } else {\n                warn(`Missing or invalid \"Content-Range\" header.`);\n                pendingRequest.onError(0);\n            }\n        } else if (chunk) {\n            pendingRequest.onDone({\n                begin: 0,\n                chunk\n            });\n        } else {\n            pendingRequest.onError(xhr.status);\n        }\n    }\n    getRequestXhr(xhrId) {\n        return this.pendingRequests[xhrId].xhr;\n    }\n    isPendingRequest(xhrId) {\n        return xhrId in this.pendingRequests;\n    }\n    abortRequest(xhrId) {\n        const xhr = this.pendingRequests[xhrId].xhr;\n        delete this.pendingRequests[xhrId];\n        xhr.abort();\n    }\n}\nclass PDFNetworkStream {\n    constructor(source){\n        this._source = source;\n        this._manager = new NetworkManager(source);\n        this._rangeChunkSize = source.rangeChunkSize;\n        this._fullRequestReader = null;\n        this._rangeRequestReaders = [];\n    }\n    _onRangeRequestReaderClosed(reader) {\n        const i = this._rangeRequestReaders.indexOf(reader);\n        if (i >= 0) {\n            this._rangeRequestReaders.splice(i, 1);\n        }\n    }\n    getFullReader() {\n        assert(!this._fullRequestReader, \"PDFNetworkStream.getFullReader can only be called once.\");\n        this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);\n        return this._fullRequestReader;\n    }\n    getRangeReader(begin, end) {\n        const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);\n        reader.onClosed = this._onRangeRequestReaderClosed.bind(this);\n        this._rangeRequestReaders.push(reader);\n        return reader;\n    }\n    cancelAllRequests(reason) {\n        this._fullRequestReader?.cancel(reason);\n        for (const reader of this._rangeRequestReaders.slice(0)){\n            reader.cancel(reason);\n        }\n    }\n}\nclass PDFNetworkStreamFullRequestReader {\n    constructor(manager, source){\n        this._manager = manager;\n        this._url = source.url;\n        this._fullRequestId = manager.request({\n            onHeadersReceived: this._onHeadersReceived.bind(this),\n            onDone: this._onDone.bind(this),\n            onError: this._onError.bind(this),\n            onProgress: this._onProgress.bind(this)\n        });\n        this._headersCapability = Promise.withResolvers();\n        this._disableRange = source.disableRange || false;\n        this._contentLength = source.length;\n        this._rangeChunkSize = source.rangeChunkSize;\n        if (!this._rangeChunkSize && !this._disableRange) {\n            this._disableRange = true;\n        }\n        this._isStreamingSupported = false;\n        this._isRangeSupported = false;\n        this._cachedChunks = [];\n        this._requests = [];\n        this._done = false;\n        this._storedError = void 0;\n        this._filename = null;\n        this.onProgress = null;\n    }\n    _onHeadersReceived() {\n        const fullRequestXhrId = this._fullRequestId;\n        const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);\n        this._manager._responseOrigin = getResponseOrigin(fullRequestXhr.responseURL);\n        const rawResponseHeaders = fullRequestXhr.getAllResponseHeaders();\n        const responseHeaders = new Headers(rawResponseHeaders ? rawResponseHeaders.trimStart().replace(/[^\\S ]+$/, \"\").split(/[\\r\\n]+/).map((x)=>{\n            const [key, ...val] = x.split(\": \");\n            return [\n                key,\n                val.join(\": \")\n            ];\n        }) : []);\n        const { allowRangeRequests, suggestedLength } = validateRangeRequestCapabilities({\n            responseHeaders,\n            isHttp: this._manager.isHttp,\n            rangeChunkSize: this._rangeChunkSize,\n            disableRange: this._disableRange\n        });\n        if (allowRangeRequests) {\n            this._isRangeSupported = true;\n        }\n        this._contentLength = suggestedLength || this._contentLength;\n        this._filename = extractFilenameFromHeader(responseHeaders);\n        if (this._isRangeSupported) {\n            this._manager.abortRequest(fullRequestXhrId);\n        }\n        this._headersCapability.resolve();\n    }\n    _onDone(data) {\n        if (data) {\n            if (this._requests.length > 0) {\n                const requestCapability = this._requests.shift();\n                requestCapability.resolve({\n                    value: data.chunk,\n                    done: false\n                });\n            } else {\n                this._cachedChunks.push(data.chunk);\n            }\n        }\n        this._done = true;\n        if (this._cachedChunks.length > 0) {\n            return;\n        }\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: void 0,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n    }\n    _onError(status) {\n        this._storedError = createResponseError(status, this._url);\n        this._headersCapability.reject(this._storedError);\n        for (const requestCapability of this._requests){\n            requestCapability.reject(this._storedError);\n        }\n        this._requests.length = 0;\n        this._cachedChunks.length = 0;\n    }\n    _onProgress(evt) {\n        this.onProgress?.({\n            loaded: evt.loaded,\n            total: evt.lengthComputable ? evt.total : this._contentLength\n        });\n    }\n    get filename() {\n        return this._filename;\n    }\n    get isRangeSupported() {\n        return this._isRangeSupported;\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    get contentLength() {\n        return this._contentLength;\n    }\n    get headersReady() {\n        return this._headersCapability.promise;\n    }\n    async read() {\n        await this._headersCapability.promise;\n        if (this._storedError) {\n            throw this._storedError;\n        }\n        if (this._cachedChunks.length > 0) {\n            const chunk = this._cachedChunks.shift();\n            return {\n                value: chunk,\n                done: false\n            };\n        }\n        if (this._done) {\n            return {\n                value: void 0,\n                done: true\n            };\n        }\n        const requestCapability = Promise.withResolvers();\n        this._requests.push(requestCapability);\n        return requestCapability.promise;\n    }\n    cancel(reason) {\n        this._done = true;\n        this._headersCapability.reject(reason);\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: void 0,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n        if (this._manager.isPendingRequest(this._fullRequestId)) {\n            this._manager.abortRequest(this._fullRequestId);\n        }\n        this._fullRequestReader = null;\n    }\n}\nclass PDFNetworkStreamRangeRequestReader {\n    constructor(manager, begin, end){\n        this._manager = manager;\n        this._url = manager.url;\n        this._requestId = manager.request({\n            begin,\n            end,\n            onHeadersReceived: this._onHeadersReceived.bind(this),\n            onDone: this._onDone.bind(this),\n            onError: this._onError.bind(this),\n            onProgress: this._onProgress.bind(this)\n        });\n        this._requests = [];\n        this._queuedChunk = null;\n        this._done = false;\n        this._storedError = void 0;\n        this.onProgress = null;\n        this.onClosed = null;\n    }\n    _onHeadersReceived() {\n        const responseOrigin = getResponseOrigin(this._manager.getRequestXhr(this._requestId)?.responseURL);\n        if (responseOrigin !== this._manager._responseOrigin) {\n            this._storedError = new Error(`Expected range response-origin \"${responseOrigin}\" to match \"${this._manager._responseOrigin}\".`);\n            this._onError(0);\n        }\n    }\n    _close() {\n        this.onClosed?.(this);\n    }\n    _onDone(data) {\n        const chunk = data.chunk;\n        if (this._requests.length > 0) {\n            const requestCapability = this._requests.shift();\n            requestCapability.resolve({\n                value: chunk,\n                done: false\n            });\n        } else {\n            this._queuedChunk = chunk;\n        }\n        this._done = true;\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: void 0,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n        this._close();\n    }\n    _onError(status) {\n        this._storedError ??= createResponseError(status, this._url);\n        for (const requestCapability of this._requests){\n            requestCapability.reject(this._storedError);\n        }\n        this._requests.length = 0;\n        this._queuedChunk = null;\n    }\n    _onProgress(evt) {\n        if (!this.isStreamingSupported) {\n            this.onProgress?.({\n                loaded: evt.loaded\n            });\n        }\n    }\n    get isStreamingSupported() {\n        return false;\n    }\n    async read() {\n        if (this._storedError) {\n            throw this._storedError;\n        }\n        if (this._queuedChunk !== null) {\n            const chunk = this._queuedChunk;\n            this._queuedChunk = null;\n            return {\n                value: chunk,\n                done: false\n            };\n        }\n        if (this._done) {\n            return {\n                value: void 0,\n                done: true\n            };\n        }\n        const requestCapability = Promise.withResolvers();\n        this._requests.push(requestCapability);\n        return requestCapability.promise;\n    }\n    cancel(reason) {\n        this._done = true;\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: void 0,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n        if (this._manager.isPendingRequest(this._requestId)) {\n            this._manager.abortRequest(this._requestId);\n        }\n        this._close();\n    }\n}\nconst urlRegex = /^[a-z][a-z0-9\\-+.]+:/i;\nfunction parseUrlOrPath(sourceUrl) {\n    if (urlRegex.test(sourceUrl)) {\n        return new URL(sourceUrl);\n    }\n    const url = process.getBuiltinModule(\"url\");\n    return new URL(url.pathToFileURL(sourceUrl));\n}\nclass PDFNodeStream {\n    constructor(source){\n        this.source = source;\n        this.url = parseUrlOrPath(source.url);\n        assert(this.url.protocol === \"file:\", \"PDFNodeStream only supports file:// URLs.\");\n        this._fullRequestReader = null;\n        this._rangeRequestReaders = [];\n    }\n    get _progressiveDataLength() {\n        return this._fullRequestReader?._loaded ?? 0;\n    }\n    getFullReader() {\n        assert(!this._fullRequestReader, \"PDFNodeStream.getFullReader can only be called once.\");\n        this._fullRequestReader = new PDFNodeStreamFsFullReader(this);\n        return this._fullRequestReader;\n    }\n    getRangeReader(start, end) {\n        if (end <= this._progressiveDataLength) {\n            return null;\n        }\n        const rangeReader = new PDFNodeStreamFsRangeReader(this, start, end);\n        this._rangeRequestReaders.push(rangeReader);\n        return rangeReader;\n    }\n    cancelAllRequests(reason) {\n        this._fullRequestReader?.cancel(reason);\n        for (const reader of this._rangeRequestReaders.slice(0)){\n            reader.cancel(reason);\n        }\n    }\n}\nclass PDFNodeStreamFsFullReader {\n    constructor(stream){\n        this._url = stream.url;\n        this._done = false;\n        this._storedError = null;\n        this.onProgress = null;\n        const source = stream.source;\n        this._contentLength = source.length;\n        this._loaded = 0;\n        this._filename = null;\n        this._disableRange = source.disableRange || false;\n        this._rangeChunkSize = source.rangeChunkSize;\n        if (!this._rangeChunkSize && !this._disableRange) {\n            this._disableRange = true;\n        }\n        this._isStreamingSupported = !source.disableStream;\n        this._isRangeSupported = !source.disableRange;\n        this._readableStream = null;\n        this._readCapability = Promise.withResolvers();\n        this._headersCapability = Promise.withResolvers();\n        const fs = process.getBuiltinModule(\"fs\");\n        fs.promises.lstat(this._url).then((stat)=>{\n            this._contentLength = stat.size;\n            this._setReadableStream(fs.createReadStream(this._url));\n            this._headersCapability.resolve();\n        }, (error)=>{\n            if (error.code === \"ENOENT\") {\n                error = createResponseError(0, this._url.href);\n            }\n            this._storedError = error;\n            this._headersCapability.reject(error);\n        });\n    }\n    get headersReady() {\n        return this._headersCapability.promise;\n    }\n    get filename() {\n        return this._filename;\n    }\n    get contentLength() {\n        return this._contentLength;\n    }\n    get isRangeSupported() {\n        return this._isRangeSupported;\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    async read() {\n        await this._readCapability.promise;\n        if (this._done) {\n            return {\n                value: void 0,\n                done: true\n            };\n        }\n        if (this._storedError) {\n            throw this._storedError;\n        }\n        const chunk = this._readableStream.read();\n        if (chunk === null) {\n            this._readCapability = Promise.withResolvers();\n            return this.read();\n        }\n        this._loaded += chunk.length;\n        this.onProgress?.({\n            loaded: this._loaded,\n            total: this._contentLength\n        });\n        const buffer = new Uint8Array(chunk).buffer;\n        return {\n            value: buffer,\n            done: false\n        };\n    }\n    cancel(reason) {\n        if (!this._readableStream) {\n            this._error(reason);\n            return;\n        }\n        this._readableStream.destroy(reason);\n    }\n    _error(reason) {\n        this._storedError = reason;\n        this._readCapability.resolve();\n    }\n    _setReadableStream(readableStream) {\n        this._readableStream = readableStream;\n        readableStream.on(\"readable\", ()=>{\n            this._readCapability.resolve();\n        });\n        readableStream.on(\"end\", ()=>{\n            readableStream.destroy();\n            this._done = true;\n            this._readCapability.resolve();\n        });\n        readableStream.on(\"error\", (reason)=>{\n            this._error(reason);\n        });\n        if (!this._isStreamingSupported && this._isRangeSupported) {\n            this._error(new AbortException(\"streaming is disabled\"));\n        }\n        if (this._storedError) {\n            this._readableStream.destroy(this._storedError);\n        }\n    }\n}\nclass PDFNodeStreamFsRangeReader {\n    constructor(stream, start, end){\n        this._url = stream.url;\n        this._done = false;\n        this._storedError = null;\n        this.onProgress = null;\n        this._loaded = 0;\n        this._readableStream = null;\n        this._readCapability = Promise.withResolvers();\n        const source = stream.source;\n        this._isStreamingSupported = !source.disableStream;\n        const fs = process.getBuiltinModule(\"fs\");\n        this._setReadableStream(fs.createReadStream(this._url, {\n            start,\n            end: end - 1\n        }));\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    async read() {\n        await this._readCapability.promise;\n        if (this._done) {\n            return {\n                value: void 0,\n                done: true\n            };\n        }\n        if (this._storedError) {\n            throw this._storedError;\n        }\n        const chunk = this._readableStream.read();\n        if (chunk === null) {\n            this._readCapability = Promise.withResolvers();\n            return this.read();\n        }\n        this._loaded += chunk.length;\n        this.onProgress?.({\n            loaded: this._loaded\n        });\n        const buffer = new Uint8Array(chunk).buffer;\n        return {\n            value: buffer,\n            done: false\n        };\n    }\n    cancel(reason) {\n        if (!this._readableStream) {\n            this._error(reason);\n            return;\n        }\n        this._readableStream.destroy(reason);\n    }\n    _error(reason) {\n        this._storedError = reason;\n        this._readCapability.resolve();\n    }\n    _setReadableStream(readableStream) {\n        this._readableStream = readableStream;\n        readableStream.on(\"readable\", ()=>{\n            this._readCapability.resolve();\n        });\n        readableStream.on(\"end\", ()=>{\n            readableStream.destroy();\n            this._done = true;\n            this._readCapability.resolve();\n        });\n        readableStream.on(\"error\", (reason)=>{\n            this._error(reason);\n        });\n        if (this._storedError) {\n            this._readableStream.destroy(this._storedError);\n        }\n    }\n}\nconst INITIAL_DATA = Symbol(\"INITIAL_DATA\");\nclass PDFObjects {\n    #objs;\n    #ensureObj(objId) {\n        return this.#objs[objId] ||= {\n            ...Promise.withResolvers(),\n            data: INITIAL_DATA\n        };\n    }\n    get(objId, callback = null) {\n        if (callback) {\n            const obj2 = this.#ensureObj(objId);\n            obj2.promise.then(()=>callback(obj2.data));\n            return null;\n        }\n        const obj = this.#objs[objId];\n        if (!obj || obj.data === INITIAL_DATA) {\n            throw new Error(`Requesting object that isn't resolved yet ${objId}.`);\n        }\n        return obj.data;\n    }\n    has(objId) {\n        const obj = this.#objs[objId];\n        return !!obj && obj.data !== INITIAL_DATA;\n    }\n    delete(objId) {\n        const obj = this.#objs[objId];\n        if (!obj || obj.data === INITIAL_DATA) {\n            return false;\n        }\n        delete this.#objs[objId];\n        return true;\n    }\n    resolve(objId, data = null) {\n        const obj = this.#ensureObj(objId);\n        obj.data = data;\n        obj.resolve();\n    }\n    clear() {\n        for(const objId in this.#objs){\n            const { data } = this.#objs[objId];\n            data?.bitmap?.close();\n        }\n        this.#objs = /* @__PURE__ */ Object.create(null);\n    }\n    *[Symbol.iterator]() {\n        for(const objId in this.#objs){\n            const { data } = this.#objs[objId];\n            if (data === INITIAL_DATA) {\n                continue;\n            }\n            yield [\n                objId,\n                data\n            ];\n        }\n    }\n    constructor(){\n        this.#objs = /* @__PURE__ */ Object.create(null);\n    }\n}\nconst MAX_TEXT_DIVS_TO_RENDER = 1e5;\nconst DEFAULT_FONT_SIZE = 30;\nclass TextLayer {\n    #capability;\n    #container;\n    #disableProcessItems;\n    #fontInspectorEnabled;\n    #lang;\n    #layoutTextParams;\n    #pageHeight;\n    #pageWidth;\n    #reader;\n    #rootContainer;\n    #rotation;\n    #scale;\n    #styleCache;\n    #textContentItemsStr;\n    #textContentSource;\n    #textDivs;\n    #textDivProperties;\n    #transform;\n    static #ascentCache = /* @__PURE__ */ new Map();\n    static #canvasContexts = /* @__PURE__ */ new Map();\n    static #canvasCtxFonts = /* @__PURE__ */ new WeakMap();\n    static #minFontSize = null;\n    static #pendingTextLayers = /* @__PURE__ */ new Set();\n    constructor({ textContentSource, container, viewport }){\n        this.#capability = Promise.withResolvers();\n        this.#container = null;\n        this.#disableProcessItems = false;\n        this.#fontInspectorEnabled = !!globalThis.FontInspector?.enabled;\n        this.#lang = null;\n        this.#layoutTextParams = null;\n        this.#pageHeight = 0;\n        this.#pageWidth = 0;\n        this.#reader = null;\n        this.#rootContainer = null;\n        this.#rotation = 0;\n        this.#scale = 0;\n        this.#styleCache = /* @__PURE__ */ Object.create(null);\n        this.#textContentItemsStr = [];\n        this.#textContentSource = null;\n        this.#textDivs = [];\n        this.#textDivProperties = /* @__PURE__ */ new WeakMap();\n        this.#transform = null;\n        if (textContentSource instanceof ReadableStream) {\n            this.#textContentSource = textContentSource;\n        } else if (typeof textContentSource === \"object\") {\n            this.#textContentSource = new ReadableStream({\n                start (controller) {\n                    controller.enqueue(textContentSource);\n                    controller.close();\n                }\n            });\n        } else {\n            throw new Error('No \"textContentSource\" parameter specified.');\n        }\n        this.#container = this.#rootContainer = container;\n        this.#scale = viewport.scale * OutputScale.pixelRatio;\n        this.#rotation = viewport.rotation;\n        this.#layoutTextParams = {\n            div: null,\n            properties: null,\n            ctx: null\n        };\n        const { pageWidth, pageHeight, pageX, pageY } = viewport.rawDims;\n        this.#transform = [\n            1,\n            0,\n            0,\n            -1,\n            -pageX,\n            pageY + pageHeight\n        ];\n        this.#pageWidth = pageWidth;\n        this.#pageHeight = pageHeight;\n        TextLayer.#ensureMinFontSizeComputed();\n        setLayerDimensions(container, viewport);\n        this.#capability.promise.finally(()=>{\n            TextLayer.#pendingTextLayers.delete(this);\n            this.#layoutTextParams = null;\n            this.#styleCache = null;\n        }).catch(()=>{});\n    }\n    static get fontFamilyMap() {\n        const { isWindows, isFirefox } = util_FeatureTest.platform;\n        return shadow(this, \"fontFamilyMap\", /* @__PURE__ */ new Map([\n            [\n                \"sans-serif\",\n                `${isWindows && isFirefox ? \"Calibri, \" : \"\"}sans-serif`\n            ],\n            [\n                \"monospace\",\n                `${isWindows && isFirefox ? \"Lucida Console, \" : \"\"}monospace`\n            ]\n        ]));\n    }\n    render() {\n        const pump = ()=>{\n            this.#reader.read().then(({ value: value1, done })=>{\n                if (done) {\n                    this.#capability.resolve();\n                    return;\n                }\n                this.#lang ??= value1.lang;\n                Object.assign(this.#styleCache, value1.styles);\n                this.#processItems(value1.items);\n                pump();\n            }, this.#capability.reject);\n        };\n        this.#reader = this.#textContentSource.getReader();\n        TextLayer.#pendingTextLayers.add(this);\n        pump();\n        return this.#capability.promise;\n    }\n    update({ viewport, onBefore = null }) {\n        const scale = viewport.scale * OutputScale.pixelRatio;\n        const rotation = viewport.rotation;\n        if (rotation !== this.#rotation) {\n            onBefore?.();\n            this.#rotation = rotation;\n            setLayerDimensions(this.#rootContainer, {\n                rotation\n            });\n        }\n        if (scale !== this.#scale) {\n            onBefore?.();\n            this.#scale = scale;\n            const params = {\n                div: null,\n                properties: null,\n                ctx: TextLayer.#getCtx(this.#lang)\n            };\n            for (const div of this.#textDivs){\n                params.properties = this.#textDivProperties.get(div);\n                params.div = div;\n                this.#layout(params);\n            }\n        }\n    }\n    cancel() {\n        const abortEx = new AbortException(\"TextLayer task cancelled.\");\n        this.#reader?.cancel(abortEx).catch(()=>{});\n        this.#reader = null;\n        this.#capability.reject(abortEx);\n    }\n    get textDivs() {\n        return this.#textDivs;\n    }\n    get textContentItemsStr() {\n        return this.#textContentItemsStr;\n    }\n    #processItems(items) {\n        if (this.#disableProcessItems) {\n            return;\n        }\n        this.#layoutTextParams.ctx ??= TextLayer.#getCtx(this.#lang);\n        const textDivs = this.#textDivs, textContentItemsStr = this.#textContentItemsStr;\n        for (const item of items){\n            if (textDivs.length > MAX_TEXT_DIVS_TO_RENDER) {\n                warn(\"Ignoring additional textDivs for performance reasons.\");\n                this.#disableProcessItems = true;\n                return;\n            }\n            if (item.str === void 0) {\n                if (item.type === \"beginMarkedContentProps\" || item.type === \"beginMarkedContent\") {\n                    const parent = this.#container;\n                    this.#container = document.createElement(\"span\");\n                    this.#container.classList.add(\"markedContent\");\n                    if (item.id) {\n                        this.#container.setAttribute(\"id\", `${item.id}`);\n                    }\n                    parent.append(this.#container);\n                } else if (item.type === \"endMarkedContent\") {\n                    this.#container = this.#container.parentNode;\n                }\n                continue;\n            }\n            textContentItemsStr.push(item.str);\n            this.#appendText(item);\n        }\n    }\n    #appendText(geom) {\n        const textDiv = document.createElement(\"span\");\n        const textDivProperties = {\n            angle: 0,\n            canvasWidth: 0,\n            hasText: geom.str !== \"\",\n            hasEOL: geom.hasEOL,\n            fontSize: 0\n        };\n        this.#textDivs.push(textDiv);\n        const tx = Util.transform(this.#transform, geom.transform);\n        let angle = Math.atan2(tx[1], tx[0]);\n        const style = this.#styleCache[geom.fontName];\n        if (style.vertical) {\n            angle += Math.PI / 2;\n        }\n        let fontFamily = this.#fontInspectorEnabled && style.fontSubstitution || style.fontFamily;\n        fontFamily = TextLayer.fontFamilyMap.get(fontFamily) || fontFamily;\n        const fontHeight = Math.hypot(tx[2], tx[3]);\n        const fontAscent = fontHeight * TextLayer.#getAscent(fontFamily, style, this.#lang);\n        let left, top;\n        if (angle === 0) {\n            left = tx[4];\n            top = tx[5] - fontAscent;\n        } else {\n            left = tx[4] + fontAscent * Math.sin(angle);\n            top = tx[5] - fontAscent * Math.cos(angle);\n        }\n        const scaleFactorStr = \"calc(var(--total-scale-factor) *\";\n        const divStyle = textDiv.style;\n        if (this.#container === this.#rootContainer) {\n            divStyle.left = `${(100 * left / this.#pageWidth).toFixed(2)}%`;\n            divStyle.top = `${(100 * top / this.#pageHeight).toFixed(2)}%`;\n        } else {\n            divStyle.left = `${scaleFactorStr}${left.toFixed(2)}px)`;\n            divStyle.top = `${scaleFactorStr}${top.toFixed(2)}px)`;\n        }\n        divStyle.fontSize = `${scaleFactorStr}${(TextLayer.#minFontSize * fontHeight).toFixed(2)}px)`;\n        divStyle.fontFamily = fontFamily;\n        textDivProperties.fontSize = fontHeight;\n        textDiv.setAttribute(\"role\", \"presentation\");\n        textDiv.textContent = geom.str;\n        textDiv.dir = geom.dir;\n        if (this.#fontInspectorEnabled) {\n            textDiv.dataset.fontName = style.fontSubstitutionLoadedName || geom.fontName;\n        }\n        if (angle !== 0) {\n            textDivProperties.angle = angle * (180 / Math.PI);\n        }\n        let shouldScaleText = false;\n        if (geom.str.length > 1) {\n            shouldScaleText = true;\n        } else if (geom.str !== \" \" && geom.transform[0] !== geom.transform[3]) {\n            const absScaleX = Math.abs(geom.transform[0]), absScaleY = Math.abs(geom.transform[3]);\n            if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {\n                shouldScaleText = true;\n            }\n        }\n        if (shouldScaleText) {\n            textDivProperties.canvasWidth = style.vertical ? geom.height : geom.width;\n        }\n        this.#textDivProperties.set(textDiv, textDivProperties);\n        this.#layoutTextParams.div = textDiv;\n        this.#layoutTextParams.properties = textDivProperties;\n        this.#layout(this.#layoutTextParams);\n        if (textDivProperties.hasText) {\n            this.#container.append(textDiv);\n        }\n        if (textDivProperties.hasEOL) {\n            const br = document.createElement(\"br\");\n            br.setAttribute(\"role\", \"presentation\");\n            this.#container.append(br);\n        }\n    }\n    #layout(params) {\n        const { div, properties, ctx } = params;\n        const { style } = div;\n        let transform = \"\";\n        if (TextLayer.#minFontSize > 1) {\n            transform = `scale(${1 / TextLayer.#minFontSize})`;\n        }\n        if (properties.canvasWidth !== 0 && properties.hasText) {\n            const { fontFamily } = style;\n            const { canvasWidth, fontSize } = properties;\n            TextLayer.#ensureCtxFont(ctx, fontSize * this.#scale, fontFamily);\n            const { width } = ctx.measureText(div.textContent);\n            if (width > 0) {\n                transform = `scaleX(${canvasWidth * this.#scale / width}) ${transform}`;\n            }\n        }\n        if (properties.angle !== 0) {\n            transform = `rotate(${properties.angle}deg) ${transform}`;\n        }\n        if (transform.length > 0) {\n            style.transform = transform;\n        }\n    }\n    static cleanup() {\n        if (this.#pendingTextLayers.size > 0) {\n            return;\n        }\n        this.#ascentCache.clear();\n        for (const { canvas } of this.#canvasContexts.values()){\n            canvas.remove();\n        }\n        this.#canvasContexts.clear();\n    }\n    static #getCtx(lang = null) {\n        let ctx = this.#canvasContexts.get(lang ||= \"\");\n        if (!ctx) {\n            const canvas = document.createElement(\"canvas\");\n            canvas.className = \"hiddenCanvasElement\";\n            canvas.lang = lang;\n            document.body.append(canvas);\n            ctx = canvas.getContext(\"2d\", {\n                alpha: false,\n                willReadFrequently: true\n            });\n            this.#canvasContexts.set(lang, ctx);\n            this.#canvasCtxFonts.set(ctx, {\n                size: 0,\n                family: \"\"\n            });\n        }\n        return ctx;\n    }\n    static #ensureCtxFont(ctx, size, family) {\n        const cached = this.#canvasCtxFonts.get(ctx);\n        if (size === cached.size && family === cached.family) {\n            return;\n        }\n        ctx.font = `${size}px ${family}`;\n        cached.size = size;\n        cached.family = family;\n    }\n    static #ensureMinFontSizeComputed() {\n        if (this.#minFontSize !== null) {\n            return;\n        }\n        const div = document.createElement(\"div\");\n        div.style.opacity = 0;\n        div.style.lineHeight = 1;\n        div.style.fontSize = \"1px\";\n        div.style.position = \"absolute\";\n        div.textContent = \"X\";\n        document.body.append(div);\n        this.#minFontSize = div.getBoundingClientRect().height;\n        div.remove();\n    }\n    static #getAscent(fontFamily, style, lang) {\n        const cachedAscent = this.#ascentCache.get(fontFamily);\n        if (cachedAscent) {\n            return cachedAscent;\n        }\n        const ctx = this.#getCtx(lang);\n        ctx.canvas.width = ctx.canvas.height = DEFAULT_FONT_SIZE;\n        this.#ensureCtxFont(ctx, DEFAULT_FONT_SIZE, fontFamily);\n        const metrics = ctx.measureText(\"\");\n        const ascent = metrics.fontBoundingBoxAscent;\n        const descent = Math.abs(metrics.fontBoundingBoxDescent);\n        ctx.canvas.width = ctx.canvas.height = 0;\n        let ratio = 0.8;\n        if (ascent) {\n            ratio = ascent / (ascent + descent);\n        } else {\n            if (util_FeatureTest.platform.isFirefox) {\n                warn(\"Enable the `dom.textMetrics.fontBoundingBox.enabled` preference in `about:config` to improve TextLayer rendering.\");\n            }\n            if (style.ascent) {\n                ratio = style.ascent;\n            } else if (style.descent) {\n                ratio = 1 + style.descent;\n            }\n        }\n        this.#ascentCache.set(fontFamily, ratio);\n        return ratio;\n    }\n}\nconst RENDERING_CANCELLED_TIMEOUT = 100;\nfunction getDocument(src = {}) {\n    if (typeof src === \"string\" || src instanceof URL) {\n        src = {\n            url: src\n        };\n    } else if (src instanceof ArrayBuffer || ArrayBuffer.isView(src)) {\n        src = {\n            data: src\n        };\n    }\n    const task = new PDFDocumentLoadingTask();\n    const { docId } = task;\n    const url = src.url ? getUrlProp(src.url) : null;\n    const data = src.data ? getDataProp(src.data) : null;\n    const httpHeaders = src.httpHeaders || null;\n    const withCredentials = src.withCredentials === true;\n    const password = src.password ?? null;\n    const rangeTransport = src.range instanceof PDFDataRangeTransport ? src.range : null;\n    const rangeChunkSize = Number.isInteger(src.rangeChunkSize) && src.rangeChunkSize > 0 ? src.rangeChunkSize : 2 ** 16;\n    let worker = src.worker instanceof PDFWorker ? src.worker : null;\n    const verbosity2 = src.verbosity;\n    const docBaseUrl = typeof src.docBaseUrl === \"string\" && !isDataScheme(src.docBaseUrl) ? src.docBaseUrl : null;\n    const cMapUrl = getFactoryUrlProp(src.cMapUrl);\n    const cMapPacked = src.cMapPacked !== false;\n    const CMapReaderFactory = src.CMapReaderFactory || (isNodeJS ? NodeCMapReaderFactory : DOMCMapReaderFactory);\n    const iccUrl = getFactoryUrlProp(src.iccUrl);\n    const standardFontDataUrl = getFactoryUrlProp(src.standardFontDataUrl);\n    const StandardFontDataFactory = src.StandardFontDataFactory || (isNodeJS ? NodeStandardFontDataFactory : DOMStandardFontDataFactory);\n    const wasmUrl = getFactoryUrlProp(src.wasmUrl);\n    const WasmFactory = src.WasmFactory || (isNodeJS ? NodeWasmFactory : DOMWasmFactory);\n    const ignoreErrors = src.stopAtErrors !== true;\n    const maxImageSize = Number.isInteger(src.maxImageSize) && src.maxImageSize > -1 ? src.maxImageSize : -1;\n    const isEvalSupported2 = src.isEvalSupported !== false;\n    const isOffscreenCanvasSupported = typeof src.isOffscreenCanvasSupported === \"boolean\" ? src.isOffscreenCanvasSupported : !isNodeJS;\n    const isImageDecoderSupported = typeof src.isImageDecoderSupported === \"boolean\" ? src.isImageDecoderSupported : !isNodeJS && (util_FeatureTest.platform.isFirefox || !globalThis.chrome);\n    const canvasMaxAreaInBytes = Number.isInteger(src.canvasMaxAreaInBytes) ? src.canvasMaxAreaInBytes : -1;\n    const disableFontFace = typeof src.disableFontFace === \"boolean\" ? src.disableFontFace : isNodeJS;\n    const fontExtraProperties = src.fontExtraProperties === true;\n    const enableXfa = src.enableXfa === true;\n    const ownerDocument = src.ownerDocument || globalThis.document;\n    const disableRange = src.disableRange === true;\n    const disableStream = src.disableStream === true;\n    const disableAutoFetch = src.disableAutoFetch === true;\n    const pdfBug = src.pdfBug === true;\n    const CanvasFactory = src.CanvasFactory || (isNodeJS ? NodeCanvasFactory : DOMCanvasFactory);\n    const FilterFactory = src.FilterFactory || (isNodeJS ? NodeFilterFactory : DOMFilterFactory);\n    const enableHWA = src.enableHWA === true;\n    const useWasm = src.useWasm !== false;\n    const length = rangeTransport ? rangeTransport.length : src.length ?? NaN;\n    const useSystemFonts = typeof src.useSystemFonts === \"boolean\" ? src.useSystemFonts : !isNodeJS && !disableFontFace;\n    const useWorkerFetch = typeof src.useWorkerFetch === \"boolean\" ? src.useWorkerFetch : !!(CMapReaderFactory === DOMCMapReaderFactory && StandardFontDataFactory === DOMStandardFontDataFactory && WasmFactory === DOMWasmFactory && cMapUrl && standardFontDataUrl && wasmUrl && isValidFetchUrl(cMapUrl, document.baseURI) && isValidFetchUrl(standardFontDataUrl, document.baseURI) && isValidFetchUrl(wasmUrl, document.baseURI));\n    const styleElement = null;\n    setVerbosityLevel(verbosity2);\n    const transportFactory = {\n        canvasFactory: new CanvasFactory({\n            ownerDocument,\n            enableHWA\n        }),\n        filterFactory: new FilterFactory({\n            docId,\n            ownerDocument\n        }),\n        cMapReaderFactory: useWorkerFetch ? null : new CMapReaderFactory({\n            baseUrl: cMapUrl,\n            isCompressed: cMapPacked\n        }),\n        standardFontDataFactory: useWorkerFetch ? null : new StandardFontDataFactory({\n            baseUrl: standardFontDataUrl\n        }),\n        wasmFactory: useWorkerFetch ? null : new WasmFactory({\n            baseUrl: wasmUrl\n        })\n    };\n    if (!worker) {\n        worker = PDFWorker.create({\n            verbosity: verbosity2,\n            port: GlobalWorkerOptions.workerPort\n        });\n        task._worker = worker;\n    }\n    const docParams = {\n        docId,\n        apiVersion: \"5.4.296\",\n        data,\n        password,\n        disableAutoFetch,\n        rangeChunkSize,\n        length,\n        docBaseUrl,\n        enableXfa,\n        evaluatorOptions: {\n            maxImageSize,\n            disableFontFace,\n            ignoreErrors,\n            isEvalSupported: isEvalSupported2,\n            isOffscreenCanvasSupported,\n            isImageDecoderSupported,\n            canvasMaxAreaInBytes,\n            fontExtraProperties,\n            useSystemFonts,\n            useWasm,\n            useWorkerFetch,\n            cMapUrl,\n            iccUrl,\n            standardFontDataUrl,\n            wasmUrl\n        }\n    };\n    const transportParams = {\n        ownerDocument,\n        pdfBug,\n        styleElement,\n        loadingParams: {\n            disableAutoFetch,\n            enableXfa\n        }\n    };\n    worker.promise.then(function() {\n        if (task.destroyed) {\n            throw new Error(\"Loading aborted\");\n        }\n        if (worker.destroyed) {\n            throw new Error(\"Worker was destroyed\");\n        }\n        const workerIdPromise = worker.messageHandler.sendWithPromise(\"GetDocRequest\", docParams, data ? [\n            data.buffer\n        ] : null);\n        let networkStream;\n        if (rangeTransport) {\n            networkStream = new PDFDataTransportStream(rangeTransport, {\n                disableRange,\n                disableStream\n            });\n        } else if (!data) {\n            if (!url) {\n                throw new Error(\"getDocument - no `url` parameter provided.\");\n            }\n            const NetworkStream = isValidFetchUrl(url) ? PDFFetchStream : isNodeJS ? PDFNodeStream : PDFNetworkStream;\n            networkStream = new NetworkStream({\n                url,\n                length,\n                httpHeaders,\n                withCredentials,\n                rangeChunkSize,\n                disableRange,\n                disableStream\n            });\n        }\n        return workerIdPromise.then((workerId)=>{\n            if (task.destroyed) {\n                throw new Error(\"Loading aborted\");\n            }\n            if (worker.destroyed) {\n                throw new Error(\"Worker was destroyed\");\n            }\n            const messageHandler = new MessageHandler(docId, workerId, worker.port);\n            const transport = new WorkerTransport(messageHandler, task, networkStream, transportParams, transportFactory, enableHWA);\n            task._transport = transport;\n            messageHandler.send(\"Ready\", null);\n        });\n    }).catch(task._capability.reject);\n    return task;\n}\nclass PDFDocumentLoadingTask {\n    static #docId = 0;\n    get promise() {\n        return this._capability.promise;\n    }\n    async destroy() {\n        this.destroyed = true;\n        try {\n            if (this._worker?.port) {\n                this._worker._pendingDestroy = true;\n            }\n            await this._transport?.destroy();\n        } catch (ex) {\n            if (this._worker?.port) {\n                delete this._worker._pendingDestroy;\n            }\n            throw ex;\n        }\n        this._transport = null;\n        this._worker?.destroy();\n        this._worker = null;\n    }\n    async getData() {\n        return this._transport.getData();\n    }\n    constructor(){\n        this._capability = Promise.withResolvers();\n        this._transport = null;\n        this._worker = null;\n        this.docId = `d${PDFDocumentLoadingTask.#docId++}`;\n        this.destroyed = false;\n        this.onPassword = null;\n        this.onProgress = null;\n    }\n}\nclass PDFDataRangeTransport {\n    #capability;\n    #progressiveDoneListeners;\n    #progressiveReadListeners;\n    #progressListeners;\n    #rangeListeners;\n    constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null){\n        this.#capability = Promise.withResolvers();\n        this.#progressiveDoneListeners = [];\n        this.#progressiveReadListeners = [];\n        this.#progressListeners = [];\n        this.#rangeListeners = [];\n        this.length = length;\n        this.initialData = initialData;\n        this.progressiveDone = progressiveDone;\n        this.contentDispositionFilename = contentDispositionFilename;\n    }\n    addRangeListener(listener) {\n        this.#rangeListeners.push(listener);\n    }\n    addProgressListener(listener) {\n        this.#progressListeners.push(listener);\n    }\n    addProgressiveReadListener(listener) {\n        this.#progressiveReadListeners.push(listener);\n    }\n    addProgressiveDoneListener(listener) {\n        this.#progressiveDoneListeners.push(listener);\n    }\n    onDataRange(begin, chunk) {\n        for (const listener of this.#rangeListeners){\n            listener(begin, chunk);\n        }\n    }\n    onDataProgress(loaded, total) {\n        this.#capability.promise.then(()=>{\n            for (const listener of this.#progressListeners){\n                listener(loaded, total);\n            }\n        });\n    }\n    onDataProgressiveRead(chunk) {\n        this.#capability.promise.then(()=>{\n            for (const listener of this.#progressiveReadListeners){\n                listener(chunk);\n            }\n        });\n    }\n    onDataProgressiveDone() {\n        this.#capability.promise.then(()=>{\n            for (const listener of this.#progressiveDoneListeners){\n                listener();\n            }\n        });\n    }\n    transportReady() {\n        this.#capability.resolve();\n    }\n    requestDataRange(begin, end) {\n        unreachable(\"Abstract method PDFDataRangeTransport.requestDataRange\");\n    }\n    abort() {}\n}\nclass PDFDocumentProxy {\n    constructor(pdfInfo, transport){\n        this._pdfInfo = pdfInfo;\n        this._transport = transport;\n    }\n    get annotationStorage() {\n        return this._transport.annotationStorage;\n    }\n    get canvasFactory() {\n        return this._transport.canvasFactory;\n    }\n    get filterFactory() {\n        return this._transport.filterFactory;\n    }\n    get numPages() {\n        return this._pdfInfo.numPages;\n    }\n    get fingerprints() {\n        return this._pdfInfo.fingerprints;\n    }\n    get isPureXfa() {\n        return shadow(this, \"isPureXfa\", !!this._transport._htmlForXfa);\n    }\n    get allXfaHtml() {\n        return this._transport._htmlForXfa;\n    }\n    getPage(pageNumber) {\n        return this._transport.getPage(pageNumber);\n    }\n    getPageIndex(ref) {\n        return this._transport.getPageIndex(ref);\n    }\n    getDestinations() {\n        return this._transport.getDestinations();\n    }\n    getDestination(id) {\n        return this._transport.getDestination(id);\n    }\n    getPageLabels() {\n        return this._transport.getPageLabels();\n    }\n    getPageLayout() {\n        return this._transport.getPageLayout();\n    }\n    getPageMode() {\n        return this._transport.getPageMode();\n    }\n    getViewerPreferences() {\n        return this._transport.getViewerPreferences();\n    }\n    getOpenAction() {\n        return this._transport.getOpenAction();\n    }\n    getAttachments() {\n        return this._transport.getAttachments();\n    }\n    getAnnotationsByType(types, pageIndexesToSkip) {\n        return this._transport.getAnnotationsByType(types, pageIndexesToSkip);\n    }\n    getJSActions() {\n        return this._transport.getDocJSActions();\n    }\n    getOutline() {\n        return this._transport.getOutline();\n    }\n    getOptionalContentConfig({ intent = \"display\" } = {}) {\n        const { renderingIntent } = this._transport.getRenderingIntent(intent);\n        return this._transport.getOptionalContentConfig(renderingIntent);\n    }\n    getPermissions() {\n        return this._transport.getPermissions();\n    }\n    getMetadata() {\n        return this._transport.getMetadata();\n    }\n    getMarkInfo() {\n        return this._transport.getMarkInfo();\n    }\n    getData() {\n        return this._transport.getData();\n    }\n    saveDocument() {\n        return this._transport.saveDocument();\n    }\n    getDownloadInfo() {\n        return this._transport.downloadInfoCapability.promise;\n    }\n    cleanup(keepLoadedFonts = false) {\n        return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);\n    }\n    destroy() {\n        return this.loadingTask.destroy();\n    }\n    cachedPageNumber(ref) {\n        return this._transport.cachedPageNumber(ref);\n    }\n    get loadingParams() {\n        return this._transport.loadingParams;\n    }\n    get loadingTask() {\n        return this._transport.loadingTask;\n    }\n    getFieldObjects() {\n        return this._transport.getFieldObjects();\n    }\n    hasJSActions() {\n        return this._transport.hasJSActions();\n    }\n    getCalculationOrderIds() {\n        return this._transport.getCalculationOrderIds();\n    }\n}\nclass PDFPageProxy {\n    #pendingCleanup;\n    constructor(pageIndex, pageInfo, transport, pdfBug = false){\n        this.#pendingCleanup = false;\n        this._pageIndex = pageIndex;\n        this._pageInfo = pageInfo;\n        this._transport = transport;\n        this._stats = pdfBug ? new StatTimer() : null;\n        this._pdfBug = pdfBug;\n        this.commonObjs = transport.commonObjs;\n        this.objs = new PDFObjects();\n        this._intentStates = /* @__PURE__ */ new Map();\n        this.destroyed = false;\n        this.recordedBBoxes = null;\n    }\n    get pageNumber() {\n        return this._pageIndex + 1;\n    }\n    get rotate() {\n        return this._pageInfo.rotate;\n    }\n    get ref() {\n        return this._pageInfo.ref;\n    }\n    get userUnit() {\n        return this._pageInfo.userUnit;\n    }\n    get view() {\n        return this._pageInfo.view;\n    }\n    getViewport({ scale, rotation = this.rotate, offsetX = 0, offsetY = 0, dontFlip = false } = {}) {\n        return new PageViewport({\n            viewBox: this.view,\n            userUnit: this.userUnit,\n            scale,\n            rotation,\n            offsetX,\n            offsetY,\n            dontFlip\n        });\n    }\n    getAnnotations({ intent = \"display\" } = {}) {\n        const { renderingIntent } = this._transport.getRenderingIntent(intent);\n        return this._transport.getAnnotations(this._pageIndex, renderingIntent);\n    }\n    getJSActions() {\n        return this._transport.getPageJSActions(this._pageIndex);\n    }\n    get filterFactory() {\n        return this._transport.filterFactory;\n    }\n    get isPureXfa() {\n        return shadow(this, \"isPureXfa\", !!this._transport._htmlForXfa);\n    }\n    async getXfa() {\n        return this._transport._htmlForXfa?.children[this._pageIndex] || null;\n    }\n    render({ canvasContext, canvas = canvasContext.canvas, viewport, intent = \"display\", annotationMode = AnnotationMode.ENABLE, transform = null, background = null, optionalContentConfigPromise = null, annotationCanvasMap = null, pageColors = null, printAnnotationStorage = null, isEditing = false, recordOperations = false, operationsFilter = null }) {\n        this._stats?.time(\"Overall\");\n        const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, isEditing);\n        const { renderingIntent, cacheKey } = intentArgs;\n        this.#pendingCleanup = false;\n        optionalContentConfigPromise ||= this._transport.getOptionalContentConfig(renderingIntent);\n        let intentState = this._intentStates.get(cacheKey);\n        if (!intentState) {\n            intentState = /* @__PURE__ */ Object.create(null);\n            this._intentStates.set(cacheKey, intentState);\n        }\n        if (intentState.streamReaderCancelTimeout) {\n            clearTimeout(intentState.streamReaderCancelTimeout);\n            intentState.streamReaderCancelTimeout = null;\n        }\n        const intentPrint = !!(renderingIntent & RenderingIntentFlag.PRINT);\n        if (!intentState.displayReadyCapability) {\n            intentState.displayReadyCapability = Promise.withResolvers();\n            intentState.operatorList = {\n                fnArray: [],\n                argsArray: [],\n                lastChunk: false,\n                separateAnnots: null\n            };\n            this._stats?.time(\"Page Request\");\n            this._pumpOperatorList(intentArgs);\n        }\n        const recordForDebugger = Boolean(this._pdfBug && globalThis.StepperManager?.enabled);\n        const shouldRecordOperations = !this.recordedBBoxes && (recordOperations || recordForDebugger);\n        const complete = (error)=>{\n            intentState.renderTasks.delete(internalRenderTask);\n            if (shouldRecordOperations) {\n                const recordedBBoxes = internalRenderTask.gfx?.dependencyTracker.take();\n                if (recordedBBoxes) {\n                    if (internalRenderTask.stepper) {\n                        internalRenderTask.stepper.setOperatorBBoxes(recordedBBoxes, internalRenderTask.gfx.dependencyTracker.takeDebugMetadata());\n                    }\n                    if (recordOperations) {\n                        this.recordedBBoxes = recordedBBoxes;\n                    }\n                }\n            }\n            if (intentPrint) {\n                this.#pendingCleanup = true;\n            }\n            this.#tryCleanup();\n            if (error) {\n                internalRenderTask.capability.reject(error);\n                this._abortOperatorList({\n                    intentState,\n                    reason: error instanceof Error ? error : new Error(error)\n                });\n            } else {\n                internalRenderTask.capability.resolve();\n            }\n            if (this._stats) {\n                this._stats.timeEnd(\"Rendering\");\n                this._stats.timeEnd(\"Overall\");\n                if (globalThis.Stats?.enabled) {\n                    globalThis.Stats.add(this.pageNumber, this._stats);\n                }\n            }\n        };\n        const internalRenderTask = new InternalRenderTask({\n            callback: complete,\n            params: {\n                canvas,\n                canvasContext,\n                dependencyTracker: shouldRecordOperations ? new CanvasDependencyTracker(canvas, intentState.operatorList.length, recordForDebugger) : null,\n                viewport,\n                transform,\n                background\n            },\n            objs: this.objs,\n            commonObjs: this.commonObjs,\n            annotationCanvasMap,\n            operatorList: intentState.operatorList,\n            pageIndex: this._pageIndex,\n            canvasFactory: this._transport.canvasFactory,\n            filterFactory: this._transport.filterFactory,\n            useRequestAnimationFrame: !intentPrint,\n            pdfBug: this._pdfBug,\n            pageColors,\n            enableHWA: this._transport.enableHWA,\n            operationsFilter\n        });\n        (intentState.renderTasks ||= /* @__PURE__ */ new Set()).add(internalRenderTask);\n        const renderTask = internalRenderTask.task;\n        Promise.all([\n            intentState.displayReadyCapability.promise,\n            optionalContentConfigPromise\n        ]).then(([transparency, optionalContentConfig])=>{\n            if (this.destroyed) {\n                complete();\n                return;\n            }\n            this._stats?.time(\"Rendering\");\n            if (!(optionalContentConfig.renderingIntent & renderingIntent)) {\n                throw new Error(\"Must use the same `intent`-argument when calling the `PDFPageProxy.render` and `PDFDocumentProxy.getOptionalContentConfig` methods.\");\n            }\n            internalRenderTask.initializeGraphics({\n                transparency,\n                optionalContentConfig\n            });\n            internalRenderTask.operatorListChanged();\n        }).catch(complete);\n        return renderTask;\n    }\n    getOperatorList({ intent = \"display\", annotationMode = AnnotationMode.ENABLE, printAnnotationStorage = null, isEditing = false } = {}) {\n        function operatorListChanged() {\n            if (intentState.operatorList.lastChunk) {\n                intentState.opListReadCapability.resolve(intentState.operatorList);\n                intentState.renderTasks.delete(opListTask);\n            }\n        }\n        const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, isEditing, true);\n        let intentState = this._intentStates.get(intentArgs.cacheKey);\n        if (!intentState) {\n            intentState = /* @__PURE__ */ Object.create(null);\n            this._intentStates.set(intentArgs.cacheKey, intentState);\n        }\n        let opListTask;\n        if (!intentState.opListReadCapability) {\n            opListTask = /* @__PURE__ */ Object.create(null);\n            opListTask.operatorListChanged = operatorListChanged;\n            intentState.opListReadCapability = Promise.withResolvers();\n            (intentState.renderTasks ||= /* @__PURE__ */ new Set()).add(opListTask);\n            intentState.operatorList = {\n                fnArray: [],\n                argsArray: [],\n                lastChunk: false,\n                separateAnnots: null\n            };\n            this._stats?.time(\"Page Request\");\n            this._pumpOperatorList(intentArgs);\n        }\n        return intentState.opListReadCapability.promise;\n    }\n    streamTextContent({ includeMarkedContent = false, disableNormalization = false } = {}) {\n        const TEXT_CONTENT_CHUNK_SIZE = 100;\n        return this._transport.messageHandler.sendWithStream(\"GetTextContent\", {\n            pageIndex: this._pageIndex,\n            includeMarkedContent: includeMarkedContent === true,\n            disableNormalization: disableNormalization === true\n        }, {\n            highWaterMark: TEXT_CONTENT_CHUNK_SIZE,\n            size (textContent) {\n                return textContent.items.length;\n            }\n        });\n    }\n    getTextContent(params = {}) {\n        if (this._transport._htmlForXfa) {\n            return this.getXfa().then((xfa)=>XfaText.textContent(xfa));\n        }\n        const readableStream = this.streamTextContent(params);\n        return new Promise(function(resolve, reject) {\n            function pump() {\n                reader.read().then(function({ value: value1, done }) {\n                    if (done) {\n                        resolve(textContent);\n                        return;\n                    }\n                    textContent.lang ??= value1.lang;\n                    Object.assign(textContent.styles, value1.styles);\n                    textContent.items.push(...value1.items);\n                    pump();\n                }, reject);\n            }\n            const reader = readableStream.getReader();\n            const textContent = {\n                items: [],\n                styles: /* @__PURE__ */ Object.create(null),\n                lang: null\n            };\n            pump();\n        });\n    }\n    getStructTree() {\n        return this._transport.getStructTree(this._pageIndex);\n    }\n    _destroy() {\n        this.destroyed = true;\n        const waitOn = [];\n        for (const intentState of this._intentStates.values()){\n            this._abortOperatorList({\n                intentState,\n                reason: new Error(\"Page was destroyed.\"),\n                force: true\n            });\n            if (intentState.opListReadCapability) {\n                continue;\n            }\n            for (const internalRenderTask of intentState.renderTasks){\n                waitOn.push(internalRenderTask.completed);\n                internalRenderTask.cancel();\n            }\n        }\n        this.objs.clear();\n        this.#pendingCleanup = false;\n        return Promise.all(waitOn);\n    }\n    cleanup(resetStats = false) {\n        this.#pendingCleanup = true;\n        const success = this.#tryCleanup();\n        if (resetStats && success) {\n            this._stats &&= new StatTimer();\n        }\n        return success;\n    }\n    #tryCleanup() {\n        if (!this.#pendingCleanup || this.destroyed) {\n            return false;\n        }\n        for (const { renderTasks, operatorList } of this._intentStates.values()){\n            if (renderTasks.size > 0 || !operatorList.lastChunk) {\n                return false;\n            }\n        }\n        this._intentStates.clear();\n        this.objs.clear();\n        this.#pendingCleanup = false;\n        return true;\n    }\n    _startRenderPage(transparency, cacheKey) {\n        const intentState = this._intentStates.get(cacheKey);\n        if (!intentState) {\n            return;\n        }\n        this._stats?.timeEnd(\"Page Request\");\n        intentState.displayReadyCapability?.resolve(transparency);\n    }\n    _renderPageChunk(operatorListChunk, intentState) {\n        for(let i = 0, ii = operatorListChunk.length; i < ii; i++){\n            intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);\n            intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);\n        }\n        intentState.operatorList.lastChunk = operatorListChunk.lastChunk;\n        intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;\n        for (const internalRenderTask of intentState.renderTasks){\n            internalRenderTask.operatorListChanged();\n        }\n        if (operatorListChunk.lastChunk) {\n            this.#tryCleanup();\n        }\n    }\n    _pumpOperatorList({ renderingIntent, cacheKey, annotationStorageSerializable, modifiedIds }) {\n        const { map, transfer } = annotationStorageSerializable;\n        const readableStream = this._transport.messageHandler.sendWithStream(\"GetOperatorList\", {\n            pageIndex: this._pageIndex,\n            intent: renderingIntent,\n            cacheKey,\n            annotationStorage: map,\n            modifiedIds\n        }, transfer);\n        const reader = readableStream.getReader();\n        const intentState = this._intentStates.get(cacheKey);\n        intentState.streamReader = reader;\n        const pump = ()=>{\n            reader.read().then(({ value: value1, done })=>{\n                if (done) {\n                    intentState.streamReader = null;\n                    return;\n                }\n                if (this._transport.destroyed) {\n                    return;\n                }\n                this._renderPageChunk(value1, intentState);\n                pump();\n            }, (reason)=>{\n                intentState.streamReader = null;\n                if (this._transport.destroyed) {\n                    return;\n                }\n                if (intentState.operatorList) {\n                    intentState.operatorList.lastChunk = true;\n                    for (const internalRenderTask of intentState.renderTasks){\n                        internalRenderTask.operatorListChanged();\n                    }\n                    this.#tryCleanup();\n                }\n                if (intentState.displayReadyCapability) {\n                    intentState.displayReadyCapability.reject(reason);\n                } else if (intentState.opListReadCapability) {\n                    intentState.opListReadCapability.reject(reason);\n                } else {\n                    throw reason;\n                }\n            });\n        };\n        pump();\n    }\n    _abortOperatorList({ intentState, reason, force = false }) {\n        if (!intentState.streamReader) {\n            return;\n        }\n        if (intentState.streamReaderCancelTimeout) {\n            clearTimeout(intentState.streamReaderCancelTimeout);\n            intentState.streamReaderCancelTimeout = null;\n        }\n        if (!force) {\n            if (intentState.renderTasks.size > 0) {\n                return;\n            }\n            if (reason instanceof RenderingCancelledException) {\n                let delay = RENDERING_CANCELLED_TIMEOUT;\n                if (reason.extraDelay > 0 && reason.extraDelay < 1e3) {\n                    delay += reason.extraDelay;\n                }\n                intentState.streamReaderCancelTimeout = setTimeout(()=>{\n                    intentState.streamReaderCancelTimeout = null;\n                    this._abortOperatorList({\n                        intentState,\n                        reason,\n                        force: true\n                    });\n                }, delay);\n                return;\n            }\n        }\n        intentState.streamReader.cancel(new AbortException(reason.message)).catch(()=>{});\n        intentState.streamReader = null;\n        if (this._transport.destroyed) {\n            return;\n        }\n        for (const [curCacheKey, curIntentState] of this._intentStates){\n            if (curIntentState === intentState) {\n                this._intentStates.delete(curCacheKey);\n                break;\n            }\n        }\n        this.cleanup();\n    }\n    get stats() {\n        return this._stats;\n    }\n}\nconst _PDFWorker = class _PDFWorker {\n    constructor({ name = null, port = null, verbosity: verbosity2 = getVerbosityLevel() } = {}){\n        __privateAdd(this, _PDFWorker_instances);\n        __privateAdd(this, _capability, Promise.withResolvers());\n        __privateAdd(this, _messageHandler, null);\n        __privateAdd(this, _port, null);\n        __privateAdd(this, _webWorker, null);\n        this.name = name;\n        this.destroyed = false;\n        this.verbosity = verbosity2;\n        if (port) {\n            if (__privateGet(_PDFWorker, _workerPorts).has(port)) {\n                throw new Error(\"Cannot use more than one PDFWorker per port.\");\n            }\n            __privateGet(_PDFWorker, _workerPorts).set(port, this);\n            __privateMethod(this, _PDFWorker_instances, initializeFromPort_fn).call(this, port);\n        } else {\n            __privateMethod(this, _PDFWorker_instances, initialize_fn).call(this);\n        }\n    }\n    get promise() {\n        return __privateGet(this, _capability).promise;\n    }\n    get port() {\n        return __privateGet(this, _port);\n    }\n    get messageHandler() {\n        return __privateGet(this, _messageHandler);\n    }\n    destroy() {\n        this.destroyed = true;\n        __privateGet(this, _webWorker)?.terminate();\n        __privateSet(this, _webWorker, null);\n        __privateGet(_PDFWorker, _workerPorts).delete(__privateGet(this, _port));\n        __privateSet(this, _port, null);\n        __privateGet(this, _messageHandler)?.destroy();\n        __privateSet(this, _messageHandler, null);\n    }\n    static create(params) {\n        const cachedPort = __privateGet(this, _workerPorts).get(params?.port);\n        if (cachedPort) {\n            if (cachedPort._pendingDestroy) {\n                throw new Error(\"PDFWorker.create - the worker is being destroyed.\\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls.\");\n            }\n            return cachedPort;\n        }\n        return new _PDFWorker(params);\n    }\n    static get workerSrc() {\n        if (GlobalWorkerOptions.workerSrc) {\n            return GlobalWorkerOptions.workerSrc;\n        }\n        throw new Error('No \"GlobalWorkerOptions.workerSrc\" specified.');\n    }\n    static get _setupFakeWorkerGlobal() {\n        const loader = async ()=>{\n            if (__privateGet(this, _PDFWorker_static, mainThreadWorkerMessageHandler_get)) {\n                return __privateGet(this, _PDFWorker_static, mainThreadWorkerMessageHandler_get);\n            }\n            const worker = await import(/*webpackIgnore: true*/ /*@vite-ignore*/ this.workerSrc);\n            return worker.WorkerMessageHandler;\n        };\n        return shadow(this, \"_setupFakeWorkerGlobal\", loader());\n    }\n};\n_capability = new WeakMap();\n_messageHandler = new WeakMap();\n_port = new WeakMap();\n_webWorker = new WeakMap();\n_fakeWorkerId = new WeakMap();\n_isWorkerDisabled = new WeakMap();\n_workerPorts = new WeakMap();\n_PDFWorker_instances = new WeakSet();\nresolve_fn = function() {\n    __privateGet(this, _capability).resolve();\n    __privateGet(this, _messageHandler).send(\"configure\", {\n        verbosity: this.verbosity\n    });\n};\ninitializeFromPort_fn = function(port) {\n    __privateSet(this, _port, port);\n    __privateSet(this, _messageHandler, new MessageHandler(\"main\", \"worker\", port));\n    __privateGet(this, _messageHandler).on(\"ready\", ()=>{});\n    __privateMethod(this, _PDFWorker_instances, resolve_fn).call(this);\n};\ninitialize_fn = function() {\n    if (__privateGet(_PDFWorker, _isWorkerDisabled) || __privateGet(_PDFWorker, _PDFWorker_static, mainThreadWorkerMessageHandler_get)) {\n        __privateMethod(this, _PDFWorker_instances, setupFakeWorker_fn).call(this);\n        return;\n    }\n    let { workerSrc } = _PDFWorker;\n    try {\n        if (!_PDFWorker._isSameOrigin(window.location, workerSrc)) {\n            workerSrc = _PDFWorker._createCDNWrapper(new URL(workerSrc, window.location).href);\n        }\n        const worker = new Worker(workerSrc, {\n            type: \"module\"\n        });\n        const messageHandler = new MessageHandler(\"main\", \"worker\", worker);\n        const terminateEarly = ()=>{\n            ac.abort();\n            messageHandler.destroy();\n            worker.terminate();\n            if (this.destroyed) {\n                __privateGet(this, _capability).reject(new Error(\"Worker was destroyed\"));\n            } else {\n                __privateMethod(this, _PDFWorker_instances, setupFakeWorker_fn).call(this);\n            }\n        };\n        const ac = new AbortController();\n        worker.addEventListener(\"error\", ()=>{\n            if (!__privateGet(this, _webWorker)) {\n                terminateEarly();\n            }\n        }, {\n            signal: ac.signal\n        });\n        messageHandler.on(\"test\", (data)=>{\n            ac.abort();\n            if (this.destroyed || !data) {\n                terminateEarly();\n                return;\n            }\n            __privateSet(this, _messageHandler, messageHandler);\n            __privateSet(this, _port, worker);\n            __privateSet(this, _webWorker, worker);\n            __privateMethod(this, _PDFWorker_instances, resolve_fn).call(this);\n        });\n        messageHandler.on(\"ready\", (data)=>{\n            ac.abort();\n            if (this.destroyed) {\n                terminateEarly();\n                return;\n            }\n            try {\n                sendTest();\n            } catch  {\n                __privateMethod(this, _PDFWorker_instances, setupFakeWorker_fn).call(this);\n            }\n        });\n        const sendTest = ()=>{\n            const testObj = new Uint8Array();\n            messageHandler.send(\"test\", testObj, [\n                testObj.buffer\n            ]);\n        };\n        sendTest();\n        return;\n    } catch  {\n        info(\"The worker has been disabled.\");\n    }\n    __privateMethod(this, _PDFWorker_instances, setupFakeWorker_fn).call(this);\n};\nsetupFakeWorker_fn = function() {\n    if (!__privateGet(_PDFWorker, _isWorkerDisabled)) {\n        warn(\"Setting up fake worker.\");\n        __privateSet(_PDFWorker, _isWorkerDisabled, true);\n    }\n    _PDFWorker._setupFakeWorkerGlobal.then((WorkerMessageHandler)=>{\n        if (this.destroyed) {\n            __privateGet(this, _capability).reject(new Error(\"Worker was destroyed\"));\n            return;\n        }\n        const port = new LoopbackPort();\n        __privateSet(this, _port, port);\n        const id = `fake${__privateWrapper(_PDFWorker, _fakeWorkerId)._++}`;\n        const workerHandler = new MessageHandler(id + \"_worker\", id, port);\n        WorkerMessageHandler.setup(workerHandler, port);\n        __privateSet(this, _messageHandler, new MessageHandler(id, id + \"_worker\", port));\n        __privateMethod(this, _PDFWorker_instances, resolve_fn).call(this);\n    }).catch((reason)=>{\n        __privateGet(this, _capability).reject(new Error(`Setting up fake worker failed: \"${reason.message}\".`));\n    });\n};\n_PDFWorker_static = new WeakSet();\nmainThreadWorkerMessageHandler_get = function() {\n    try {\n        return globalThis.pdfjsWorker?.WorkerMessageHandler || null;\n    } catch  {\n        return null;\n    }\n};\n__privateAdd(_PDFWorker, _PDFWorker_static);\n__privateAdd(_PDFWorker, _fakeWorkerId, 0);\n__privateAdd(_PDFWorker, _isWorkerDisabled, false);\n__privateAdd(_PDFWorker, _workerPorts, /* @__PURE__ */ new WeakMap());\n(()=>{\n    if (isNodeJS) {\n        __privateSet(_PDFWorker, _isWorkerDisabled, true);\n        GlobalWorkerOptions.workerSrc ||= \"./pdf.worker.mjs\";\n    }\n    _PDFWorker._isSameOrigin = (baseUrl, otherUrl)=>{\n        const base = URL.parse(baseUrl);\n        if (!base?.origin || base.origin === \"null\") {\n            return false;\n        }\n        const other = new URL(otherUrl, base);\n        return base.origin === other.origin;\n    };\n    _PDFWorker._createCDNWrapper = (url)=>{\n        const wrapper = `await import(\"${url}\");`;\n        return URL.createObjectURL(new Blob([\n            wrapper\n        ], {\n            type: \"text/javascript\"\n        }));\n    };\n    _PDFWorker.fromPort = (params)=>{\n        deprecated(\"`PDFWorker.fromPort` - please use `PDFWorker.create` instead.\");\n        if (!params?.port) {\n            throw new Error(\"PDFWorker.fromPort - invalid method signature.\");\n        }\n        return _PDFWorker.create(params);\n    };\n})();\nlet PDFWorker = _PDFWorker;\nclass WorkerTransport {\n    #methodPromises;\n    #pageCache;\n    #pagePromises;\n    #pageRefCache;\n    #passwordCapability;\n    constructor(messageHandler, loadingTask, networkStream, params, factory, enableHWA){\n        this.#methodPromises = /* @__PURE__ */ new Map();\n        this.#pageCache = /* @__PURE__ */ new Map();\n        this.#pagePromises = /* @__PURE__ */ new Map();\n        this.#pageRefCache = /* @__PURE__ */ new Map();\n        this.#passwordCapability = null;\n        this.messageHandler = messageHandler;\n        this.loadingTask = loadingTask;\n        this.commonObjs = new PDFObjects();\n        this.fontLoader = new FontLoader({\n            ownerDocument: params.ownerDocument,\n            styleElement: params.styleElement\n        });\n        this.loadingParams = params.loadingParams;\n        this._params = params;\n        this.canvasFactory = factory.canvasFactory;\n        this.filterFactory = factory.filterFactory;\n        this.cMapReaderFactory = factory.cMapReaderFactory;\n        this.standardFontDataFactory = factory.standardFontDataFactory;\n        this.wasmFactory = factory.wasmFactory;\n        this.destroyed = false;\n        this.destroyCapability = null;\n        this._networkStream = networkStream;\n        this._fullReader = null;\n        this._lastProgress = null;\n        this.downloadInfoCapability = Promise.withResolvers();\n        this.enableHWA = enableHWA;\n        this.setupMessageHandler();\n    }\n    #cacheSimpleMethod(name, data = null) {\n        const cachedPromise = this.#methodPromises.get(name);\n        if (cachedPromise) {\n            return cachedPromise;\n        }\n        const promise = this.messageHandler.sendWithPromise(name, data);\n        this.#methodPromises.set(name, promise);\n        return promise;\n    }\n    get annotationStorage() {\n        return shadow(this, \"annotationStorage\", new AnnotationStorage());\n    }\n    getRenderingIntent(intent, annotationMode = AnnotationMode.ENABLE, printAnnotationStorage = null, isEditing = false, isOpList = false) {\n        let renderingIntent = RenderingIntentFlag.DISPLAY;\n        let annotationStorageSerializable = SerializableEmpty;\n        switch(intent){\n            case \"any\":\n                renderingIntent = RenderingIntentFlag.ANY;\n                break;\n            case \"display\":\n                break;\n            case \"print\":\n                renderingIntent = RenderingIntentFlag.PRINT;\n                break;\n            default:\n                warn(`getRenderingIntent - invalid intent: ${intent}`);\n        }\n        const annotationStorage = renderingIntent & RenderingIntentFlag.PRINT && printAnnotationStorage instanceof PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage;\n        switch(annotationMode){\n            case AnnotationMode.DISABLE:\n                renderingIntent += RenderingIntentFlag.ANNOTATIONS_DISABLE;\n                break;\n            case AnnotationMode.ENABLE:\n                break;\n            case AnnotationMode.ENABLE_FORMS:\n                renderingIntent += RenderingIntentFlag.ANNOTATIONS_FORMS;\n                break;\n            case AnnotationMode.ENABLE_STORAGE:\n                renderingIntent += RenderingIntentFlag.ANNOTATIONS_STORAGE;\n                annotationStorageSerializable = annotationStorage.serializable;\n                break;\n            default:\n                warn(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);\n        }\n        if (isEditing) {\n            renderingIntent += RenderingIntentFlag.IS_EDITING;\n        }\n        if (isOpList) {\n            renderingIntent += RenderingIntentFlag.OPLIST;\n        }\n        const { ids: modifiedIds, hash: modifiedIdsHash } = annotationStorage.modifiedIds;\n        const cacheKeyBuf = [\n            renderingIntent,\n            annotationStorageSerializable.hash,\n            modifiedIdsHash\n        ];\n        return {\n            renderingIntent,\n            cacheKey: cacheKeyBuf.join(\"_\"),\n            annotationStorageSerializable,\n            modifiedIds\n        };\n    }\n    destroy() {\n        if (this.destroyCapability) {\n            return this.destroyCapability.promise;\n        }\n        this.destroyed = true;\n        this.destroyCapability = Promise.withResolvers();\n        this.#passwordCapability?.reject(new Error(\"Worker was destroyed during onPassword callback\"));\n        const waitOn = [];\n        for (const page of this.#pageCache.values()){\n            waitOn.push(page._destroy());\n        }\n        this.#pageCache.clear();\n        this.#pagePromises.clear();\n        this.#pageRefCache.clear();\n        if (this.hasOwnProperty(\"annotationStorage\")) {\n            this.annotationStorage.resetModified();\n        }\n        const terminated = this.messageHandler.sendWithPromise(\"Terminate\", null);\n        waitOn.push(terminated);\n        Promise.all(waitOn).then(()=>{\n            this.commonObjs.clear();\n            this.fontLoader.clear();\n            this.#methodPromises.clear();\n            this.filterFactory.destroy();\n            TextLayer.cleanup();\n            this._networkStream?.cancelAllRequests(new AbortException(\"Worker was terminated.\"));\n            this.messageHandler?.destroy();\n            this.messageHandler = null;\n            this.destroyCapability.resolve();\n        }, this.destroyCapability.reject);\n        return this.destroyCapability.promise;\n    }\n    setupMessageHandler() {\n        const { messageHandler, loadingTask } = this;\n        messageHandler.on(\"GetReader\", (data, sink)=>{\n            assert(this._networkStream, \"GetReader - no `IPDFStream` instance available.\");\n            this._fullReader = this._networkStream.getFullReader();\n            this._fullReader.onProgress = (evt)=>{\n                this._lastProgress = {\n                    loaded: evt.loaded,\n                    total: evt.total\n                };\n            };\n            sink.onPull = ()=>{\n                this._fullReader.read().then(function({ value: value1, done }) {\n                    if (done) {\n                        sink.close();\n                        return;\n                    }\n                    assert(value1 instanceof ArrayBuffer, \"GetReader - expected an ArrayBuffer.\");\n                    sink.enqueue(new Uint8Array(value1), 1, [\n                        value1\n                    ]);\n                }).catch((reason)=>{\n                    sink.error(reason);\n                });\n            };\n            sink.onCancel = (reason)=>{\n                this._fullReader.cancel(reason);\n                sink.ready.catch((readyReason)=>{\n                    if (this.destroyed) {\n                        return;\n                    }\n                    throw readyReason;\n                });\n            };\n        });\n        messageHandler.on(\"ReaderHeadersReady\", async (data)=>{\n            await this._fullReader.headersReady;\n            const { isStreamingSupported, isRangeSupported, contentLength } = this._fullReader;\n            if (!isStreamingSupported || !isRangeSupported) {\n                if (this._lastProgress) {\n                    loadingTask.onProgress?.(this._lastProgress);\n                }\n                this._fullReader.onProgress = (evt)=>{\n                    loadingTask.onProgress?.({\n                        loaded: evt.loaded,\n                        total: evt.total\n                    });\n                };\n            }\n            return {\n                isStreamingSupported,\n                isRangeSupported,\n                contentLength\n            };\n        });\n        messageHandler.on(\"GetRangeReader\", (data, sink)=>{\n            assert(this._networkStream, \"GetRangeReader - no `IPDFStream` instance available.\");\n            const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);\n            if (!rangeReader) {\n                sink.close();\n                return;\n            }\n            sink.onPull = ()=>{\n                rangeReader.read().then(function({ value: value1, done }) {\n                    if (done) {\n                        sink.close();\n                        return;\n                    }\n                    assert(value1 instanceof ArrayBuffer, \"GetRangeReader - expected an ArrayBuffer.\");\n                    sink.enqueue(new Uint8Array(value1), 1, [\n                        value1\n                    ]);\n                }).catch((reason)=>{\n                    sink.error(reason);\n                });\n            };\n            sink.onCancel = (reason)=>{\n                rangeReader.cancel(reason);\n                sink.ready.catch((readyReason)=>{\n                    if (this.destroyed) {\n                        return;\n                    }\n                    throw readyReason;\n                });\n            };\n        });\n        messageHandler.on(\"GetDoc\", ({ pdfInfo })=>{\n            this._numPages = pdfInfo.numPages;\n            this._htmlForXfa = pdfInfo.htmlForXfa;\n            delete pdfInfo.htmlForXfa;\n            loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));\n        });\n        messageHandler.on(\"DocException\", (ex)=>{\n            loadingTask._capability.reject(wrapReason(ex));\n        });\n        messageHandler.on(\"PasswordRequest\", (ex)=>{\n            this.#passwordCapability = Promise.withResolvers();\n            try {\n                if (!loadingTask.onPassword) {\n                    throw wrapReason(ex);\n                }\n                const updatePassword = (password)=>{\n                    if (password instanceof Error) {\n                        this.#passwordCapability.reject(password);\n                    } else {\n                        this.#passwordCapability.resolve({\n                            password\n                        });\n                    }\n                };\n                loadingTask.onPassword(updatePassword, ex.code);\n            } catch (err) {\n                this.#passwordCapability.reject(err);\n            }\n            return this.#passwordCapability.promise;\n        });\n        messageHandler.on(\"DataLoaded\", (data)=>{\n            loadingTask.onProgress?.({\n                loaded: data.length,\n                total: data.length\n            });\n            this.downloadInfoCapability.resolve(data);\n        });\n        messageHandler.on(\"StartRenderPage\", (data)=>{\n            if (this.destroyed) {\n                return;\n            }\n            const page = this.#pageCache.get(data.pageIndex);\n            page._startRenderPage(data.transparency, data.cacheKey);\n        });\n        messageHandler.on(\"commonobj\", ([id, type, exportedData])=>{\n            if (this.destroyed) {\n                return null;\n            }\n            if (this.commonObjs.has(id)) {\n                return null;\n            }\n            switch(type){\n                case \"Font\":\n                    if (\"error\" in exportedData) {\n                        const exportedError = exportedData.error;\n                        warn(`Error during font loading: ${exportedError}`);\n                        this.commonObjs.resolve(id, exportedError);\n                        break;\n                    }\n                    const fontData = new FontInfo(exportedData);\n                    const inspectFont = this._params.pdfBug && globalThis.FontInspector?.enabled ? (font2, url)=>globalThis.FontInspector.fontAdded(font2, url) : null;\n                    const font = new FontFaceObject(fontData, inspectFont, exportedData.extra, exportedData.charProcOperatorList);\n                    this.fontLoader.bind(font).catch(()=>messageHandler.sendWithPromise(\"FontFallback\", {\n                            id\n                        })).finally(()=>{\n                        if (!font.fontExtraProperties && font.data) {\n                            font.clearData();\n                        }\n                        this.commonObjs.resolve(id, font);\n                    });\n                    break;\n                case \"CopyLocalImage\":\n                    const { imageRef } = exportedData;\n                    assert(imageRef, \"The imageRef must be defined.\");\n                    for (const pageProxy of this.#pageCache.values()){\n                        for (const [, data] of pageProxy.objs){\n                            if (data?.ref !== imageRef) {\n                                continue;\n                            }\n                            if (!data.dataLen) {\n                                return null;\n                            }\n                            this.commonObjs.resolve(id, structuredClone(data));\n                            return data.dataLen;\n                        }\n                    }\n                    break;\n                case \"FontPath\":\n                case \"Image\":\n                case \"Pattern\":\n                    this.commonObjs.resolve(id, exportedData);\n                    break;\n                default:\n                    throw new Error(`Got unknown common object type ${type}`);\n            }\n            return null;\n        });\n        messageHandler.on(\"obj\", ([id, pageIndex, type, imageData])=>{\n            if (this.destroyed) {\n                return;\n            }\n            const pageProxy = this.#pageCache.get(pageIndex);\n            if (pageProxy.objs.has(id)) {\n                return;\n            }\n            if (pageProxy._intentStates.size === 0) {\n                imageData?.bitmap?.close();\n                return;\n            }\n            switch(type){\n                case \"Image\":\n                case \"Pattern\":\n                    pageProxy.objs.resolve(id, imageData);\n                    break;\n                default:\n                    throw new Error(`Got unknown object type ${type}`);\n            }\n        });\n        messageHandler.on(\"DocProgress\", (data)=>{\n            if (this.destroyed) {\n                return;\n            }\n            loadingTask.onProgress?.({\n                loaded: data.loaded,\n                total: data.total\n            });\n        });\n        messageHandler.on(\"FetchBinaryData\", async (data)=>{\n            if (this.destroyed) {\n                throw new Error(\"Worker was destroyed.\");\n            }\n            const factory = this[data.type];\n            if (!factory) {\n                throw new Error(`${data.type} not initialized, see the \\`useWorkerFetch\\` parameter.`);\n            }\n            return factory.fetch(data);\n        });\n    }\n    getData() {\n        return this.messageHandler.sendWithPromise(\"GetData\", null);\n    }\n    saveDocument() {\n        if (this.annotationStorage.size <= 0) {\n            warn(\"saveDocument called while `annotationStorage` is empty, please use the getData-method instead.\");\n        }\n        const { map, transfer } = this.annotationStorage.serializable;\n        return this.messageHandler.sendWithPromise(\"SaveDocument\", {\n            isPureXfa: !!this._htmlForXfa,\n            numPages: this._numPages,\n            annotationStorage: map,\n            filename: this._fullReader?.filename ?? null\n        }, transfer).finally(()=>{\n            this.annotationStorage.resetModified();\n        });\n    }\n    getPage(pageNumber) {\n        if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {\n            return Promise.reject(new Error(\"Invalid page request.\"));\n        }\n        const pageIndex = pageNumber - 1, cachedPromise = this.#pagePromises.get(pageIndex);\n        if (cachedPromise) {\n            return cachedPromise;\n        }\n        const promise = this.messageHandler.sendWithPromise(\"GetPage\", {\n            pageIndex\n        }).then((pageInfo)=>{\n            if (this.destroyed) {\n                throw new Error(\"Transport destroyed\");\n            }\n            if (pageInfo.refStr) {\n                this.#pageRefCache.set(pageInfo.refStr, pageNumber);\n            }\n            const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.pdfBug);\n            this.#pageCache.set(pageIndex, page);\n            return page;\n        });\n        this.#pagePromises.set(pageIndex, promise);\n        return promise;\n    }\n    getPageIndex(ref) {\n        if (!isRefProxy(ref)) {\n            return Promise.reject(new Error(\"Invalid pageIndex request.\"));\n        }\n        return this.messageHandler.sendWithPromise(\"GetPageIndex\", {\n            num: ref.num,\n            gen: ref.gen\n        });\n    }\n    getAnnotations(pageIndex, intent) {\n        return this.messageHandler.sendWithPromise(\"GetAnnotations\", {\n            pageIndex,\n            intent\n        });\n    }\n    getFieldObjects() {\n        return this.#cacheSimpleMethod(\"GetFieldObjects\");\n    }\n    hasJSActions() {\n        return this.#cacheSimpleMethod(\"HasJSActions\");\n    }\n    getCalculationOrderIds() {\n        return this.messageHandler.sendWithPromise(\"GetCalculationOrderIds\", null);\n    }\n    getDestinations() {\n        return this.messageHandler.sendWithPromise(\"GetDestinations\", null);\n    }\n    getDestination(id) {\n        if (typeof id !== \"string\") {\n            return Promise.reject(new Error(\"Invalid destination request.\"));\n        }\n        return this.messageHandler.sendWithPromise(\"GetDestination\", {\n            id\n        });\n    }\n    getPageLabels() {\n        return this.messageHandler.sendWithPromise(\"GetPageLabels\", null);\n    }\n    getPageLayout() {\n        return this.messageHandler.sendWithPromise(\"GetPageLayout\", null);\n    }\n    getPageMode() {\n        return this.messageHandler.sendWithPromise(\"GetPageMode\", null);\n    }\n    getViewerPreferences() {\n        return this.messageHandler.sendWithPromise(\"GetViewerPreferences\", null);\n    }\n    getOpenAction() {\n        return this.messageHandler.sendWithPromise(\"GetOpenAction\", null);\n    }\n    getAttachments() {\n        return this.messageHandler.sendWithPromise(\"GetAttachments\", null);\n    }\n    getAnnotationsByType(types, pageIndexesToSkip) {\n        return this.messageHandler.sendWithPromise(\"GetAnnotationsByType\", {\n            types,\n            pageIndexesToSkip\n        });\n    }\n    getDocJSActions() {\n        return this.#cacheSimpleMethod(\"GetDocJSActions\");\n    }\n    getPageJSActions(pageIndex) {\n        return this.messageHandler.sendWithPromise(\"GetPageJSActions\", {\n            pageIndex\n        });\n    }\n    getStructTree(pageIndex) {\n        return this.messageHandler.sendWithPromise(\"GetStructTree\", {\n            pageIndex\n        });\n    }\n    getOutline() {\n        return this.messageHandler.sendWithPromise(\"GetOutline\", null);\n    }\n    getOptionalContentConfig(renderingIntent) {\n        return this.#cacheSimpleMethod(\"GetOptionalContentConfig\").then((data)=>new OptionalContentConfig(data, renderingIntent));\n    }\n    getPermissions() {\n        return this.messageHandler.sendWithPromise(\"GetPermissions\", null);\n    }\n    getMetadata() {\n        const name = \"GetMetadata\", cachedPromise = this.#methodPromises.get(name);\n        if (cachedPromise) {\n            return cachedPromise;\n        }\n        const promise = this.messageHandler.sendWithPromise(name, null).then((results)=>({\n                info: results[0],\n                metadata: results[1] ? new Metadata(results[1]) : null,\n                contentDispositionFilename: this._fullReader?.filename ?? null,\n                contentLength: this._fullReader?.contentLength ?? null\n            }));\n        this.#methodPromises.set(name, promise);\n        return promise;\n    }\n    getMarkInfo() {\n        return this.messageHandler.sendWithPromise(\"GetMarkInfo\", null);\n    }\n    async startCleanup(keepLoadedFonts = false) {\n        if (this.destroyed) {\n            return;\n        }\n        await this.messageHandler.sendWithPromise(\"Cleanup\", null);\n        for (const page of this.#pageCache.values()){\n            const cleanupSuccessful = page.cleanup();\n            if (!cleanupSuccessful) {\n                throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);\n            }\n        }\n        this.commonObjs.clear();\n        if (!keepLoadedFonts) {\n            this.fontLoader.clear();\n        }\n        this.#methodPromises.clear();\n        this.filterFactory.destroy(true);\n        TextLayer.cleanup();\n    }\n    cachedPageNumber(ref) {\n        if (!isRefProxy(ref)) {\n            return null;\n        }\n        const refStr = ref.gen === 0 ? `${ref.num}R` : `${ref.num}R${ref.gen}`;\n        return this.#pageRefCache.get(refStr) ?? null;\n    }\n}\nclass RenderTask {\n    #internalRenderTask;\n    constructor(internalRenderTask){\n        this.#internalRenderTask = null;\n        this.onContinue = null;\n        this.onError = null;\n        this.#internalRenderTask = internalRenderTask;\n    }\n    get promise() {\n        return this.#internalRenderTask.capability.promise;\n    }\n    cancel(extraDelay = 0) {\n        this.#internalRenderTask.cancel(null, extraDelay);\n    }\n    get separateAnnots() {\n        const { separateAnnots } = this.#internalRenderTask.operatorList;\n        if (!separateAnnots) {\n            return false;\n        }\n        const { annotationCanvasMap } = this.#internalRenderTask;\n        return separateAnnots.form || separateAnnots.canvas && annotationCanvasMap?.size > 0;\n    }\n}\nclass InternalRenderTask {\n    #rAF;\n    static #canvasInUse = /* @__PURE__ */ new WeakSet();\n    constructor({ callback, params, objs, commonObjs, annotationCanvasMap, operatorList, pageIndex, canvasFactory, filterFactory, useRequestAnimationFrame = false, pdfBug = false, pageColors = null, enableHWA = false, operationsFilter = null }){\n        this.#rAF = null;\n        this.callback = callback;\n        this.params = params;\n        this.objs = objs;\n        this.commonObjs = commonObjs;\n        this.annotationCanvasMap = annotationCanvasMap;\n        this.operatorListIdx = null;\n        this.operatorList = operatorList;\n        this._pageIndex = pageIndex;\n        this.canvasFactory = canvasFactory;\n        this.filterFactory = filterFactory;\n        this._pdfBug = pdfBug;\n        this.pageColors = pageColors;\n        this.running = false;\n        this.graphicsReadyCallback = null;\n        this.graphicsReady = false;\n        this._useRequestAnimationFrame = useRequestAnimationFrame === true && \"undefined\" !== \"undefined\";\n        this.cancelled = false;\n        this.capability = Promise.withResolvers();\n        this.task = new RenderTask(this);\n        this._cancelBound = this.cancel.bind(this);\n        this._continueBound = this._continue.bind(this);\n        this._scheduleNextBound = this._scheduleNext.bind(this);\n        this._nextBound = this._next.bind(this);\n        this._canvas = params.canvas;\n        this._canvasContext = params.canvas ? null : params.canvasContext;\n        this._enableHWA = enableHWA;\n        this._dependencyTracker = params.dependencyTracker;\n        this._operationsFilter = operationsFilter;\n    }\n    get completed() {\n        return this.capability.promise.catch(function() {});\n    }\n    initializeGraphics({ transparency = false, optionalContentConfig }) {\n        if (this.cancelled) {\n            return;\n        }\n        if (this._canvas) {\n            if (InternalRenderTask.#canvasInUse.has(this._canvas)) {\n                throw new Error(\"Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.\");\n            }\n            InternalRenderTask.#canvasInUse.add(this._canvas);\n        }\n        if (this._pdfBug && globalThis.StepperManager?.enabled) {\n            this.stepper = globalThis.StepperManager.create(this._pageIndex);\n            this.stepper.init(this.operatorList);\n            this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();\n        }\n        const { viewport, transform, background, dependencyTracker } = this.params;\n        const canvasContext = this._canvasContext || this._canvas.getContext(\"2d\", {\n            alpha: false,\n            willReadFrequently: !this._enableHWA\n        });\n        this.gfx = new CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {\n            optionalContentConfig\n        }, this.annotationCanvasMap, this.pageColors, dependencyTracker);\n        this.gfx.beginDrawing({\n            transform,\n            viewport,\n            transparency,\n            background\n        });\n        this.operatorListIdx = 0;\n        this.graphicsReady = true;\n        this.graphicsReadyCallback?.();\n    }\n    cancel(error = null, extraDelay = 0) {\n        this.running = false;\n        this.cancelled = true;\n        this.gfx?.endDrawing();\n        if (this.#rAF) {\n            window.cancelAnimationFrame(this.#rAF);\n            this.#rAF = null;\n        }\n        InternalRenderTask.#canvasInUse.delete(this._canvas);\n        error ||= new RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, extraDelay);\n        this.callback(error);\n        this.task.onError?.(error);\n    }\n    operatorListChanged() {\n        if (!this.graphicsReady) {\n            this.graphicsReadyCallback ||= this._continueBound;\n            return;\n        }\n        this.gfx.dependencyTracker?.growOperationsCount(this.operatorList.fnArray.length);\n        this.stepper?.updateOperatorList(this.operatorList);\n        if (this.running) {\n            return;\n        }\n        this._continue();\n    }\n    _continue() {\n        this.running = true;\n        if (this.cancelled) {\n            return;\n        }\n        if (this.task.onContinue) {\n            this.task.onContinue(this._scheduleNextBound);\n        } else {\n            this._scheduleNext();\n        }\n    }\n    _scheduleNext() {\n        if (this._useRequestAnimationFrame) {\n            this.#rAF = window.requestAnimationFrame(()=>{\n                this.#rAF = null;\n                this._nextBound().catch(this._cancelBound);\n            });\n        } else {\n            Promise.resolve().then(this._nextBound).catch(this._cancelBound);\n        }\n    }\n    async _next() {\n        if (this.cancelled) {\n            return;\n        }\n        this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper, this._operationsFilter);\n        if (this.operatorListIdx === this.operatorList.argsArray.length) {\n            this.running = false;\n            if (this.operatorList.lastChunk) {\n                this.gfx.endDrawing();\n                InternalRenderTask.#canvasInUse.delete(this._canvas);\n                this.callback();\n            }\n        }\n    }\n}\nconst version = \"5.4.296\";\nconst build = \"f56dc8601\";\nclass ColorPicker {\n    #button;\n    #buttonSwatch;\n    #defaultColor;\n    #dropdown;\n    #dropdownWasFromKeyboard;\n    #isMainColorPicker;\n    #editor;\n    #eventBus;\n    #openDropdownAC;\n    #uiManager;\n    static #l10nColor = null;\n    static get _keyboardManager() {\n        return shadow(this, \"_keyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"Escape\",\n                    \"mac+Escape\"\n                ],\n                ColorPicker.prototype._hideDropdownFromKeyboard\n            ],\n            [\n                [\n                    \" \",\n                    \"mac+ \"\n                ],\n                ColorPicker.prototype._colorSelectFromKeyboard\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"ArrowRight\",\n                    \"mac+ArrowDown\",\n                    \"mac+ArrowRight\"\n                ],\n                ColorPicker.prototype._moveToNext\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"ArrowLeft\",\n                    \"mac+ArrowUp\",\n                    \"mac+ArrowLeft\"\n                ],\n                ColorPicker.prototype._moveToPrevious\n            ],\n            [\n                [\n                    \"Home\",\n                    \"mac+Home\"\n                ],\n                ColorPicker.prototype._moveToBeginning\n            ],\n            [\n                [\n                    \"End\",\n                    \"mac+End\"\n                ],\n                ColorPicker.prototype._moveToEnd\n            ]\n        ]));\n    }\n    constructor({ editor = null, uiManager = null }){\n        this.#button = null;\n        this.#buttonSwatch = null;\n        this.#dropdown = null;\n        this.#dropdownWasFromKeyboard = false;\n        this.#isMainColorPicker = false;\n        this.#editor = null;\n        this.#openDropdownAC = null;\n        this.#uiManager = null;\n        if (editor) {\n            this.#isMainColorPicker = false;\n            this.#editor = editor;\n        } else {\n            this.#isMainColorPicker = true;\n        }\n        this.#uiManager = editor?._uiManager || uiManager;\n        this.#eventBus = this.#uiManager._eventBus;\n        this.#defaultColor = editor?.color?.toUpperCase() || this.#uiManager?.highlightColors.values().next().value || \"#FFFF98\";\n        ColorPicker.#l10nColor ||= Object.freeze({\n            blue: \"pdfjs-editor-colorpicker-blue\",\n            green: \"pdfjs-editor-colorpicker-green\",\n            pink: \"pdfjs-editor-colorpicker-pink\",\n            red: \"pdfjs-editor-colorpicker-red\",\n            yellow: \"pdfjs-editor-colorpicker-yellow\"\n        });\n    }\n    renderButton() {\n        const button = this.#button = document.createElement(\"button\");\n        button.className = \"colorPicker\";\n        button.tabIndex = \"0\";\n        button.setAttribute(\"data-l10n-id\", \"pdfjs-editor-colorpicker-button\");\n        button.ariaHasPopup = \"true\";\n        if (this.#editor) {\n            button.ariaControls = `${this.#editor.id}_colorpicker_dropdown`;\n        }\n        const signal = this.#uiManager._signal;\n        button.addEventListener(\"click\", this.#openDropdown.bind(this), {\n            signal\n        });\n        button.addEventListener(\"keydown\", this.#keyDown.bind(this), {\n            signal\n        });\n        const swatch = this.#buttonSwatch = document.createElement(\"span\");\n        swatch.className = \"swatch\";\n        swatch.ariaHidden = \"true\";\n        swatch.style.backgroundColor = this.#defaultColor;\n        button.append(swatch);\n        return button;\n    }\n    renderMainDropdown() {\n        const dropdown = this.#dropdown = this.#getDropdownRoot();\n        dropdown.ariaOrientation = \"horizontal\";\n        dropdown.ariaLabelledBy = \"highlightColorPickerLabel\";\n        return dropdown;\n    }\n    #getDropdownRoot() {\n        const div = document.createElement(\"div\");\n        const signal = this.#uiManager._signal;\n        div.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        div.className = \"dropdown\";\n        div.role = \"listbox\";\n        div.ariaMultiSelectable = \"false\";\n        div.ariaOrientation = \"vertical\";\n        div.setAttribute(\"data-l10n-id\", \"pdfjs-editor-colorpicker-dropdown\");\n        if (this.#editor) {\n            div.id = `${this.#editor.id}_colorpicker_dropdown`;\n        }\n        for (const [name, color] of this.#uiManager.highlightColors){\n            const button = document.createElement(\"button\");\n            button.tabIndex = \"0\";\n            button.role = \"option\";\n            button.setAttribute(\"data-color\", color);\n            button.title = name;\n            button.setAttribute(\"data-l10n-id\", ColorPicker.#l10nColor[name]);\n            const swatch = document.createElement(\"span\");\n            button.append(swatch);\n            swatch.className = \"swatch\";\n            swatch.style.backgroundColor = color;\n            button.ariaSelected = color === this.#defaultColor;\n            button.addEventListener(\"click\", this.#colorSelect.bind(this, color), {\n                signal\n            });\n            div.append(button);\n        }\n        div.addEventListener(\"keydown\", this.#keyDown.bind(this), {\n            signal\n        });\n        return div;\n    }\n    #colorSelect(color, event) {\n        event.stopPropagation();\n        this.#eventBus.dispatch(\"switchannotationeditorparams\", {\n            source: this,\n            type: AnnotationEditorParamsType.HIGHLIGHT_COLOR,\n            value: color\n        });\n        this.updateColor(color);\n    }\n    _colorSelectFromKeyboard(event) {\n        if (event.target === this.#button) {\n            this.#openDropdown(event);\n            return;\n        }\n        const color = event.target.getAttribute(\"data-color\");\n        if (!color) {\n            return;\n        }\n        this.#colorSelect(color, event);\n    }\n    _moveToNext(event) {\n        if (!this.#isDropdownVisible) {\n            this.#openDropdown(event);\n            return;\n        }\n        if (event.target === this.#button) {\n            this.#dropdown.firstChild?.focus();\n            return;\n        }\n        event.target.nextSibling?.focus();\n    }\n    _moveToPrevious(event) {\n        if (event.target === this.#dropdown?.firstChild || event.target === this.#button) {\n            if (this.#isDropdownVisible) {\n                this._hideDropdownFromKeyboard();\n            }\n            return;\n        }\n        if (!this.#isDropdownVisible) {\n            this.#openDropdown(event);\n        }\n        event.target.previousSibling?.focus();\n    }\n    _moveToBeginning(event) {\n        if (!this.#isDropdownVisible) {\n            this.#openDropdown(event);\n            return;\n        }\n        this.#dropdown.firstChild?.focus();\n    }\n    _moveToEnd(event) {\n        if (!this.#isDropdownVisible) {\n            this.#openDropdown(event);\n            return;\n        }\n        this.#dropdown.lastChild?.focus();\n    }\n    #keyDown(event) {\n        ColorPicker._keyboardManager.exec(this, event);\n    }\n    #openDropdown(event) {\n        if (this.#isDropdownVisible) {\n            this.hideDropdown();\n            return;\n        }\n        this.#dropdownWasFromKeyboard = event.detail === 0;\n        if (!this.#openDropdownAC) {\n            this.#openDropdownAC = new AbortController();\n            window.addEventListener(\"pointerdown\", this.#pointerDown.bind(this), {\n                signal: this.#uiManager.combinedSignal(this.#openDropdownAC)\n            });\n        }\n        this.#button.ariaExpanded = \"true\";\n        if (this.#dropdown) {\n            this.#dropdown.classList.remove(\"hidden\");\n            return;\n        }\n        const root = this.#dropdown = this.#getDropdownRoot();\n        this.#button.append(root);\n    }\n    #pointerDown(event) {\n        if (this.#dropdown?.contains(event.target)) {\n            return;\n        }\n        this.hideDropdown();\n    }\n    hideDropdown() {\n        this.#dropdown?.classList.add(\"hidden\");\n        this.#button.ariaExpanded = \"false\";\n        this.#openDropdownAC?.abort();\n        this.#openDropdownAC = null;\n    }\n    get #isDropdownVisible() {\n        return this.#dropdown && !this.#dropdown.classList.contains(\"hidden\");\n    }\n    _hideDropdownFromKeyboard() {\n        if (this.#isMainColorPicker) {\n            return;\n        }\n        if (!this.#isDropdownVisible) {\n            this.#editor?.unselect();\n            return;\n        }\n        this.hideDropdown();\n        this.#button.focus({\n            preventScroll: true,\n            focusVisible: this.#dropdownWasFromKeyboard\n        });\n    }\n    updateColor(color) {\n        if (this.#buttonSwatch) {\n            this.#buttonSwatch.style.backgroundColor = color;\n        }\n        if (!this.#dropdown) {\n            return;\n        }\n        const i = this.#uiManager.highlightColors.values();\n        for (const child of this.#dropdown.children){\n            child.ariaSelected = i.next().value === color.toUpperCase();\n        }\n    }\n    destroy() {\n        this.#button?.remove();\n        this.#button = null;\n        this.#buttonSwatch = null;\n        this.#dropdown?.remove();\n        this.#dropdown = null;\n    }\n}\nclass BasicColorPicker {\n    #input;\n    #editor;\n    #uiManager;\n    static #l10nColor = null;\n    constructor(editor){\n        this.#input = null;\n        this.#editor = null;\n        this.#uiManager = null;\n        this.#editor = editor;\n        this.#uiManager = editor._uiManager;\n        BasicColorPicker.#l10nColor ||= Object.freeze({\n            freetext: \"pdfjs-editor-color-picker-free-text-input\",\n            ink: \"pdfjs-editor-color-picker-ink-input\"\n        });\n    }\n    renderButton() {\n        if (this.#input) {\n            return this.#input;\n        }\n        const { editorType, colorType, colorValue } = this.#editor;\n        const input = this.#input = document.createElement(\"input\");\n        input.type = \"color\";\n        input.value = colorValue || \"#000000\";\n        input.className = \"basicColorPicker\";\n        input.tabIndex = 0;\n        input.setAttribute(\"data-l10n-id\", BasicColorPicker.#l10nColor[editorType]);\n        input.addEventListener(\"input\", ()=>{\n            this.#uiManager.updateParams(colorType, input.value);\n        }, {\n            signal: this.#uiManager._signal\n        });\n        return input;\n    }\n    update(value1) {\n        if (!this.#input) {\n            return;\n        }\n        this.#input.value = value1;\n    }\n    destroy() {\n        this.#input?.remove();\n        this.#input = null;\n    }\n    hideDropdown() {}\n}\n__nested_webpack_require_192967__(116);\n__nested_webpack_require_192967__(531);\nfunction makeColorComp(n) {\n    return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, \"0\");\n}\nfunction scaleAndClamp(x) {\n    return Math.max(0, Math.min(255, 255 * x));\n}\nclass ColorConverters {\n    static CMYK_G([c, y, m, k]) {\n        return [\n            \"G\",\n            1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)\n        ];\n    }\n    static G_CMYK([g]) {\n        return [\n            \"CMYK\",\n            0,\n            0,\n            0,\n            1 - g\n        ];\n    }\n    static G_RGB([g]) {\n        return [\n            \"RGB\",\n            g,\n            g,\n            g\n        ];\n    }\n    static G_rgb([g]) {\n        g = scaleAndClamp(g);\n        return [\n            g,\n            g,\n            g\n        ];\n    }\n    static G_HTML([g]) {\n        const G = makeColorComp(g);\n        return `#${G}${G}${G}`;\n    }\n    static RGB_G([r, g, b]) {\n        return [\n            \"G\",\n            0.3 * r + 0.59 * g + 0.11 * b\n        ];\n    }\n    static RGB_rgb(color) {\n        return color.map(scaleAndClamp);\n    }\n    static RGB_HTML(color) {\n        return `#${color.map(makeColorComp).join(\"\")}`;\n    }\n    static T_HTML() {\n        return \"#00000000\";\n    }\n    static T_rgb() {\n        return [\n            null\n        ];\n    }\n    static CMYK_RGB([c, y, m, k]) {\n        return [\n            \"RGB\",\n            1 - Math.min(1, c + k),\n            1 - Math.min(1, m + k),\n            1 - Math.min(1, y + k)\n        ];\n    }\n    static CMYK_rgb([c, y, m, k]) {\n        return [\n            scaleAndClamp(1 - Math.min(1, c + k)),\n            scaleAndClamp(1 - Math.min(1, m + k)),\n            scaleAndClamp(1 - Math.min(1, y + k))\n        ];\n    }\n    static CMYK_HTML(components) {\n        const rgb = this.CMYK_RGB(components).slice(1);\n        return this.RGB_HTML(rgb);\n    }\n    static RGB_CMYK([r, g, b]) {\n        const c = 1 - r;\n        const m = 1 - g;\n        const y = 1 - b;\n        const k = Math.min(c, m, y);\n        return [\n            \"CMYK\",\n            c,\n            m,\n            y,\n            k\n        ];\n    }\n}\nclass BaseSVGFactory {\n    create(width, height, skipDimensions = false) {\n        if (width <= 0 || height <= 0) {\n            throw new Error(\"Invalid SVG dimensions\");\n        }\n        const svg = this._createSVG(\"svg:svg\");\n        svg.setAttribute(\"version\", \"1.1\");\n        if (!skipDimensions) {\n            svg.setAttribute(\"width\", `${width}px`);\n            svg.setAttribute(\"height\", `${height}px`);\n        }\n        svg.setAttribute(\"preserveAspectRatio\", \"none\");\n        svg.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n        return svg;\n    }\n    createElement(type) {\n        if (typeof type !== \"string\") {\n            throw new Error(\"Invalid SVG element type\");\n        }\n        return this._createSVG(type);\n    }\n    _createSVG(type) {\n        unreachable(\"Abstract method `_createSVG` called.\");\n    }\n}\nclass DOMSVGFactory extends BaseSVGFactory {\n    _createSVG(type) {\n        return document.createElementNS(SVG_NS, type);\n    }\n}\nconst annotation_layer_DEFAULT_FONT_SIZE = 9;\nconst GetElementsByNameSet = /* @__PURE__ */ new WeakSet();\nconst TIMEZONE_OFFSET = /* @__PURE__ */ new Date().getTimezoneOffset() * 60 * 1e3;\nclass AnnotationElementFactory {\n    static create(parameters) {\n        const subtype = parameters.data.annotationType;\n        switch(subtype){\n            case AnnotationType.LINK:\n                return new LinkAnnotationElement(parameters);\n            case AnnotationType.TEXT:\n                return new TextAnnotationElement(parameters);\n            case AnnotationType.WIDGET:\n                const fieldType = parameters.data.fieldType;\n                switch(fieldType){\n                    case \"Tx\":\n                        return new TextWidgetAnnotationElement(parameters);\n                    case \"Btn\":\n                        if (parameters.data.radioButton) {\n                            return new RadioButtonWidgetAnnotationElement(parameters);\n                        } else if (parameters.data.checkBox) {\n                            return new CheckboxWidgetAnnotationElement(parameters);\n                        }\n                        return new PushButtonWidgetAnnotationElement(parameters);\n                    case \"Ch\":\n                        return new ChoiceWidgetAnnotationElement(parameters);\n                    case \"Sig\":\n                        return new SignatureWidgetAnnotationElement(parameters);\n                }\n                return new WidgetAnnotationElement(parameters);\n            case AnnotationType.POPUP:\n                return new PopupAnnotationElement(parameters);\n            case AnnotationType.FREETEXT:\n                return new FreeTextAnnotationElement(parameters);\n            case AnnotationType.LINE:\n                return new LineAnnotationElement(parameters);\n            case AnnotationType.SQUARE:\n                return new SquareAnnotationElement(parameters);\n            case AnnotationType.CIRCLE:\n                return new CircleAnnotationElement(parameters);\n            case AnnotationType.POLYLINE:\n                return new PolylineAnnotationElement(parameters);\n            case AnnotationType.CARET:\n                return new CaretAnnotationElement(parameters);\n            case AnnotationType.INK:\n                return new InkAnnotationElement(parameters);\n            case AnnotationType.POLYGON:\n                return new PolygonAnnotationElement(parameters);\n            case AnnotationType.HIGHLIGHT:\n                return new HighlightAnnotationElement(parameters);\n            case AnnotationType.UNDERLINE:\n                return new UnderlineAnnotationElement(parameters);\n            case AnnotationType.SQUIGGLY:\n                return new SquigglyAnnotationElement(parameters);\n            case AnnotationType.STRIKEOUT:\n                return new StrikeOutAnnotationElement(parameters);\n            case AnnotationType.STAMP:\n                return new StampAnnotationElement(parameters);\n            case AnnotationType.FILEATTACHMENT:\n                return new FileAttachmentAnnotationElement(parameters);\n            default:\n                return new AnnotationElement(parameters);\n        }\n    }\n}\nclass AnnotationElement {\n    #updates;\n    #hasBorder;\n    #popupElement;\n    constructor(parameters, { isRenderable = false, ignoreBorder = false, createQuadrilaterals = false } = {}){\n        this.#updates = null;\n        this.#hasBorder = false;\n        this.#popupElement = null;\n        this.isRenderable = isRenderable;\n        this.data = parameters.data;\n        this.layer = parameters.layer;\n        this.linkService = parameters.linkService;\n        this.downloadManager = parameters.downloadManager;\n        this.imageResourcesPath = parameters.imageResourcesPath;\n        this.renderForms = parameters.renderForms;\n        this.svgFactory = parameters.svgFactory;\n        this.annotationStorage = parameters.annotationStorage;\n        this.enableComment = parameters.enableComment;\n        this.enableScripting = parameters.enableScripting;\n        this.hasJSActions = parameters.hasJSActions;\n        this._fieldObjects = parameters.fieldObjects;\n        this.parent = parameters.parent;\n        if (isRenderable) {\n            this.container = this._createContainer(ignoreBorder);\n        }\n        if (createQuadrilaterals) {\n            this._createQuadrilaterals();\n        }\n    }\n    static _hasPopupData({ contentsObj, richText }) {\n        return !!(contentsObj?.str || richText?.str);\n    }\n    get _isEditable() {\n        return this.data.isEditable;\n    }\n    get hasPopupData() {\n        return AnnotationElement._hasPopupData(this.data) || this.enableComment && !!this.commentText;\n    }\n    get commentData() {\n        const { data } = this;\n        const editor = this.annotationStorage?.getEditor(data.id);\n        if (editor) {\n            return editor.getData();\n        }\n        return data;\n    }\n    get hasCommentButton() {\n        return this.enableComment && this.hasPopupElement;\n    }\n    get commentButtonPosition() {\n        const editor = this.annotationStorage?.getEditor(this.data.id);\n        if (editor) {\n            return editor.commentButtonPositionInPage;\n        }\n        const { quadPoints, inkLists, rect } = this.data;\n        let maxX = -Infinity;\n        let maxY = -Infinity;\n        if (quadPoints?.length >= 8) {\n            for(let i = 0; i < quadPoints.length; i += 8){\n                if (quadPoints[i + 1] > maxY) {\n                    maxY = quadPoints[i + 1];\n                    maxX = quadPoints[i + 2];\n                } else if (quadPoints[i + 1] === maxY) {\n                    maxX = Math.max(maxX, quadPoints[i + 2]);\n                }\n            }\n            return [\n                maxX,\n                maxY\n            ];\n        }\n        if (inkLists?.length >= 1) {\n            for (const inkList of inkLists){\n                for(let i = 0, ii = inkList.length; i < ii; i += 2){\n                    if (inkList[i + 1] > maxY) {\n                        maxY = inkList[i + 1];\n                        maxX = inkList[i];\n                    } else if (inkList[i + 1] === maxY) {\n                        maxX = Math.max(maxX, inkList[i]);\n                    }\n                }\n            }\n            if (maxX !== Infinity) {\n                return [\n                    maxX,\n                    maxY\n                ];\n            }\n        }\n        if (rect) {\n            return [\n                rect[2],\n                rect[3]\n            ];\n        }\n        return null;\n    }\n    _normalizePoint(point) {\n        const { page: { view }, viewport: { rawDims: { pageWidth, pageHeight, pageX, pageY } } } = this.parent;\n        point[1] = view[3] - point[1] + view[1];\n        point[0] = 100 * (point[0] - pageX) / pageWidth;\n        point[1] = 100 * (point[1] - pageY) / pageHeight;\n        return point;\n    }\n    get commentText() {\n        const { data } = this;\n        return this.annotationStorage.getRawValue(`${AnnotationEditorPrefix}${data.id}`)?.popup?.contents || data.contentsObj?.str || \"\";\n    }\n    set commentText(text) {\n        const { data } = this;\n        const popup = {\n            deleted: !text,\n            contents: text || \"\"\n        };\n        if (!this.annotationStorage.updateEditor(data.id, {\n            popup\n        })) {\n            this.annotationStorage.setValue(`${AnnotationEditorPrefix}${data.id}`, {\n                id: data.id,\n                annotationType: data.annotationType,\n                pageIndex: this.parent.page._pageIndex,\n                popup,\n                popupRef: data.popupRef,\n                modificationDate: /* @__PURE__ */ new Date()\n            });\n        }\n        if (!text) {\n            this.removePopup();\n        }\n    }\n    removePopup() {\n        (this.#popupElement?.popup || this.popup)?.remove();\n        this.#popupElement = this.popup = null;\n    }\n    updateEdited(params) {\n        if (!this.container) {\n            return;\n        }\n        if (params.rect) {\n            this.#updates ||= {\n                rect: this.data.rect.slice(0)\n            };\n        }\n        const { rect, popup: newPopup } = params;\n        if (rect) {\n            this.#setRectEdited(rect);\n        }\n        let popup = this.#popupElement?.popup || this.popup;\n        if (!popup && newPopup?.text) {\n            this._createPopup(newPopup);\n            popup = this.#popupElement.popup;\n        }\n        if (!popup) {\n            return;\n        }\n        popup.updateEdited(params);\n        if (newPopup?.deleted) {\n            popup.remove();\n            this.#popupElement = null;\n            this.popup = null;\n        }\n    }\n    resetEdited() {\n        if (!this.#updates) {\n            return;\n        }\n        this.#setRectEdited(this.#updates.rect);\n        this.#popupElement?.popup.resetEdited();\n        this.#updates = null;\n    }\n    #setRectEdited(rect) {\n        const { container: { style }, data: { rect: currentRect, rotation }, parent: { viewport: { rawDims: { pageWidth, pageHeight, pageX, pageY } } } } = this;\n        currentRect?.splice(0, 4, ...rect);\n        style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;\n        style.top = `${100 * (pageHeight - rect[3] + pageY) / pageHeight}%`;\n        if (rotation === 0) {\n            style.width = `${100 * (rect[2] - rect[0]) / pageWidth}%`;\n            style.height = `${100 * (rect[3] - rect[1]) / pageHeight}%`;\n        } else {\n            this.setRotation(rotation);\n        }\n    }\n    _createContainer(ignoreBorder) {\n        const { data, parent: { page, viewport } } = this;\n        const container = document.createElement(\"section\");\n        container.setAttribute(\"data-annotation-id\", data.id);\n        if (!(this instanceof WidgetAnnotationElement) && !(this instanceof LinkAnnotationElement)) {\n            container.tabIndex = 0;\n        }\n        const { style } = container;\n        style.zIndex = this.parent.zIndex;\n        this.parent.zIndex += 2;\n        if (data.alternativeText) {\n            container.title = data.alternativeText;\n        }\n        if (data.noRotate) {\n            container.classList.add(\"norotate\");\n        }\n        if (!data.rect || this instanceof PopupAnnotationElement) {\n            const { rotation: rotation2 } = data;\n            if (!data.hasOwnCanvas && rotation2 !== 0) {\n                this.setRotation(rotation2, container);\n            }\n            return container;\n        }\n        const { width, height } = this;\n        if (!ignoreBorder && data.borderStyle.width > 0) {\n            style.borderWidth = `${data.borderStyle.width}px`;\n            const horizontalRadius = data.borderStyle.horizontalCornerRadius;\n            const verticalRadius = data.borderStyle.verticalCornerRadius;\n            if (horizontalRadius > 0 || verticalRadius > 0) {\n                const radius = `calc(${horizontalRadius}px * var(--total-scale-factor)) / calc(${verticalRadius}px * var(--total-scale-factor))`;\n                style.borderRadius = radius;\n            } else if (this instanceof RadioButtonWidgetAnnotationElement) {\n                const radius = `calc(${width}px * var(--total-scale-factor)) / calc(${height}px * var(--total-scale-factor))`;\n                style.borderRadius = radius;\n            }\n            switch(data.borderStyle.style){\n                case AnnotationBorderStyleType.SOLID:\n                    style.borderStyle = \"solid\";\n                    break;\n                case AnnotationBorderStyleType.DASHED:\n                    style.borderStyle = \"dashed\";\n                    break;\n                case AnnotationBorderStyleType.BEVELED:\n                    warn(\"Unimplemented border style: beveled\");\n                    break;\n                case AnnotationBorderStyleType.INSET:\n                    warn(\"Unimplemented border style: inset\");\n                    break;\n                case AnnotationBorderStyleType.UNDERLINE:\n                    style.borderBottomStyle = \"solid\";\n                    break;\n            }\n            const borderColor = data.borderColor || null;\n            if (borderColor) {\n                this.#hasBorder = true;\n                style.borderColor = Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0);\n            } else {\n                style.borderWidth = 0;\n            }\n        }\n        const rect = Util.normalizeRect([\n            data.rect[0],\n            page.view[3] - data.rect[1] + page.view[1],\n            data.rect[2],\n            page.view[3] - data.rect[3] + page.view[1]\n        ]);\n        const { pageWidth, pageHeight, pageX, pageY } = viewport.rawDims;\n        style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;\n        style.top = `${100 * (rect[1] - pageY) / pageHeight}%`;\n        const { rotation } = data;\n        if (data.hasOwnCanvas || rotation === 0) {\n            style.width = `${100 * width / pageWidth}%`;\n            style.height = `${100 * height / pageHeight}%`;\n        } else {\n            this.setRotation(rotation, container);\n        }\n        return container;\n    }\n    setRotation(angle, container = this.container) {\n        if (!this.data.rect) {\n            return;\n        }\n        const { pageWidth, pageHeight } = this.parent.viewport.rawDims;\n        let { width, height } = this;\n        if (angle % 180 !== 0) {\n            [width, height] = [\n                height,\n                width\n            ];\n        }\n        container.style.width = `${100 * width / pageWidth}%`;\n        container.style.height = `${100 * height / pageHeight}%`;\n        container.setAttribute(\"data-main-rotation\", (360 - angle) % 360);\n    }\n    get _commonActions() {\n        const setColor = (jsName, styleName, event)=>{\n            const color = event.detail[jsName];\n            const colorType = color[0];\n            const colorArray = color.slice(1);\n            event.target.style[styleName] = ColorConverters[`${colorType}_HTML`](colorArray);\n            this.annotationStorage.setValue(this.data.id, {\n                [styleName]: ColorConverters[`${colorType}_rgb`](colorArray)\n            });\n        };\n        return shadow(this, \"_commonActions\", {\n            display: (event)=>{\n                const { display } = event.detail;\n                const hidden = display % 2 === 1;\n                this.container.style.visibility = hidden ? \"hidden\" : \"visible\";\n                this.annotationStorage.setValue(this.data.id, {\n                    noView: hidden,\n                    noPrint: display === 1 || display === 2\n                });\n            },\n            print: (event)=>{\n                this.annotationStorage.setValue(this.data.id, {\n                    noPrint: !event.detail.print\n                });\n            },\n            hidden: (event)=>{\n                const { hidden } = event.detail;\n                this.container.style.visibility = hidden ? \"hidden\" : \"visible\";\n                this.annotationStorage.setValue(this.data.id, {\n                    noPrint: hidden,\n                    noView: hidden\n                });\n            },\n            focus: (event)=>{\n                setTimeout(()=>event.target.focus({\n                        preventScroll: false\n                    }), 0);\n            },\n            userName: (event)=>{\n                event.target.title = event.detail.userName;\n            },\n            readonly: (event)=>{\n                event.target.disabled = event.detail.readonly;\n            },\n            required: (event)=>{\n                this._setRequired(event.target, event.detail.required);\n            },\n            bgColor: (event)=>{\n                setColor(\"bgColor\", \"backgroundColor\", event);\n            },\n            fillColor: (event)=>{\n                setColor(\"fillColor\", \"backgroundColor\", event);\n            },\n            fgColor: (event)=>{\n                setColor(\"fgColor\", \"color\", event);\n            },\n            textColor: (event)=>{\n                setColor(\"textColor\", \"color\", event);\n            },\n            borderColor: (event)=>{\n                setColor(\"borderColor\", \"borderColor\", event);\n            },\n            strokeColor: (event)=>{\n                setColor(\"strokeColor\", \"borderColor\", event);\n            },\n            rotation: (event)=>{\n                const angle = event.detail.rotation;\n                this.setRotation(angle);\n                this.annotationStorage.setValue(this.data.id, {\n                    rotation: angle\n                });\n            }\n        });\n    }\n    _dispatchEventFromSandbox(actions, jsEvent) {\n        const commonActions = this._commonActions;\n        for (const name of Object.keys(jsEvent.detail)){\n            const action = actions[name] || commonActions[name];\n            action?.(jsEvent);\n        }\n    }\n    _setDefaultPropertiesFromJS(element) {\n        if (!this.enableScripting) {\n            return;\n        }\n        const storedData = this.annotationStorage.getRawValue(this.data.id);\n        if (!storedData) {\n            return;\n        }\n        const commonActions = this._commonActions;\n        for (const [actionName, detail] of Object.entries(storedData)){\n            const action = commonActions[actionName];\n            if (action) {\n                const eventProxy = {\n                    detail: {\n                        [actionName]: detail\n                    },\n                    target: element\n                };\n                action(eventProxy);\n                delete storedData[actionName];\n            }\n        }\n    }\n    _createQuadrilaterals() {\n        if (!this.container) {\n            return;\n        }\n        const { quadPoints } = this.data;\n        if (!quadPoints) {\n            return;\n        }\n        const [rectBlX, rectBlY, rectTrX, rectTrY] = this.data.rect.map((x)=>Math.fround(x));\n        if (quadPoints.length === 8) {\n            const [trX, trY, blX, blY] = quadPoints.subarray(2, 6);\n            if (rectTrX === trX && rectTrY === trY && rectBlX === blX && rectBlY === blY) {\n                return;\n            }\n        }\n        const { style } = this.container;\n        let svgBuffer;\n        if (this.#hasBorder) {\n            const { borderColor, borderWidth } = style;\n            style.borderWidth = 0;\n            svgBuffer = [\n                \"url('data:image/svg+xml;utf8,\",\n                `<svg xmlns=\"http://www.w3.org/2000/svg\"`,\n                ` preserveAspectRatio=\"none\" viewBox=\"0 0 1 1\">`,\n                `<g fill=\"transparent\" stroke=\"${borderColor}\" stroke-width=\"${borderWidth}\">`\n            ];\n            this.container.classList.add(\"hasBorder\");\n        }\n        const width = rectTrX - rectBlX;\n        const height = rectTrY - rectBlY;\n        const { svgFactory } = this;\n        const svg = svgFactory.createElement(\"svg\");\n        svg.classList.add(\"quadrilateralsContainer\");\n        svg.setAttribute(\"width\", 0);\n        svg.setAttribute(\"height\", 0);\n        svg.role = \"none\";\n        const defs = svgFactory.createElement(\"defs\");\n        svg.append(defs);\n        const clipPath = svgFactory.createElement(\"clipPath\");\n        const id = `clippath_${this.data.id}`;\n        clipPath.setAttribute(\"id\", id);\n        clipPath.setAttribute(\"clipPathUnits\", \"objectBoundingBox\");\n        defs.append(clipPath);\n        for(let i = 2, ii = quadPoints.length; i < ii; i += 8){\n            const trX = quadPoints[i];\n            const trY = quadPoints[i + 1];\n            const blX = quadPoints[i + 2];\n            const blY = quadPoints[i + 3];\n            const rect = svgFactory.createElement(\"rect\");\n            const x = (blX - rectBlX) / width;\n            const y = (rectTrY - trY) / height;\n            const rectWidth = (trX - blX) / width;\n            const rectHeight = (trY - blY) / height;\n            rect.setAttribute(\"x\", x);\n            rect.setAttribute(\"y\", y);\n            rect.setAttribute(\"width\", rectWidth);\n            rect.setAttribute(\"height\", rectHeight);\n            clipPath.append(rect);\n            svgBuffer?.push(`<rect vector-effect=\"non-scaling-stroke\" x=\"${x}\" y=\"${y}\" width=\"${rectWidth}\" height=\"${rectHeight}\"/>`);\n        }\n        if (this.#hasBorder) {\n            svgBuffer.push(`</g></svg>')`);\n            style.backgroundImage = svgBuffer.join(\"\");\n        }\n        this.container.append(svg);\n        this.container.style.clipPath = `url(#${id})`;\n    }\n    _createPopup(popupData = null) {\n        const { data } = this;\n        let contentsObj, modificationDate;\n        if (popupData) {\n            contentsObj = {\n                str: popupData.text\n            };\n            modificationDate = popupData.date;\n        } else {\n            contentsObj = data.contentsObj;\n            modificationDate = data.modificationDate;\n        }\n        const popup = this.#popupElement = new PopupAnnotationElement({\n            data: {\n                color: data.color,\n                titleObj: data.titleObj,\n                modificationDate,\n                contentsObj,\n                richText: data.richText,\n                parentRect: data.rect,\n                borderStyle: 0,\n                id: `popup_${data.id}`,\n                rotation: data.rotation,\n                noRotate: true\n            },\n            linkService: this.linkService,\n            parent: this.parent,\n            elements: [\n                this\n            ]\n        });\n        if (!this.parent._commentManager) {\n            this.parent.div.append(popup.render());\n        }\n    }\n    get hasPopupElement() {\n        return !!(this.#popupElement || this.popup || this.data.popupRef);\n    }\n    get extraPopupElement() {\n        return this.#popupElement;\n    }\n    render() {\n        unreachable(\"Abstract method `AnnotationElement.render` called\");\n    }\n    _getElementsByName(name, skipId = null) {\n        const fields = [];\n        if (this._fieldObjects) {\n            const fieldObj = this._fieldObjects[name];\n            if (fieldObj) {\n                for (const { page, id, exportValues } of fieldObj){\n                    if (page === -1) {\n                        continue;\n                    }\n                    if (id === skipId) {\n                        continue;\n                    }\n                    const exportValue = typeof exportValues === \"string\" ? exportValues : null;\n                    const domElement = document.querySelector(`[data-element-id=\"${id}\"]`);\n                    if (domElement && !GetElementsByNameSet.has(domElement)) {\n                        warn(`_getElementsByName - element not allowed: ${id}`);\n                        continue;\n                    }\n                    fields.push({\n                        id,\n                        exportValue,\n                        domElement\n                    });\n                }\n            }\n            return fields;\n        }\n        for (const domElement of document.getElementsByName(name)){\n            const { exportValue } = domElement;\n            const id = domElement.getAttribute(\"data-element-id\");\n            if (id === skipId) {\n                continue;\n            }\n            if (!GetElementsByNameSet.has(domElement)) {\n                continue;\n            }\n            fields.push({\n                id,\n                exportValue,\n                domElement\n            });\n        }\n        return fields;\n    }\n    show() {\n        if (this.container) {\n            this.container.hidden = false;\n        }\n        this.popup?.maybeShow();\n    }\n    hide() {\n        if (this.container) {\n            this.container.hidden = true;\n        }\n        this.popup?.forceHide();\n    }\n    getElementsToTriggerPopup() {\n        return this.container;\n    }\n    addHighlightArea() {\n        const triggers = this.getElementsToTriggerPopup();\n        if (Array.isArray(triggers)) {\n            for (const element of triggers){\n                element.classList.add(\"highlightArea\");\n            }\n        } else {\n            triggers.classList.add(\"highlightArea\");\n        }\n    }\n    _editOnDoubleClick() {\n        if (!this._isEditable) {\n            return;\n        }\n        const { annotationEditorType: mode, data: { id: editId } } = this;\n        this.container.addEventListener(\"dblclick\", ()=>{\n            this.linkService.eventBus?.dispatch(\"switchannotationeditormode\", {\n                source: this,\n                mode,\n                editId,\n                mustEnterInEditMode: true\n            });\n        });\n    }\n    get width() {\n        return this.data.rect[2] - this.data.rect[0];\n    }\n    get height() {\n        return this.data.rect[3] - this.data.rect[1];\n    }\n}\nclass EditorAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.editor = parameters.editor;\n    }\n    render() {\n        this.container.className = \"editorAnnotation\";\n        return this.container;\n    }\n    createOrUpdatePopup() {\n        const { editor } = this;\n        if (!editor.hasComment) {\n            return;\n        }\n        this._createPopup(editor.comment);\n        this.extraPopupElement.popup.renderCommentButton();\n    }\n    get hasCommentButton() {\n        return this.enableComment && this.editor.hasComment;\n    }\n    get commentButtonPosition() {\n        return this.editor.commentButtonPositionInPage;\n    }\n    get commentText() {\n        return this.editor.comment.text;\n    }\n    set commentText(text) {\n        this.editor.comment = text;\n        if (!text) {\n            this.removePopup();\n        }\n    }\n    get commentData() {\n        return this.editor.getData();\n    }\n    remove() {\n        this.container.remove();\n        this.container = null;\n        this.removePopup();\n    }\n}\nclass LinkAnnotationElement extends AnnotationElement {\n    constructor(parameters, options = null){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: !!options?.ignoreBorder,\n            createQuadrilaterals: true\n        });\n        this.isTooltipOnly = parameters.data.isTooltipOnly;\n    }\n    render() {\n        const { data, linkService } = this;\n        const link = document.createElement(\"a\");\n        link.setAttribute(\"data-element-id\", data.id);\n        let isBound = false;\n        if (data.url) {\n            linkService.addLinkAttributes(link, data.url, data.newWindow);\n            isBound = true;\n        } else if (data.action) {\n            this._bindNamedAction(link, data.action, data.overlaidText);\n            isBound = true;\n        } else if (data.attachment) {\n            this.#bindAttachment(link, data.attachment, data.overlaidText, data.attachmentDest);\n            isBound = true;\n        } else if (data.setOCGState) {\n            this.#bindSetOCGState(link, data.setOCGState, data.overlaidText);\n            isBound = true;\n        } else if (data.dest) {\n            this._bindLink(link, data.dest, data.overlaidText);\n            isBound = true;\n        } else {\n            if (data.actions && (data.actions.Action || data.actions[\"Mouse Up\"] || data.actions[\"Mouse Down\"]) && this.enableScripting && this.hasJSActions) {\n                this._bindJSAction(link, data);\n                isBound = true;\n            }\n            if (data.resetForm) {\n                this._bindResetFormAction(link, data.resetForm);\n                isBound = true;\n            } else if (this.isTooltipOnly && !isBound) {\n                this._bindLink(link, \"\");\n                isBound = true;\n            }\n        }\n        this.container.classList.add(\"linkAnnotation\");\n        if (isBound) {\n            this.container.append(link);\n        }\n        return this.container;\n    }\n    #setInternalLink() {\n        this.container.setAttribute(\"data-internal-link\", \"\");\n    }\n    _bindLink(link, destination, overlaidText = \"\") {\n        link.href = this.linkService.getDestinationHash(destination);\n        link.onclick = ()=>{\n            if (destination) {\n                this.linkService.goToDestination(destination);\n            }\n            return false;\n        };\n        if (destination || destination === \"\") {\n            this.#setInternalLink();\n        }\n        if (overlaidText) {\n            link.title = overlaidText;\n        }\n    }\n    _bindNamedAction(link, action, overlaidText = \"\") {\n        link.href = this.linkService.getAnchorUrl(\"\");\n        link.onclick = ()=>{\n            this.linkService.executeNamedAction(action);\n            return false;\n        };\n        if (overlaidText) {\n            link.title = overlaidText;\n        }\n        this.#setInternalLink();\n    }\n    #bindAttachment(link, attachment, overlaidText = \"\", dest = null) {\n        link.href = this.linkService.getAnchorUrl(\"\");\n        if (attachment.description) {\n            link.title = attachment.description;\n        } else if (overlaidText) {\n            link.title = overlaidText;\n        }\n        link.onclick = ()=>{\n            this.downloadManager?.openOrDownloadData(attachment.content, attachment.filename, dest);\n            return false;\n        };\n        this.#setInternalLink();\n    }\n    #bindSetOCGState(link, action, overlaidText = \"\") {\n        link.href = this.linkService.getAnchorUrl(\"\");\n        link.onclick = ()=>{\n            this.linkService.executeSetOCGState(action);\n            return false;\n        };\n        if (overlaidText) {\n            link.title = overlaidText;\n        }\n        this.#setInternalLink();\n    }\n    _bindJSAction(link, data) {\n        link.href = this.linkService.getAnchorUrl(\"\");\n        const map = /* @__PURE__ */ new Map([\n            [\n                \"Action\",\n                \"onclick\"\n            ],\n            [\n                \"Mouse Up\",\n                \"onmouseup\"\n            ],\n            [\n                \"Mouse Down\",\n                \"onmousedown\"\n            ]\n        ]);\n        for (const name of Object.keys(data.actions)){\n            const jsName = map.get(name);\n            if (!jsName) {\n                continue;\n            }\n            link[jsName] = ()=>{\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id: data.id,\n                        name\n                    }\n                });\n                return false;\n            };\n        }\n        if (data.overlaidText) {\n            link.title = data.overlaidText;\n        }\n        if (!link.onclick) {\n            link.onclick = ()=>false;\n        }\n        this.#setInternalLink();\n    }\n    _bindResetFormAction(link, resetForm) {\n        const otherClickAction = link.onclick;\n        if (!otherClickAction) {\n            link.href = this.linkService.getAnchorUrl(\"\");\n        }\n        this.#setInternalLink();\n        if (!this._fieldObjects) {\n            warn(`_bindResetFormAction - \"resetForm\" action not supported, ensure that the \\`fieldObjects\\` parameter is provided.`);\n            if (!otherClickAction) {\n                link.onclick = ()=>false;\n            }\n            return;\n        }\n        link.onclick = ()=>{\n            otherClickAction?.();\n            const { fields: resetFormFields, refs: resetFormRefs, include } = resetForm;\n            const allFields = [];\n            if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {\n                const fieldIds = new Set(resetFormRefs);\n                for (const fieldName of resetFormFields){\n                    const fields = this._fieldObjects[fieldName] || [];\n                    for (const { id } of fields){\n                        fieldIds.add(id);\n                    }\n                }\n                for (const fields of Object.values(this._fieldObjects)){\n                    for (const field of fields){\n                        if (fieldIds.has(field.id) === include) {\n                            allFields.push(field);\n                        }\n                    }\n                }\n            } else {\n                for (const fields of Object.values(this._fieldObjects)){\n                    allFields.push(...fields);\n                }\n            }\n            const storage = this.annotationStorage;\n            const allIds = [];\n            for (const field of allFields){\n                const { id } = field;\n                allIds.push(id);\n                switch(field.type){\n                    case \"text\":\n                        {\n                            const value1 = field.defaultValue || \"\";\n                            storage.setValue(id, {\n                                value: value1\n                            });\n                            break;\n                        }\n                    case \"checkbox\":\n                    case \"radiobutton\":\n                        {\n                            const value1 = field.defaultValue === field.exportValues;\n                            storage.setValue(id, {\n                                value: value1\n                            });\n                            break;\n                        }\n                    case \"combobox\":\n                    case \"listbox\":\n                        {\n                            const value1 = field.defaultValue || \"\";\n                            storage.setValue(id, {\n                                value: value1\n                            });\n                            break;\n                        }\n                    default:\n                        continue;\n                }\n                const domElement = document.querySelector(`[data-element-id=\"${id}\"]`);\n                if (!domElement) {\n                    continue;\n                } else if (!GetElementsByNameSet.has(domElement)) {\n                    warn(`_bindResetFormAction - element not allowed: ${id}`);\n                    continue;\n                }\n                domElement.dispatchEvent(new Event(\"resetform\"));\n            }\n            if (this.enableScripting) {\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id: \"app\",\n                        ids: allIds,\n                        name: \"ResetForm\"\n                    }\n                });\n            }\n            return false;\n        };\n    }\n}\nclass TextAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true\n        });\n    }\n    render() {\n        this.container.classList.add(\"textAnnotation\");\n        const image = document.createElement(\"img\");\n        image.src = this.imageResourcesPath + \"annotation-\" + this.data.name.toLowerCase() + \".svg\";\n        image.setAttribute(\"data-l10n-id\", \"pdfjs-text-annotation-type\");\n        image.setAttribute(\"data-l10n-args\", JSON.stringify({\n            type: this.data.name\n        }));\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.append(image);\n        return this.container;\n    }\n}\nclass WidgetAnnotationElement extends AnnotationElement {\n    render() {\n        return this.container;\n    }\n    showElementAndHideCanvas(element) {\n        if (this.data.hasOwnCanvas) {\n            if (element.previousSibling?.nodeName === \"CANVAS\") {\n                element.previousSibling.hidden = true;\n            }\n            element.hidden = false;\n        }\n    }\n    _getKeyModifier(event) {\n        return util_FeatureTest.platform.isMac ? event.metaKey : event.ctrlKey;\n    }\n    _setEventListener(element, elementData, baseName, eventName, valueGetter) {\n        if (baseName.includes(\"mouse\")) {\n            element.addEventListener(baseName, (event)=>{\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id: this.data.id,\n                        name: eventName,\n                        value: valueGetter(event),\n                        shift: event.shiftKey,\n                        modifier: this._getKeyModifier(event)\n                    }\n                });\n            });\n        } else {\n            element.addEventListener(baseName, (event)=>{\n                if (baseName === \"blur\") {\n                    if (!elementData.focused || !event.relatedTarget) {\n                        return;\n                    }\n                    elementData.focused = false;\n                } else if (baseName === \"focus\") {\n                    if (elementData.focused) {\n                        return;\n                    }\n                    elementData.focused = true;\n                }\n                if (!valueGetter) {\n                    return;\n                }\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id: this.data.id,\n                        name: eventName,\n                        value: valueGetter(event)\n                    }\n                });\n            });\n        }\n    }\n    _setEventListeners(element, elementData, names, getter) {\n        for (const [baseName, eventName] of names){\n            if (eventName === \"Action\" || this.data.actions?.[eventName]) {\n                if (eventName === \"Focus\" || eventName === \"Blur\") {\n                    elementData ||= {\n                        focused: false\n                    };\n                }\n                this._setEventListener(element, elementData, baseName, eventName, getter);\n                if (eventName === \"Focus\" && !this.data.actions?.Blur) {\n                    this._setEventListener(element, elementData, \"blur\", \"Blur\", null);\n                } else if (eventName === \"Blur\" && !this.data.actions?.Focus) {\n                    this._setEventListener(element, elementData, \"focus\", \"Focus\", null);\n                }\n            }\n        }\n    }\n    _setBackgroundColor(element) {\n        const color = this.data.backgroundColor || null;\n        element.style.backgroundColor = color === null ? \"transparent\" : Util.makeHexColor(color[0], color[1], color[2]);\n    }\n    _setTextStyle(element) {\n        const TEXT_ALIGNMENT = [\n            \"left\",\n            \"center\",\n            \"right\"\n        ];\n        const { fontColor } = this.data.defaultAppearanceData;\n        const fontSize = this.data.defaultAppearanceData.fontSize || annotation_layer_DEFAULT_FONT_SIZE;\n        const style = element.style;\n        let computedFontSize;\n        const BORDER_SIZE = 2;\n        const roundToOneDecimal = (x)=>Math.round(10 * x) / 10;\n        if (this.data.multiLine) {\n            const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);\n            const numberOfLines = Math.round(height / (LINE_FACTOR * fontSize)) || 1;\n            const lineHeight = height / numberOfLines;\n            computedFontSize = Math.min(fontSize, roundToOneDecimal(lineHeight / LINE_FACTOR));\n        } else {\n            const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);\n            computedFontSize = Math.min(fontSize, roundToOneDecimal(height / LINE_FACTOR));\n        }\n        style.fontSize = `calc(${computedFontSize}px * var(--total-scale-factor))`;\n        style.color = Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);\n        if (this.data.textAlignment !== null) {\n            style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];\n        }\n    }\n    _setRequired(element, isRequired) {\n        if (isRequired) {\n            element.setAttribute(\"required\", true);\n        } else {\n            element.removeAttribute(\"required\");\n        }\n        element.setAttribute(\"aria-required\", isRequired);\n    }\n}\nclass TextWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        const isRenderable = parameters.renderForms || parameters.data.hasOwnCanvas || !parameters.data.hasAppearance && !!parameters.data.fieldValue;\n        super(parameters, {\n            isRenderable\n        });\n    }\n    setPropertyOnSiblings(base, key, value1, keyInStorage) {\n        const storage = this.annotationStorage;\n        for (const element of this._getElementsByName(base.name, base.id)){\n            if (element.domElement) {\n                element.domElement[key] = value1;\n            }\n            storage.setValue(element.id, {\n                [keyInStorage]: value1\n            });\n        }\n    }\n    render() {\n        const storage = this.annotationStorage;\n        const id = this.data.id;\n        this.container.classList.add(\"textWidgetAnnotation\");\n        let element = null;\n        if (this.renderForms) {\n            const storedData = storage.getValue(id, {\n                value: this.data.fieldValue\n            });\n            let textContent = storedData.value || \"\";\n            const maxLen = storage.getValue(id, {\n                charLimit: this.data.maxLen\n            }).charLimit;\n            if (maxLen && textContent.length > maxLen) {\n                textContent = textContent.slice(0, maxLen);\n            }\n            let fieldFormattedValues = storedData.formattedValue || this.data.textContent?.join(\"\\n\") || null;\n            if (fieldFormattedValues && this.data.comb) {\n                fieldFormattedValues = fieldFormattedValues.replaceAll(/\\s+/g, \"\");\n            }\n            const elementData = {\n                userValue: textContent,\n                formattedValue: fieldFormattedValues,\n                lastCommittedValue: null,\n                commitKey: 1,\n                focused: false\n            };\n            if (this.data.multiLine) {\n                element = document.createElement(\"textarea\");\n                element.textContent = fieldFormattedValues ?? textContent;\n                if (this.data.doNotScroll) {\n                    element.style.overflowY = \"hidden\";\n                }\n            } else {\n                element = document.createElement(\"input\");\n                element.type = this.data.password ? \"password\" : \"text\";\n                element.setAttribute(\"value\", fieldFormattedValues ?? textContent);\n                if (this.data.doNotScroll) {\n                    element.style.overflowX = \"hidden\";\n                }\n            }\n            if (this.data.hasOwnCanvas) {\n                element.hidden = true;\n            }\n            GetElementsByNameSet.add(element);\n            element.setAttribute(\"data-element-id\", id);\n            element.disabled = this.data.readOnly;\n            element.name = this.data.fieldName;\n            element.tabIndex = 0;\n            const { datetimeFormat, datetimeType, timeStep } = this.data;\n            const hasDateOrTime = !!datetimeType && this.enableScripting;\n            if (datetimeFormat) {\n                element.title = datetimeFormat;\n            }\n            this._setRequired(element, this.data.required);\n            if (maxLen) {\n                element.maxLength = maxLen;\n            }\n            element.addEventListener(\"input\", (event)=>{\n                storage.setValue(id, {\n                    value: event.target.value\n                });\n                this.setPropertyOnSiblings(element, \"value\", event.target.value, \"value\");\n                elementData.formattedValue = null;\n            });\n            element.addEventListener(\"resetform\", (event)=>{\n                const defaultValue = this.data.defaultFieldValue ?? \"\";\n                element.value = elementData.userValue = defaultValue;\n                elementData.formattedValue = null;\n            });\n            let blurListener = (event)=>{\n                const { formattedValue } = elementData;\n                if (formattedValue !== null && formattedValue !== void 0) {\n                    event.target.value = formattedValue;\n                }\n                event.target.scrollLeft = 0;\n            };\n            if (this.enableScripting && this.hasJSActions) {\n                element.addEventListener(\"focus\", (event)=>{\n                    if (elementData.focused) {\n                        return;\n                    }\n                    const { target } = event;\n                    if (hasDateOrTime) {\n                        target.type = datetimeType;\n                        if (timeStep) {\n                            target.step = timeStep;\n                        }\n                    }\n                    if (elementData.userValue) {\n                        const value1 = elementData.userValue;\n                        if (hasDateOrTime) {\n                            if (datetimeType === \"time\") {\n                                const date = new Date(value1);\n                                const parts = [\n                                    date.getHours(),\n                                    date.getMinutes(),\n                                    date.getSeconds()\n                                ];\n                                target.value = parts.map((v)=>v.toString().padStart(2, \"0\")).join(\":\");\n                            } else {\n                                target.value = new Date(value1 - TIMEZONE_OFFSET).toISOString().split(datetimeType === \"date\" ? \"T\" : \".\", 1)[0];\n                            }\n                        } else {\n                            target.value = value1;\n                        }\n                    }\n                    elementData.lastCommittedValue = target.value;\n                    elementData.commitKey = 1;\n                    if (!this.data.actions?.Focus) {\n                        elementData.focused = true;\n                    }\n                });\n                element.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                    this.showElementAndHideCanvas(jsEvent.target);\n                    const actions = {\n                        value (event) {\n                            elementData.userValue = event.detail.value ?? \"\";\n                            if (!hasDateOrTime) {\n                                storage.setValue(id, {\n                                    value: elementData.userValue.toString()\n                                });\n                            }\n                            event.target.value = elementData.userValue;\n                        },\n                        formattedValue (event) {\n                            const { formattedValue } = event.detail;\n                            elementData.formattedValue = formattedValue;\n                            if (formattedValue !== null && formattedValue !== void 0 && event.target !== document.activeElement) {\n                                event.target.value = formattedValue;\n                            }\n                            const data = {\n                                formattedValue\n                            };\n                            if (hasDateOrTime) {\n                                data.value = formattedValue;\n                            }\n                            storage.setValue(id, data);\n                        },\n                        selRange (event) {\n                            event.target.setSelectionRange(...event.detail.selRange);\n                        },\n                        charLimit: (event)=>{\n                            const { charLimit } = event.detail;\n                            const { target } = event;\n                            if (charLimit === 0) {\n                                target.removeAttribute(\"maxLength\");\n                                return;\n                            }\n                            target.setAttribute(\"maxLength\", charLimit);\n                            let value1 = elementData.userValue;\n                            if (!value1 || value1.length <= charLimit) {\n                                return;\n                            }\n                            value1 = value1.slice(0, charLimit);\n                            target.value = elementData.userValue = value1;\n                            storage.setValue(id, {\n                                value: value1\n                            });\n                            this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                                source: this,\n                                detail: {\n                                    id,\n                                    name: \"Keystroke\",\n                                    value: value1,\n                                    willCommit: true,\n                                    commitKey: 1,\n                                    selStart: target.selectionStart,\n                                    selEnd: target.selectionEnd\n                                }\n                            });\n                        }\n                    };\n                    this._dispatchEventFromSandbox(actions, jsEvent);\n                });\n                element.addEventListener(\"keydown\", (event)=>{\n                    elementData.commitKey = 1;\n                    let commitKey = -1;\n                    if (event.key === \"Escape\") {\n                        commitKey = 0;\n                    } else if (event.key === \"Enter\" && !this.data.multiLine) {\n                        commitKey = 2;\n                    } else if (event.key === \"Tab\") {\n                        elementData.commitKey = 3;\n                    }\n                    if (commitKey === -1) {\n                        return;\n                    }\n                    const { value: value1 } = event.target;\n                    if (elementData.lastCommittedValue === value1) {\n                        return;\n                    }\n                    elementData.lastCommittedValue = value1;\n                    elementData.userValue = value1;\n                    this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                        source: this,\n                        detail: {\n                            id,\n                            name: \"Keystroke\",\n                            value: value1,\n                            willCommit: true,\n                            commitKey,\n                            selStart: event.target.selectionStart,\n                            selEnd: event.target.selectionEnd\n                        }\n                    });\n                });\n                const _blurListener = blurListener;\n                blurListener = null;\n                element.addEventListener(\"blur\", (event)=>{\n                    if (!elementData.focused || !event.relatedTarget) {\n                        return;\n                    }\n                    if (!this.data.actions?.Blur) {\n                        elementData.focused = false;\n                    }\n                    const { target } = event;\n                    let { value: value1 } = target;\n                    if (hasDateOrTime) {\n                        if (value1 && datetimeType === \"time\") {\n                            const parts = value1.split(\":\").map((v)=>parseInt(v, 10));\n                            value1 = new Date(2e3, 0, 1, parts[0], parts[1], parts[2] || 0).valueOf();\n                            target.step = \"\";\n                        } else {\n                            if (!value1.includes(\"T\")) {\n                                value1 = `${value1}T00:00`;\n                            }\n                            value1 = new Date(value1).valueOf();\n                        }\n                        target.type = \"text\";\n                    }\n                    elementData.userValue = value1;\n                    if (elementData.lastCommittedValue !== value1) {\n                        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                            source: this,\n                            detail: {\n                                id,\n                                name: \"Keystroke\",\n                                value: value1,\n                                willCommit: true,\n                                commitKey: elementData.commitKey,\n                                selStart: event.target.selectionStart,\n                                selEnd: event.target.selectionEnd\n                            }\n                        });\n                    }\n                    _blurListener(event);\n                });\n                if (this.data.actions?.Keystroke) {\n                    element.addEventListener(\"beforeinput\", (event)=>{\n                        elementData.lastCommittedValue = null;\n                        const { data, target } = event;\n                        const { value: value1, selectionStart, selectionEnd } = target;\n                        let selStart = selectionStart, selEnd = selectionEnd;\n                        switch(event.inputType){\n                            case \"deleteWordBackward\":\n                                {\n                                    const match = value1.substring(0, selectionStart).match(/\\w*[^\\w]*$/);\n                                    if (match) {\n                                        selStart -= match[0].length;\n                                    }\n                                    break;\n                                }\n                            case \"deleteWordForward\":\n                                {\n                                    const match = value1.substring(selectionStart).match(/^[^\\w]*\\w*/);\n                                    if (match) {\n                                        selEnd += match[0].length;\n                                    }\n                                    break;\n                                }\n                            case \"deleteContentBackward\":\n                                if (selectionStart === selectionEnd) {\n                                    selStart -= 1;\n                                }\n                                break;\n                            case \"deleteContentForward\":\n                                if (selectionStart === selectionEnd) {\n                                    selEnd += 1;\n                                }\n                                break;\n                        }\n                        event.preventDefault();\n                        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                            source: this,\n                            detail: {\n                                id,\n                                name: \"Keystroke\",\n                                value: value1,\n                                change: data || \"\",\n                                willCommit: false,\n                                selStart,\n                                selEnd\n                            }\n                        });\n                    });\n                }\n                this._setEventListeners(element, elementData, [\n                    [\n                        \"focus\",\n                        \"Focus\"\n                    ],\n                    [\n                        \"blur\",\n                        \"Blur\"\n                    ],\n                    [\n                        \"mousedown\",\n                        \"Mouse Down\"\n                    ],\n                    [\n                        \"mouseenter\",\n                        \"Mouse Enter\"\n                    ],\n                    [\n                        \"mouseleave\",\n                        \"Mouse Exit\"\n                    ],\n                    [\n                        \"mouseup\",\n                        \"Mouse Up\"\n                    ]\n                ], (event)=>event.target.value);\n            }\n            if (blurListener) {\n                element.addEventListener(\"blur\", blurListener);\n            }\n            if (this.data.comb) {\n                const fieldWidth = this.data.rect[2] - this.data.rect[0];\n                const combWidth = fieldWidth / maxLen;\n                element.classList.add(\"comb\");\n                element.style.letterSpacing = `calc(${combWidth}px * var(--total-scale-factor) - 1ch)`;\n            }\n        } else {\n            element = document.createElement(\"div\");\n            element.textContent = this.data.fieldValue;\n            element.style.verticalAlign = \"middle\";\n            element.style.display = \"table-cell\";\n            if (this.data.hasOwnCanvas) {\n                element.hidden = true;\n            }\n        }\n        this._setTextStyle(element);\n        this._setBackgroundColor(element);\n        this._setDefaultPropertiesFromJS(element);\n        this.container.append(element);\n        return this.container;\n    }\n}\nclass SignatureWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: !!parameters.data.hasOwnCanvas\n        });\n    }\n}\nclass CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: parameters.renderForms\n        });\n    }\n    render() {\n        const storage = this.annotationStorage;\n        const data = this.data;\n        const id = data.id;\n        let value1 = storage.getValue(id, {\n            value: data.exportValue === data.fieldValue\n        }).value;\n        if (typeof value1 === \"string\") {\n            value1 = value1 !== \"Off\";\n            storage.setValue(id, {\n                value: value1\n            });\n        }\n        this.container.classList.add(\"buttonWidgetAnnotation\", \"checkBox\");\n        const element = document.createElement(\"input\");\n        GetElementsByNameSet.add(element);\n        element.setAttribute(\"data-element-id\", id);\n        element.disabled = data.readOnly;\n        this._setRequired(element, this.data.required);\n        element.type = \"checkbox\";\n        element.name = data.fieldName;\n        if (value1) {\n            element.setAttribute(\"checked\", true);\n        }\n        element.setAttribute(\"exportValue\", data.exportValue);\n        element.tabIndex = 0;\n        element.addEventListener(\"change\", (event)=>{\n            const { name, checked } = event.target;\n            for (const checkbox of this._getElementsByName(name, id)){\n                const curChecked = checked && checkbox.exportValue === data.exportValue;\n                if (checkbox.domElement) {\n                    checkbox.domElement.checked = curChecked;\n                }\n                storage.setValue(checkbox.id, {\n                    value: curChecked\n                });\n            }\n            storage.setValue(id, {\n                value: checked\n            });\n        });\n        element.addEventListener(\"resetform\", (event)=>{\n            const defaultValue = data.defaultFieldValue || \"Off\";\n            event.target.checked = defaultValue === data.exportValue;\n        });\n        if (this.enableScripting && this.hasJSActions) {\n            element.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                const actions = {\n                    value (event) {\n                        event.target.checked = event.detail.value !== \"Off\";\n                        storage.setValue(id, {\n                            value: event.target.checked\n                        });\n                    }\n                };\n                this._dispatchEventFromSandbox(actions, jsEvent);\n            });\n            this._setEventListeners(element, null, [\n                [\n                    \"change\",\n                    \"Validate\"\n                ],\n                [\n                    \"change\",\n                    \"Action\"\n                ],\n                [\n                    \"focus\",\n                    \"Focus\"\n                ],\n                [\n                    \"blur\",\n                    \"Blur\"\n                ],\n                [\n                    \"mousedown\",\n                    \"Mouse Down\"\n                ],\n                [\n                    \"mouseenter\",\n                    \"Mouse Enter\"\n                ],\n                [\n                    \"mouseleave\",\n                    \"Mouse Exit\"\n                ],\n                [\n                    \"mouseup\",\n                    \"Mouse Up\"\n                ]\n            ], (event)=>event.target.checked);\n        }\n        this._setBackgroundColor(element);\n        this._setDefaultPropertiesFromJS(element);\n        this.container.append(element);\n        return this.container;\n    }\n}\nclass RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: parameters.renderForms\n        });\n    }\n    render() {\n        this.container.classList.add(\"buttonWidgetAnnotation\", \"radioButton\");\n        const storage = this.annotationStorage;\n        const data = this.data;\n        const id = data.id;\n        let value1 = storage.getValue(id, {\n            value: data.fieldValue === data.buttonValue\n        }).value;\n        if (typeof value1 === \"string\") {\n            value1 = value1 !== data.buttonValue;\n            storage.setValue(id, {\n                value: value1\n            });\n        }\n        if (value1) {\n            for (const radio of this._getElementsByName(data.fieldName, id)){\n                storage.setValue(radio.id, {\n                    value: false\n                });\n            }\n        }\n        const element = document.createElement(\"input\");\n        GetElementsByNameSet.add(element);\n        element.setAttribute(\"data-element-id\", id);\n        element.disabled = data.readOnly;\n        this._setRequired(element, this.data.required);\n        element.type = \"radio\";\n        element.name = data.fieldName;\n        if (value1) {\n            element.setAttribute(\"checked\", true);\n        }\n        element.tabIndex = 0;\n        element.addEventListener(\"change\", (event)=>{\n            const { name, checked } = event.target;\n            for (const radio of this._getElementsByName(name, id)){\n                storage.setValue(radio.id, {\n                    value: false\n                });\n            }\n            storage.setValue(id, {\n                value: checked\n            });\n        });\n        element.addEventListener(\"resetform\", (event)=>{\n            const defaultValue = data.defaultFieldValue;\n            event.target.checked = defaultValue !== null && defaultValue !== void 0 && defaultValue === data.buttonValue;\n        });\n        if (this.enableScripting && this.hasJSActions) {\n            const pdfButtonValue = data.buttonValue;\n            element.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                const actions = {\n                    value: (event)=>{\n                        const checked = pdfButtonValue === event.detail.value;\n                        for (const radio of this._getElementsByName(event.target.name)){\n                            const curChecked = checked && radio.id === id;\n                            if (radio.domElement) {\n                                radio.domElement.checked = curChecked;\n                            }\n                            storage.setValue(radio.id, {\n                                value: curChecked\n                            });\n                        }\n                    }\n                };\n                this._dispatchEventFromSandbox(actions, jsEvent);\n            });\n            this._setEventListeners(element, null, [\n                [\n                    \"change\",\n                    \"Validate\"\n                ],\n                [\n                    \"change\",\n                    \"Action\"\n                ],\n                [\n                    \"focus\",\n                    \"Focus\"\n                ],\n                [\n                    \"blur\",\n                    \"Blur\"\n                ],\n                [\n                    \"mousedown\",\n                    \"Mouse Down\"\n                ],\n                [\n                    \"mouseenter\",\n                    \"Mouse Enter\"\n                ],\n                [\n                    \"mouseleave\",\n                    \"Mouse Exit\"\n                ],\n                [\n                    \"mouseup\",\n                    \"Mouse Up\"\n                ]\n            ], (event)=>event.target.checked);\n        }\n        this._setBackgroundColor(element);\n        this._setDefaultPropertiesFromJS(element);\n        this.container.append(element);\n        return this.container;\n    }\n}\nclass PushButtonWidgetAnnotationElement extends LinkAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            ignoreBorder: parameters.data.hasAppearance\n        });\n    }\n    render() {\n        const container = super.render();\n        container.classList.add(\"buttonWidgetAnnotation\", \"pushButton\");\n        const linkElement = container.lastChild;\n        if (this.enableScripting && this.hasJSActions && linkElement) {\n            this._setDefaultPropertiesFromJS(linkElement);\n            linkElement.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                this._dispatchEventFromSandbox({}, jsEvent);\n            });\n        }\n        return container;\n    }\n}\nclass ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: parameters.renderForms\n        });\n    }\n    render() {\n        this.container.classList.add(\"choiceWidgetAnnotation\");\n        const storage = this.annotationStorage;\n        const id = this.data.id;\n        const storedData = storage.getValue(id, {\n            value: this.data.fieldValue\n        });\n        const selectElement = document.createElement(\"select\");\n        GetElementsByNameSet.add(selectElement);\n        selectElement.setAttribute(\"data-element-id\", id);\n        selectElement.disabled = this.data.readOnly;\n        this._setRequired(selectElement, this.data.required);\n        selectElement.name = this.data.fieldName;\n        selectElement.tabIndex = 0;\n        let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;\n        if (!this.data.combo) {\n            selectElement.size = this.data.options.length;\n            if (this.data.multiSelect) {\n                selectElement.multiple = true;\n            }\n        }\n        selectElement.addEventListener(\"resetform\", (event)=>{\n            const defaultValue = this.data.defaultFieldValue;\n            for (const option of selectElement.options){\n                option.selected = option.value === defaultValue;\n            }\n        });\n        for (const option of this.data.options){\n            const optionElement = document.createElement(\"option\");\n            optionElement.textContent = option.displayValue;\n            optionElement.value = option.exportValue;\n            if (storedData.value.includes(option.exportValue)) {\n                optionElement.setAttribute(\"selected\", true);\n                addAnEmptyEntry = false;\n            }\n            selectElement.append(optionElement);\n        }\n        let removeEmptyEntry = null;\n        if (addAnEmptyEntry) {\n            const noneOptionElement = document.createElement(\"option\");\n            noneOptionElement.value = \" \";\n            noneOptionElement.setAttribute(\"hidden\", true);\n            noneOptionElement.setAttribute(\"selected\", true);\n            selectElement.prepend(noneOptionElement);\n            removeEmptyEntry = ()=>{\n                noneOptionElement.remove();\n                selectElement.removeEventListener(\"input\", removeEmptyEntry);\n                removeEmptyEntry = null;\n            };\n            selectElement.addEventListener(\"input\", removeEmptyEntry);\n        }\n        const getValue = (isExport)=>{\n            const name = isExport ? \"value\" : \"textContent\";\n            const { options, multiple } = selectElement;\n            if (!multiple) {\n                return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];\n            }\n            return Array.prototype.filter.call(options, (option)=>option.selected).map((option)=>option[name]);\n        };\n        let selectedValues = getValue(false);\n        const getItems = (event)=>{\n            const options = event.target.options;\n            return Array.prototype.map.call(options, (option)=>({\n                    displayValue: option.textContent,\n                    exportValue: option.value\n                }));\n        };\n        if (this.enableScripting && this.hasJSActions) {\n            selectElement.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                const actions = {\n                    value (event) {\n                        removeEmptyEntry?.();\n                        const value1 = event.detail.value;\n                        const values = new Set(Array.isArray(value1) ? value1 : [\n                            value1\n                        ]);\n                        for (const option of selectElement.options){\n                            option.selected = values.has(option.value);\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    multipleSelection (event) {\n                        selectElement.multiple = true;\n                    },\n                    remove (event) {\n                        const options = selectElement.options;\n                        const index = event.detail.remove;\n                        options[index].selected = false;\n                        selectElement.remove(index);\n                        if (options.length > 0) {\n                            const i = Array.prototype.findIndex.call(options, (option)=>option.selected);\n                            if (i === -1) {\n                                options[0].selected = true;\n                            }\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true),\n                            items: getItems(event)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    clear (event) {\n                        while(selectElement.length !== 0){\n                            selectElement.remove(0);\n                        }\n                        storage.setValue(id, {\n                            value: null,\n                            items: []\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    insert (event) {\n                        const { index, displayValue, exportValue } = event.detail.insert;\n                        const selectChild = selectElement.children[index];\n                        const optionElement = document.createElement(\"option\");\n                        optionElement.textContent = displayValue;\n                        optionElement.value = exportValue;\n                        if (selectChild) {\n                            selectChild.before(optionElement);\n                        } else {\n                            selectElement.append(optionElement);\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true),\n                            items: getItems(event)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    items (event) {\n                        const { items } = event.detail;\n                        while(selectElement.length !== 0){\n                            selectElement.remove(0);\n                        }\n                        for (const item of items){\n                            const { displayValue, exportValue } = item;\n                            const optionElement = document.createElement(\"option\");\n                            optionElement.textContent = displayValue;\n                            optionElement.value = exportValue;\n                            selectElement.append(optionElement);\n                        }\n                        if (selectElement.options.length > 0) {\n                            selectElement.options[0].selected = true;\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true),\n                            items: getItems(event)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    indices (event) {\n                        const indices = new Set(event.detail.indices);\n                        for (const option of event.target.options){\n                            option.selected = indices.has(option.index);\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    editable (event) {\n                        event.target.disabled = !event.detail.editable;\n                    }\n                };\n                this._dispatchEventFromSandbox(actions, jsEvent);\n            });\n            selectElement.addEventListener(\"input\", (event)=>{\n                const exportValue = getValue(true);\n                const change = getValue(false);\n                storage.setValue(id, {\n                    value: exportValue\n                });\n                event.preventDefault();\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id,\n                        name: \"Keystroke\",\n                        value: selectedValues,\n                        change,\n                        changeEx: exportValue,\n                        willCommit: false,\n                        commitKey: 1,\n                        keyDown: false\n                    }\n                });\n            });\n            this._setEventListeners(selectElement, null, [\n                [\n                    \"focus\",\n                    \"Focus\"\n                ],\n                [\n                    \"blur\",\n                    \"Blur\"\n                ],\n                [\n                    \"mousedown\",\n                    \"Mouse Down\"\n                ],\n                [\n                    \"mouseenter\",\n                    \"Mouse Enter\"\n                ],\n                [\n                    \"mouseleave\",\n                    \"Mouse Exit\"\n                ],\n                [\n                    \"mouseup\",\n                    \"Mouse Up\"\n                ],\n                [\n                    \"input\",\n                    \"Action\"\n                ],\n                [\n                    \"input\",\n                    \"Validate\"\n                ]\n            ], (event)=>event.target.value);\n        } else {\n            selectElement.addEventListener(\"input\", function(event) {\n                storage.setValue(id, {\n                    value: getValue(true)\n                });\n            });\n        }\n        if (this.data.combo) {\n            this._setTextStyle(selectElement);\n        }\n        this._setBackgroundColor(selectElement);\n        this._setDefaultPropertiesFromJS(selectElement);\n        this.container.append(selectElement);\n        return this.container;\n    }\n}\nclass PopupAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        const { data, elements, parent } = parameters;\n        const hasCommentManager = !!parent._commentManager;\n        super(parameters, {\n            isRenderable: !hasCommentManager && AnnotationElement._hasPopupData(data)\n        });\n        this.elements = elements;\n        if (hasCommentManager && AnnotationElement._hasPopupData(data)) {\n            const popup = this.popup = this.#createPopup();\n            for (const element of elements){\n                element.popup = popup;\n            }\n        } else {\n            this.popup = null;\n        }\n    }\n    #createPopup() {\n        return new PopupElement({\n            container: this.container,\n            color: this.data.color,\n            titleObj: this.data.titleObj,\n            modificationDate: this.data.modificationDate || this.data.creationDate,\n            contentsObj: this.data.contentsObj,\n            richText: this.data.richText,\n            rect: this.data.rect,\n            parentRect: this.data.parentRect || null,\n            parent: this.parent,\n            elements: this.elements,\n            open: this.data.open,\n            commentManager: this.parent._commentManager\n        });\n    }\n    render() {\n        const { container } = this;\n        container.classList.add(\"popupAnnotation\");\n        container.role = \"comment\";\n        const popup = this.popup = this.#createPopup();\n        const elementIds = [];\n        for (const element of this.elements){\n            element.popup = popup;\n            element.container.ariaHasPopup = \"dialog\";\n            elementIds.push(element.data.id);\n            element.addHighlightArea();\n        }\n        this.container.setAttribute(\"aria-controls\", elementIds.map((id)=>`${AnnotationPrefix}${id}`).join(\",\"));\n        return this.container;\n    }\n}\nclass PopupElement {\n    #commentManager;\n    #boundKeyDown;\n    #boundHide;\n    #boundShow;\n    #boundToggle;\n    #color;\n    #container;\n    #contentsObj;\n    #dateObj;\n    #elements;\n    #parent;\n    #parentRect;\n    #pinned;\n    #popup;\n    #popupAbortController;\n    #position;\n    #commentButton;\n    #commentButtonPosition;\n    #popupPosition;\n    #rect;\n    #richText;\n    #titleObj;\n    #updates;\n    #wasVisible;\n    #firstElement;\n    #commentText;\n    constructor({ container, color, elements, titleObj, modificationDate, contentsObj, richText, parent, rect, parentRect, open, commentManager = null }){\n        this.#commentManager = null;\n        this.#boundKeyDown = this.#keyDown.bind(this);\n        this.#boundHide = this.#hide.bind(this);\n        this.#boundShow = this.#show.bind(this);\n        this.#boundToggle = this.#toggle.bind(this);\n        this.#color = null;\n        this.#container = null;\n        this.#contentsObj = null;\n        this.#dateObj = null;\n        this.#elements = null;\n        this.#parent = null;\n        this.#parentRect = null;\n        this.#pinned = false;\n        this.#popup = null;\n        this.#popupAbortController = null;\n        this.#position = null;\n        this.#commentButton = null;\n        this.#commentButtonPosition = null;\n        this.#popupPosition = null;\n        this.#rect = null;\n        this.#richText = null;\n        this.#titleObj = null;\n        this.#updates = null;\n        this.#wasVisible = false;\n        this.#firstElement = null;\n        this.#commentText = null;\n        this.#container = container;\n        this.#titleObj = titleObj;\n        this.#contentsObj = contentsObj;\n        this.#richText = richText;\n        this.#parent = parent;\n        this.#color = color;\n        this.#rect = rect;\n        this.#parentRect = parentRect;\n        this.#elements = elements;\n        this.#commentManager = commentManager;\n        this.#firstElement = elements[0];\n        this.#dateObj = PDFDateString.toDateObject(modificationDate);\n        this.trigger = elements.flatMap((e)=>e.getElementsToTriggerPopup());\n        if (commentManager) {\n            this.renderCommentButton();\n        } else {\n            this.#addEventListeners();\n            this.#container.hidden = true;\n            if (open) {\n                this.#toggle();\n            }\n        }\n    }\n    #addEventListeners() {\n        if (this.#popupAbortController) {\n            return;\n        }\n        this.#popupAbortController = new AbortController();\n        const { signal } = this.#popupAbortController;\n        for (const element of this.trigger){\n            element.addEventListener(\"click\", this.#boundToggle, {\n                signal\n            });\n            element.addEventListener(\"pointerenter\", this.#boundShow, {\n                signal\n            });\n            element.addEventListener(\"pointerleave\", this.#boundHide, {\n                signal\n            });\n            element.classList.add(\"popupTriggerArea\");\n        }\n        for (const element of this.#elements){\n            element.container?.addEventListener(\"keydown\", this.#boundKeyDown, {\n                signal\n            });\n        }\n    }\n    #setCommentButtonPosition() {\n        const element = this.#elements.find((e)=>e.hasCommentButton);\n        if (!element) {\n            return;\n        }\n        this.#commentButtonPosition = element._normalizePoint(element.commentButtonPosition);\n    }\n    renderCommentButton() {\n        if (this.#commentButton) {\n            return;\n        }\n        if (!this.#commentButtonPosition) {\n            this.#setCommentButtonPosition();\n        }\n        if (!this.#commentButtonPosition) {\n            return;\n        }\n        const { signal } = this.#popupAbortController = new AbortController();\n        const hasOwnButton = !!this.#firstElement.extraPopupElement;\n        const togglePopup = ()=>{\n            this.#commentManager.toggleCommentPopup(this, true, void 0, !hasOwnButton);\n        };\n        const showPopup = ()=>{\n            this.#commentManager.toggleCommentPopup(this, false, true, !hasOwnButton);\n        };\n        const hidePopup = ()=>{\n            this.#commentManager.toggleCommentPopup(this, false, false);\n        };\n        if (!hasOwnButton) {\n            const button = this.#commentButton = document.createElement(\"button\");\n            button.className = \"annotationCommentButton\";\n            const parentContainer = this.#firstElement.container;\n            button.style.zIndex = parentContainer.style.zIndex + 1;\n            button.tabIndex = 0;\n            button.ariaHasPopup = \"dialog\";\n            button.ariaControls = \"commentPopup\";\n            button.setAttribute(\"data-l10n-id\", \"pdfjs-show-comment-button\");\n            this.#updateColor();\n            this.#updateCommentButtonPosition();\n            button.addEventListener(\"keydown\", this.#boundKeyDown, {\n                signal\n            });\n            button.addEventListener(\"click\", togglePopup, {\n                signal\n            });\n            button.addEventListener(\"pointerenter\", showPopup, {\n                signal\n            });\n            button.addEventListener(\"pointerleave\", hidePopup, {\n                signal\n            });\n            parentContainer.after(button);\n        } else {\n            this.#commentButton = this.#firstElement.container;\n            for (const element of this.trigger){\n                element.ariaHasPopup = \"dialog\";\n                element.ariaControls = \"commentPopup\";\n                element.addEventListener(\"keydown\", this.#boundKeyDown, {\n                    signal\n                });\n                element.addEventListener(\"click\", togglePopup, {\n                    signal\n                });\n                element.addEventListener(\"pointerenter\", showPopup, {\n                    signal\n                });\n                element.addEventListener(\"pointerleave\", hidePopup, {\n                    signal\n                });\n                element.classList.add(\"popupTriggerArea\");\n            }\n        }\n    }\n    #updateCommentButtonPosition() {\n        if (this.#firstElement.extraPopupElement && !this.#firstElement.editor) {\n            return;\n        }\n        this.renderCommentButton();\n        const [x, y] = this.#commentButtonPosition;\n        const { style } = this.#commentButton;\n        style.left = `calc(${x}%)`;\n        style.top = `calc(${y}% - var(--comment-button-dim))`;\n    }\n    #updateColor() {\n        if (this.#firstElement.extraPopupElement) {\n            return;\n        }\n        this.renderCommentButton();\n        this.#commentButton.style.backgroundColor = this.commentButtonColor || \"\";\n    }\n    get commentButtonColor() {\n        const { color, opacity } = this.#firstElement.commentData;\n        if (!color) {\n            return null;\n        }\n        return this.#parent._commentManager.makeCommentColor(color, opacity);\n    }\n    focusCommentButton() {\n        setTimeout(()=>{\n            this.#commentButton?.focus();\n        }, 0);\n    }\n    getData() {\n        const { richText, color, opacity, creationDate, modificationDate } = this.#firstElement.commentData;\n        return {\n            contentsObj: {\n                str: this.comment\n            },\n            richText,\n            color,\n            opacity,\n            creationDate,\n            modificationDate\n        };\n    }\n    get elementBeforePopup() {\n        return this.#commentButton;\n    }\n    get comment() {\n        this.#commentText ||= this.#firstElement.commentText;\n        return this.#commentText;\n    }\n    set comment(text) {\n        if (text === this.comment) {\n            return;\n        }\n        this.#firstElement.commentText = this.#commentText = text;\n    }\n    get parentBoundingClientRect() {\n        return this.#firstElement.layer.getBoundingClientRect();\n    }\n    setCommentButtonStates({ selected, hasPopup }) {\n        if (!this.#commentButton) {\n            return;\n        }\n        this.#commentButton.classList.toggle(\"selected\", selected);\n        this.#commentButton.ariaExpanded = hasPopup;\n    }\n    setSelectedCommentButton(selected) {\n        this.#commentButton.classList.toggle(\"selected\", selected);\n    }\n    get commentPopupPosition() {\n        if (this.#popupPosition) {\n            return this.#popupPosition;\n        }\n        const { x, y, height } = this.#commentButton.getBoundingClientRect();\n        const { x: parentX, y: parentY, width: parentWidth, height: parentHeight } = this.#firstElement.layer.getBoundingClientRect();\n        return [\n            (x - parentX) / parentWidth,\n            (y + height - parentY) / parentHeight\n        ];\n    }\n    set commentPopupPosition(pos) {\n        this.#popupPosition = pos;\n    }\n    hasDefaultPopupPosition() {\n        return this.#popupPosition === null;\n    }\n    get commentButtonPosition() {\n        return this.#commentButtonPosition;\n    }\n    get commentButtonWidth() {\n        return this.#commentButton.getBoundingClientRect().width / this.parentBoundingClientRect.width;\n    }\n    editComment(options) {\n        const [posX, posY] = this.#popupPosition || this.commentButtonPosition.map((x)=>x / 100);\n        const parentDimensions = this.parentBoundingClientRect;\n        const { x: parentX, y: parentY, width: parentWidth, height: parentHeight } = parentDimensions;\n        this.#commentManager.showDialog(null, this, parentX + posX * parentWidth, parentY + posY * parentHeight, {\n            ...options,\n            parentDimensions\n        });\n    }\n    render() {\n        if (this.#popup) {\n            return;\n        }\n        const popup = this.#popup = document.createElement(\"div\");\n        popup.className = \"popup\";\n        if (this.#color) {\n            const baseColor = popup.style.outlineColor = Util.makeHexColor(...this.#color);\n            popup.style.backgroundColor = `color-mix(in srgb, ${baseColor} 30%, white)`;\n        }\n        const header = document.createElement(\"span\");\n        header.className = \"header\";\n        if (this.#titleObj?.str) {\n            const title = document.createElement(\"span\");\n            title.className = \"title\";\n            header.append(title);\n            ({ dir: title.dir, str: title.textContent } = this.#titleObj);\n        }\n        popup.append(header);\n        if (this.#dateObj) {\n            const modificationDate = document.createElement(\"time\");\n            modificationDate.className = \"popupDate\";\n            modificationDate.setAttribute(\"data-l10n-id\", \"pdfjs-annotation-date-time-string\");\n            modificationDate.setAttribute(\"data-l10n-args\", JSON.stringify({\n                dateObj: this.#dateObj.valueOf()\n            }));\n            modificationDate.dateTime = this.#dateObj.toISOString();\n            header.append(modificationDate);\n        }\n        renderRichText({\n            html: this.#html || this.#contentsObj.str,\n            dir: this.#contentsObj?.dir,\n            className: \"popupContent\"\n        }, popup);\n        this.#container.append(popup);\n    }\n    get #html() {\n        const richText = this.#richText;\n        const contentsObj = this.#contentsObj;\n        if (richText?.str && (!contentsObj?.str || contentsObj.str === richText.str)) {\n            return this.#richText.html || null;\n        }\n        return null;\n    }\n    get #fontSize() {\n        return this.#html?.attributes?.style?.fontSize || 0;\n    }\n    get #fontColor() {\n        return this.#html?.attributes?.style?.color || null;\n    }\n    #makePopupContent(text) {\n        const popupLines = [];\n        const popupContent = {\n            str: text,\n            html: {\n                name: \"div\",\n                attributes: {\n                    dir: \"auto\"\n                },\n                children: [\n                    {\n                        name: \"p\",\n                        children: popupLines\n                    }\n                ]\n            }\n        };\n        const lineAttributes = {\n            style: {\n                color: this.#fontColor,\n                fontSize: this.#fontSize ? `calc(${this.#fontSize}px * var(--total-scale-factor))` : \"\"\n            }\n        };\n        for (const line of text.split(\"\\n\")){\n            popupLines.push({\n                name: \"span\",\n                value: line,\n                attributes: lineAttributes\n            });\n        }\n        return popupContent;\n    }\n    #keyDown(event) {\n        if (event.altKey || event.shiftKey || event.ctrlKey || event.metaKey) {\n            return;\n        }\n        if (event.key === \"Enter\" || event.key === \"Escape\" && this.#pinned) {\n            this.#toggle();\n        }\n    }\n    updateEdited({ rect, popup, deleted }) {\n        if (this.#commentManager) {\n            if (deleted) {\n                this.remove();\n                this.#commentText = null;\n            } else if (popup) {\n                if (popup.deleted) {\n                    this.remove();\n                } else {\n                    this.#updateColor();\n                    this.#commentText = popup.text;\n                }\n            }\n            if (rect) {\n                this.#commentButtonPosition = null;\n                this.#setCommentButtonPosition();\n                this.#updateCommentButtonPosition();\n            }\n            return;\n        }\n        if (deleted || popup?.deleted) {\n            this.remove();\n            return;\n        }\n        this.#addEventListeners();\n        this.#updates ||= {\n            contentsObj: this.#contentsObj,\n            richText: this.#richText\n        };\n        if (rect) {\n            this.#position = null;\n        }\n        if (popup && popup.text) {\n            this.#richText = this.#makePopupContent(popup.text);\n            this.#dateObj = PDFDateString.toDateObject(popup.date);\n            this.#contentsObj = null;\n        }\n        this.#popup?.remove();\n        this.#popup = null;\n    }\n    resetEdited() {\n        if (!this.#updates) {\n            return;\n        }\n        ({ contentsObj: this.#contentsObj, richText: this.#richText } = this.#updates);\n        this.#updates = null;\n        this.#popup?.remove();\n        this.#popup = null;\n        this.#position = null;\n    }\n    remove() {\n        this.#popupAbortController?.abort();\n        this.#popupAbortController = null;\n        this.#popup?.remove();\n        this.#popup = null;\n        this.#wasVisible = false;\n        this.#pinned = false;\n        this.#commentButton?.remove();\n        this.#commentButton = null;\n        if (this.trigger) {\n            for (const element of this.trigger){\n                element.classList.remove(\"popupTriggerArea\");\n            }\n        }\n    }\n    #setPosition() {\n        if (this.#position !== null) {\n            return;\n        }\n        const { page: { view }, viewport: { rawDims: { pageWidth, pageHeight, pageX, pageY } } } = this.#parent;\n        let useParentRect = !!this.#parentRect;\n        let rect = useParentRect ? this.#parentRect : this.#rect;\n        for (const element of this.#elements){\n            if (!rect || Util.intersect(element.data.rect, rect) !== null) {\n                rect = element.data.rect;\n                useParentRect = true;\n                break;\n            }\n        }\n        const normalizedRect = Util.normalizeRect([\n            rect[0],\n            view[3] - rect[1] + view[1],\n            rect[2],\n            view[3] - rect[3] + view[1]\n        ]);\n        const HORIZONTAL_SPACE_AFTER_ANNOTATION = 5;\n        const parentWidth = useParentRect ? rect[2] - rect[0] + HORIZONTAL_SPACE_AFTER_ANNOTATION : 0;\n        const popupLeft = normalizedRect[0] + parentWidth;\n        const popupTop = normalizedRect[1];\n        this.#position = [\n            100 * (popupLeft - pageX) / pageWidth,\n            100 * (popupTop - pageY) / pageHeight\n        ];\n        const { style } = this.#container;\n        style.left = `${this.#position[0]}%`;\n        style.top = `${this.#position[1]}%`;\n    }\n    #toggle() {\n        if (this.#commentManager) {\n            this.#commentManager.toggleCommentPopup(this, false);\n            return;\n        }\n        this.#pinned = !this.#pinned;\n        if (this.#pinned) {\n            this.#show();\n            this.#container.addEventListener(\"click\", this.#boundToggle);\n            this.#container.addEventListener(\"keydown\", this.#boundKeyDown);\n        } else {\n            this.#hide();\n            this.#container.removeEventListener(\"click\", this.#boundToggle);\n            this.#container.removeEventListener(\"keydown\", this.#boundKeyDown);\n        }\n    }\n    #show() {\n        if (!this.#popup) {\n            this.render();\n        }\n        if (!this.isVisible) {\n            this.#setPosition();\n            this.#container.hidden = false;\n            this.#container.style.zIndex = parseInt(this.#container.style.zIndex) + 1e3;\n        } else if (this.#pinned) {\n            this.#container.classList.add(\"focused\");\n        }\n    }\n    #hide() {\n        this.#container.classList.remove(\"focused\");\n        if (this.#pinned || !this.isVisible) {\n            return;\n        }\n        this.#container.hidden = true;\n        this.#container.style.zIndex = parseInt(this.#container.style.zIndex) - 1e3;\n    }\n    forceHide() {\n        this.#wasVisible = this.isVisible;\n        if (!this.#wasVisible) {\n            return;\n        }\n        this.#container.hidden = true;\n    }\n    maybeShow() {\n        if (this.#commentManager) {\n            return;\n        }\n        this.#addEventListeners();\n        if (!this.#wasVisible) {\n            return;\n        }\n        if (!this.#popup) {\n            this.#show();\n        }\n        this.#wasVisible = false;\n        this.#container.hidden = false;\n    }\n    get isVisible() {\n        if (this.#commentManager) {\n            return false;\n        }\n        return this.#container.hidden === false;\n    }\n}\nclass FreeTextAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.textContent = parameters.data.textContent;\n        this.textPosition = parameters.data.textPosition;\n        this.annotationEditorType = AnnotationEditorType.FREETEXT;\n    }\n    render() {\n        this.container.classList.add(\"freeTextAnnotation\");\n        if (this.textContent) {\n            const content = document.createElement(\"div\");\n            content.classList.add(\"annotationTextContent\");\n            content.setAttribute(\"role\", \"comment\");\n            for (const line of this.textContent){\n                const lineSpan = document.createElement(\"span\");\n                lineSpan.textContent = line;\n                content.append(lineSpan);\n            }\n            this.container.append(content);\n        }\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this._editOnDoubleClick();\n        return this.container;\n    }\n}\nclass LineAnnotationElement extends AnnotationElement {\n    #line;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#line = null;\n    }\n    render() {\n        this.container.classList.add(\"lineAnnotation\");\n        const { data, width, height } = this;\n        const svg = this.svgFactory.create(width, height, true);\n        const line = this.#line = this.svgFactory.createElement(\"svg:line\");\n        line.setAttribute(\"x1\", data.rect[2] - data.lineCoordinates[0]);\n        line.setAttribute(\"y1\", data.rect[3] - data.lineCoordinates[1]);\n        line.setAttribute(\"x2\", data.rect[2] - data.lineCoordinates[2]);\n        line.setAttribute(\"y2\", data.rect[3] - data.lineCoordinates[3]);\n        line.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n        line.setAttribute(\"stroke\", \"transparent\");\n        line.setAttribute(\"fill\", \"transparent\");\n        svg.append(line);\n        this.container.append(svg);\n        if (!data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#line;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n}\nclass SquareAnnotationElement extends AnnotationElement {\n    #square;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#square = null;\n    }\n    render() {\n        this.container.classList.add(\"squareAnnotation\");\n        const { data, width, height } = this;\n        const svg = this.svgFactory.create(width, height, true);\n        const borderWidth = data.borderStyle.width;\n        const square = this.#square = this.svgFactory.createElement(\"svg:rect\");\n        square.setAttribute(\"x\", borderWidth / 2);\n        square.setAttribute(\"y\", borderWidth / 2);\n        square.setAttribute(\"width\", width - borderWidth);\n        square.setAttribute(\"height\", height - borderWidth);\n        square.setAttribute(\"stroke-width\", borderWidth || 1);\n        square.setAttribute(\"stroke\", \"transparent\");\n        square.setAttribute(\"fill\", \"transparent\");\n        svg.append(square);\n        this.container.append(svg);\n        if (!data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#square;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n}\nclass CircleAnnotationElement extends AnnotationElement {\n    #circle;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#circle = null;\n    }\n    render() {\n        this.container.classList.add(\"circleAnnotation\");\n        const { data, width, height } = this;\n        const svg = this.svgFactory.create(width, height, true);\n        const borderWidth = data.borderStyle.width;\n        const circle = this.#circle = this.svgFactory.createElement(\"svg:ellipse\");\n        circle.setAttribute(\"cx\", width / 2);\n        circle.setAttribute(\"cy\", height / 2);\n        circle.setAttribute(\"rx\", width / 2 - borderWidth / 2);\n        circle.setAttribute(\"ry\", height / 2 - borderWidth / 2);\n        circle.setAttribute(\"stroke-width\", borderWidth || 1);\n        circle.setAttribute(\"stroke\", \"transparent\");\n        circle.setAttribute(\"fill\", \"transparent\");\n        svg.append(circle);\n        this.container.append(svg);\n        if (!data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#circle;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n}\nclass PolylineAnnotationElement extends AnnotationElement {\n    #polyline;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#polyline = null;\n        this.containerClassName = \"polylineAnnotation\";\n        this.svgElementName = \"svg:polyline\";\n    }\n    render() {\n        this.container.classList.add(this.containerClassName);\n        const { data: { rect, vertices, borderStyle, popupRef }, width, height } = this;\n        if (!vertices) {\n            return this.container;\n        }\n        const svg = this.svgFactory.create(width, height, true);\n        let points = [];\n        for(let i = 0, ii = vertices.length; i < ii; i += 2){\n            const x = vertices[i] - rect[0];\n            const y = rect[3] - vertices[i + 1];\n            points.push(`${x},${y}`);\n        }\n        points = points.join(\" \");\n        const polyline = this.#polyline = this.svgFactory.createElement(this.svgElementName);\n        polyline.setAttribute(\"points\", points);\n        polyline.setAttribute(\"stroke-width\", borderStyle.width || 1);\n        polyline.setAttribute(\"stroke\", \"transparent\");\n        polyline.setAttribute(\"fill\", \"transparent\");\n        svg.append(polyline);\n        this.container.append(svg);\n        if (!popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#polyline;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n}\nclass PolygonAnnotationElement extends PolylineAnnotationElement {\n    constructor(parameters){\n        super(parameters);\n        this.containerClassName = \"polygonAnnotation\";\n        this.svgElementName = \"svg:polygon\";\n    }\n}\nclass CaretAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n    }\n    render() {\n        this.container.classList.add(\"caretAnnotation\");\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n}\nclass InkAnnotationElement extends AnnotationElement {\n    #polylinesGroupElement;\n    #polylines;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#polylinesGroupElement = null;\n        this.#polylines = [];\n        this.containerClassName = \"inkAnnotation\";\n        this.svgElementName = \"svg:polyline\";\n        this.annotationEditorType = this.data.it === \"InkHighlight\" ? AnnotationEditorType.HIGHLIGHT : AnnotationEditorType.INK;\n    }\n    #getTransform(rotation, rect) {\n        switch(rotation){\n            case 90:\n                return {\n                    transform: `rotate(90) translate(${-rect[0]},${rect[1]}) scale(1,-1)`,\n                    width: rect[3] - rect[1],\n                    height: rect[2] - rect[0]\n                };\n            case 180:\n                return {\n                    transform: `rotate(180) translate(${-rect[2]},${rect[1]}) scale(1,-1)`,\n                    width: rect[2] - rect[0],\n                    height: rect[3] - rect[1]\n                };\n            case 270:\n                return {\n                    transform: `rotate(270) translate(${-rect[2]},${rect[3]}) scale(1,-1)`,\n                    width: rect[3] - rect[1],\n                    height: rect[2] - rect[0]\n                };\n            default:\n                return {\n                    transform: `translate(${-rect[0]},${rect[3]}) scale(1,-1)`,\n                    width: rect[2] - rect[0],\n                    height: rect[3] - rect[1]\n                };\n        }\n    }\n    render() {\n        this.container.classList.add(this.containerClassName);\n        const { data: { rect, rotation, inkLists, borderStyle, popupRef } } = this;\n        const { transform, width, height } = this.#getTransform(rotation, rect);\n        const svg = this.svgFactory.create(width, height, true);\n        const g = this.#polylinesGroupElement = this.svgFactory.createElement(\"svg:g\");\n        svg.append(g);\n        g.setAttribute(\"stroke-width\", borderStyle.width || 1);\n        g.setAttribute(\"stroke-linecap\", \"round\");\n        g.setAttribute(\"stroke-linejoin\", \"round\");\n        g.setAttribute(\"stroke-miterlimit\", 10);\n        g.setAttribute(\"stroke\", \"transparent\");\n        g.setAttribute(\"fill\", \"transparent\");\n        g.setAttribute(\"transform\", transform);\n        for(let i = 0, ii = inkLists.length; i < ii; i++){\n            const polyline = this.svgFactory.createElement(this.svgElementName);\n            this.#polylines.push(polyline);\n            polyline.setAttribute(\"points\", inkLists[i].join(\",\"));\n            g.append(polyline);\n        }\n        if (!popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.append(svg);\n        this._editOnDoubleClick();\n        return this.container;\n    }\n    updateEdited(params) {\n        super.updateEdited(params);\n        const { thickness, points, rect } = params;\n        const g = this.#polylinesGroupElement;\n        if (thickness >= 0) {\n            g.setAttribute(\"stroke-width\", thickness || 1);\n        }\n        if (points) {\n            for(let i = 0, ii = this.#polylines.length; i < ii; i++){\n                this.#polylines[i].setAttribute(\"points\", points[i].join(\",\"));\n            }\n        }\n        if (rect) {\n            const { transform, width, height } = this.#getTransform(this.data.rotation, rect);\n            const root = g.parentElement;\n            root.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n            g.setAttribute(\"transform\", transform);\n        }\n    }\n    getElementsToTriggerPopup() {\n        return this.#polylines;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n}\nclass HighlightAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true,\n            createQuadrilaterals: true\n        });\n        this.annotationEditorType = AnnotationEditorType.HIGHLIGHT;\n    }\n    render() {\n        const { data: { overlaidText, popupRef } } = this;\n        if (!popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.classList.add(\"highlightAnnotation\");\n        this._editOnDoubleClick();\n        if (overlaidText) {\n            const mark = document.createElement(\"mark\");\n            mark.classList.add(\"overlaidText\");\n            mark.textContent = overlaidText;\n            this.container.append(mark);\n        }\n        return this.container;\n    }\n}\nclass UnderlineAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true,\n            createQuadrilaterals: true\n        });\n    }\n    render() {\n        const { data: { overlaidText, popupRef } } = this;\n        if (!popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.classList.add(\"underlineAnnotation\");\n        if (overlaidText) {\n            const underline = document.createElement(\"u\");\n            underline.classList.add(\"overlaidText\");\n            underline.textContent = overlaidText;\n            this.container.append(underline);\n        }\n        return this.container;\n    }\n}\nclass SquigglyAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true,\n            createQuadrilaterals: true\n        });\n    }\n    render() {\n        const { data: { overlaidText, popupRef } } = this;\n        if (!popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.classList.add(\"squigglyAnnotation\");\n        if (overlaidText) {\n            const underline = document.createElement(\"u\");\n            underline.classList.add(\"overlaidText\");\n            underline.textContent = overlaidText;\n            this.container.append(underline);\n        }\n        return this.container;\n    }\n}\nclass StrikeOutAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true,\n            createQuadrilaterals: true\n        });\n    }\n    render() {\n        const { data: { overlaidText, popupRef } } = this;\n        if (!popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.classList.add(\"strikeoutAnnotation\");\n        if (overlaidText) {\n            const strikeout = document.createElement(\"s\");\n            strikeout.classList.add(\"overlaidText\");\n            strikeout.textContent = overlaidText;\n            this.container.append(strikeout);\n        }\n        return this.container;\n    }\n}\nclass StampAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.annotationEditorType = AnnotationEditorType.STAMP;\n    }\n    render() {\n        this.container.classList.add(\"stampAnnotation\");\n        this.container.setAttribute(\"role\", \"img\");\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this._editOnDoubleClick();\n        return this.container;\n    }\n}\nclass FileAttachmentAnnotationElement extends AnnotationElement {\n    #trigger;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true\n        });\n        this.#trigger = null;\n        const { file } = this.data;\n        this.filename = file.filename;\n        this.content = file.content;\n        this.linkService.eventBus?.dispatch(\"fileattachmentannotation\", {\n            source: this,\n            ...file\n        });\n    }\n    render() {\n        this.container.classList.add(\"fileAttachmentAnnotation\");\n        const { container, data } = this;\n        let trigger;\n        if (data.hasAppearance || data.fillAlpha === 0) {\n            trigger = document.createElement(\"div\");\n        } else {\n            trigger = document.createElement(\"img\");\n            trigger.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(data.name) ? \"paperclip\" : \"pushpin\"}.svg`;\n            if (data.fillAlpha && data.fillAlpha < 1) {\n                trigger.style = `filter: opacity(${Math.round(data.fillAlpha * 100)}%);`;\n            }\n        }\n        trigger.addEventListener(\"dblclick\", this.#download.bind(this));\n        this.#trigger = trigger;\n        const { isMac } = util_FeatureTest.platform;\n        container.addEventListener(\"keydown\", (evt)=>{\n            if (evt.key === \"Enter\" && (isMac ? evt.metaKey : evt.ctrlKey)) {\n                this.#download();\n            }\n        });\n        if (!data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        } else {\n            trigger.classList.add(\"popupTriggerArea\");\n        }\n        container.append(trigger);\n        return container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#trigger;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n    #download() {\n        this.downloadManager?.openOrDownloadData(this.content, this.filename);\n    }\n}\nclass AnnotationLayer {\n    #accessibilityManager;\n    #annotationCanvasMap;\n    #annotationStorage;\n    #editableAnnotations;\n    #structTreeLayer;\n    #linkService;\n    constructor({ div, accessibilityManager, annotationCanvasMap, annotationEditorUIManager, page, viewport, structTreeLayer, commentManager, linkService, annotationStorage }){\n        this.#accessibilityManager = null;\n        this.#annotationCanvasMap = null;\n        this.#annotationStorage = null;\n        this.#editableAnnotations = /* @__PURE__ */ new Map();\n        this.#structTreeLayer = null;\n        this.#linkService = null;\n        this.div = div;\n        this.#accessibilityManager = accessibilityManager;\n        this.#annotationCanvasMap = annotationCanvasMap;\n        this.#structTreeLayer = structTreeLayer || null;\n        this.#linkService = linkService || null;\n        this.#annotationStorage = annotationStorage || new AnnotationStorage();\n        this.page = page;\n        this.viewport = viewport;\n        this.zIndex = 0;\n        this._annotationEditorUIManager = annotationEditorUIManager;\n        this._commentManager = commentManager || null;\n    }\n    hasEditableAnnotations() {\n        return this.#editableAnnotations.size > 0;\n    }\n    async #appendElement(element, id, popupElements) {\n        const contentElement = element.firstChild || element;\n        const annotationId = contentElement.id = `${AnnotationPrefix}${id}`;\n        const ariaAttributes = await this.#structTreeLayer?.getAriaAttributes(annotationId);\n        if (ariaAttributes) {\n            for (const [key, value1] of ariaAttributes){\n                contentElement.setAttribute(key, value1);\n            }\n        }\n        if (popupElements) {\n            popupElements.at(-1).container.after(element);\n        } else {\n            this.div.append(element);\n            this.#accessibilityManager?.moveElementInDOM(this.div, element, contentElement, false);\n        }\n    }\n    async render(params) {\n        const { annotations } = params;\n        const layer = this.div;\n        setLayerDimensions(layer, this.viewport);\n        const popupToElements = /* @__PURE__ */ new Map();\n        const elementParams = {\n            data: null,\n            layer,\n            linkService: this.#linkService,\n            downloadManager: params.downloadManager,\n            imageResourcesPath: params.imageResourcesPath || \"\",\n            renderForms: params.renderForms !== false,\n            svgFactory: new DOMSVGFactory(),\n            annotationStorage: this.#annotationStorage,\n            enableComment: params.enableComment === true,\n            enableScripting: params.enableScripting === true,\n            hasJSActions: params.hasJSActions,\n            fieldObjects: params.fieldObjects,\n            parent: this,\n            elements: null\n        };\n        for (const data of annotations){\n            if (data.noHTML) {\n                continue;\n            }\n            const isPopupAnnotation = data.annotationType === AnnotationType.POPUP;\n            if (!isPopupAnnotation) {\n                if (data.rect[2] === data.rect[0] || data.rect[3] === data.rect[1]) {\n                    continue;\n                }\n            } else {\n                const elements = popupToElements.get(data.id);\n                if (!elements) {\n                    continue;\n                }\n                elementParams.elements = elements;\n            }\n            elementParams.data = data;\n            const element = AnnotationElementFactory.create(elementParams);\n            if (!element.isRenderable) {\n                continue;\n            }\n            if (!isPopupAnnotation && data.popupRef) {\n                const elements = popupToElements.get(data.popupRef);\n                if (!elements) {\n                    popupToElements.set(data.popupRef, [\n                        element\n                    ]);\n                } else {\n                    elements.push(element);\n                }\n            }\n            const rendered = element.render();\n            if (data.hidden) {\n                rendered.style.visibility = \"hidden\";\n            }\n            await this.#appendElement(rendered, data.id, elementParams.elements);\n            element.extraPopupElement?.popup?.renderCommentButton();\n            if (element._isEditable) {\n                this.#editableAnnotations.set(element.data.id, element);\n                this._annotationEditorUIManager?.renderAnnotationElement(element);\n            }\n        }\n        this.#setAnnotationCanvasMap();\n    }\n    async addLinkAnnotations(annotations) {\n        const elementParams = {\n            data: null,\n            layer: this.div,\n            linkService: this.#linkService,\n            svgFactory: new DOMSVGFactory(),\n            parent: this\n        };\n        for (const data of annotations){\n            data.borderStyle ||= AnnotationLayer._defaultBorderStyle;\n            elementParams.data = data;\n            const element = AnnotationElementFactory.create(elementParams);\n            if (!element.isRenderable) {\n                continue;\n            }\n            const rendered = element.render();\n            await this.#appendElement(rendered, data.id, null);\n        }\n    }\n    update({ viewport }) {\n        const layer = this.div;\n        this.viewport = viewport;\n        setLayerDimensions(layer, {\n            rotation: viewport.rotation\n        });\n        this.#setAnnotationCanvasMap();\n        layer.hidden = false;\n    }\n    #setAnnotationCanvasMap() {\n        if (!this.#annotationCanvasMap) {\n            return;\n        }\n        const layer = this.div;\n        for (const [id, canvas] of this.#annotationCanvasMap){\n            const element = layer.querySelector(`[data-annotation-id=\"${id}\"]`);\n            if (!element) {\n                continue;\n            }\n            canvas.className = \"annotationContent\";\n            const { firstChild } = element;\n            if (!firstChild) {\n                element.append(canvas);\n            } else if (firstChild.nodeName === \"CANVAS\") {\n                firstChild.replaceWith(canvas);\n            } else if (!firstChild.classList.contains(\"annotationContent\")) {\n                firstChild.before(canvas);\n            } else {\n                firstChild.after(canvas);\n            }\n            const editableAnnotation = this.#editableAnnotations.get(id);\n            if (!editableAnnotation) {\n                continue;\n            }\n            if (editableAnnotation._hasNoCanvas) {\n                this._annotationEditorUIManager?.setMissingCanvas(id, element.id, canvas);\n                editableAnnotation._hasNoCanvas = false;\n            } else {\n                editableAnnotation.canvas = canvas;\n            }\n        }\n        this.#annotationCanvasMap.clear();\n    }\n    getEditableAnnotations() {\n        return Array.from(this.#editableAnnotations.values());\n    }\n    getEditableAnnotation(id) {\n        return this.#editableAnnotations.get(id);\n    }\n    addFakeAnnotation(editor) {\n        const { div } = this;\n        const { id, rotation } = editor;\n        const element = new EditorAnnotationElement({\n            data: {\n                id,\n                rect: editor.getPDFRect(),\n                rotation\n            },\n            editor,\n            layer: div,\n            parent: this,\n            enableComment: !!this._commentManager,\n            linkService: this.#linkService,\n            annotationStorage: this.#annotationStorage\n        });\n        const htmlElement = element.render();\n        div.append(htmlElement);\n        this.#accessibilityManager?.moveElementInDOM(div, htmlElement, htmlElement, false);\n        element.createOrUpdatePopup();\n        return element;\n    }\n    static get _defaultBorderStyle() {\n        return shadow(this, \"_defaultBorderStyle\", Object.freeze({\n            width: 1,\n            rawWidth: 1,\n            style: AnnotationBorderStyleType.SOLID,\n            dashArray: [\n                3\n            ],\n            horizontalCornerRadius: 0,\n            verticalCornerRadius: 0\n        }));\n    }\n}\nconst EOL_PATTERN = /\\r\\n?|\\n/g;\nclass FreeTextEditor extends AnnotationEditor {\n    #content;\n    #editorDivId;\n    #editModeAC;\n    #fontSize;\n    static{\n        this._freeTextDefaultContent = \"\";\n    }\n    static{\n        this._internalPadding = 0;\n    }\n    static{\n        this._defaultColor = null;\n    }\n    static{\n        this._defaultFontSize = 10;\n    }\n    static get _keyboardManager() {\n        const proto = FreeTextEditor.prototype;\n        const arrowChecker = (self2)=>self2.isEmpty();\n        const small = AnnotationEditorUIManager.TRANSLATE_SMALL;\n        const big = AnnotationEditorUIManager.TRANSLATE_BIG;\n        return shadow(this, \"_keyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"ctrl+s\",\n                    \"mac+meta+s\",\n                    \"ctrl+p\",\n                    \"mac+meta+p\"\n                ],\n                proto.commitOrRemove,\n                {\n                    bubbles: true\n                }\n            ],\n            [\n                [\n                    \"ctrl+Enter\",\n                    \"mac+meta+Enter\",\n                    \"Escape\",\n                    \"mac+Escape\"\n                ],\n                proto.commitOrRemove\n            ],\n            [\n                [\n                    \"ArrowLeft\",\n                    \"mac+ArrowLeft\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        -small,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowLeft\",\n                    \"mac+shift+ArrowLeft\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        -big,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowRight\",\n                    \"mac+ArrowRight\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        small,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowRight\",\n                    \"mac+shift+ArrowRight\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        big,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"mac+ArrowUp\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        0,\n                        -small\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowUp\",\n                    \"mac+shift+ArrowUp\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        0,\n                        -big\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"mac+ArrowDown\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        0,\n                        small\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowDown\",\n                    \"mac+shift+ArrowDown\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        0,\n                        big\n                    ],\n                    checker: arrowChecker\n                }\n            ]\n        ]));\n    }\n    static{\n        this._type = \"freetext\";\n    }\n    static{\n        this._editorType = AnnotationEditorType.FREETEXT;\n    }\n    constructor(params){\n        super({\n            ...params,\n            name: \"freeTextEditor\"\n        });\n        this.#content = \"\";\n        this.#editorDivId = `${this.id}-editor`;\n        this.#editModeAC = null;\n        this._colorPicker = null;\n        this.color = params.color || FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor;\n        this.#fontSize = params.fontSize || FreeTextEditor._defaultFontSize;\n        if (!this.annotationElementId) {\n            this._uiManager.a11yAlert(\"pdfjs-editor-freetext-added-alert\");\n        }\n    }\n    static initialize(l10n, uiManager) {\n        AnnotationEditor.initialize(l10n, uiManager);\n        const style = getComputedStyle(document.documentElement);\n        this._internalPadding = parseFloat(style.getPropertyValue(\"--freetext-padding\"));\n    }\n    static updateDefaultParams(type, value1) {\n        switch(type){\n            case AnnotationEditorParamsType.FREETEXT_SIZE:\n                FreeTextEditor._defaultFontSize = value1;\n                break;\n            case AnnotationEditorParamsType.FREETEXT_COLOR:\n                FreeTextEditor._defaultColor = value1;\n                break;\n        }\n    }\n    updateParams(type, value1) {\n        switch(type){\n            case AnnotationEditorParamsType.FREETEXT_SIZE:\n                this.#updateFontSize(value1);\n                break;\n            case AnnotationEditorParamsType.FREETEXT_COLOR:\n                this.#updateColor(value1);\n                break;\n        }\n    }\n    static get defaultPropertiesToUpdate() {\n        return [\n            [\n                AnnotationEditorParamsType.FREETEXT_SIZE,\n                FreeTextEditor._defaultFontSize\n            ],\n            [\n                AnnotationEditorParamsType.FREETEXT_COLOR,\n                FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor\n            ]\n        ];\n    }\n    get propertiesToUpdate() {\n        return [\n            [\n                AnnotationEditorParamsType.FREETEXT_SIZE,\n                this.#fontSize\n            ],\n            [\n                AnnotationEditorParamsType.FREETEXT_COLOR,\n                this.color\n            ]\n        ];\n    }\n    get toolbarButtons() {\n        this._colorPicker ||= new BasicColorPicker(this);\n        return [\n            [\n                \"colorPicker\",\n                this._colorPicker\n            ]\n        ];\n    }\n    get colorType() {\n        return AnnotationEditorParamsType.FREETEXT_COLOR;\n    }\n    #updateFontSize(fontSize) {\n        const setFontsize = (size)=>{\n            this.editorDiv.style.fontSize = `calc(${size}px * var(--total-scale-factor))`;\n            this.translate(0, -(size - this.#fontSize) * this.parentScale);\n            this.#fontSize = size;\n            this.#setEditorDimensions();\n        };\n        const savedFontsize = this.#fontSize;\n        this.addCommands({\n            cmd: setFontsize.bind(this, fontSize),\n            undo: setFontsize.bind(this, savedFontsize),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type: AnnotationEditorParamsType.FREETEXT_SIZE,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n    }\n    onUpdatedColor() {\n        this.editorDiv.style.color = this.color;\n        this._colorPicker?.update(this.color);\n        super.onUpdatedColor();\n    }\n    #updateColor(color) {\n        const setColor = (col)=>{\n            this.color = col;\n            this.onUpdatedColor();\n        };\n        const savedColor = this.color;\n        this.addCommands({\n            cmd: setColor.bind(this, color),\n            undo: setColor.bind(this, savedColor),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type: AnnotationEditorParamsType.FREETEXT_COLOR,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n    }\n    _translateEmpty(x, y) {\n        this._uiManager.translateSelectedEditors(x, y, true);\n    }\n    getInitialTranslation() {\n        const scale = this.parentScale;\n        return [\n            -FreeTextEditor._internalPadding * scale,\n            -(FreeTextEditor._internalPadding + this.#fontSize) * scale\n        ];\n    }\n    rebuild() {\n        if (!this.parent) {\n            return;\n        }\n        super.rebuild();\n        if (this.div === null) {\n            return;\n        }\n        if (!this.isAttachedToDOM) {\n            this.parent.add(this);\n        }\n    }\n    enableEditMode() {\n        if (!super.enableEditMode()) {\n            return false;\n        }\n        this.overlayDiv.classList.remove(\"enabled\");\n        this.editorDiv.contentEditable = true;\n        this._isDraggable = false;\n        this.div.removeAttribute(\"aria-activedescendant\");\n        this.#editModeAC = new AbortController();\n        const signal = this._uiManager.combinedSignal(this.#editModeAC);\n        this.editorDiv.addEventListener(\"keydown\", this.editorDivKeydown.bind(this), {\n            signal\n        });\n        this.editorDiv.addEventListener(\"focus\", this.editorDivFocus.bind(this), {\n            signal\n        });\n        this.editorDiv.addEventListener(\"blur\", this.editorDivBlur.bind(this), {\n            signal\n        });\n        this.editorDiv.addEventListener(\"input\", this.editorDivInput.bind(this), {\n            signal\n        });\n        this.editorDiv.addEventListener(\"paste\", this.editorDivPaste.bind(this), {\n            signal\n        });\n        return true;\n    }\n    disableEditMode() {\n        if (!super.disableEditMode()) {\n            return false;\n        }\n        this.overlayDiv.classList.add(\"enabled\");\n        this.editorDiv.contentEditable = false;\n        this.div.setAttribute(\"aria-activedescendant\", this.#editorDivId);\n        this._isDraggable = true;\n        this.#editModeAC?.abort();\n        this.#editModeAC = null;\n        this.div.focus({\n            preventScroll: true\n        });\n        this.isEditing = false;\n        this.parent.div.classList.add(\"freetextEditing\");\n        return true;\n    }\n    focusin(event) {\n        if (!this._focusEventsAllowed) {\n            return;\n        }\n        super.focusin(event);\n        if (event.target !== this.editorDiv) {\n            this.editorDiv.focus();\n        }\n    }\n    onceAdded(focus) {\n        if (this.width) {\n            return;\n        }\n        this.enableEditMode();\n        if (focus) {\n            this.editorDiv.focus();\n        }\n        if (this._initialOptions?.isCentered) {\n            this.center();\n        }\n        this._initialOptions = null;\n    }\n    isEmpty() {\n        return !this.editorDiv || this.editorDiv.innerText.trim() === \"\";\n    }\n    remove() {\n        this.isEditing = false;\n        if (this.parent) {\n            this.parent.setEditingState(true);\n            this.parent.div.classList.add(\"freetextEditing\");\n        }\n        super.remove();\n    }\n    #extractText() {\n        const buffer = [];\n        this.editorDiv.normalize();\n        let prevChild = null;\n        for (const child of this.editorDiv.childNodes){\n            if (prevChild?.nodeType === Node.TEXT_NODE && child.nodeName === \"BR\") {\n                continue;\n            }\n            buffer.push(FreeTextEditor.#getNodeContent(child));\n            prevChild = child;\n        }\n        return buffer.join(\"\\n\");\n    }\n    #setEditorDimensions() {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        let rect;\n        if (this.isAttachedToDOM) {\n            rect = this.div.getBoundingClientRect();\n        } else {\n            const { currentLayer, div } = this;\n            const savedDisplay = div.style.display;\n            const savedVisibility = div.classList.contains(\"hidden\");\n            div.classList.remove(\"hidden\");\n            div.style.display = \"hidden\";\n            currentLayer.div.append(this.div);\n            rect = div.getBoundingClientRect();\n            div.remove();\n            div.style.display = savedDisplay;\n            div.classList.toggle(\"hidden\", savedVisibility);\n        }\n        if (this.rotation % 180 === this.parentRotation % 180) {\n            this.width = rect.width / parentWidth;\n            this.height = rect.height / parentHeight;\n        } else {\n            this.width = rect.height / parentWidth;\n            this.height = rect.width / parentHeight;\n        }\n        this.fixAndSetPosition();\n    }\n    commit() {\n        if (!this.isInEditMode()) {\n            return;\n        }\n        super.commit();\n        this.disableEditMode();\n        const savedText = this.#content;\n        const newText = this.#content = this.#extractText().trimEnd();\n        if (savedText === newText) {\n            return;\n        }\n        const setText = (text)=>{\n            this.#content = text;\n            if (!text) {\n                this.remove();\n                return;\n            }\n            this.#setContent();\n            this._uiManager.rebuild(this);\n            this.#setEditorDimensions();\n        };\n        this.addCommands({\n            cmd: ()=>{\n                setText(newText);\n            },\n            undo: ()=>{\n                setText(savedText);\n            },\n            mustExec: false\n        });\n        this.#setEditorDimensions();\n    }\n    shouldGetKeyboardEvents() {\n        return this.isInEditMode();\n    }\n    enterInEditMode() {\n        this.enableEditMode();\n        this.editorDiv.focus();\n    }\n    keydown(event) {\n        if (event.target === this.div && event.key === \"Enter\") {\n            this.enterInEditMode();\n            event.preventDefault();\n        }\n    }\n    editorDivKeydown(event) {\n        FreeTextEditor._keyboardManager.exec(this, event);\n    }\n    editorDivFocus(event) {\n        this.isEditing = true;\n    }\n    editorDivBlur(event) {\n        this.isEditing = false;\n    }\n    editorDivInput(event) {\n        this.parent.div.classList.toggle(\"freetextEditing\", this.isEmpty());\n    }\n    disableEditing() {\n        this.editorDiv.setAttribute(\"role\", \"comment\");\n        this.editorDiv.removeAttribute(\"aria-multiline\");\n    }\n    enableEditing() {\n        this.editorDiv.setAttribute(\"role\", \"textbox\");\n        this.editorDiv.setAttribute(\"aria-multiline\", true);\n    }\n    get canChangeContent() {\n        return true;\n    }\n    render() {\n        if (this.div) {\n            return this.div;\n        }\n        let baseX, baseY;\n        if (this._isCopy || this.annotationElementId) {\n            baseX = this.x;\n            baseY = this.y;\n        }\n        super.render();\n        this.editorDiv = document.createElement(\"div\");\n        this.editorDiv.className = \"internal\";\n        this.editorDiv.setAttribute(\"id\", this.#editorDivId);\n        this.editorDiv.setAttribute(\"data-l10n-id\", \"pdfjs-free-text2\");\n        this.editorDiv.setAttribute(\"data-l10n-attrs\", \"default-content\");\n        this.enableEditing();\n        this.editorDiv.contentEditable = true;\n        const { style } = this.editorDiv;\n        style.fontSize = `calc(${this.#fontSize}px * var(--total-scale-factor))`;\n        style.color = this.color;\n        this.div.append(this.editorDiv);\n        this.overlayDiv = document.createElement(\"div\");\n        this.overlayDiv.classList.add(\"overlay\", \"enabled\");\n        this.div.append(this.overlayDiv);\n        if (this._isCopy || this.annotationElementId) {\n            const [parentWidth, parentHeight] = this.parentDimensions;\n            if (this.annotationElementId) {\n                const { position } = this._initialData;\n                let [tx, ty] = this.getInitialTranslation();\n                [tx, ty] = this.pageTranslationToScreen(tx, ty);\n                const [pageWidth, pageHeight] = this.pageDimensions;\n                const [pageX, pageY] = this.pageTranslation;\n                let posX, posY;\n                switch(this.rotation){\n                    case 0:\n                        posX = baseX + (position[0] - pageX) / pageWidth;\n                        posY = baseY + this.height - (position[1] - pageY) / pageHeight;\n                        break;\n                    case 90:\n                        posX = baseX + (position[0] - pageX) / pageWidth;\n                        posY = baseY - (position[1] - pageY) / pageHeight;\n                        [tx, ty] = [\n                            ty,\n                            -tx\n                        ];\n                        break;\n                    case 180:\n                        posX = baseX - this.width + (position[0] - pageX) / pageWidth;\n                        posY = baseY - (position[1] - pageY) / pageHeight;\n                        [tx, ty] = [\n                            -tx,\n                            -ty\n                        ];\n                        break;\n                    case 270:\n                        posX = baseX + (position[0] - pageX - this.height * pageHeight) / pageWidth;\n                        posY = baseY + (position[1] - pageY - this.width * pageWidth) / pageHeight;\n                        [tx, ty] = [\n                            -ty,\n                            tx\n                        ];\n                        break;\n                }\n                this.setAt(posX * parentWidth, posY * parentHeight, tx, ty);\n            } else {\n                this._moveAfterPaste(baseX, baseY);\n            }\n            this.#setContent();\n            this._isDraggable = true;\n            this.editorDiv.contentEditable = false;\n        } else {\n            this._isDraggable = false;\n            this.editorDiv.contentEditable = true;\n        }\n        return this.div;\n    }\n    static #getNodeContent(node) {\n        return (node.nodeType === Node.TEXT_NODE ? node.nodeValue : node.innerText).replaceAll(EOL_PATTERN, \"\");\n    }\n    editorDivPaste(event) {\n        const clipboardData = event.clipboardData || window.clipboardData;\n        const { types } = clipboardData;\n        if (types.length === 1 && types[0] === \"text/plain\") {\n            return;\n        }\n        event.preventDefault();\n        const paste = FreeTextEditor.#deserializeContent(clipboardData.getData(\"text\") || \"\").replaceAll(EOL_PATTERN, \"\\n\");\n        if (!paste) {\n            return;\n        }\n        const selection = window.getSelection();\n        if (!selection.rangeCount) {\n            return;\n        }\n        this.editorDiv.normalize();\n        selection.deleteFromDocument();\n        const range = selection.getRangeAt(0);\n        if (!paste.includes(\"\\n\")) {\n            range.insertNode(document.createTextNode(paste));\n            this.editorDiv.normalize();\n            selection.collapseToStart();\n            return;\n        }\n        const { startContainer, startOffset } = range;\n        const bufferBefore = [];\n        const bufferAfter = [];\n        if (startContainer.nodeType === Node.TEXT_NODE) {\n            const parent = startContainer.parentElement;\n            bufferAfter.push(startContainer.nodeValue.slice(startOffset).replaceAll(EOL_PATTERN, \"\"));\n            if (parent !== this.editorDiv) {\n                let buffer = bufferBefore;\n                for (const child of this.editorDiv.childNodes){\n                    if (child === parent) {\n                        buffer = bufferAfter;\n                        continue;\n                    }\n                    buffer.push(FreeTextEditor.#getNodeContent(child));\n                }\n            }\n            bufferBefore.push(startContainer.nodeValue.slice(0, startOffset).replaceAll(EOL_PATTERN, \"\"));\n        } else if (startContainer === this.editorDiv) {\n            let buffer = bufferBefore;\n            let i = 0;\n            for (const child of this.editorDiv.childNodes){\n                if (i++ === startOffset) {\n                    buffer = bufferAfter;\n                }\n                buffer.push(FreeTextEditor.#getNodeContent(child));\n            }\n        }\n        this.#content = `${bufferBefore.join(\"\\n\")}${paste}${bufferAfter.join(\"\\n\")}`;\n        this.#setContent();\n        const newRange = new Range();\n        let beforeLength = Math.sumPrecise(bufferBefore.map((line)=>line.length));\n        for (const { firstChild } of this.editorDiv.childNodes){\n            if (firstChild.nodeType === Node.TEXT_NODE) {\n                const length = firstChild.nodeValue.length;\n                if (beforeLength <= length) {\n                    newRange.setStart(firstChild, beforeLength);\n                    newRange.setEnd(firstChild, beforeLength);\n                    break;\n                }\n                beforeLength -= length;\n            }\n        }\n        selection.removeAllRanges();\n        selection.addRange(newRange);\n    }\n    #setContent() {\n        this.editorDiv.replaceChildren();\n        if (!this.#content) {\n            return;\n        }\n        for (const line of this.#content.split(\"\\n\")){\n            const div = document.createElement(\"div\");\n            div.append(line ? document.createTextNode(line) : document.createElement(\"br\"));\n            this.editorDiv.append(div);\n        }\n    }\n    #serializeContent() {\n        return this.#content.replaceAll(\"\\xa0\", \" \");\n    }\n    static #deserializeContent(content) {\n        return content.replaceAll(\" \", \"\\xa0\");\n    }\n    get contentDiv() {\n        return this.editorDiv;\n    }\n    getPDFRect() {\n        const padding = FreeTextEditor._internalPadding * this.parentScale;\n        return this.getRect(padding, padding);\n    }\n    static async deserialize(data, parent, uiManager) {\n        let initialData = null;\n        if (data instanceof FreeTextAnnotationElement) {\n            const { data: { defaultAppearanceData: { fontSize, fontColor }, rect, rotation, id, popupRef, richText, contentsObj, creationDate, modificationDate }, textContent, textPosition, parent: { page: { pageNumber } } } = data;\n            if (!textContent || textContent.length === 0) {\n                return null;\n            }\n            initialData = data = {\n                annotationType: AnnotationEditorType.FREETEXT,\n                color: Array.from(fontColor),\n                fontSize,\n                value: textContent.join(\"\\n\"),\n                position: textPosition,\n                pageIndex: pageNumber - 1,\n                rect: rect.slice(0),\n                rotation,\n                annotationElementId: id,\n                id,\n                deleted: false,\n                popupRef,\n                comment: contentsObj?.str || null,\n                richText,\n                creationDate,\n                modificationDate\n            };\n        }\n        const editor = await super.deserialize(data, parent, uiManager);\n        editor.#fontSize = data.fontSize;\n        editor.color = Util.makeHexColor(...data.color);\n        editor.#content = FreeTextEditor.#deserializeContent(data.value);\n        editor._initialData = initialData;\n        if (data.comment) {\n            editor.setCommentData(data);\n        }\n        return editor;\n    }\n    serialize(isForCopying = false) {\n        if (this.isEmpty()) {\n            return null;\n        }\n        if (this.deleted) {\n            return this.serializeDeleted();\n        }\n        const color = AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : this.color);\n        const serialized = Object.assign(super.serialize(isForCopying), {\n            color,\n            fontSize: this.#fontSize,\n            value: this.#serializeContent()\n        });\n        this.addComment(serialized);\n        if (isForCopying) {\n            serialized.isCopy = true;\n            return serialized;\n        }\n        if (this.annotationElementId && !this.#hasElementChanged(serialized)) {\n            return null;\n        }\n        serialized.id = this.annotationElementId;\n        return serialized;\n    }\n    #hasElementChanged(serialized) {\n        const { value: value1, fontSize, color, pageIndex } = this._initialData;\n        return this.hasEditedComment || this._hasBeenMoved || serialized.value !== value1 || serialized.fontSize !== fontSize || serialized.color.some((c, i)=>c !== color[i]) || serialized.pageIndex !== pageIndex;\n    }\n    renderAnnotationElement(annotation) {\n        const content = super.renderAnnotationElement(annotation);\n        if (!content) {\n            return null;\n        }\n        const { style } = content;\n        style.fontSize = `calc(${this.#fontSize}px * var(--total-scale-factor))`;\n        style.color = this.color;\n        content.replaceChildren();\n        for (const line of this.#content.split(\"\\n\")){\n            const div = document.createElement(\"div\");\n            div.append(line ? document.createTextNode(line) : document.createElement(\"br\"));\n            content.append(div);\n        }\n        annotation.updateEdited({\n            rect: this.getPDFRect(),\n            popup: this._uiManager.hasCommentManager() || this.hasEditedComment ? this.comment : {\n                text: this.#content\n            }\n        });\n        return content;\n    }\n    resetAnnotationElement(annotation) {\n        super.resetAnnotationElement(annotation);\n        annotation.resetEdited();\n    }\n}\nclass Outline {\n    static{\n        this.PRECISION = 1e-4;\n    }\n    toSVGPath() {\n        unreachable(\"Abstract method `toSVGPath` must be implemented.\");\n    }\n    get box() {\n        unreachable(\"Abstract getter `box` must be implemented.\");\n    }\n    serialize(_bbox, _rotation) {\n        unreachable(\"Abstract method `serialize` must be implemented.\");\n    }\n    static _rescale(src, tx, ty, sx, sy, dest) {\n        dest ||= new Float32Array(src.length);\n        for(let i = 0, ii = src.length; i < ii; i += 2){\n            dest[i] = tx + src[i] * sx;\n            dest[i + 1] = ty + src[i + 1] * sy;\n        }\n        return dest;\n    }\n    static _rescaleAndSwap(src, tx, ty, sx, sy, dest) {\n        dest ||= new Float32Array(src.length);\n        for(let i = 0, ii = src.length; i < ii; i += 2){\n            dest[i] = tx + src[i + 1] * sx;\n            dest[i + 1] = ty + src[i] * sy;\n        }\n        return dest;\n    }\n    static _translate(src, tx, ty, dest) {\n        dest ||= new Float32Array(src.length);\n        for(let i = 0, ii = src.length; i < ii; i += 2){\n            dest[i] = tx + src[i];\n            dest[i + 1] = ty + src[i + 1];\n        }\n        return dest;\n    }\n    static svgRound(x) {\n        return Math.round(x * 1e4);\n    }\n    static _normalizePoint(x, y, parentWidth, parentHeight, rotation) {\n        switch(rotation){\n            case 90:\n                return [\n                    1 - y / parentWidth,\n                    x / parentHeight\n                ];\n            case 180:\n                return [\n                    1 - x / parentWidth,\n                    1 - y / parentHeight\n                ];\n            case 270:\n                return [\n                    y / parentWidth,\n                    1 - x / parentHeight\n                ];\n            default:\n                return [\n                    x / parentWidth,\n                    y / parentHeight\n                ];\n        }\n    }\n    static _normalizePagePoint(x, y, rotation) {\n        switch(rotation){\n            case 90:\n                return [\n                    1 - y,\n                    x\n                ];\n            case 180:\n                return [\n                    1 - x,\n                    1 - y\n                ];\n            case 270:\n                return [\n                    y,\n                    1 - x\n                ];\n            default:\n                return [\n                    x,\n                    y\n                ];\n        }\n    }\n    static createBezierPoints(x1, y1, x2, y2, x3, y3) {\n        return [\n            (x1 + 5 * x2) / 6,\n            (y1 + 5 * y2) / 6,\n            (5 * x2 + x3) / 6,\n            (5 * y2 + y3) / 6,\n            (x2 + x3) / 2,\n            (y2 + y3) / 2\n        ];\n    }\n}\nclass FreeDrawOutliner {\n    #box;\n    #bottom;\n    #innerMargin;\n    #isLTR;\n    #top;\n    #last;\n    #lastX;\n    #lastY;\n    #min;\n    #min_dist;\n    #scaleFactor;\n    #thickness;\n    #points;\n    static #MIN_DIST = 8;\n    static #MIN_DIFF = 2;\n    static #MIN = FreeDrawOutliner.#MIN_DIST + FreeDrawOutliner.#MIN_DIFF;\n    constructor({ x, y }, box, scaleFactor, thickness, isLTR, innerMargin = 0){\n        this.#bottom = [];\n        this.#top = [];\n        this.#last = new Float32Array(18);\n        this.#points = [];\n        this.#box = box;\n        this.#thickness = thickness * scaleFactor;\n        this.#isLTR = isLTR;\n        this.#last.set([\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            x,\n            y\n        ], 6);\n        this.#innerMargin = innerMargin;\n        this.#min_dist = FreeDrawOutliner.#MIN_DIST * scaleFactor;\n        this.#min = FreeDrawOutliner.#MIN * scaleFactor;\n        this.#scaleFactor = scaleFactor;\n        this.#points.push(x, y);\n    }\n    isEmpty() {\n        return isNaN(this.#last[8]);\n    }\n    #getLastCoords() {\n        const lastTop = this.#last.subarray(4, 6);\n        const lastBottom = this.#last.subarray(16, 18);\n        const [x, y, width, height] = this.#box;\n        return [\n            (this.#lastX + (lastTop[0] - lastBottom[0]) / 2 - x) / width,\n            (this.#lastY + (lastTop[1] - lastBottom[1]) / 2 - y) / height,\n            (this.#lastX + (lastBottom[0] - lastTop[0]) / 2 - x) / width,\n            (this.#lastY + (lastBottom[1] - lastTop[1]) / 2 - y) / height\n        ];\n    }\n    add({ x, y }) {\n        this.#lastX = x;\n        this.#lastY = y;\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        let [x1, y1, x2, y2] = this.#last.subarray(8, 12);\n        const diffX = x - x2;\n        const diffY = y - y2;\n        const d = Math.hypot(diffX, diffY);\n        if (d < this.#min) {\n            return false;\n        }\n        const diffD = d - this.#min_dist;\n        const K = diffD / d;\n        const shiftX = K * diffX;\n        const shiftY = K * diffY;\n        let x0 = x1;\n        let y0 = y1;\n        x1 = x2;\n        y1 = y2;\n        x2 += shiftX;\n        y2 += shiftY;\n        this.#points?.push(x, y);\n        const nX = -shiftY / diffD;\n        const nY = shiftX / diffD;\n        const thX = nX * this.#thickness;\n        const thY = nY * this.#thickness;\n        this.#last.set(this.#last.subarray(2, 8), 0);\n        this.#last.set([\n            x2 + thX,\n            y2 + thY\n        ], 4);\n        this.#last.set(this.#last.subarray(14, 18), 12);\n        this.#last.set([\n            x2 - thX,\n            y2 - thY\n        ], 16);\n        if (isNaN(this.#last[6])) {\n            if (this.#top.length === 0) {\n                this.#last.set([\n                    x1 + thX,\n                    y1 + thY\n                ], 2);\n                this.#top.push(NaN, NaN, NaN, NaN, (x1 + thX - layerX) / layerWidth, (y1 + thY - layerY) / layerHeight);\n                this.#last.set([\n                    x1 - thX,\n                    y1 - thY\n                ], 14);\n                this.#bottom.push(NaN, NaN, NaN, NaN, (x1 - thX - layerX) / layerWidth, (y1 - thY - layerY) / layerHeight);\n            }\n            this.#last.set([\n                x0,\n                y0,\n                x1,\n                y1,\n                x2,\n                y2\n            ], 6);\n            return !this.isEmpty();\n        }\n        this.#last.set([\n            x0,\n            y0,\n            x1,\n            y1,\n            x2,\n            y2\n        ], 6);\n        const angle = Math.abs(Math.atan2(y0 - y1, x0 - x1) - Math.atan2(shiftY, shiftX));\n        if (angle < Math.PI / 2) {\n            [x1, y1, x2, y2] = this.#last.subarray(2, 6);\n            this.#top.push(NaN, NaN, NaN, NaN, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);\n            [x1, y1, x0, y0] = this.#last.subarray(14, 18);\n            this.#bottom.push(NaN, NaN, NaN, NaN, ((x0 + x1) / 2 - layerX) / layerWidth, ((y0 + y1) / 2 - layerY) / layerHeight);\n            return true;\n        }\n        [x0, y0, x1, y1, x2, y2] = this.#last.subarray(0, 6);\n        this.#top.push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x2) / 6 - layerX) / layerWidth, ((5 * y1 + y2) / 6 - layerY) / layerHeight, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);\n        [x2, y2, x1, y1, x0, y0] = this.#last.subarray(12, 18);\n        this.#bottom.push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x2) / 6 - layerX) / layerWidth, ((5 * y1 + y2) / 6 - layerY) / layerHeight, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);\n        return true;\n    }\n    toSVGPath() {\n        if (this.isEmpty()) {\n            return \"\";\n        }\n        const top = this.#top;\n        const bottom = this.#bottom;\n        if (isNaN(this.#last[6]) && !this.isEmpty()) {\n            return this.#toSVGPathTwoPoints();\n        }\n        const buffer = [];\n        buffer.push(`M${top[4]} ${top[5]}`);\n        for(let i = 6; i < top.length; i += 6){\n            if (isNaN(top[i])) {\n                buffer.push(`L${top[i + 4]} ${top[i + 5]}`);\n            } else {\n                buffer.push(`C${top[i]} ${top[i + 1]} ${top[i + 2]} ${top[i + 3]} ${top[i + 4]} ${top[i + 5]}`);\n            }\n        }\n        this.#toSVGPathEnd(buffer);\n        for(let i = bottom.length - 6; i >= 6; i -= 6){\n            if (isNaN(bottom[i])) {\n                buffer.push(`L${bottom[i + 4]} ${bottom[i + 5]}`);\n            } else {\n                buffer.push(`C${bottom[i]} ${bottom[i + 1]} ${bottom[i + 2]} ${bottom[i + 3]} ${bottom[i + 4]} ${bottom[i + 5]}`);\n            }\n        }\n        this.#toSVGPathStart(buffer);\n        return buffer.join(\" \");\n    }\n    #toSVGPathTwoPoints() {\n        const [x, y, width, height] = this.#box;\n        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n        return `M${(this.#last[2] - x) / width} ${(this.#last[3] - y) / height} L${(this.#last[4] - x) / width} ${(this.#last[5] - y) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(this.#last[16] - x) / width} ${(this.#last[17] - y) / height} L${(this.#last[14] - x) / width} ${(this.#last[15] - y) / height} Z`;\n    }\n    #toSVGPathStart(buffer) {\n        const bottom = this.#bottom;\n        buffer.push(`L${bottom[4]} ${bottom[5]} Z`);\n    }\n    #toSVGPathEnd(buffer) {\n        const [x, y, width, height] = this.#box;\n        const lastTop = this.#last.subarray(4, 6);\n        const lastBottom = this.#last.subarray(16, 18);\n        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n        buffer.push(`L${(lastTop[0] - x) / width} ${(lastTop[1] - y) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(lastBottom[0] - x) / width} ${(lastBottom[1] - y) / height}`);\n    }\n    newFreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR) {\n        return new FreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR);\n    }\n    getOutlines() {\n        const top = this.#top;\n        const bottom = this.#bottom;\n        const last = this.#last;\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        const points = new Float32Array((this.#points?.length ?? 0) + 2);\n        for(let i = 0, ii = points.length - 2; i < ii; i += 2){\n            points[i] = (this.#points[i] - layerX) / layerWidth;\n            points[i + 1] = (this.#points[i + 1] - layerY) / layerHeight;\n        }\n        points[points.length - 2] = (this.#lastX - layerX) / layerWidth;\n        points[points.length - 1] = (this.#lastY - layerY) / layerHeight;\n        if (isNaN(last[6]) && !this.isEmpty()) {\n            return this.#getOutlineTwoPoints(points);\n        }\n        const outline = new Float32Array(this.#top.length + 24 + this.#bottom.length);\n        let N = top.length;\n        for(let i = 0; i < N; i += 2){\n            if (isNaN(top[i])) {\n                outline[i] = outline[i + 1] = NaN;\n                continue;\n            }\n            outline[i] = top[i];\n            outline[i + 1] = top[i + 1];\n        }\n        N = this.#getOutlineEnd(outline, N);\n        for(let i = bottom.length - 6; i >= 6; i -= 6){\n            for(let j = 0; j < 6; j += 2){\n                if (isNaN(bottom[i + j])) {\n                    outline[N] = outline[N + 1] = NaN;\n                    N += 2;\n                    continue;\n                }\n                outline[N] = bottom[i + j];\n                outline[N + 1] = bottom[i + j + 1];\n                N += 2;\n            }\n        }\n        this.#getOutlineStart(outline, N);\n        return this.newFreeDrawOutline(outline, points, this.#box, this.#scaleFactor, this.#innerMargin, this.#isLTR);\n    }\n    #getOutlineTwoPoints(points) {\n        const last = this.#last;\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n        const outline = new Float32Array(36);\n        outline.set([\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (last[2] - layerX) / layerWidth,\n            (last[3] - layerY) / layerHeight,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (last[4] - layerX) / layerWidth,\n            (last[5] - layerY) / layerHeight,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            lastTopX,\n            lastTopY,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            lastBottomX,\n            lastBottomY,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (last[16] - layerX) / layerWidth,\n            (last[17] - layerY) / layerHeight,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (last[14] - layerX) / layerWidth,\n            (last[15] - layerY) / layerHeight\n        ], 0);\n        return this.newFreeDrawOutline(outline, points, this.#box, this.#scaleFactor, this.#innerMargin, this.#isLTR);\n    }\n    #getOutlineStart(outline, pos) {\n        const bottom = this.#bottom;\n        outline.set([\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            bottom[4],\n            bottom[5]\n        ], pos);\n        return pos += 6;\n    }\n    #getOutlineEnd(outline, pos) {\n        const lastTop = this.#last.subarray(4, 6);\n        const lastBottom = this.#last.subarray(16, 18);\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n        outline.set([\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (lastTop[0] - layerX) / layerWidth,\n            (lastTop[1] - layerY) / layerHeight,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            lastTopX,\n            lastTopY,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            lastBottomX,\n            lastBottomY,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (lastBottom[0] - layerX) / layerWidth,\n            (lastBottom[1] - layerY) / layerHeight\n        ], pos);\n        return pos += 24;\n    }\n}\nclass FreeDrawOutline extends Outline {\n    #box;\n    #bbox;\n    #innerMargin;\n    #isLTR;\n    #points;\n    #scaleFactor;\n    #outline;\n    constructor(outline, points, box, scaleFactor, innerMargin, isLTR){\n        super();\n        this.#bbox = new Float32Array(4);\n        this.#outline = outline;\n        this.#points = points;\n        this.#box = box;\n        this.#scaleFactor = scaleFactor;\n        this.#innerMargin = innerMargin;\n        this.#isLTR = isLTR;\n        this.firstPoint = [\n            NaN,\n            NaN\n        ];\n        this.lastPoint = [\n            NaN,\n            NaN\n        ];\n        this.#computeMinMax(isLTR);\n        const [x, y, width, height] = this.#bbox;\n        for(let i = 0, ii = outline.length; i < ii; i += 2){\n            outline[i] = (outline[i] - x) / width;\n            outline[i + 1] = (outline[i + 1] - y) / height;\n        }\n        for(let i = 0, ii = points.length; i < ii; i += 2){\n            points[i] = (points[i] - x) / width;\n            points[i + 1] = (points[i + 1] - y) / height;\n        }\n    }\n    toSVGPath() {\n        const buffer = [\n            `M${this.#outline[4]} ${this.#outline[5]}`\n        ];\n        for(let i = 6, ii = this.#outline.length; i < ii; i += 6){\n            if (isNaN(this.#outline[i])) {\n                buffer.push(`L${this.#outline[i + 4]} ${this.#outline[i + 5]}`);\n                continue;\n            }\n            buffer.push(`C${this.#outline[i]} ${this.#outline[i + 1]} ${this.#outline[i + 2]} ${this.#outline[i + 3]} ${this.#outline[i + 4]} ${this.#outline[i + 5]}`);\n        }\n        buffer.push(\"Z\");\n        return buffer.join(\" \");\n    }\n    serialize([blX, blY, trX, trY], rotation) {\n        const width = trX - blX;\n        const height = trY - blY;\n        let outline;\n        let points;\n        switch(rotation){\n            case 0:\n                outline = Outline._rescale(this.#outline, blX, trY, width, -height);\n                points = Outline._rescale(this.#points, blX, trY, width, -height);\n                break;\n            case 90:\n                outline = Outline._rescaleAndSwap(this.#outline, blX, blY, width, height);\n                points = Outline._rescaleAndSwap(this.#points, blX, blY, width, height);\n                break;\n            case 180:\n                outline = Outline._rescale(this.#outline, trX, blY, -width, height);\n                points = Outline._rescale(this.#points, trX, blY, -width, height);\n                break;\n            case 270:\n                outline = Outline._rescaleAndSwap(this.#outline, trX, trY, -width, -height);\n                points = Outline._rescaleAndSwap(this.#points, trX, trY, -width, -height);\n                break;\n        }\n        return {\n            outline: Array.from(outline),\n            points: [\n                Array.from(points)\n            ]\n        };\n    }\n    #computeMinMax(isLTR) {\n        const outline = this.#outline;\n        let lastX = outline[4];\n        let lastY = outline[5];\n        const minMax = [\n            lastX,\n            lastY,\n            lastX,\n            lastY\n        ];\n        let firstPointX = lastX;\n        let firstPointY = lastY;\n        let lastPointX = lastX;\n        let lastPointY = lastY;\n        const ltrCallback = isLTR ? Math.max : Math.min;\n        const bezierBbox = new Float32Array(4);\n        for(let i = 6, ii = outline.length; i < ii; i += 6){\n            const x = outline[i + 4], y = outline[i + 5];\n            if (isNaN(outline[i])) {\n                Util.pointBoundingBox(x, y, minMax);\n                if (firstPointY > y) {\n                    firstPointX = x;\n                    firstPointY = y;\n                } else if (firstPointY === y) {\n                    firstPointX = ltrCallback(firstPointX, x);\n                }\n                if (lastPointY < y) {\n                    lastPointX = x;\n                    lastPointY = y;\n                } else if (lastPointY === y) {\n                    lastPointX = ltrCallback(lastPointX, x);\n                }\n            } else {\n                bezierBbox[0] = bezierBbox[1] = Infinity;\n                bezierBbox[2] = bezierBbox[3] = -Infinity;\n                Util.bezierBoundingBox(lastX, lastY, ...outline.slice(i, i + 6), bezierBbox);\n                Util.rectBoundingBox(bezierBbox[0], bezierBbox[1], bezierBbox[2], bezierBbox[3], minMax);\n                if (firstPointY > bezierBbox[1]) {\n                    firstPointX = bezierBbox[0];\n                    firstPointY = bezierBbox[1];\n                } else if (firstPointY === bezierBbox[1]) {\n                    firstPointX = ltrCallback(firstPointX, bezierBbox[0]);\n                }\n                if (lastPointY < bezierBbox[3]) {\n                    lastPointX = bezierBbox[2];\n                    lastPointY = bezierBbox[3];\n                } else if (lastPointY === bezierBbox[3]) {\n                    lastPointX = ltrCallback(lastPointX, bezierBbox[2]);\n                }\n            }\n            lastX = x;\n            lastY = y;\n        }\n        const bbox = this.#bbox;\n        bbox[0] = minMax[0] - this.#innerMargin;\n        bbox[1] = minMax[1] - this.#innerMargin;\n        bbox[2] = minMax[2] - minMax[0] + 2 * this.#innerMargin;\n        bbox[3] = minMax[3] - minMax[1] + 2 * this.#innerMargin;\n        this.firstPoint = [\n            firstPointX,\n            firstPointY\n        ];\n        this.lastPoint = [\n            lastPointX,\n            lastPointY\n        ];\n    }\n    get box() {\n        return this.#bbox;\n    }\n    newOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin = 0) {\n        return new FreeDrawOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin);\n    }\n    getNewOutline(thickness, innerMargin) {\n        const [x, y, width, height] = this.#bbox;\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        const sx = width * layerWidth;\n        const sy = height * layerHeight;\n        const tx = x * layerWidth + layerX;\n        const ty = y * layerHeight + layerY;\n        const outliner = this.newOutliner({\n            x: this.#points[0] * sx + tx,\n            y: this.#points[1] * sy + ty\n        }, this.#box, this.#scaleFactor, thickness, this.#isLTR, innerMargin ?? this.#innerMargin);\n        for(let i = 2; i < this.#points.length; i += 2){\n            outliner.add({\n                x: this.#points[i] * sx + tx,\n                y: this.#points[i + 1] * sy + ty\n            });\n        }\n        return outliner.getOutlines();\n    }\n}\nclass HighlightOutliner {\n    #box;\n    #firstPoint;\n    #lastPoint;\n    #verticalEdges;\n    #intervals;\n    constructor(boxes, borderWidth = 0, innerMargin = 0, isLTR = true){\n        this.#verticalEdges = [];\n        this.#intervals = [];\n        const minMax = [\n            Infinity,\n            Infinity,\n            -Infinity,\n            -Infinity\n        ];\n        const EPSILON = 10 ** -4;\n        for (const { x, y, width, height } of boxes){\n            const x1 = Math.floor((x - borderWidth) / EPSILON) * EPSILON;\n            const x2 = Math.ceil((x + width + borderWidth) / EPSILON) * EPSILON;\n            const y1 = Math.floor((y - borderWidth) / EPSILON) * EPSILON;\n            const y2 = Math.ceil((y + height + borderWidth) / EPSILON) * EPSILON;\n            const left = [\n                x1,\n                y1,\n                y2,\n                true\n            ];\n            const right = [\n                x2,\n                y1,\n                y2,\n                false\n            ];\n            this.#verticalEdges.push(left, right);\n            Util.rectBoundingBox(x1, y1, x2, y2, minMax);\n        }\n        const bboxWidth = minMax[2] - minMax[0] + 2 * innerMargin;\n        const bboxHeight = minMax[3] - minMax[1] + 2 * innerMargin;\n        const shiftedMinX = minMax[0] - innerMargin;\n        const shiftedMinY = minMax[1] - innerMargin;\n        let firstPointX = isLTR ? -Infinity : Infinity;\n        let firstPointY = Infinity;\n        const lastEdge = this.#verticalEdges.at(isLTR ? -1 : -2);\n        const lastPoint = [\n            lastEdge[0],\n            lastEdge[2]\n        ];\n        for (const edge of this.#verticalEdges){\n            const [x, y1, y2, left] = edge;\n            if (!left && isLTR) {\n                if (y1 < firstPointY) {\n                    firstPointY = y1;\n                    firstPointX = x;\n                } else if (y1 === firstPointY) {\n                    firstPointX = Math.max(firstPointX, x);\n                }\n            } else if (left && !isLTR) {\n                if (y1 < firstPointY) {\n                    firstPointY = y1;\n                    firstPointX = x;\n                } else if (y1 === firstPointY) {\n                    firstPointX = Math.min(firstPointX, x);\n                }\n            }\n            edge[0] = (x - shiftedMinX) / bboxWidth;\n            edge[1] = (y1 - shiftedMinY) / bboxHeight;\n            edge[2] = (y2 - shiftedMinY) / bboxHeight;\n        }\n        this.#box = new Float32Array([\n            shiftedMinX,\n            shiftedMinY,\n            bboxWidth,\n            bboxHeight\n        ]);\n        this.#firstPoint = [\n            firstPointX,\n            firstPointY\n        ];\n        this.#lastPoint = lastPoint;\n    }\n    getOutlines() {\n        this.#verticalEdges.sort((a, b)=>a[0] - b[0] || a[1] - b[1] || a[2] - b[2]);\n        const outlineVerticalEdges = [];\n        for (const edge of this.#verticalEdges){\n            if (edge[3]) {\n                outlineVerticalEdges.push(...this.#breakEdge(edge));\n                this.#insert(edge);\n            } else {\n                this.#remove(edge);\n                outlineVerticalEdges.push(...this.#breakEdge(edge));\n            }\n        }\n        return this.#getOutlines(outlineVerticalEdges);\n    }\n    #getOutlines(outlineVerticalEdges) {\n        const edges = [];\n        const allEdges = /* @__PURE__ */ new Set();\n        for (const edge of outlineVerticalEdges){\n            const [x, y1, y2] = edge;\n            edges.push([\n                x,\n                y1,\n                edge\n            ], [\n                x,\n                y2,\n                edge\n            ]);\n        }\n        edges.sort((a, b)=>a[1] - b[1] || a[0] - b[0]);\n        for(let i = 0, ii = edges.length; i < ii; i += 2){\n            const edge1 = edges[i][2];\n            const edge2 = edges[i + 1][2];\n            edge1.push(edge2);\n            edge2.push(edge1);\n            allEdges.add(edge1);\n            allEdges.add(edge2);\n        }\n        const outlines = [];\n        let outline;\n        while(allEdges.size > 0){\n            const edge = allEdges.values().next().value;\n            let [x, y1, y2, edge1, edge2] = edge;\n            allEdges.delete(edge);\n            let lastPointX = x;\n            let lastPointY = y1;\n            outline = [\n                x,\n                y2\n            ];\n            outlines.push(outline);\n            while(true){\n                let e;\n                if (allEdges.has(edge1)) {\n                    e = edge1;\n                } else if (allEdges.has(edge2)) {\n                    e = edge2;\n                } else {\n                    break;\n                }\n                allEdges.delete(e);\n                [x, y1, y2, edge1, edge2] = e;\n                if (lastPointX !== x) {\n                    outline.push(lastPointX, lastPointY, x, lastPointY === y1 ? y1 : y2);\n                    lastPointX = x;\n                }\n                lastPointY = lastPointY === y1 ? y2 : y1;\n            }\n            outline.push(lastPointX, lastPointY);\n        }\n        return new HighlightOutline(outlines, this.#box, this.#firstPoint, this.#lastPoint);\n    }\n    #binarySearch(y) {\n        const array = this.#intervals;\n        let start = 0;\n        let end = array.length - 1;\n        while(start <= end){\n            const middle = start + end >> 1;\n            const y1 = array[middle][0];\n            if (y1 === y) {\n                return middle;\n            }\n            if (y1 < y) {\n                start = middle + 1;\n            } else {\n                end = middle - 1;\n            }\n        }\n        return end + 1;\n    }\n    #insert([, y1, y2]) {\n        const index = this.#binarySearch(y1);\n        this.#intervals.splice(index, 0, [\n            y1,\n            y2\n        ]);\n    }\n    #remove([, y1, y2]) {\n        const index = this.#binarySearch(y1);\n        for(let i = index; i < this.#intervals.length; i++){\n            const [start, end] = this.#intervals[i];\n            if (start !== y1) {\n                break;\n            }\n            if (start === y1 && end === y2) {\n                this.#intervals.splice(i, 1);\n                return;\n            }\n        }\n        for(let i = index - 1; i >= 0; i--){\n            const [start, end] = this.#intervals[i];\n            if (start !== y1) {\n                break;\n            }\n            if (start === y1 && end === y2) {\n                this.#intervals.splice(i, 1);\n                return;\n            }\n        }\n    }\n    #breakEdge(edge) {\n        const [x, y1, y2] = edge;\n        const results = [\n            [\n                x,\n                y1,\n                y2\n            ]\n        ];\n        const index = this.#binarySearch(y2);\n        for(let i = 0; i < index; i++){\n            const [start, end] = this.#intervals[i];\n            for(let j = 0, jj = results.length; j < jj; j++){\n                const [, y3, y4] = results[j];\n                if (end <= y3 || y4 <= start) {\n                    continue;\n                }\n                if (y3 >= start) {\n                    if (y4 > end) {\n                        results[j][1] = end;\n                    } else {\n                        if (jj === 1) {\n                            return [];\n                        }\n                        results.splice(j, 1);\n                        j--;\n                        jj--;\n                    }\n                    continue;\n                }\n                results[j][2] = start;\n                if (y4 > end) {\n                    results.push([\n                        x,\n                        end,\n                        y4\n                    ]);\n                }\n            }\n        }\n        return results;\n    }\n}\nclass HighlightOutline extends Outline {\n    #box;\n    #outlines;\n    constructor(outlines, box, firstPoint, lastPoint){\n        super();\n        this.#outlines = outlines;\n        this.#box = box;\n        this.firstPoint = firstPoint;\n        this.lastPoint = lastPoint;\n    }\n    toSVGPath() {\n        const buffer = [];\n        for (const polygon of this.#outlines){\n            let [prevX, prevY] = polygon;\n            buffer.push(`M${prevX} ${prevY}`);\n            for(let i = 2; i < polygon.length; i += 2){\n                const x = polygon[i];\n                const y = polygon[i + 1];\n                if (x === prevX) {\n                    buffer.push(`V${y}`);\n                    prevY = y;\n                } else if (y === prevY) {\n                    buffer.push(`H${x}`);\n                    prevX = x;\n                }\n            }\n            buffer.push(\"Z\");\n        }\n        return buffer.join(\" \");\n    }\n    serialize([blX, blY, trX, trY], _rotation) {\n        const outlines = [];\n        const width = trX - blX;\n        const height = trY - blY;\n        for (const outline of this.#outlines){\n            const points = new Array(outline.length);\n            for(let i = 0; i < outline.length; i += 2){\n                points[i] = blX + outline[i] * width;\n                points[i + 1] = trY - outline[i + 1] * height;\n            }\n            outlines.push(points);\n        }\n        return outlines;\n    }\n    get box() {\n        return this.#box;\n    }\n    get classNamesForOutlining() {\n        return [\n            \"highlightOutline\"\n        ];\n    }\n}\nclass FreeHighlightOutliner extends FreeDrawOutliner {\n    newFreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR) {\n        return new FreeHighlightOutline(outline, points, box, scaleFactor, innerMargin, isLTR);\n    }\n}\nclass FreeHighlightOutline extends FreeDrawOutline {\n    newOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin = 0) {\n        return new FreeHighlightOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin);\n    }\n}\nclass HighlightEditor extends AnnotationEditor {\n    #anchorNode;\n    #anchorOffset;\n    #boxes;\n    #clipPathId;\n    #colorPicker;\n    #focusOutlines;\n    #focusNode;\n    #focusOffset;\n    #highlightDiv;\n    #highlightOutlines;\n    #id;\n    #isFreeHighlight;\n    #firstPoint;\n    #lastPoint;\n    #outlineId;\n    #text;\n    #thickness;\n    #methodOfCreation;\n    static{\n        this._defaultColor = null;\n    }\n    static{\n        this._defaultOpacity = 1;\n    }\n    static{\n        this._defaultThickness = 12;\n    }\n    static{\n        this._type = \"highlight\";\n    }\n    static{\n        this._editorType = AnnotationEditorType.HIGHLIGHT;\n    }\n    static{\n        this._freeHighlightId = -1;\n    }\n    static{\n        this._freeHighlight = null;\n    }\n    static{\n        this._freeHighlightClipId = \"\";\n    }\n    static get _keyboardManager() {\n        const proto = HighlightEditor.prototype;\n        return shadow(this, \"_keyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"ArrowLeft\",\n                    \"mac+ArrowLeft\"\n                ],\n                proto._moveCaret,\n                {\n                    args: [\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowRight\",\n                    \"mac+ArrowRight\"\n                ],\n                proto._moveCaret,\n                {\n                    args: [\n                        1\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"mac+ArrowUp\"\n                ],\n                proto._moveCaret,\n                {\n                    args: [\n                        2\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"mac+ArrowDown\"\n                ],\n                proto._moveCaret,\n                {\n                    args: [\n                        3\n                    ]\n                }\n            ]\n        ]));\n    }\n    constructor(params){\n        super({\n            ...params,\n            name: \"highlightEditor\"\n        });\n        this.#anchorNode = null;\n        this.#anchorOffset = 0;\n        this.#clipPathId = null;\n        this.#colorPicker = null;\n        this.#focusOutlines = null;\n        this.#focusNode = null;\n        this.#focusOffset = 0;\n        this.#highlightDiv = null;\n        this.#highlightOutlines = null;\n        this.#id = null;\n        this.#isFreeHighlight = false;\n        this.#firstPoint = null;\n        this.#lastPoint = null;\n        this.#outlineId = null;\n        this.#text = \"\";\n        this.#methodOfCreation = \"\";\n        this.color = params.color || HighlightEditor._defaultColor;\n        this.#thickness = params.thickness || HighlightEditor._defaultThickness;\n        this.opacity = params.opacity || HighlightEditor._defaultOpacity;\n        this.#boxes = params.boxes || null;\n        this.#methodOfCreation = params.methodOfCreation || \"\";\n        this.#text = params.text || \"\";\n        this._isDraggable = false;\n        this.defaultL10nId = \"pdfjs-editor-highlight-editor\";\n        if (params.highlightId > -1) {\n            this.#isFreeHighlight = true;\n            this.#createFreeOutlines(params);\n            this.#addToDrawLayer();\n        } else if (this.#boxes) {\n            this.#anchorNode = params.anchorNode;\n            this.#anchorOffset = params.anchorOffset;\n            this.#focusNode = params.focusNode;\n            this.#focusOffset = params.focusOffset;\n            this.#createOutlines();\n            this.#addToDrawLayer();\n            this.rotate(this.rotation);\n        }\n        if (!this.annotationElementId) {\n            this._uiManager.a11yAlert(\"pdfjs-editor-highlight-added-alert\");\n        }\n    }\n    get telemetryInitialData() {\n        return {\n            action: \"added\",\n            type: this.#isFreeHighlight ? \"free_highlight\" : \"highlight\",\n            color: this._uiManager.getNonHCMColorName(this.color),\n            thickness: this.#thickness,\n            methodOfCreation: this.#methodOfCreation\n        };\n    }\n    get telemetryFinalData() {\n        return {\n            type: \"highlight\",\n            color: this._uiManager.getNonHCMColorName(this.color)\n        };\n    }\n    static computeTelemetryFinalData(data) {\n        return {\n            numberOfColors: data.get(\"color\").size\n        };\n    }\n    #createOutlines() {\n        const outliner = new HighlightOutliner(this.#boxes, 1e-3);\n        this.#highlightOutlines = outliner.getOutlines();\n        [this.x, this.y, this.width, this.height] = this.#highlightOutlines.box;\n        const outlinerForOutline = new HighlightOutliner(this.#boxes, 25e-4, 1e-3, this._uiManager.direction === \"ltr\");\n        this.#focusOutlines = outlinerForOutline.getOutlines();\n        const { firstPoint } = this.#highlightOutlines;\n        this.#firstPoint = [\n            (firstPoint[0] - this.x) / this.width,\n            (firstPoint[1] - this.y) / this.height\n        ];\n        const { lastPoint } = this.#focusOutlines;\n        this.#lastPoint = [\n            (lastPoint[0] - this.x) / this.width,\n            (lastPoint[1] - this.y) / this.height\n        ];\n    }\n    #createFreeOutlines({ highlightOutlines, highlightId, clipPathId }) {\n        this.#highlightOutlines = highlightOutlines;\n        const extraThickness = 1.5;\n        this.#focusOutlines = highlightOutlines.getNewOutline(this.#thickness / 2 + extraThickness, 25e-4);\n        if (highlightId >= 0) {\n            this.#id = highlightId;\n            this.#clipPathId = clipPathId;\n            this.parent.drawLayer.finalizeDraw(highlightId, {\n                bbox: highlightOutlines.box,\n                path: {\n                    d: highlightOutlines.toSVGPath()\n                }\n            });\n            this.#outlineId = this.parent.drawLayer.drawOutline({\n                rootClass: {\n                    highlightOutline: true,\n                    free: true\n                },\n                bbox: this.#focusOutlines.box,\n                path: {\n                    d: this.#focusOutlines.toSVGPath()\n                }\n            }, true);\n        } else if (this.parent) {\n            const angle = this.parent.viewport.rotation;\n            this.parent.drawLayer.updateProperties(this.#id, {\n                bbox: HighlightEditor.#rotateBbox(this.#highlightOutlines.box, (angle - this.rotation + 360) % 360),\n                path: {\n                    d: highlightOutlines.toSVGPath()\n                }\n            });\n            this.parent.drawLayer.updateProperties(this.#outlineId, {\n                bbox: HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle),\n                path: {\n                    d: this.#focusOutlines.toSVGPath()\n                }\n            });\n        }\n        const [x, y, width, height] = highlightOutlines.box;\n        switch(this.rotation){\n            case 0:\n                this.x = x;\n                this.y = y;\n                this.width = width;\n                this.height = height;\n                break;\n            case 90:\n                {\n                    const [pageWidth, pageHeight] = this.parentDimensions;\n                    this.x = y;\n                    this.y = 1 - x;\n                    this.width = width * pageHeight / pageWidth;\n                    this.height = height * pageWidth / pageHeight;\n                    break;\n                }\n            case 180:\n                this.x = 1 - x;\n                this.y = 1 - y;\n                this.width = width;\n                this.height = height;\n                break;\n            case 270:\n                {\n                    const [pageWidth, pageHeight] = this.parentDimensions;\n                    this.x = 1 - y;\n                    this.y = x;\n                    this.width = width * pageHeight / pageWidth;\n                    this.height = height * pageWidth / pageHeight;\n                    break;\n                }\n        }\n        const { firstPoint } = highlightOutlines;\n        this.#firstPoint = [\n            (firstPoint[0] - x) / width,\n            (firstPoint[1] - y) / height\n        ];\n        const { lastPoint } = this.#focusOutlines;\n        this.#lastPoint = [\n            (lastPoint[0] - x) / width,\n            (lastPoint[1] - y) / height\n        ];\n    }\n    static initialize(l10n, uiManager) {\n        AnnotationEditor.initialize(l10n, uiManager);\n        HighlightEditor._defaultColor ||= uiManager.highlightColors?.values().next().value || \"#fff066\";\n    }\n    static updateDefaultParams(type, value1) {\n        switch(type){\n            case AnnotationEditorParamsType.HIGHLIGHT_COLOR:\n                HighlightEditor._defaultColor = value1;\n                break;\n            case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:\n                HighlightEditor._defaultThickness = value1;\n                break;\n        }\n    }\n    translateInPage(x, y) {}\n    get toolbarPosition() {\n        return this.#lastPoint;\n    }\n    get commentButtonPosition() {\n        return this.#firstPoint;\n    }\n    updateParams(type, value1) {\n        switch(type){\n            case AnnotationEditorParamsType.HIGHLIGHT_COLOR:\n                this.#updateColor(value1);\n                break;\n            case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:\n                this.#updateThickness(value1);\n                break;\n        }\n    }\n    static get defaultPropertiesToUpdate() {\n        return [\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_COLOR,\n                HighlightEditor._defaultColor\n            ],\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_THICKNESS,\n                HighlightEditor._defaultThickness\n            ]\n        ];\n    }\n    get propertiesToUpdate() {\n        return [\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_COLOR,\n                this.color || HighlightEditor._defaultColor\n            ],\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_THICKNESS,\n                this.#thickness || HighlightEditor._defaultThickness\n            ],\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_FREE,\n                this.#isFreeHighlight\n            ]\n        ];\n    }\n    onUpdatedColor() {\n        this.parent?.drawLayer.updateProperties(this.#id, {\n            root: {\n                fill: this.color,\n                \"fill-opacity\": this.opacity\n            }\n        });\n        this.#colorPicker?.updateColor(this.color);\n        super.onUpdatedColor();\n    }\n    #updateColor(color) {\n        const setColorAndOpacity = (col, opa)=>{\n            this.color = col;\n            this.opacity = opa;\n            this.onUpdatedColor();\n        };\n        const savedColor = this.color;\n        const savedOpacity = this.opacity;\n        this.addCommands({\n            cmd: setColorAndOpacity.bind(this, color, HighlightEditor._defaultOpacity),\n            undo: setColorAndOpacity.bind(this, savedColor, savedOpacity),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type: AnnotationEditorParamsType.HIGHLIGHT_COLOR,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n        this._reportTelemetry({\n            action: \"color_changed\",\n            color: this._uiManager.getNonHCMColorName(color)\n        }, true);\n    }\n    #updateThickness(thickness) {\n        const savedThickness = this.#thickness;\n        const setThickness = (th)=>{\n            this.#thickness = th;\n            this.#changeThickness(th);\n        };\n        this.addCommands({\n            cmd: setThickness.bind(this, thickness),\n            undo: setThickness.bind(this, savedThickness),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type: AnnotationEditorParamsType.INK_THICKNESS,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n        this._reportTelemetry({\n            action: \"thickness_changed\",\n            thickness\n        }, true);\n    }\n    get toolbarButtons() {\n        if (this._uiManager.highlightColors) {\n            const colorPicker = this.#colorPicker = new ColorPicker({\n                editor: this\n            });\n            return [\n                [\n                    \"colorPicker\",\n                    colorPicker\n                ]\n            ];\n        }\n        return super.toolbarButtons;\n    }\n    disableEditing() {\n        super.disableEditing();\n        this.div.classList.toggle(\"disabled\", true);\n    }\n    enableEditing() {\n        super.enableEditing();\n        this.div.classList.toggle(\"disabled\", false);\n    }\n    fixAndSetPosition() {\n        return super.fixAndSetPosition(this.#getRotation());\n    }\n    getBaseTranslation() {\n        return [\n            0,\n            0\n        ];\n    }\n    getRect(tx, ty) {\n        return super.getRect(tx, ty, this.#getRotation());\n    }\n    onceAdded(focus) {\n        if (!this.annotationElementId) {\n            this.parent.addUndoableEditor(this);\n        }\n        if (focus) {\n            this.div.focus();\n        }\n    }\n    remove() {\n        this.#cleanDrawLayer();\n        this._reportTelemetry({\n            action: \"deleted\"\n        });\n        super.remove();\n    }\n    rebuild() {\n        if (!this.parent) {\n            return;\n        }\n        super.rebuild();\n        if (this.div === null) {\n            return;\n        }\n        this.#addToDrawLayer();\n        if (!this.isAttachedToDOM) {\n            this.parent.add(this);\n        }\n    }\n    setParent(parent) {\n        let mustBeSelected = false;\n        if (this.parent && !parent) {\n            this.#cleanDrawLayer();\n        } else if (parent) {\n            this.#addToDrawLayer(parent);\n            mustBeSelected = !this.parent && this.div?.classList.contains(\"selectedEditor\");\n        }\n        super.setParent(parent);\n        this.show(this._isVisible);\n        if (mustBeSelected) {\n            this.select();\n        }\n    }\n    #changeThickness(thickness) {\n        if (!this.#isFreeHighlight) {\n            return;\n        }\n        this.#createFreeOutlines({\n            highlightOutlines: this.#highlightOutlines.getNewOutline(thickness / 2)\n        });\n        this.fixAndSetPosition();\n        this.setDims(this.width, this.height);\n    }\n    #cleanDrawLayer() {\n        if (this.#id === null || !this.parent) {\n            return;\n        }\n        this.parent.drawLayer.remove(this.#id);\n        this.#id = null;\n        this.parent.drawLayer.remove(this.#outlineId);\n        this.#outlineId = null;\n    }\n    #addToDrawLayer(parent = this.parent) {\n        if (this.#id !== null) {\n            return;\n        }\n        ({ id: this.#id, clipPathId: this.#clipPathId } = parent.drawLayer.draw({\n            bbox: this.#highlightOutlines.box,\n            root: {\n                viewBox: \"0 0 1 1\",\n                fill: this.color,\n                \"fill-opacity\": this.opacity\n            },\n            rootClass: {\n                highlight: true,\n                free: this.#isFreeHighlight\n            },\n            path: {\n                d: this.#highlightOutlines.toSVGPath()\n            }\n        }, false, true));\n        this.#outlineId = parent.drawLayer.drawOutline({\n            rootClass: {\n                highlightOutline: true,\n                free: this.#isFreeHighlight\n            },\n            bbox: this.#focusOutlines.box,\n            path: {\n                d: this.#focusOutlines.toSVGPath()\n            }\n        }, this.#isFreeHighlight);\n        if (this.#highlightDiv) {\n            this.#highlightDiv.style.clipPath = this.#clipPathId;\n        }\n    }\n    static #rotateBbox([x, y, width, height], angle) {\n        switch(angle){\n            case 90:\n                return [\n                    1 - y - height,\n                    x,\n                    height,\n                    width\n                ];\n            case 180:\n                return [\n                    1 - x - width,\n                    1 - y - height,\n                    width,\n                    height\n                ];\n            case 270:\n                return [\n                    y,\n                    1 - x - width,\n                    height,\n                    width\n                ];\n        }\n        return [\n            x,\n            y,\n            width,\n            height\n        ];\n    }\n    rotate(angle) {\n        const { drawLayer } = this.parent;\n        let box;\n        if (this.#isFreeHighlight) {\n            angle = (angle - this.rotation + 360) % 360;\n            box = HighlightEditor.#rotateBbox(this.#highlightOutlines.box, angle);\n        } else {\n            box = HighlightEditor.#rotateBbox([\n                this.x,\n                this.y,\n                this.width,\n                this.height\n            ], angle);\n        }\n        drawLayer.updateProperties(this.#id, {\n            bbox: box,\n            root: {\n                \"data-main-rotation\": angle\n            }\n        });\n        drawLayer.updateProperties(this.#outlineId, {\n            bbox: HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle),\n            root: {\n                \"data-main-rotation\": angle\n            }\n        });\n    }\n    render() {\n        if (this.div) {\n            return this.div;\n        }\n        const div = super.render();\n        if (this.#text) {\n            div.setAttribute(\"aria-label\", this.#text);\n            div.setAttribute(\"role\", \"mark\");\n        }\n        if (this.#isFreeHighlight) {\n            div.classList.add(\"free\");\n        } else {\n            this.div.addEventListener(\"keydown\", this.#keydown.bind(this), {\n                signal: this._uiManager._signal\n            });\n        }\n        const highlightDiv = this.#highlightDiv = document.createElement(\"div\");\n        div.append(highlightDiv);\n        highlightDiv.setAttribute(\"aria-hidden\", \"true\");\n        highlightDiv.className = \"internal\";\n        highlightDiv.style.clipPath = this.#clipPathId;\n        this.setDims(this.width, this.height);\n        bindEvents(this, this.#highlightDiv, [\n            \"pointerover\",\n            \"pointerleave\"\n        ]);\n        this.enableEditing();\n        return div;\n    }\n    pointerover() {\n        if (!this.isSelected) {\n            this.parent?.drawLayer.updateProperties(this.#outlineId, {\n                rootClass: {\n                    hovered: true\n                }\n            });\n        }\n    }\n    pointerleave() {\n        if (!this.isSelected) {\n            this.parent?.drawLayer.updateProperties(this.#outlineId, {\n                rootClass: {\n                    hovered: false\n                }\n            });\n        }\n    }\n    #keydown(event) {\n        HighlightEditor._keyboardManager.exec(this, event);\n    }\n    _moveCaret(direction) {\n        this.parent.unselect(this);\n        switch(direction){\n            case 0:\n            case 2:\n                this.#setCaret(true);\n                break;\n            case 1:\n            case 3:\n                this.#setCaret(false);\n                break;\n        }\n    }\n    #setCaret(start) {\n        if (!this.#anchorNode) {\n            return;\n        }\n        const selection = window.getSelection();\n        if (start) {\n            selection.setPosition(this.#anchorNode, this.#anchorOffset);\n        } else {\n            selection.setPosition(this.#focusNode, this.#focusOffset);\n        }\n    }\n    select() {\n        super.select();\n        if (!this.#outlineId) {\n            return;\n        }\n        this.parent?.drawLayer.updateProperties(this.#outlineId, {\n            rootClass: {\n                hovered: false,\n                selected: true\n            }\n        });\n    }\n    unselect() {\n        super.unselect();\n        if (!this.#outlineId) {\n            return;\n        }\n        this.parent?.drawLayer.updateProperties(this.#outlineId, {\n            rootClass: {\n                selected: false\n            }\n        });\n        if (!this.#isFreeHighlight) {\n            this.#setCaret(false);\n        }\n    }\n    get _mustFixPosition() {\n        return !this.#isFreeHighlight;\n    }\n    show(visible = this._isVisible) {\n        super.show(visible);\n        if (this.parent) {\n            this.parent.drawLayer.updateProperties(this.#id, {\n                rootClass: {\n                    hidden: !visible\n                }\n            });\n            this.parent.drawLayer.updateProperties(this.#outlineId, {\n                rootClass: {\n                    hidden: !visible\n                }\n            });\n        }\n    }\n    #getRotation() {\n        return this.#isFreeHighlight ? this.rotation : 0;\n    }\n    #serializeBoxes() {\n        if (this.#isFreeHighlight) {\n            return null;\n        }\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        const [pageX, pageY] = this.pageTranslation;\n        const boxes = this.#boxes;\n        const quadPoints = new Float32Array(boxes.length * 8);\n        let i = 0;\n        for (const { x, y, width, height } of boxes){\n            const sx = x * pageWidth + pageX;\n            const sy = (1 - y) * pageHeight + pageY;\n            quadPoints[i] = quadPoints[i + 4] = sx;\n            quadPoints[i + 1] = quadPoints[i + 3] = sy;\n            quadPoints[i + 2] = quadPoints[i + 6] = sx + width * pageWidth;\n            quadPoints[i + 5] = quadPoints[i + 7] = sy - height * pageHeight;\n            i += 8;\n        }\n        return quadPoints;\n    }\n    #serializeOutlines(rect) {\n        return this.#highlightOutlines.serialize(rect, this.#getRotation());\n    }\n    static startHighlighting(parent, isLTR, { target: textLayer, x, y }) {\n        const { x: layerX, y: layerY, width: parentWidth, height: parentHeight } = textLayer.getBoundingClientRect();\n        const ac = new AbortController();\n        const signal = parent.combinedSignal(ac);\n        const pointerUpCallback = (e)=>{\n            ac.abort();\n            this.#endHighlight(parent, e);\n        };\n        window.addEventListener(\"blur\", pointerUpCallback, {\n            signal\n        });\n        window.addEventListener(\"pointerup\", pointerUpCallback, {\n            signal\n        });\n        window.addEventListener(\"pointerdown\", stopEvent, {\n            capture: true,\n            passive: false,\n            signal\n        });\n        window.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        textLayer.addEventListener(\"pointermove\", this.#highlightMove.bind(this, parent), {\n            signal\n        });\n        this._freeHighlight = new FreeHighlightOutliner({\n            x,\n            y\n        }, [\n            layerX,\n            layerY,\n            parentWidth,\n            parentHeight\n        ], parent.scale, this._defaultThickness / 2, isLTR, 1e-3);\n        ({ id: this._freeHighlightId, clipPathId: this._freeHighlightClipId } = parent.drawLayer.draw({\n            bbox: [\n                0,\n                0,\n                1,\n                1\n            ],\n            root: {\n                viewBox: \"0 0 1 1\",\n                fill: this._defaultColor,\n                \"fill-opacity\": this._defaultOpacity\n            },\n            rootClass: {\n                highlight: true,\n                free: true\n            },\n            path: {\n                d: this._freeHighlight.toSVGPath()\n            }\n        }, true, true));\n    }\n    static #highlightMove(parent, event) {\n        if (this._freeHighlight.add(event)) {\n            parent.drawLayer.updateProperties(this._freeHighlightId, {\n                path: {\n                    d: this._freeHighlight.toSVGPath()\n                }\n            });\n        }\n    }\n    static #endHighlight(parent, event) {\n        if (!this._freeHighlight.isEmpty()) {\n            parent.createAndAddNewEditor(event, false, {\n                highlightId: this._freeHighlightId,\n                highlightOutlines: this._freeHighlight.getOutlines(),\n                clipPathId: this._freeHighlightClipId,\n                methodOfCreation: \"main_toolbar\"\n            });\n        } else {\n            parent.drawLayer.remove(this._freeHighlightId);\n        }\n        this._freeHighlightId = -1;\n        this._freeHighlight = null;\n        this._freeHighlightClipId = \"\";\n    }\n    static async deserialize(data, parent, uiManager) {\n        let initialData = null;\n        if (data instanceof HighlightAnnotationElement) {\n            const { data: { quadPoints: quadPoints2, rect, rotation, id, color: color2, opacity: opacity2, popupRef, richText, contentsObj, creationDate, modificationDate }, parent: { page: { pageNumber } } } = data;\n            initialData = data = {\n                annotationType: AnnotationEditorType.HIGHLIGHT,\n                color: Array.from(color2),\n                opacity: opacity2,\n                quadPoints: quadPoints2,\n                boxes: null,\n                pageIndex: pageNumber - 1,\n                rect: rect.slice(0),\n                rotation,\n                annotationElementId: id,\n                id,\n                deleted: false,\n                popupRef,\n                richText,\n                comment: contentsObj?.str || null,\n                creationDate,\n                modificationDate\n            };\n        } else if (data instanceof InkAnnotationElement) {\n            const { data: { inkLists: inkLists2, rect, rotation, id, color: color2, borderStyle: { rawWidth: thickness }, popupRef, richText, contentsObj, creationDate, modificationDate }, parent: { page: { pageNumber } } } = data;\n            initialData = data = {\n                annotationType: AnnotationEditorType.HIGHLIGHT,\n                color: Array.from(color2),\n                thickness,\n                inkLists: inkLists2,\n                boxes: null,\n                pageIndex: pageNumber - 1,\n                rect: rect.slice(0),\n                rotation,\n                annotationElementId: id,\n                id,\n                deleted: false,\n                popupRef,\n                richText,\n                comment: contentsObj?.str || null,\n                creationDate,\n                modificationDate\n            };\n        }\n        const { color, quadPoints, inkLists, opacity } = data;\n        const editor = await super.deserialize(data, parent, uiManager);\n        editor.color = Util.makeHexColor(...color);\n        editor.opacity = opacity || 1;\n        if (inkLists) {\n            editor.#thickness = data.thickness;\n        }\n        editor._initialData = initialData;\n        if (data.comment) {\n            editor.setCommentData(data);\n        }\n        const [pageWidth, pageHeight] = editor.pageDimensions;\n        const [pageX, pageY] = editor.pageTranslation;\n        if (quadPoints) {\n            const boxes = editor.#boxes = [];\n            for(let i = 0; i < quadPoints.length; i += 8){\n                boxes.push({\n                    x: (quadPoints[i] - pageX) / pageWidth,\n                    y: 1 - (quadPoints[i + 1] - pageY) / pageHeight,\n                    width: (quadPoints[i + 2] - quadPoints[i]) / pageWidth,\n                    height: (quadPoints[i + 1] - quadPoints[i + 5]) / pageHeight\n                });\n            }\n            editor.#createOutlines();\n            editor.#addToDrawLayer();\n            editor.rotate(editor.rotation);\n        } else if (inkLists) {\n            editor.#isFreeHighlight = true;\n            const points = inkLists[0];\n            const point = {\n                x: points[0] - pageX,\n                y: pageHeight - (points[1] - pageY)\n            };\n            const outliner = new FreeHighlightOutliner(point, [\n                0,\n                0,\n                pageWidth,\n                pageHeight\n            ], 1, editor.#thickness / 2, true, 1e-3);\n            for(let i = 0, ii = points.length; i < ii; i += 2){\n                point.x = points[i] - pageX;\n                point.y = pageHeight - (points[i + 1] - pageY);\n                outliner.add(point);\n            }\n            const { id, clipPathId } = parent.drawLayer.draw({\n                bbox: [\n                    0,\n                    0,\n                    1,\n                    1\n                ],\n                root: {\n                    viewBox: \"0 0 1 1\",\n                    fill: editor.color,\n                    \"fill-opacity\": editor._defaultOpacity\n                },\n                rootClass: {\n                    highlight: true,\n                    free: true\n                },\n                path: {\n                    d: outliner.toSVGPath()\n                }\n            }, true, true);\n            editor.#createFreeOutlines({\n                highlightOutlines: outliner.getOutlines(),\n                highlightId: id,\n                clipPathId\n            });\n            editor.#addToDrawLayer();\n            editor.rotate(editor.parentRotation);\n        }\n        return editor;\n    }\n    serialize(isForCopying = false) {\n        if (this.isEmpty() || isForCopying) {\n            return null;\n        }\n        if (this.deleted) {\n            return this.serializeDeleted();\n        }\n        const color = AnnotationEditor._colorManager.convert(this._uiManager.getNonHCMColor(this.color));\n        const serialized = super.serialize(isForCopying);\n        Object.assign(serialized, {\n            color,\n            opacity: this.opacity,\n            thickness: this.#thickness,\n            quadPoints: this.#serializeBoxes(),\n            outlines: this.#serializeOutlines(serialized.rect)\n        });\n        this.addComment(serialized);\n        if (this.annotationElementId && !this.#hasElementChanged(serialized)) {\n            return null;\n        }\n        serialized.id = this.annotationElementId;\n        return serialized;\n    }\n    #hasElementChanged(serialized) {\n        const { color } = this._initialData;\n        return this.hasEditedComment || serialized.color.some((c, i)=>c !== color[i]);\n    }\n    renderAnnotationElement(annotation) {\n        if (this.deleted) {\n            annotation.hide();\n            return null;\n        }\n        annotation.updateEdited({\n            rect: this.getPDFRect(),\n            popup: this.comment\n        });\n        return null;\n    }\n    static canCreateNewEmptyEditor() {\n        return false;\n    }\n}\nclass DrawingOptions {\n    #svgProperties;\n    updateProperty(name, value1) {\n        this[name] = value1;\n        this.updateSVGProperty(name, value1);\n    }\n    updateProperties(properties) {\n        if (!properties) {\n            return;\n        }\n        for (const [name, value1] of Object.entries(properties)){\n            if (!name.startsWith(\"_\")) {\n                this.updateProperty(name, value1);\n            }\n        }\n    }\n    updateSVGProperty(name, value1) {\n        this.#svgProperties[name] = value1;\n    }\n    toSVGProperties() {\n        const root = this.#svgProperties;\n        this.#svgProperties = /* @__PURE__ */ Object.create(null);\n        return {\n            root\n        };\n    }\n    reset() {\n        this.#svgProperties = /* @__PURE__ */ Object.create(null);\n    }\n    updateAll(options = this) {\n        this.updateProperties(options);\n    }\n    clone() {\n        unreachable(\"Not implemented\");\n    }\n    constructor(){\n        this.#svgProperties = /* @__PURE__ */ Object.create(null);\n    }\n}\nclass DrawingEditor extends AnnotationEditor {\n    #drawOutlines;\n    #mustBeCommitted;\n    static{\n        this._currentDrawId = -1;\n    }\n    static{\n        this._currentParent = null;\n    }\n    static #currentDraw = null;\n    static #currentDrawingAC = null;\n    static #currentDrawingOptions = null;\n    static #currentPointerId = NaN;\n    static #currentPointerType = null;\n    static #currentPointerIds = null;\n    static #currentMoveTimestamp = NaN;\n    static{\n        this._INNER_MARGIN = 3;\n    }\n    constructor(params){\n        super(params);\n        this.#drawOutlines = null;\n        this._colorPicker = null;\n        this._drawId = null;\n        this.#mustBeCommitted = params.mustBeCommitted || false;\n        this._addOutlines(params);\n    }\n    onUpdatedColor() {\n        this._colorPicker?.update(this.color);\n        super.onUpdatedColor();\n    }\n    _addOutlines(params) {\n        if (params.drawOutlines) {\n            this.#createDrawOutlines(params);\n            this.#addToDrawLayer();\n        }\n    }\n    #createDrawOutlines({ drawOutlines, drawId, drawingOptions }) {\n        this.#drawOutlines = drawOutlines;\n        this._drawingOptions ||= drawingOptions;\n        if (!this.annotationElementId) {\n            this._uiManager.a11yAlert(`pdfjs-editor-${this.editorType}-added-alert`);\n        }\n        if (drawId >= 0) {\n            this._drawId = drawId;\n            this.parent.drawLayer.finalizeDraw(drawId, drawOutlines.defaultProperties);\n        } else {\n            this._drawId = this.#createDrawing(drawOutlines, this.parent);\n        }\n        this.#updateBbox(drawOutlines.box);\n    }\n    #createDrawing(drawOutlines, parent) {\n        const { id } = parent.drawLayer.draw(DrawingEditor._mergeSVGProperties(this._drawingOptions.toSVGProperties(), drawOutlines.defaultSVGProperties), false, false);\n        return id;\n    }\n    static _mergeSVGProperties(p1, p2) {\n        const p1Keys = new Set(Object.keys(p1));\n        for (const [key, value1] of Object.entries(p2)){\n            if (p1Keys.has(key)) {\n                Object.assign(p1[key], value1);\n            } else {\n                p1[key] = value1;\n            }\n        }\n        return p1;\n    }\n    static getDefaultDrawingOptions(_options) {\n        unreachable(\"Not implemented\");\n    }\n    static get typesMap() {\n        unreachable(\"Not implemented\");\n    }\n    static get isDrawer() {\n        return true;\n    }\n    static get supportMultipleDrawings() {\n        return false;\n    }\n    static updateDefaultParams(type, value1) {\n        const propertyName = this.typesMap.get(type);\n        if (propertyName) {\n            this._defaultDrawingOptions.updateProperty(propertyName, value1);\n        }\n        if (this._currentParent) {\n            DrawingEditor.#currentDraw.updateProperty(propertyName, value1);\n            this._currentParent.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties());\n        }\n    }\n    updateParams(type, value1) {\n        const propertyName = this.constructor.typesMap.get(type);\n        if (propertyName) {\n            this._updateProperty(type, propertyName, value1);\n        }\n    }\n    static get defaultPropertiesToUpdate() {\n        const properties = [];\n        const options = this._defaultDrawingOptions;\n        for (const [type, name] of this.typesMap){\n            properties.push([\n                type,\n                options[name]\n            ]);\n        }\n        return properties;\n    }\n    get propertiesToUpdate() {\n        const properties = [];\n        const { _drawingOptions } = this;\n        for (const [type, name] of this.constructor.typesMap){\n            properties.push([\n                type,\n                _drawingOptions[name]\n            ]);\n        }\n        return properties;\n    }\n    _updateProperty(type, name, value1) {\n        const options = this._drawingOptions;\n        const savedValue = options[name];\n        const setter = (val)=>{\n            options.updateProperty(name, val);\n            const bbox = this.#drawOutlines.updateProperty(name, val);\n            if (bbox) {\n                this.#updateBbox(bbox);\n            }\n            this.parent?.drawLayer.updateProperties(this._drawId, options.toSVGProperties());\n            if (type === this.colorType) {\n                this.onUpdatedColor();\n            }\n        };\n        this.addCommands({\n            cmd: setter.bind(this, value1),\n            undo: setter.bind(this, savedValue),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n    }\n    _onResizing() {\n        this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathResizingSVGProperties(this.#convertToDrawSpace()), {\n            bbox: this.#rotateBox()\n        }));\n    }\n    _onResized() {\n        this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathResizedSVGProperties(this.#convertToDrawSpace()), {\n            bbox: this.#rotateBox()\n        }));\n    }\n    _onTranslating(_x, _y) {\n        this.parent?.drawLayer.updateProperties(this._drawId, {\n            bbox: this.#rotateBox()\n        });\n    }\n    _onTranslated() {\n        this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathTranslatedSVGProperties(this.#convertToDrawSpace(), this.parentDimensions), {\n            bbox: this.#rotateBox()\n        }));\n    }\n    _onStartDragging() {\n        this.parent?.drawLayer.updateProperties(this._drawId, {\n            rootClass: {\n                moving: true\n            }\n        });\n    }\n    _onStopDragging() {\n        this.parent?.drawLayer.updateProperties(this._drawId, {\n            rootClass: {\n                moving: false\n            }\n        });\n    }\n    commit() {\n        super.commit();\n        this.disableEditMode();\n        this.disableEditing();\n    }\n    disableEditing() {\n        super.disableEditing();\n        this.div.classList.toggle(\"disabled\", true);\n    }\n    enableEditing() {\n        super.enableEditing();\n        this.div.classList.toggle(\"disabled\", false);\n    }\n    getBaseTranslation() {\n        return [\n            0,\n            0\n        ];\n    }\n    get isResizable() {\n        return true;\n    }\n    onceAdded(focus) {\n        if (!this.annotationElementId) {\n            this.parent.addUndoableEditor(this);\n        }\n        this._isDraggable = true;\n        if (this.#mustBeCommitted) {\n            this.#mustBeCommitted = false;\n            this.commit();\n            this.parent.setSelected(this);\n            if (focus && this.isOnScreen) {\n                this.div.focus();\n            }\n        }\n    }\n    remove() {\n        this.#cleanDrawLayer();\n        super.remove();\n    }\n    rebuild() {\n        if (!this.parent) {\n            return;\n        }\n        super.rebuild();\n        if (this.div === null) {\n            return;\n        }\n        this.#addToDrawLayer();\n        this.#updateBbox(this.#drawOutlines.box);\n        if (!this.isAttachedToDOM) {\n            this.parent.add(this);\n        }\n    }\n    setParent(parent) {\n        let mustBeSelected = false;\n        if (this.parent && !parent) {\n            this._uiManager.removeShouldRescale(this);\n            this.#cleanDrawLayer();\n        } else if (parent) {\n            this._uiManager.addShouldRescale(this);\n            this.#addToDrawLayer(parent);\n            mustBeSelected = !this.parent && this.div?.classList.contains(\"selectedEditor\");\n        }\n        super.setParent(parent);\n        if (mustBeSelected) {\n            this.select();\n        }\n    }\n    #cleanDrawLayer() {\n        if (this._drawId === null || !this.parent) {\n            return;\n        }\n        this.parent.drawLayer.remove(this._drawId);\n        this._drawId = null;\n        this._drawingOptions.reset();\n    }\n    #addToDrawLayer(parent = this.parent) {\n        if (this._drawId !== null && this.parent === parent) {\n            return;\n        }\n        if (this._drawId !== null) {\n            this.parent.drawLayer.updateParent(this._drawId, parent.drawLayer);\n            return;\n        }\n        this._drawingOptions.updateAll();\n        this._drawId = this.#createDrawing(this.#drawOutlines, parent);\n    }\n    #convertToParentSpace([x, y, width, height]) {\n        const { parentDimensions: [pW, pH], rotation } = this;\n        switch(rotation){\n            case 90:\n                return [\n                    y,\n                    1 - x,\n                    width * (pH / pW),\n                    height * (pW / pH)\n                ];\n            case 180:\n                return [\n                    1 - x,\n                    1 - y,\n                    width,\n                    height\n                ];\n            case 270:\n                return [\n                    1 - y,\n                    x,\n                    width * (pH / pW),\n                    height * (pW / pH)\n                ];\n            default:\n                return [\n                    x,\n                    y,\n                    width,\n                    height\n                ];\n        }\n    }\n    #convertToDrawSpace() {\n        const { x, y, width, height, parentDimensions: [pW, pH], rotation } = this;\n        switch(rotation){\n            case 90:\n                return [\n                    1 - y,\n                    x,\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            case 180:\n                return [\n                    1 - x,\n                    1 - y,\n                    width,\n                    height\n                ];\n            case 270:\n                return [\n                    y,\n                    1 - x,\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            default:\n                return [\n                    x,\n                    y,\n                    width,\n                    height\n                ];\n        }\n    }\n    #updateBbox(bbox) {\n        [this.x, this.y, this.width, this.height] = this.#convertToParentSpace(bbox);\n        if (this.div) {\n            this.fixAndSetPosition();\n            this.setDims();\n        }\n        this._onResized();\n    }\n    #rotateBox() {\n        const { x, y, width, height, rotation, parentRotation, parentDimensions: [pW, pH] } = this;\n        switch((rotation * 4 + parentRotation) / 90){\n            case 1:\n                return [\n                    1 - y - height,\n                    x,\n                    height,\n                    width\n                ];\n            case 2:\n                return [\n                    1 - x - width,\n                    1 - y - height,\n                    width,\n                    height\n                ];\n            case 3:\n                return [\n                    y,\n                    1 - x - width,\n                    height,\n                    width\n                ];\n            case 4:\n                return [\n                    x,\n                    y - width * (pW / pH),\n                    height * (pH / pW),\n                    width * (pW / pH)\n                ];\n            case 5:\n                return [\n                    1 - y,\n                    x,\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            case 6:\n                return [\n                    1 - x - height * (pH / pW),\n                    1 - y,\n                    height * (pH / pW),\n                    width * (pW / pH)\n                ];\n            case 7:\n                return [\n                    y - width * (pW / pH),\n                    1 - x - height * (pH / pW),\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            case 8:\n                return [\n                    x - width,\n                    y - height,\n                    width,\n                    height\n                ];\n            case 9:\n                return [\n                    1 - y,\n                    x - width,\n                    height,\n                    width\n                ];\n            case 10:\n                return [\n                    1 - x,\n                    1 - y,\n                    width,\n                    height\n                ];\n            case 11:\n                return [\n                    y - height,\n                    1 - x,\n                    height,\n                    width\n                ];\n            case 12:\n                return [\n                    x - height * (pH / pW),\n                    y,\n                    height * (pH / pW),\n                    width * (pW / pH)\n                ];\n            case 13:\n                return [\n                    1 - y - width * (pW / pH),\n                    x - height * (pH / pW),\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            case 14:\n                return [\n                    1 - x,\n                    1 - y - width * (pW / pH),\n                    height * (pH / pW),\n                    width * (pW / pH)\n                ];\n            case 15:\n                return [\n                    y,\n                    1 - x,\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            default:\n                return [\n                    x,\n                    y,\n                    width,\n                    height\n                ];\n        }\n    }\n    rotate() {\n        if (!this.parent) {\n            return;\n        }\n        this.parent.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties({\n            bbox: this.#rotateBox()\n        }, this.#drawOutlines.updateRotation((this.parentRotation - this.rotation + 360) % 360)));\n    }\n    onScaleChanging() {\n        if (!this.parent) {\n            return;\n        }\n        this.#updateBbox(this.#drawOutlines.updateParentDimensions(this.parentDimensions, this.parent.scale));\n    }\n    static onScaleChangingWhenDrawing() {}\n    render() {\n        if (this.div) {\n            return this.div;\n        }\n        let baseX, baseY;\n        if (this._isCopy) {\n            baseX = this.x;\n            baseY = this.y;\n        }\n        const div = super.render();\n        div.classList.add(\"draw\");\n        const drawDiv = document.createElement(\"div\");\n        div.append(drawDiv);\n        drawDiv.setAttribute(\"aria-hidden\", \"true\");\n        drawDiv.className = \"internal\";\n        this.setDims();\n        this._uiManager.addShouldRescale(this);\n        this.disableEditing();\n        if (this._isCopy) {\n            this._moveAfterPaste(baseX, baseY);\n        }\n        return div;\n    }\n    static createDrawerInstance(_x, _y, _parentWidth, _parentHeight, _rotation) {\n        unreachable(\"Not implemented\");\n    }\n    static startDrawing(parent, uiManager, _isLTR, event) {\n        const { target, offsetX: x, offsetY: y, pointerId, pointerType } = event;\n        if (DrawingEditor.#currentPointerType && DrawingEditor.#currentPointerType !== pointerType) {\n            return;\n        }\n        const { viewport: { rotation } } = parent;\n        const { width: parentWidth, height: parentHeight } = target.getBoundingClientRect();\n        const ac = DrawingEditor.#currentDrawingAC = new AbortController();\n        const signal = parent.combinedSignal(ac);\n        DrawingEditor.#currentPointerId ||= pointerId;\n        DrawingEditor.#currentPointerType ??= pointerType;\n        window.addEventListener(\"pointerup\", (e)=>{\n            if (DrawingEditor.#currentPointerId === e.pointerId) {\n                this._endDraw(e);\n            } else {\n                DrawingEditor.#currentPointerIds?.delete(e.pointerId);\n            }\n        }, {\n            signal\n        });\n        window.addEventListener(\"pointercancel\", (e)=>{\n            if (DrawingEditor.#currentPointerId === e.pointerId) {\n                this._currentParent.endDrawingSession();\n            } else {\n                DrawingEditor.#currentPointerIds?.delete(e.pointerId);\n            }\n        }, {\n            signal\n        });\n        window.addEventListener(\"pointerdown\", (e)=>{\n            if (DrawingEditor.#currentPointerType !== e.pointerType) {\n                return;\n            }\n            (DrawingEditor.#currentPointerIds ||= /* @__PURE__ */ new Set()).add(e.pointerId);\n            if (DrawingEditor.#currentDraw.isCancellable()) {\n                DrawingEditor.#currentDraw.removeLastElement();\n                if (DrawingEditor.#currentDraw.isEmpty()) {\n                    this._currentParent.endDrawingSession(true);\n                } else {\n                    this._endDraw(null);\n                }\n            }\n        }, {\n            capture: true,\n            passive: false,\n            signal\n        });\n        window.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        target.addEventListener(\"pointermove\", this._drawMove.bind(this), {\n            signal\n        });\n        target.addEventListener(\"touchmove\", (e)=>{\n            if (e.timeStamp === DrawingEditor.#currentMoveTimestamp) {\n                stopEvent(e);\n            }\n        }, {\n            signal\n        });\n        parent.toggleDrawing();\n        uiManager._editorUndoBar?.hide();\n        if (DrawingEditor.#currentDraw) {\n            parent.drawLayer.updateProperties(this._currentDrawId, DrawingEditor.#currentDraw.startNew(x, y, parentWidth, parentHeight, rotation));\n            return;\n        }\n        uiManager.updateUIForDefaultProperties(this);\n        DrawingEditor.#currentDraw = this.createDrawerInstance(x, y, parentWidth, parentHeight, rotation);\n        DrawingEditor.#currentDrawingOptions = this.getDefaultDrawingOptions();\n        this._currentParent = parent;\n        ({ id: this._currentDrawId } = parent.drawLayer.draw(this._mergeSVGProperties(DrawingEditor.#currentDrawingOptions.toSVGProperties(), DrawingEditor.#currentDraw.defaultSVGProperties), true, false));\n    }\n    static _drawMove(event) {\n        DrawingEditor.#currentMoveTimestamp = -1;\n        if (!DrawingEditor.#currentDraw) {\n            return;\n        }\n        const { offsetX, offsetY, pointerId } = event;\n        if (DrawingEditor.#currentPointerId !== pointerId) {\n            return;\n        }\n        if (DrawingEditor.#currentPointerIds?.size >= 1) {\n            this._endDraw(event);\n            return;\n        }\n        this._currentParent.drawLayer.updateProperties(this._currentDrawId, DrawingEditor.#currentDraw.add(offsetX, offsetY));\n        DrawingEditor.#currentMoveTimestamp = event.timeStamp;\n        stopEvent(event);\n    }\n    static _cleanup(all) {\n        if (all) {\n            this._currentDrawId = -1;\n            this._currentParent = null;\n            DrawingEditor.#currentDraw = null;\n            DrawingEditor.#currentDrawingOptions = null;\n            DrawingEditor.#currentPointerType = null;\n            DrawingEditor.#currentMoveTimestamp = NaN;\n        }\n        if (DrawingEditor.#currentDrawingAC) {\n            DrawingEditor.#currentDrawingAC.abort();\n            DrawingEditor.#currentDrawingAC = null;\n            DrawingEditor.#currentPointerId = NaN;\n            DrawingEditor.#currentPointerIds = null;\n        }\n    }\n    static _endDraw(event) {\n        const parent = this._currentParent;\n        if (!parent) {\n            return;\n        }\n        parent.toggleDrawing(true);\n        this._cleanup(false);\n        if (event?.target === parent.div) {\n            parent.drawLayer.updateProperties(this._currentDrawId, DrawingEditor.#currentDraw.end(event.offsetX, event.offsetY));\n        }\n        if (this.supportMultipleDrawings) {\n            const draw = DrawingEditor.#currentDraw;\n            const drawId = this._currentDrawId;\n            const lastElement = draw.getLastElement();\n            parent.addCommands({\n                cmd: ()=>{\n                    parent.drawLayer.updateProperties(drawId, draw.setLastElement(lastElement));\n                },\n                undo: ()=>{\n                    parent.drawLayer.updateProperties(drawId, draw.removeLastElement());\n                },\n                mustExec: false,\n                type: AnnotationEditorParamsType.DRAW_STEP\n            });\n            return;\n        }\n        this.endDrawing(false);\n    }\n    static endDrawing(isAborted) {\n        const parent = this._currentParent;\n        if (!parent) {\n            return null;\n        }\n        parent.toggleDrawing(true);\n        parent.cleanUndoStack(AnnotationEditorParamsType.DRAW_STEP);\n        if (!DrawingEditor.#currentDraw.isEmpty()) {\n            const { pageDimensions: [pageWidth, pageHeight], scale } = parent;\n            const editor = parent.createAndAddNewEditor({\n                offsetX: 0,\n                offsetY: 0\n            }, false, {\n                drawId: this._currentDrawId,\n                drawOutlines: DrawingEditor.#currentDraw.getOutlines(pageWidth * scale, pageHeight * scale, scale, this._INNER_MARGIN),\n                drawingOptions: DrawingEditor.#currentDrawingOptions,\n                mustBeCommitted: !isAborted\n            });\n            this._cleanup(true);\n            return editor;\n        }\n        parent.drawLayer.remove(this._currentDrawId);\n        this._cleanup(true);\n        return null;\n    }\n    createDrawingOptions(_data) {}\n    static deserializeDraw(_pageX, _pageY, _pageWidth, _pageHeight, _innerWidth, _data) {\n        unreachable(\"Not implemented\");\n    }\n    static async deserialize(data, parent, uiManager) {\n        const { rawDims: { pageWidth, pageHeight, pageX, pageY } } = parent.viewport;\n        const drawOutlines = this.deserializeDraw(pageX, pageY, pageWidth, pageHeight, this._INNER_MARGIN, data);\n        const editor = await super.deserialize(data, parent, uiManager);\n        editor.createDrawingOptions(data);\n        editor.#createDrawOutlines({\n            drawOutlines\n        });\n        editor.#addToDrawLayer();\n        editor.onScaleChanging();\n        editor.rotate();\n        return editor;\n    }\n    serializeDraw(isForCopying) {\n        const [pageX, pageY] = this.pageTranslation;\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        return this.#drawOutlines.serialize([\n            pageX,\n            pageY,\n            pageWidth,\n            pageHeight\n        ], isForCopying);\n    }\n    renderAnnotationElement(annotation) {\n        annotation.updateEdited({\n            rect: this.getPDFRect()\n        });\n        return null;\n    }\n    static canCreateNewEmptyEditor() {\n        return false;\n    }\n}\nclass InkDrawOutliner {\n    #last;\n    #line;\n    #lines;\n    #rotation;\n    #thickness;\n    #points;\n    #lastSVGPath;\n    #lastIndex;\n    #outlines;\n    #parentWidth;\n    #parentHeight;\n    constructor(x, y, parentWidth, parentHeight, rotation, thickness){\n        this.#last = new Float64Array(6);\n        this.#lastSVGPath = \"\";\n        this.#lastIndex = 0;\n        this.#outlines = new InkDrawOutline();\n        this.#parentWidth = parentWidth;\n        this.#parentHeight = parentHeight;\n        this.#rotation = rotation;\n        this.#thickness = thickness;\n        [x, y] = this.#normalizePoint(x, y);\n        const line = this.#line = [\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            x,\n            y\n        ];\n        this.#points = [\n            x,\n            y\n        ];\n        this.#lines = [\n            {\n                line,\n                points: this.#points\n            }\n        ];\n        this.#last.set(line, 0);\n    }\n    updateProperty(name, value1) {\n        if (name === \"stroke-width\") {\n            this.#thickness = value1;\n        }\n    }\n    #normalizePoint(x, y) {\n        return Outline._normalizePoint(x, y, this.#parentWidth, this.#parentHeight, this.#rotation);\n    }\n    isEmpty() {\n        return !this.#lines || this.#lines.length === 0;\n    }\n    isCancellable() {\n        return this.#points.length <= 10;\n    }\n    add(x, y) {\n        [x, y] = this.#normalizePoint(x, y);\n        const [x1, y1, x2, y2] = this.#last.subarray(2, 6);\n        const diffX = x - x2;\n        const diffY = y - y2;\n        const d = Math.hypot(this.#parentWidth * diffX, this.#parentHeight * diffY);\n        if (d <= 2) {\n            return null;\n        }\n        this.#points.push(x, y);\n        if (isNaN(x1)) {\n            this.#last.set([\n                x2,\n                y2,\n                x,\n                y\n            ], 2);\n            this.#line.push(NaN, NaN, NaN, NaN, x, y);\n            return {\n                path: {\n                    d: this.toSVGPath()\n                }\n            };\n        }\n        if (isNaN(this.#last[0])) {\n            this.#line.splice(6, 6);\n        }\n        this.#last.set([\n            x1,\n            y1,\n            x2,\n            y2,\n            x,\n            y\n        ], 0);\n        this.#line.push(...Outline.createBezierPoints(x1, y1, x2, y2, x, y));\n        return {\n            path: {\n                d: this.toSVGPath()\n            }\n        };\n    }\n    end(x, y) {\n        const change = this.add(x, y);\n        if (change) {\n            return change;\n        }\n        if (this.#points.length === 2) {\n            return {\n                path: {\n                    d: this.toSVGPath()\n                }\n            };\n        }\n        return null;\n    }\n    startNew(x, y, parentWidth, parentHeight, rotation) {\n        this.#parentWidth = parentWidth;\n        this.#parentHeight = parentHeight;\n        this.#rotation = rotation;\n        [x, y] = this.#normalizePoint(x, y);\n        const line = this.#line = [\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            x,\n            y\n        ];\n        this.#points = [\n            x,\n            y\n        ];\n        const last = this.#lines.at(-1);\n        if (last) {\n            last.line = new Float32Array(last.line);\n            last.points = new Float32Array(last.points);\n        }\n        this.#lines.push({\n            line,\n            points: this.#points\n        });\n        this.#last.set(line, 0);\n        this.#lastIndex = 0;\n        this.toSVGPath();\n        return null;\n    }\n    getLastElement() {\n        return this.#lines.at(-1);\n    }\n    setLastElement(element) {\n        if (!this.#lines) {\n            return this.#outlines.setLastElement(element);\n        }\n        this.#lines.push(element);\n        this.#line = element.line;\n        this.#points = element.points;\n        this.#lastIndex = 0;\n        return {\n            path: {\n                d: this.toSVGPath()\n            }\n        };\n    }\n    removeLastElement() {\n        if (!this.#lines) {\n            return this.#outlines.removeLastElement();\n        }\n        this.#lines.pop();\n        this.#lastSVGPath = \"\";\n        for(let i = 0, ii = this.#lines.length; i < ii; i++){\n            const { line, points } = this.#lines[i];\n            this.#line = line;\n            this.#points = points;\n            this.#lastIndex = 0;\n            this.toSVGPath();\n        }\n        return {\n            path: {\n                d: this.#lastSVGPath\n            }\n        };\n    }\n    toSVGPath() {\n        const firstX = Outline.svgRound(this.#line[4]);\n        const firstY = Outline.svgRound(this.#line[5]);\n        if (this.#points.length === 2) {\n            this.#lastSVGPath = `${this.#lastSVGPath} M ${firstX} ${firstY} Z`;\n            return this.#lastSVGPath;\n        }\n        if (this.#points.length <= 6) {\n            const i = this.#lastSVGPath.lastIndexOf(\"M\");\n            this.#lastSVGPath = `${this.#lastSVGPath.slice(0, i)} M ${firstX} ${firstY}`;\n            this.#lastIndex = 6;\n        }\n        if (this.#points.length === 4) {\n            const secondX = Outline.svgRound(this.#line[10]);\n            const secondY = Outline.svgRound(this.#line[11]);\n            this.#lastSVGPath = `${this.#lastSVGPath} L ${secondX} ${secondY}`;\n            this.#lastIndex = 12;\n            return this.#lastSVGPath;\n        }\n        const buffer = [];\n        if (this.#lastIndex === 0) {\n            buffer.push(`M ${firstX} ${firstY}`);\n            this.#lastIndex = 6;\n        }\n        for(let i = this.#lastIndex, ii = this.#line.length; i < ii; i += 6){\n            const [c1x, c1y, c2x, c2y, x, y] = this.#line.slice(i, i + 6).map(Outline.svgRound);\n            buffer.push(`C${c1x} ${c1y} ${c2x} ${c2y} ${x} ${y}`);\n        }\n        this.#lastSVGPath += buffer.join(\" \");\n        this.#lastIndex = this.#line.length;\n        return this.#lastSVGPath;\n    }\n    getOutlines(parentWidth, parentHeight, scale, innerMargin) {\n        const last = this.#lines.at(-1);\n        last.line = new Float32Array(last.line);\n        last.points = new Float32Array(last.points);\n        this.#outlines.build(this.#lines, parentWidth, parentHeight, scale, this.#rotation, this.#thickness, innerMargin);\n        this.#last = null;\n        this.#line = null;\n        this.#lines = null;\n        this.#lastSVGPath = null;\n        return this.#outlines;\n    }\n    get defaultSVGProperties() {\n        return {\n            root: {\n                viewBox: \"0 0 10000 10000\"\n            },\n            rootClass: {\n                draw: true\n            },\n            bbox: [\n                0,\n                0,\n                1,\n                1\n            ]\n        };\n    }\n}\nclass InkDrawOutline extends Outline {\n    #bbox;\n    #currentRotation;\n    #innerMargin;\n    #lines;\n    #parentWidth;\n    #parentHeight;\n    #parentScale;\n    #rotation;\n    #thickness;\n    build(lines, parentWidth, parentHeight, parentScale, rotation, thickness, innerMargin) {\n        this.#parentWidth = parentWidth;\n        this.#parentHeight = parentHeight;\n        this.#parentScale = parentScale;\n        this.#rotation = rotation;\n        this.#thickness = thickness;\n        this.#innerMargin = innerMargin ?? 0;\n        this.#lines = lines;\n        this.#computeBbox();\n    }\n    get thickness() {\n        return this.#thickness;\n    }\n    setLastElement(element) {\n        this.#lines.push(element);\n        return {\n            path: {\n                d: this.toSVGPath()\n            }\n        };\n    }\n    removeLastElement() {\n        this.#lines.pop();\n        return {\n            path: {\n                d: this.toSVGPath()\n            }\n        };\n    }\n    toSVGPath() {\n        const buffer = [];\n        for (const { line } of this.#lines){\n            buffer.push(`M${Outline.svgRound(line[4])} ${Outline.svgRound(line[5])}`);\n            if (line.length === 6) {\n                buffer.push(\"Z\");\n                continue;\n            }\n            if (line.length === 12 && isNaN(line[6])) {\n                buffer.push(`L${Outline.svgRound(line[10])} ${Outline.svgRound(line[11])}`);\n                continue;\n            }\n            for(let i = 6, ii = line.length; i < ii; i += 6){\n                const [c1x, c1y, c2x, c2y, x, y] = line.subarray(i, i + 6).map(Outline.svgRound);\n                buffer.push(`C${c1x} ${c1y} ${c2x} ${c2y} ${x} ${y}`);\n            }\n        }\n        return buffer.join(\"\");\n    }\n    serialize([pageX, pageY, pageWidth, pageHeight], isForCopying) {\n        const serializedLines = [];\n        const serializedPoints = [];\n        const [x, y, width, height] = this.#getBBoxWithNoMargin();\n        let tx, ty, sx, sy, x1, y1, x2, y2, rescaleFn;\n        switch(this.#rotation){\n            case 0:\n                rescaleFn = Outline._rescale;\n                tx = pageX;\n                ty = pageY + pageHeight;\n                sx = pageWidth;\n                sy = -pageHeight;\n                x1 = pageX + x * pageWidth;\n                y1 = pageY + (1 - y - height) * pageHeight;\n                x2 = pageX + (x + width) * pageWidth;\n                y2 = pageY + (1 - y) * pageHeight;\n                break;\n            case 90:\n                rescaleFn = Outline._rescaleAndSwap;\n                tx = pageX;\n                ty = pageY;\n                sx = pageWidth;\n                sy = pageHeight;\n                x1 = pageX + y * pageWidth;\n                y1 = pageY + x * pageHeight;\n                x2 = pageX + (y + height) * pageWidth;\n                y2 = pageY + (x + width) * pageHeight;\n                break;\n            case 180:\n                rescaleFn = Outline._rescale;\n                tx = pageX + pageWidth;\n                ty = pageY;\n                sx = -pageWidth;\n                sy = pageHeight;\n                x1 = pageX + (1 - x - width) * pageWidth;\n                y1 = pageY + y * pageHeight;\n                x2 = pageX + (1 - x) * pageWidth;\n                y2 = pageY + (y + height) * pageHeight;\n                break;\n            case 270:\n                rescaleFn = Outline._rescaleAndSwap;\n                tx = pageX + pageWidth;\n                ty = pageY + pageHeight;\n                sx = -pageWidth;\n                sy = -pageHeight;\n                x1 = pageX + (1 - y - height) * pageWidth;\n                y1 = pageY + (1 - x - width) * pageHeight;\n                x2 = pageX + (1 - y) * pageWidth;\n                y2 = pageY + (1 - x) * pageHeight;\n                break;\n        }\n        for (const { line, points } of this.#lines){\n            serializedLines.push(rescaleFn(line, tx, ty, sx, sy, isForCopying ? new Array(line.length) : null));\n            serializedPoints.push(rescaleFn(points, tx, ty, sx, sy, isForCopying ? new Array(points.length) : null));\n        }\n        return {\n            lines: serializedLines,\n            points: serializedPoints,\n            rect: [\n                x1,\n                y1,\n                x2,\n                y2\n            ]\n        };\n    }\n    static deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, { paths: { lines, points }, rotation, thickness }) {\n        const newLines = [];\n        let tx, ty, sx, sy, rescaleFn;\n        switch(rotation){\n            case 0:\n                rescaleFn = Outline._rescale;\n                tx = -pageX / pageWidth;\n                ty = pageY / pageHeight + 1;\n                sx = 1 / pageWidth;\n                sy = -1 / pageHeight;\n                break;\n            case 90:\n                rescaleFn = Outline._rescaleAndSwap;\n                tx = -pageY / pageHeight;\n                ty = -pageX / pageWidth;\n                sx = 1 / pageHeight;\n                sy = 1 / pageWidth;\n                break;\n            case 180:\n                rescaleFn = Outline._rescale;\n                tx = pageX / pageWidth + 1;\n                ty = -pageY / pageHeight;\n                sx = -1 / pageWidth;\n                sy = 1 / pageHeight;\n                break;\n            case 270:\n                rescaleFn = Outline._rescaleAndSwap;\n                tx = pageY / pageHeight + 1;\n                ty = pageX / pageWidth + 1;\n                sx = -1 / pageHeight;\n                sy = -1 / pageWidth;\n                break;\n        }\n        if (!lines) {\n            lines = [];\n            for (const point of points){\n                const len = point.length;\n                if (len === 2) {\n                    lines.push(new Float32Array([\n                        NaN,\n                        NaN,\n                        NaN,\n                        NaN,\n                        point[0],\n                        point[1]\n                    ]));\n                    continue;\n                }\n                if (len === 4) {\n                    lines.push(new Float32Array([\n                        NaN,\n                        NaN,\n                        NaN,\n                        NaN,\n                        point[0],\n                        point[1],\n                        NaN,\n                        NaN,\n                        NaN,\n                        NaN,\n                        point[2],\n                        point[3]\n                    ]));\n                    continue;\n                }\n                const line = new Float32Array(3 * (len - 2));\n                lines.push(line);\n                let [x1, y1, x2, y2] = point.subarray(0, 4);\n                line.set([\n                    NaN,\n                    NaN,\n                    NaN,\n                    NaN,\n                    x1,\n                    y1\n                ], 0);\n                for(let i = 4; i < len; i += 2){\n                    const x = point[i];\n                    const y = point[i + 1];\n                    line.set(Outline.createBezierPoints(x1, y1, x2, y2, x, y), (i - 2) * 3);\n                    [x1, y1, x2, y2] = [\n                        x2,\n                        y2,\n                        x,\n                        y\n                    ];\n                }\n            }\n        }\n        for(let i = 0, ii = lines.length; i < ii; i++){\n            newLines.push({\n                line: rescaleFn(lines[i].map((x)=>x ?? NaN), tx, ty, sx, sy),\n                points: rescaleFn(points[i].map((x)=>x ?? NaN), tx, ty, sx, sy)\n            });\n        }\n        const outlines = new this.prototype.constructor();\n        outlines.build(newLines, pageWidth, pageHeight, 1, rotation, thickness, innerMargin);\n        return outlines;\n    }\n    #getMarginComponents(thickness = this.#thickness) {\n        const margin = this.#innerMargin + thickness / 2 * this.#parentScale;\n        return this.#rotation % 180 === 0 ? [\n            margin / this.#parentWidth,\n            margin / this.#parentHeight\n        ] : [\n            margin / this.#parentHeight,\n            margin / this.#parentWidth\n        ];\n    }\n    #getBBoxWithNoMargin() {\n        const [x, y, width, height] = this.#bbox;\n        const [marginX, marginY] = this.#getMarginComponents(0);\n        return [\n            x + marginX,\n            y + marginY,\n            width - 2 * marginX,\n            height - 2 * marginY\n        ];\n    }\n    #computeBbox() {\n        const bbox = this.#bbox = new Float32Array([\n            Infinity,\n            Infinity,\n            -Infinity,\n            -Infinity\n        ]);\n        for (const { line } of this.#lines){\n            if (line.length <= 12) {\n                for(let i = 4, ii = line.length; i < ii; i += 6){\n                    Util.pointBoundingBox(line[i], line[i + 1], bbox);\n                }\n                continue;\n            }\n            let lastX = line[4], lastY = line[5];\n            for(let i = 6, ii = line.length; i < ii; i += 6){\n                const [c1x, c1y, c2x, c2y, x, y] = line.subarray(i, i + 6);\n                Util.bezierBoundingBox(lastX, lastY, c1x, c1y, c2x, c2y, x, y, bbox);\n                lastX = x;\n                lastY = y;\n            }\n        }\n        const [marginX, marginY] = this.#getMarginComponents();\n        bbox[0] = MathClamp(bbox[0] - marginX, 0, 1);\n        bbox[1] = MathClamp(bbox[1] - marginY, 0, 1);\n        bbox[2] = MathClamp(bbox[2] + marginX, 0, 1);\n        bbox[3] = MathClamp(bbox[3] + marginY, 0, 1);\n        bbox[2] -= bbox[0];\n        bbox[3] -= bbox[1];\n    }\n    get box() {\n        return this.#bbox;\n    }\n    updateProperty(name, value1) {\n        if (name === \"stroke-width\") {\n            return this.#updateThickness(value1);\n        }\n        return null;\n    }\n    #updateThickness(thickness) {\n        const [oldMarginX, oldMarginY] = this.#getMarginComponents();\n        this.#thickness = thickness;\n        const [newMarginX, newMarginY] = this.#getMarginComponents();\n        const [diffMarginX, diffMarginY] = [\n            newMarginX - oldMarginX,\n            newMarginY - oldMarginY\n        ];\n        const bbox = this.#bbox;\n        bbox[0] -= diffMarginX;\n        bbox[1] -= diffMarginY;\n        bbox[2] += 2 * diffMarginX;\n        bbox[3] += 2 * diffMarginY;\n        return bbox;\n    }\n    updateParentDimensions([width, height], scale) {\n        const [oldMarginX, oldMarginY] = this.#getMarginComponents();\n        this.#parentWidth = width;\n        this.#parentHeight = height;\n        this.#parentScale = scale;\n        const [newMarginX, newMarginY] = this.#getMarginComponents();\n        const diffMarginX = newMarginX - oldMarginX;\n        const diffMarginY = newMarginY - oldMarginY;\n        const bbox = this.#bbox;\n        bbox[0] -= diffMarginX;\n        bbox[1] -= diffMarginY;\n        bbox[2] += 2 * diffMarginX;\n        bbox[3] += 2 * diffMarginY;\n        return bbox;\n    }\n    updateRotation(rotation) {\n        this.#currentRotation = rotation;\n        return {\n            path: {\n                transform: this.rotationTransform\n            }\n        };\n    }\n    get viewBox() {\n        return this.#bbox.map(Outline.svgRound).join(\" \");\n    }\n    get defaultProperties() {\n        const [x, y] = this.#bbox;\n        return {\n            root: {\n                viewBox: this.viewBox\n            },\n            path: {\n                \"transform-origin\": `${Outline.svgRound(x)} ${Outline.svgRound(y)}`\n            }\n        };\n    }\n    get rotationTransform() {\n        const [, , width, height] = this.#bbox;\n        let a = 0, b = 0, c = 0, d = 0, e = 0, f = 0;\n        switch(this.#currentRotation){\n            case 90:\n                b = height / width;\n                c = -width / height;\n                e = width;\n                break;\n            case 180:\n                a = -1;\n                d = -1;\n                e = width;\n                f = height;\n                break;\n            case 270:\n                b = -height / width;\n                c = width / height;\n                f = height;\n                break;\n            default:\n                return \"\";\n        }\n        return `matrix(${a} ${b} ${c} ${d} ${Outline.svgRound(e)} ${Outline.svgRound(f)})`;\n    }\n    getPathResizingSVGProperties([newX, newY, newWidth, newHeight]) {\n        const [marginX, marginY] = this.#getMarginComponents();\n        const [x, y, width, height] = this.#bbox;\n        if (Math.abs(width - marginX) <= Outline.PRECISION || Math.abs(height - marginY) <= Outline.PRECISION) {\n            const tx = newX + newWidth / 2 - (x + width / 2);\n            const ty = newY + newHeight / 2 - (y + height / 2);\n            return {\n                path: {\n                    \"transform-origin\": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,\n                    transform: `${this.rotationTransform} translate(${tx} ${ty})`\n                }\n            };\n        }\n        const s1x = (newWidth - 2 * marginX) / (width - 2 * marginX);\n        const s1y = (newHeight - 2 * marginY) / (height - 2 * marginY);\n        const s2x = width / newWidth;\n        const s2y = height / newHeight;\n        return {\n            path: {\n                \"transform-origin\": `${Outline.svgRound(x)} ${Outline.svgRound(y)}`,\n                transform: `${this.rotationTransform} scale(${s2x} ${s2y}) translate(${Outline.svgRound(marginX)} ${Outline.svgRound(marginY)}) scale(${s1x} ${s1y}) translate(${Outline.svgRound(-marginX)} ${Outline.svgRound(-marginY)})`\n            }\n        };\n    }\n    getPathResizedSVGProperties([newX, newY, newWidth, newHeight]) {\n        const [marginX, marginY] = this.#getMarginComponents();\n        const bbox = this.#bbox;\n        const [x, y, width, height] = bbox;\n        bbox[0] = newX;\n        bbox[1] = newY;\n        bbox[2] = newWidth;\n        bbox[3] = newHeight;\n        if (Math.abs(width - marginX) <= Outline.PRECISION || Math.abs(height - marginY) <= Outline.PRECISION) {\n            const tx2 = newX + newWidth / 2 - (x + width / 2);\n            const ty2 = newY + newHeight / 2 - (y + height / 2);\n            for (const { line, points } of this.#lines){\n                Outline._translate(line, tx2, ty2, line);\n                Outline._translate(points, tx2, ty2, points);\n            }\n            return {\n                root: {\n                    viewBox: this.viewBox\n                },\n                path: {\n                    \"transform-origin\": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,\n                    transform: this.rotationTransform || null,\n                    d: this.toSVGPath()\n                }\n            };\n        }\n        const s1x = (newWidth - 2 * marginX) / (width - 2 * marginX);\n        const s1y = (newHeight - 2 * marginY) / (height - 2 * marginY);\n        const tx = -s1x * (x + marginX) + newX + marginX;\n        const ty = -s1y * (y + marginY) + newY + marginY;\n        if (s1x !== 1 || s1y !== 1 || tx !== 0 || ty !== 0) {\n            for (const { line, points } of this.#lines){\n                Outline._rescale(line, tx, ty, s1x, s1y, line);\n                Outline._rescale(points, tx, ty, s1x, s1y, points);\n            }\n        }\n        return {\n            root: {\n                viewBox: this.viewBox\n            },\n            path: {\n                \"transform-origin\": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,\n                transform: this.rotationTransform || null,\n                d: this.toSVGPath()\n            }\n        };\n    }\n    getPathTranslatedSVGProperties([newX, newY], parentDimensions) {\n        const [newParentWidth, newParentHeight] = parentDimensions;\n        const bbox = this.#bbox;\n        const tx = newX - bbox[0];\n        const ty = newY - bbox[1];\n        if (this.#parentWidth === newParentWidth && this.#parentHeight === newParentHeight) {\n            for (const { line, points } of this.#lines){\n                Outline._translate(line, tx, ty, line);\n                Outline._translate(points, tx, ty, points);\n            }\n        } else {\n            const sx = this.#parentWidth / newParentWidth;\n            const sy = this.#parentHeight / newParentHeight;\n            this.#parentWidth = newParentWidth;\n            this.#parentHeight = newParentHeight;\n            for (const { line, points } of this.#lines){\n                Outline._rescale(line, tx, ty, sx, sy, line);\n                Outline._rescale(points, tx, ty, sx, sy, points);\n            }\n            bbox[2] *= sx;\n            bbox[3] *= sy;\n        }\n        bbox[0] = newX;\n        bbox[1] = newY;\n        return {\n            root: {\n                viewBox: this.viewBox\n            },\n            path: {\n                d: this.toSVGPath(),\n                \"transform-origin\": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`\n            }\n        };\n    }\n    get defaultSVGProperties() {\n        const bbox = this.#bbox;\n        return {\n            root: {\n                viewBox: this.viewBox\n            },\n            rootClass: {\n                draw: true\n            },\n            path: {\n                d: this.toSVGPath(),\n                \"transform-origin\": `${Outline.svgRound(bbox[0])} ${Outline.svgRound(bbox[1])}`,\n                transform: this.rotationTransform || null\n            },\n            bbox\n        };\n    }\n    constructor(...args){\n        super(...args);\n        this.#currentRotation = 0;\n    }\n}\nclass InkDrawingOptions extends DrawingOptions {\n    constructor(viewerParameters){\n        super();\n        this._viewParameters = viewerParameters;\n        super.updateProperties({\n            fill: \"none\",\n            stroke: AnnotationEditor._defaultLineColor,\n            \"stroke-opacity\": 1,\n            \"stroke-width\": 1,\n            \"stroke-linecap\": \"round\",\n            \"stroke-linejoin\": \"round\",\n            \"stroke-miterlimit\": 10\n        });\n    }\n    updateSVGProperty(name, value1) {\n        if (name === \"stroke-width\") {\n            value1 ??= this[\"stroke-width\"];\n            value1 *= this._viewParameters.realScale;\n        }\n        super.updateSVGProperty(name, value1);\n    }\n    clone() {\n        const clone = new InkDrawingOptions(this._viewParameters);\n        clone.updateAll(this);\n        return clone;\n    }\n}\nclass InkEditor extends DrawingEditor {\n    static{\n        this._type = \"ink\";\n    }\n    static{\n        this._editorType = AnnotationEditorType.INK;\n    }\n    static{\n        this._defaultDrawingOptions = null;\n    }\n    constructor(params){\n        super({\n            ...params,\n            name: \"inkEditor\"\n        });\n        this._willKeepAspectRatio = true;\n        this.defaultL10nId = \"pdfjs-editor-ink-editor\";\n    }\n    static initialize(l10n, uiManager) {\n        AnnotationEditor.initialize(l10n, uiManager);\n        this._defaultDrawingOptions = new InkDrawingOptions(uiManager.viewParameters);\n    }\n    static getDefaultDrawingOptions(options) {\n        const clone = this._defaultDrawingOptions.clone();\n        clone.updateProperties(options);\n        return clone;\n    }\n    static get supportMultipleDrawings() {\n        return true;\n    }\n    static get typesMap() {\n        return shadow(this, \"typesMap\", /* @__PURE__ */ new Map([\n            [\n                AnnotationEditorParamsType.INK_THICKNESS,\n                \"stroke-width\"\n            ],\n            [\n                AnnotationEditorParamsType.INK_COLOR,\n                \"stroke\"\n            ],\n            [\n                AnnotationEditorParamsType.INK_OPACITY,\n                \"stroke-opacity\"\n            ]\n        ]));\n    }\n    static createDrawerInstance(x, y, parentWidth, parentHeight, rotation) {\n        return new InkDrawOutliner(x, y, parentWidth, parentHeight, rotation, this._defaultDrawingOptions[\"stroke-width\"]);\n    }\n    static deserializeDraw(pageX, pageY, pageWidth, pageHeight, innerMargin, data) {\n        return InkDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);\n    }\n    static async deserialize(data, parent, uiManager) {\n        let initialData = null;\n        if (data instanceof InkAnnotationElement) {\n            const { data: { inkLists, rect, rotation, id, color, opacity, borderStyle: { rawWidth: thickness }, popupRef, richText, contentsObj, creationDate, modificationDate }, parent: { page: { pageNumber } } } = data;\n            initialData = data = {\n                annotationType: AnnotationEditorType.INK,\n                color: Array.from(color),\n                thickness,\n                opacity,\n                paths: {\n                    points: inkLists\n                },\n                boxes: null,\n                pageIndex: pageNumber - 1,\n                rect: rect.slice(0),\n                rotation,\n                annotationElementId: id,\n                id,\n                deleted: false,\n                popupRef,\n                richText,\n                comment: contentsObj?.str || null,\n                creationDate,\n                modificationDate\n            };\n        }\n        const editor = await super.deserialize(data, parent, uiManager);\n        editor._initialData = initialData;\n        if (data.comment) {\n            editor.setCommentData(data);\n        }\n        return editor;\n    }\n    get toolbarButtons() {\n        this._colorPicker ||= new BasicColorPicker(this);\n        return [\n            [\n                \"colorPicker\",\n                this._colorPicker\n            ]\n        ];\n    }\n    get colorType() {\n        return AnnotationEditorParamsType.INK_COLOR;\n    }\n    get color() {\n        return this._drawingOptions.stroke;\n    }\n    get opacity() {\n        return this._drawingOptions[\"stroke-opacity\"];\n    }\n    onScaleChanging() {\n        if (!this.parent) {\n            return;\n        }\n        super.onScaleChanging();\n        const { _drawId, _drawingOptions, parent } = this;\n        _drawingOptions.updateSVGProperty(\"stroke-width\");\n        parent.drawLayer.updateProperties(_drawId, _drawingOptions.toSVGProperties());\n    }\n    static onScaleChangingWhenDrawing() {\n        const parent = this._currentParent;\n        if (!parent) {\n            return;\n        }\n        super.onScaleChangingWhenDrawing();\n        this._defaultDrawingOptions.updateSVGProperty(\"stroke-width\");\n        parent.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties());\n    }\n    createDrawingOptions({ color, thickness, opacity }) {\n        this._drawingOptions = InkEditor.getDefaultDrawingOptions({\n            stroke: Util.makeHexColor(...color),\n            \"stroke-width\": thickness,\n            \"stroke-opacity\": opacity\n        });\n    }\n    serialize(isForCopying = false) {\n        if (this.isEmpty()) {\n            return null;\n        }\n        if (this.deleted) {\n            return this.serializeDeleted();\n        }\n        const { lines, points } = this.serializeDraw(isForCopying);\n        const { _drawingOptions: { stroke, \"stroke-opacity\": opacity, \"stroke-width\": thickness } } = this;\n        const serialized = Object.assign(super.serialize(isForCopying), {\n            color: AnnotationEditor._colorManager.convert(stroke),\n            opacity,\n            thickness,\n            paths: {\n                lines,\n                points\n            }\n        });\n        this.addComment(serialized);\n        if (isForCopying) {\n            serialized.isCopy = true;\n            return serialized;\n        }\n        if (this.annotationElementId && !this.#hasElementChanged(serialized)) {\n            return null;\n        }\n        serialized.id = this.annotationElementId;\n        return serialized;\n    }\n    #hasElementChanged(serialized) {\n        const { color, thickness, opacity, pageIndex } = this._initialData;\n        return this.hasEditedComment || this._hasBeenMoved || this._hasBeenResized || serialized.color.some((c, i)=>c !== color[i]) || serialized.thickness !== thickness || serialized.opacity !== opacity || serialized.pageIndex !== pageIndex;\n    }\n    renderAnnotationElement(annotation) {\n        if (this.deleted) {\n            annotation.hide();\n            return null;\n        }\n        const { points, rect } = this.serializeDraw(false);\n        annotation.updateEdited({\n            rect,\n            thickness: this._drawingOptions[\"stroke-width\"],\n            points,\n            popup: this.comment\n        });\n        return null;\n    }\n}\nclass ContourDrawOutline extends InkDrawOutline {\n    toSVGPath() {\n        let path = super.toSVGPath();\n        if (!path.endsWith(\"Z\")) {\n            path += \"Z\";\n        }\n        return path;\n    }\n}\nconst BASE_HEADER_LENGTH = 8;\nconst POINTS_PROPERTIES_NUMBER = 3;\nclass SignatureExtractor {\n    static #PARAMETERS = {\n        maxDim: 512,\n        sigmaSFactor: 0.02,\n        sigmaR: 25,\n        kernelSize: 16\n    };\n    static #neighborIndexToId(i0, j0, i, j) {\n        i -= i0;\n        j -= j0;\n        if (i === 0) {\n            return j > 0 ? 0 : 4;\n        }\n        if (i === 1) {\n            return j + 6;\n        }\n        return 2 - j;\n    }\n    static #neighborIdToIndex = new Int32Array([\n        0,\n        1,\n        -1,\n        1,\n        -1,\n        0,\n        -1,\n        -1,\n        0,\n        -1,\n        1,\n        -1,\n        1,\n        0,\n        1,\n        1\n    ]);\n    static #clockwiseNonZero(buf, width, i0, j0, i, j, offset) {\n        const id = this.#neighborIndexToId(i0, j0, i, j);\n        for(let k = 0; k < 8; k++){\n            const kk = (-k + id - offset + 16) % 8;\n            const shiftI = this.#neighborIdToIndex[2 * kk];\n            const shiftJ = this.#neighborIdToIndex[2 * kk + 1];\n            if (buf[(i0 + shiftI) * width + (j0 + shiftJ)] !== 0) {\n                return kk;\n            }\n        }\n        return -1;\n    }\n    static #counterClockwiseNonZero(buf, width, i0, j0, i, j, offset) {\n        const id = this.#neighborIndexToId(i0, j0, i, j);\n        for(let k = 0; k < 8; k++){\n            const kk = (k + id + offset + 16) % 8;\n            const shiftI = this.#neighborIdToIndex[2 * kk];\n            const shiftJ = this.#neighborIdToIndex[2 * kk + 1];\n            if (buf[(i0 + shiftI) * width + (j0 + shiftJ)] !== 0) {\n                return kk;\n            }\n        }\n        return -1;\n    }\n    static #findContours(buf, width, height, threshold) {\n        const N = buf.length;\n        const types = new Int32Array(N);\n        for(let i = 0; i < N; i++){\n            types[i] = buf[i] <= threshold ? 1 : 0;\n        }\n        for(let i = 1; i < height - 1; i++){\n            types[i * width] = types[i * width + width - 1] = 0;\n        }\n        for(let i = 0; i < width; i++){\n            types[i] = types[width * height - 1 - i] = 0;\n        }\n        let nbd = 1;\n        let lnbd;\n        const contours = [];\n        for(let i = 1; i < height - 1; i++){\n            lnbd = 1;\n            for(let j = 1; j < width - 1; j++){\n                const ij = i * width + j;\n                const pix = types[ij];\n                if (pix === 0) {\n                    continue;\n                }\n                let i2 = i;\n                let j2 = j;\n                if (pix === 1 && types[ij - 1] === 0) {\n                    nbd += 1;\n                    j2 -= 1;\n                } else if (pix >= 1 && types[ij + 1] === 0) {\n                    nbd += 1;\n                    j2 += 1;\n                    if (pix > 1) {\n                        lnbd = pix;\n                    }\n                } else {\n                    if (pix !== 1) {\n                        lnbd = Math.abs(pix);\n                    }\n                    continue;\n                }\n                const points = [\n                    j,\n                    i\n                ];\n                const isHole = j2 === j + 1;\n                const contour = {\n                    isHole,\n                    points,\n                    id: nbd,\n                    parent: 0\n                };\n                contours.push(contour);\n                let contour0;\n                for (const c of contours){\n                    if (c.id === lnbd) {\n                        contour0 = c;\n                        break;\n                    }\n                }\n                if (!contour0) {\n                    contour.parent = isHole ? lnbd : 0;\n                } else if (contour0.isHole) {\n                    contour.parent = isHole ? contour0.parent : lnbd;\n                } else {\n                    contour.parent = isHole ? lnbd : contour0.parent;\n                }\n                const k = this.#clockwiseNonZero(types, width, i, j, i2, j2, 0);\n                if (k === -1) {\n                    types[ij] = -nbd;\n                    if (types[ij] !== 1) {\n                        lnbd = Math.abs(types[ij]);\n                    }\n                    continue;\n                }\n                let shiftI = this.#neighborIdToIndex[2 * k];\n                let shiftJ = this.#neighborIdToIndex[2 * k + 1];\n                const i1 = i + shiftI;\n                const j1 = j + shiftJ;\n                i2 = i1;\n                j2 = j1;\n                let i3 = i;\n                let j3 = j;\n                while(true){\n                    const kk = this.#counterClockwiseNonZero(types, width, i3, j3, i2, j2, 1);\n                    shiftI = this.#neighborIdToIndex[2 * kk];\n                    shiftJ = this.#neighborIdToIndex[2 * kk + 1];\n                    const i4 = i3 + shiftI;\n                    const j4 = j3 + shiftJ;\n                    points.push(j4, i4);\n                    const ij3 = i3 * width + j3;\n                    if (types[ij3 + 1] === 0) {\n                        types[ij3] = -nbd;\n                    } else if (types[ij3] === 1) {\n                        types[ij3] = nbd;\n                    }\n                    if (i4 === i && j4 === j && i3 === i1 && j3 === j1) {\n                        if (types[ij] !== 1) {\n                            lnbd = Math.abs(types[ij]);\n                        }\n                        break;\n                    } else {\n                        i2 = i3;\n                        j2 = j3;\n                        i3 = i4;\n                        j3 = j4;\n                    }\n                }\n            }\n        }\n        return contours;\n    }\n    static #douglasPeuckerHelper(points, start, end, output) {\n        if (end - start <= 4) {\n            for(let i = start; i < end - 2; i += 2){\n                output.push(points[i], points[i + 1]);\n            }\n            return;\n        }\n        const ax = points[start];\n        const ay = points[start + 1];\n        const abx = points[end - 4] - ax;\n        const aby = points[end - 3] - ay;\n        const dist = Math.hypot(abx, aby);\n        const nabx = abx / dist;\n        const naby = aby / dist;\n        const aa = nabx * ay - naby * ax;\n        const m = aby / abx;\n        const invS = 1 / dist;\n        const phi = Math.atan(m);\n        const cosPhi = Math.cos(phi);\n        const sinPhi = Math.sin(phi);\n        const tmax = invS * (Math.abs(cosPhi) + Math.abs(sinPhi));\n        const poly = invS * (1 - tmax + tmax ** 2);\n        const partialPhi = Math.max(Math.atan(Math.abs(sinPhi + cosPhi) * poly), Math.atan(Math.abs(sinPhi - cosPhi) * poly));\n        let dmax = 0;\n        let index = start;\n        for(let i = start + 2; i < end - 2; i += 2){\n            const d = Math.abs(aa - nabx * points[i + 1] + naby * points[i]);\n            if (d > dmax) {\n                index = i;\n                dmax = d;\n            }\n        }\n        if (dmax > (dist * partialPhi) ** 2) {\n            this.#douglasPeuckerHelper(points, start, index + 2, output);\n            this.#douglasPeuckerHelper(points, index, end, output);\n        } else {\n            output.push(ax, ay);\n        }\n    }\n    static #douglasPeucker(points) {\n        const output = [];\n        const len = points.length;\n        this.#douglasPeuckerHelper(points, 0, len, output);\n        output.push(points[len - 2], points[len - 1]);\n        return output.length <= 4 ? null : output;\n    }\n    static #bilateralFilter(buf, width, height, sigmaS, sigmaR, kernelSize) {\n        const kernel = new Float32Array(kernelSize ** 2);\n        const sigmaS2 = -2 * sigmaS ** 2;\n        const halfSize = kernelSize >> 1;\n        for(let i = 0; i < kernelSize; i++){\n            const x = (i - halfSize) ** 2;\n            for(let j = 0; j < kernelSize; j++){\n                kernel[i * kernelSize + j] = Math.exp((x + (j - halfSize) ** 2) / sigmaS2);\n            }\n        }\n        const rangeValues = new Float32Array(256);\n        const sigmaR2 = -2 * sigmaR ** 2;\n        for(let i = 0; i < 256; i++){\n            rangeValues[i] = Math.exp(i ** 2 / sigmaR2);\n        }\n        const N = buf.length;\n        const out = new Uint8Array(N);\n        const histogram = new Uint32Array(256);\n        for(let i = 0; i < height; i++){\n            for(let j = 0; j < width; j++){\n                const ij = i * width + j;\n                const center = buf[ij];\n                let sum = 0;\n                let norm = 0;\n                for(let k = 0; k < kernelSize; k++){\n                    const y = i + k - halfSize;\n                    if (y < 0 || y >= height) {\n                        continue;\n                    }\n                    for(let l = 0; l < kernelSize; l++){\n                        const x = j + l - halfSize;\n                        if (x < 0 || x >= width) {\n                            continue;\n                        }\n                        const neighbour = buf[y * width + x];\n                        const w = kernel[k * kernelSize + l] * rangeValues[Math.abs(neighbour - center)];\n                        sum += neighbour * w;\n                        norm += w;\n                    }\n                }\n                const pix = out[ij] = Math.round(sum / norm);\n                histogram[pix]++;\n            }\n        }\n        return [\n            out,\n            histogram\n        ];\n    }\n    static #getHistogram(buf) {\n        const histogram = new Uint32Array(256);\n        for (const g of buf){\n            histogram[g]++;\n        }\n        return histogram;\n    }\n    static #toUint8(buf) {\n        const N = buf.length;\n        const out = new Uint8ClampedArray(N >> 2);\n        let max = -Infinity;\n        let min = Infinity;\n        for(let i = 0, ii = out.length; i < ii; i++){\n            const pix = out[i] = buf[i << 2];\n            max = Math.max(max, pix);\n            min = Math.min(min, pix);\n        }\n        const ratio = 255 / (max - min);\n        for(let i = 0, ii = out.length; i < ii; i++){\n            out[i] = (out[i] - min) * ratio;\n        }\n        return out;\n    }\n    static #guessThreshold(histogram) {\n        let i;\n        let M = -Infinity;\n        let L = -Infinity;\n        const min = histogram.findIndex((v)=>v !== 0);\n        let pos = min;\n        let spos = min;\n        for(i = min; i < 256; i++){\n            const v = histogram[i];\n            if (v > M) {\n                if (i - pos > L) {\n                    L = i - pos;\n                    spos = i - 1;\n                }\n                M = v;\n                pos = i;\n            }\n        }\n        for(i = spos - 1; i >= 0; i--){\n            if (histogram[i] > histogram[i + 1]) {\n                break;\n            }\n        }\n        return i;\n    }\n    static #getGrayPixels(bitmap) {\n        const originalBitmap = bitmap;\n        const { width, height } = bitmap;\n        const { maxDim } = this.#PARAMETERS;\n        let newWidth = width;\n        let newHeight = height;\n        if (width > maxDim || height > maxDim) {\n            let prevWidth = width;\n            let prevHeight = height;\n            let steps = Math.log2(Math.max(width, height) / maxDim);\n            const isteps = Math.floor(steps);\n            steps = steps === isteps ? isteps - 1 : isteps;\n            for(let i = 0; i < steps; i++){\n                newWidth = Math.ceil(prevWidth / 2);\n                newHeight = Math.ceil(prevHeight / 2);\n                const offscreen2 = new OffscreenCanvas(newWidth, newHeight);\n                const ctx2 = offscreen2.getContext(\"2d\");\n                ctx2.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);\n                prevWidth = newWidth;\n                prevHeight = newHeight;\n                if (bitmap !== originalBitmap) {\n                    bitmap.close();\n                }\n                bitmap = offscreen2.transferToImageBitmap();\n            }\n            const ratio = Math.min(maxDim / newWidth, maxDim / newHeight);\n            newWidth = Math.round(newWidth * ratio);\n            newHeight = Math.round(newHeight * ratio);\n        }\n        const offscreen = new OffscreenCanvas(newWidth, newHeight);\n        const ctx = offscreen.getContext(\"2d\", {\n            willReadFrequently: true\n        });\n        ctx.fillStyle = \"white\";\n        ctx.fillRect(0, 0, newWidth, newHeight);\n        ctx.filter = \"grayscale(1)\";\n        ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, newWidth, newHeight);\n        const grayImage = ctx.getImageData(0, 0, newWidth, newHeight).data;\n        const uint8Buf = this.#toUint8(grayImage);\n        return [\n            uint8Buf,\n            newWidth,\n            newHeight\n        ];\n    }\n    static extractContoursFromText(text, { fontFamily, fontStyle, fontWeight }, pageWidth, pageHeight, rotation, innerMargin) {\n        let canvas = new OffscreenCanvas(1, 1);\n        let ctx = canvas.getContext(\"2d\", {\n            alpha: false\n        });\n        const fontSize = 200;\n        const font = ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;\n        const { actualBoundingBoxLeft, actualBoundingBoxRight, actualBoundingBoxAscent, actualBoundingBoxDescent, fontBoundingBoxAscent, fontBoundingBoxDescent, width } = ctx.measureText(text);\n        const SCALE = 1.5;\n        const canvasWidth = Math.ceil(Math.max(Math.abs(actualBoundingBoxLeft) + Math.abs(actualBoundingBoxRight) || 0, width) * SCALE);\n        const canvasHeight = Math.ceil(Math.max(Math.abs(actualBoundingBoxAscent) + Math.abs(actualBoundingBoxDescent) || fontSize, Math.abs(fontBoundingBoxAscent) + Math.abs(fontBoundingBoxDescent) || fontSize) * SCALE);\n        canvas = new OffscreenCanvas(canvasWidth, canvasHeight);\n        ctx = canvas.getContext(\"2d\", {\n            alpha: true,\n            willReadFrequently: true\n        });\n        ctx.font = font;\n        ctx.filter = \"grayscale(1)\";\n        ctx.fillStyle = \"white\";\n        ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n        ctx.fillStyle = \"black\";\n        ctx.fillText(text, canvasWidth * (SCALE - 1) / 2, canvasHeight * (3 - SCALE) / 2);\n        const uint8Buf = this.#toUint8(ctx.getImageData(0, 0, canvasWidth, canvasHeight).data);\n        const histogram = this.#getHistogram(uint8Buf);\n        const threshold = this.#guessThreshold(histogram);\n        const contourList = this.#findContours(uint8Buf, canvasWidth, canvasHeight, threshold);\n        return this.processDrawnLines({\n            lines: {\n                curves: contourList,\n                width: canvasWidth,\n                height: canvasHeight\n            },\n            pageWidth,\n            pageHeight,\n            rotation,\n            innerMargin,\n            mustSmooth: true,\n            areContours: true\n        });\n    }\n    static process(bitmap, pageWidth, pageHeight, rotation, innerMargin) {\n        const [uint8Buf, width, height] = this.#getGrayPixels(bitmap);\n        const [buffer, histogram] = this.#bilateralFilter(uint8Buf, width, height, Math.hypot(width, height) * this.#PARAMETERS.sigmaSFactor, this.#PARAMETERS.sigmaR, this.#PARAMETERS.kernelSize);\n        const threshold = this.#guessThreshold(histogram);\n        const contourList = this.#findContours(buffer, width, height, threshold);\n        return this.processDrawnLines({\n            lines: {\n                curves: contourList,\n                width,\n                height\n            },\n            pageWidth,\n            pageHeight,\n            rotation,\n            innerMargin,\n            mustSmooth: true,\n            areContours: true\n        });\n    }\n    static processDrawnLines({ lines, pageWidth, pageHeight, rotation, innerMargin, mustSmooth, areContours }) {\n        if (rotation % 180 !== 0) {\n            [pageWidth, pageHeight] = [\n                pageHeight,\n                pageWidth\n            ];\n        }\n        const { curves, width, height } = lines;\n        const thickness = lines.thickness ?? 0;\n        const linesAndPoints = [];\n        const ratio = Math.min(pageWidth / width, pageHeight / height);\n        const xScale = ratio / pageWidth;\n        const yScale = ratio / pageHeight;\n        const newCurves = [];\n        for (const { points } of curves){\n            const reducedPoints = mustSmooth ? this.#douglasPeucker(points) : points;\n            if (!reducedPoints) {\n                continue;\n            }\n            newCurves.push(reducedPoints);\n            const len = reducedPoints.length;\n            const newPoints = new Float32Array(len);\n            const line = new Float32Array(3 * (len === 2 ? 2 : len - 2));\n            linesAndPoints.push({\n                line,\n                points: newPoints\n            });\n            if (len === 2) {\n                newPoints[0] = reducedPoints[0] * xScale;\n                newPoints[1] = reducedPoints[1] * yScale;\n                line.set([\n                    NaN,\n                    NaN,\n                    NaN,\n                    NaN,\n                    newPoints[0],\n                    newPoints[1]\n                ], 0);\n                continue;\n            }\n            let [x1, y1, x2, y2] = reducedPoints;\n            x1 *= xScale;\n            y1 *= yScale;\n            x2 *= xScale;\n            y2 *= yScale;\n            newPoints.set([\n                x1,\n                y1,\n                x2,\n                y2\n            ], 0);\n            line.set([\n                NaN,\n                NaN,\n                NaN,\n                NaN,\n                x1,\n                y1\n            ], 0);\n            for(let i = 4; i < len; i += 2){\n                const x = newPoints[i] = reducedPoints[i] * xScale;\n                const y = newPoints[i + 1] = reducedPoints[i + 1] * yScale;\n                line.set(Outline.createBezierPoints(x1, y1, x2, y2, x, y), (i - 2) * 3);\n                [x1, y1, x2, y2] = [\n                    x2,\n                    y2,\n                    x,\n                    y\n                ];\n            }\n        }\n        if (linesAndPoints.length === 0) {\n            return null;\n        }\n        const outline = areContours ? new ContourDrawOutline() : new InkDrawOutline();\n        outline.build(linesAndPoints, pageWidth, pageHeight, 1, rotation, areContours ? 0 : thickness, innerMargin);\n        return {\n            outline,\n            newCurves,\n            areContours,\n            thickness,\n            width,\n            height\n        };\n    }\n    static async compressSignature({ outlines, areContours, thickness, width, height }) {\n        let minDiff = Infinity;\n        let maxDiff = -Infinity;\n        let outlinesLength = 0;\n        for (const points of outlines){\n            outlinesLength += points.length;\n            for(let i = 2, ii = points.length; i < ii; i++){\n                const dx = points[i] - points[i - 2];\n                minDiff = Math.min(minDiff, dx);\n                maxDiff = Math.max(maxDiff, dx);\n            }\n        }\n        let bufferType;\n        if (minDiff >= -128 && maxDiff <= 127) {\n            bufferType = Int8Array;\n        } else if (minDiff >= -32768 && maxDiff <= 32767) {\n            bufferType = Int16Array;\n        } else {\n            bufferType = Int32Array;\n        }\n        const len = outlines.length;\n        const headerLength = BASE_HEADER_LENGTH + POINTS_PROPERTIES_NUMBER * len;\n        const header = new Uint32Array(headerLength);\n        let offset = 0;\n        header[offset++] = headerLength * Uint32Array.BYTES_PER_ELEMENT + (outlinesLength - 2 * len) * bufferType.BYTES_PER_ELEMENT;\n        header[offset++] = 0;\n        header[offset++] = width;\n        header[offset++] = height;\n        header[offset++] = areContours ? 0 : 1;\n        header[offset++] = Math.max(0, Math.floor(thickness ?? 0));\n        header[offset++] = len;\n        header[offset++] = bufferType.BYTES_PER_ELEMENT;\n        for (const points of outlines){\n            header[offset++] = points.length - 2;\n            header[offset++] = points[0];\n            header[offset++] = points[1];\n        }\n        const cs = new CompressionStream(\"deflate-raw\");\n        const writer = cs.writable.getWriter();\n        await writer.ready;\n        writer.write(header);\n        const BufferCtor = bufferType.prototype.constructor;\n        for (const points of outlines){\n            const diffs = new BufferCtor(points.length - 2);\n            for(let i = 2, ii = points.length; i < ii; i++){\n                diffs[i - 2] = points[i] - points[i - 2];\n            }\n            writer.write(diffs);\n        }\n        writer.close();\n        const buf = await new Response(cs.readable).arrayBuffer();\n        const bytes = new Uint8Array(buf);\n        return toBase64Util(bytes);\n    }\n    static async decompressSignature(signatureData) {\n        try {\n            const bytes = fromBase64Util(signatureData);\n            const { readable, writable } = new DecompressionStream(\"deflate-raw\");\n            const writer = writable.getWriter();\n            await writer.ready;\n            writer.write(bytes).then(async ()=>{\n                await writer.ready;\n                await writer.close();\n            }).catch(()=>{});\n            let data = null;\n            let offset = 0;\n            for await (const chunk of readable){\n                data ||= new Uint8Array(new Uint32Array(chunk.buffer, 0, 4)[0]);\n                data.set(chunk, offset);\n                offset += chunk.length;\n            }\n            const header = new Uint32Array(data.buffer, 0, data.length >> 2);\n            const version2 = header[1];\n            if (version2 !== 0) {\n                throw new Error(`Invalid version: ${version2}`);\n            }\n            const width = header[2];\n            const height = header[3];\n            const areContours = header[4] === 0;\n            const thickness = header[5];\n            const numberOfDrawings = header[6];\n            const bufferType = header[7];\n            const outlines = [];\n            const diffsOffset = (BASE_HEADER_LENGTH + POINTS_PROPERTIES_NUMBER * numberOfDrawings) * Uint32Array.BYTES_PER_ELEMENT;\n            let diffs;\n            switch(bufferType){\n                case Int8Array.BYTES_PER_ELEMENT:\n                    diffs = new Int8Array(data.buffer, diffsOffset);\n                    break;\n                case Int16Array.BYTES_PER_ELEMENT:\n                    diffs = new Int16Array(data.buffer, diffsOffset);\n                    break;\n                case Int32Array.BYTES_PER_ELEMENT:\n                    diffs = new Int32Array(data.buffer, diffsOffset);\n                    break;\n            }\n            offset = 0;\n            for(let i = 0; i < numberOfDrawings; i++){\n                const len = header[POINTS_PROPERTIES_NUMBER * i + BASE_HEADER_LENGTH];\n                const points = new Float32Array(len + 2);\n                outlines.push(points);\n                for(let j = 0; j < POINTS_PROPERTIES_NUMBER - 1; j++){\n                    points[j] = header[POINTS_PROPERTIES_NUMBER * i + BASE_HEADER_LENGTH + j + 1];\n                }\n                for(let j = 0; j < len; j++){\n                    points[j + 2] = points[j] + diffs[offset++];\n                }\n            }\n            return {\n                areContours,\n                thickness,\n                outlines,\n                width,\n                height\n            };\n        } catch (e) {\n            warn(`decompressSignature: ${e}`);\n            return null;\n        }\n    }\n}\nclass SignatureOptions extends DrawingOptions {\n    constructor(){\n        super();\n        super.updateProperties({\n            fill: AnnotationEditor._defaultLineColor,\n            \"stroke-width\": 0\n        });\n    }\n    clone() {\n        const clone = new SignatureOptions();\n        clone.updateAll(this);\n        return clone;\n    }\n}\nclass DrawnSignatureOptions extends InkDrawingOptions {\n    constructor(viewerParameters){\n        super(viewerParameters);\n        super.updateProperties({\n            stroke: AnnotationEditor._defaultLineColor,\n            \"stroke-width\": 1\n        });\n    }\n    clone() {\n        const clone = new DrawnSignatureOptions(this._viewParameters);\n        clone.updateAll(this);\n        return clone;\n    }\n}\nclass SignatureEditor extends DrawingEditor {\n    #isExtracted;\n    #description;\n    #signatureData;\n    #signatureUUID;\n    static{\n        this._type = \"signature\";\n    }\n    static{\n        this._editorType = AnnotationEditorType.SIGNATURE;\n    }\n    static{\n        this._defaultDrawingOptions = null;\n    }\n    constructor(params){\n        super({\n            ...params,\n            mustBeCommitted: true,\n            name: \"signatureEditor\"\n        });\n        this.#isExtracted = false;\n        this.#description = null;\n        this.#signatureData = null;\n        this.#signatureUUID = null;\n        this._willKeepAspectRatio = true;\n        this.#signatureData = params.signatureData || null;\n        this.#description = null;\n        this.defaultL10nId = \"pdfjs-editor-signature-editor1\";\n    }\n    static initialize(l10n, uiManager) {\n        AnnotationEditor.initialize(l10n, uiManager);\n        this._defaultDrawingOptions = new SignatureOptions();\n        this._defaultDrawnSignatureOptions = new DrawnSignatureOptions(uiManager.viewParameters);\n    }\n    static getDefaultDrawingOptions(options) {\n        const clone = this._defaultDrawingOptions.clone();\n        clone.updateProperties(options);\n        return clone;\n    }\n    static get supportMultipleDrawings() {\n        return false;\n    }\n    static get typesMap() {\n        return shadow(this, \"typesMap\", /* @__PURE__ */ new Map());\n    }\n    static get isDrawer() {\n        return false;\n    }\n    get telemetryFinalData() {\n        return {\n            type: \"signature\",\n            hasDescription: !!this.#description\n        };\n    }\n    static computeTelemetryFinalData(data) {\n        const hasDescriptionStats = data.get(\"hasDescription\");\n        return {\n            hasAltText: hasDescriptionStats.get(true) ?? 0,\n            hasNoAltText: hasDescriptionStats.get(false) ?? 0\n        };\n    }\n    get isResizable() {\n        return true;\n    }\n    onScaleChanging() {\n        if (this._drawId === null) {\n            return;\n        }\n        super.onScaleChanging();\n    }\n    render() {\n        if (this.div) {\n            return this.div;\n        }\n        let baseX, baseY;\n        const { _isCopy } = this;\n        if (_isCopy) {\n            this._isCopy = false;\n            baseX = this.x;\n            baseY = this.y;\n        }\n        super.render();\n        if (this._drawId === null) {\n            if (this.#signatureData) {\n                const { lines, mustSmooth, areContours, description, uuid, heightInPage } = this.#signatureData;\n                const { rawDims: { pageWidth, pageHeight }, rotation } = this.parent.viewport;\n                const outline = SignatureExtractor.processDrawnLines({\n                    lines,\n                    pageWidth,\n                    pageHeight,\n                    rotation,\n                    innerMargin: SignatureEditor._INNER_MARGIN,\n                    mustSmooth,\n                    areContours\n                });\n                this.addSignature(outline, heightInPage, description, uuid);\n            } else {\n                this.div.setAttribute(\"data-l10n-args\", JSON.stringify({\n                    description: \"\"\n                }));\n                this.div.hidden = true;\n                this._uiManager.getSignature(this);\n            }\n        } else {\n            this.div.setAttribute(\"data-l10n-args\", JSON.stringify({\n                description: this.#description || \"\"\n            }));\n        }\n        if (_isCopy) {\n            this._isCopy = true;\n            this._moveAfterPaste(baseX, baseY);\n        }\n        return this.div;\n    }\n    setUuid(uuid) {\n        this.#signatureUUID = uuid;\n        this.addEditToolbar();\n    }\n    getUuid() {\n        return this.#signatureUUID;\n    }\n    get description() {\n        return this.#description;\n    }\n    set description(description) {\n        this.#description = description;\n        if (!this.div) {\n            return;\n        }\n        this.div.setAttribute(\"data-l10n-args\", JSON.stringify({\n            description\n        }));\n        super.addEditToolbar().then((toolbar)=>{\n            toolbar?.updateEditSignatureButton(description);\n        });\n    }\n    getSignaturePreview() {\n        const { newCurves, areContours, thickness, width, height } = this.#signatureData;\n        const maxDim = Math.max(width, height);\n        const outlineData = SignatureExtractor.processDrawnLines({\n            lines: {\n                curves: newCurves.map((points)=>({\n                        points\n                    })),\n                thickness,\n                width,\n                height\n            },\n            pageWidth: maxDim,\n            pageHeight: maxDim,\n            rotation: 0,\n            innerMargin: 0,\n            mustSmooth: false,\n            areContours\n        });\n        return {\n            areContours,\n            outline: outlineData.outline\n        };\n    }\n    get toolbarButtons() {\n        if (this._uiManager.signatureManager) {\n            return [\n                [\n                    \"editSignature\",\n                    this._uiManager.signatureManager\n                ]\n            ];\n        }\n        return super.toolbarButtons;\n    }\n    addSignature(data, heightInPage, description, uuid) {\n        const { x: savedX, y: savedY } = this;\n        const { outline } = this.#signatureData = data;\n        this.#isExtracted = outline instanceof ContourDrawOutline;\n        this.description = description;\n        let drawingOptions;\n        if (this.#isExtracted) {\n            drawingOptions = SignatureEditor.getDefaultDrawingOptions();\n        } else {\n            drawingOptions = SignatureEditor._defaultDrawnSignatureOptions.clone();\n            drawingOptions.updateProperties({\n                \"stroke-width\": outline.thickness\n            });\n        }\n        this._addOutlines({\n            drawOutlines: outline,\n            drawingOptions\n        });\n        const [, pageHeight] = this.pageDimensions;\n        let newHeight = heightInPage / pageHeight;\n        newHeight = newHeight >= 1 ? 0.5 : newHeight;\n        this.width *= newHeight / this.height;\n        if (this.width >= 1) {\n            newHeight *= 0.9 / this.width;\n            this.width = 0.9;\n        }\n        this.height = newHeight;\n        this.setDims();\n        this.x = savedX;\n        this.y = savedY;\n        this.center();\n        this._onResized();\n        this.onScaleChanging();\n        this.rotate();\n        this._uiManager.addToAnnotationStorage(this);\n        this.setUuid(uuid);\n        this._reportTelemetry({\n            action: \"pdfjs.signature.inserted\",\n            data: {\n                hasBeenSaved: !!uuid,\n                hasDescription: !!description\n            }\n        });\n        this.div.hidden = false;\n    }\n    getFromImage(bitmap) {\n        const { rawDims: { pageWidth, pageHeight }, rotation } = this.parent.viewport;\n        return SignatureExtractor.process(bitmap, pageWidth, pageHeight, rotation, SignatureEditor._INNER_MARGIN);\n    }\n    getFromText(text, fontInfo) {\n        const { rawDims: { pageWidth, pageHeight }, rotation } = this.parent.viewport;\n        return SignatureExtractor.extractContoursFromText(text, fontInfo, pageWidth, pageHeight, rotation, SignatureEditor._INNER_MARGIN);\n    }\n    getDrawnSignature(curves) {\n        const { rawDims: { pageWidth, pageHeight }, rotation } = this.parent.viewport;\n        return SignatureExtractor.processDrawnLines({\n            lines: curves,\n            pageWidth,\n            pageHeight,\n            rotation,\n            innerMargin: SignatureEditor._INNER_MARGIN,\n            mustSmooth: false,\n            areContours: false\n        });\n    }\n    createDrawingOptions({ areContours, thickness }) {\n        if (areContours) {\n            this._drawingOptions = SignatureEditor.getDefaultDrawingOptions();\n        } else {\n            this._drawingOptions = SignatureEditor._defaultDrawnSignatureOptions.clone();\n            this._drawingOptions.updateProperties({\n                \"stroke-width\": thickness\n            });\n        }\n    }\n    serialize(isForCopying = false) {\n        if (this.isEmpty()) {\n            return null;\n        }\n        const { lines, points } = this.serializeDraw(isForCopying);\n        const { _drawingOptions: { \"stroke-width\": thickness } } = this;\n        const serialized = Object.assign(super.serialize(isForCopying), {\n            isSignature: true,\n            areContours: this.#isExtracted,\n            color: [\n                0,\n                0,\n                0\n            ],\n            thickness: this.#isExtracted ? 0 : thickness\n        });\n        this.addComment(serialized);\n        if (isForCopying) {\n            serialized.paths = {\n                lines,\n                points\n            };\n            serialized.uuid = this.#signatureUUID;\n            serialized.isCopy = true;\n        } else {\n            serialized.lines = lines;\n        }\n        if (this.#description) {\n            serialized.accessibilityData = {\n                type: \"Figure\",\n                alt: this.#description\n            };\n        }\n        return serialized;\n    }\n    static deserializeDraw(pageX, pageY, pageWidth, pageHeight, innerMargin, data) {\n        if (data.areContours) {\n            return ContourDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);\n        }\n        return InkDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);\n    }\n    static async deserialize(data, parent, uiManager) {\n        const editor = await super.deserialize(data, parent, uiManager);\n        editor.#isExtracted = data.areContours;\n        editor.description = data.accessibilityData?.alt || \"\";\n        editor.#signatureUUID = data.uuid;\n        return editor;\n    }\n}\nclass StampEditor extends AnnotationEditor {\n    #bitmap;\n    #bitmapId;\n    #bitmapPromise;\n    #bitmapUrl;\n    #bitmapFile;\n    #bitmapFileName;\n    #canvas;\n    #missingCanvas;\n    #resizeTimeoutId;\n    #isSvg;\n    #hasBeenAddedInUndoStack;\n    static{\n        this._type = \"stamp\";\n    }\n    static{\n        this._editorType = AnnotationEditorType.STAMP;\n    }\n    constructor(params){\n        super({\n            ...params,\n            name: \"stampEditor\"\n        });\n        this.#bitmap = null;\n        this.#bitmapId = null;\n        this.#bitmapPromise = null;\n        this.#bitmapUrl = null;\n        this.#bitmapFile = null;\n        this.#bitmapFileName = \"\";\n        this.#canvas = null;\n        this.#missingCanvas = false;\n        this.#resizeTimeoutId = null;\n        this.#isSvg = false;\n        this.#hasBeenAddedInUndoStack = false;\n        this.#bitmapUrl = params.bitmapUrl;\n        this.#bitmapFile = params.bitmapFile;\n        this.defaultL10nId = \"pdfjs-editor-stamp-editor\";\n    }\n    static initialize(l10n, uiManager) {\n        AnnotationEditor.initialize(l10n, uiManager);\n    }\n    static isHandlingMimeForPasting(mime) {\n        return SupportedImageMimeTypes.includes(mime);\n    }\n    static paste(item, parent) {\n        parent.pasteEditor({\n            mode: AnnotationEditorType.STAMP\n        }, {\n            bitmapFile: item.getAsFile()\n        });\n    }\n    altTextFinish() {\n        if (this._uiManager.useNewAltTextFlow) {\n            this.div.hidden = false;\n        }\n        super.altTextFinish();\n    }\n    get telemetryFinalData() {\n        return {\n            type: \"stamp\",\n            hasAltText: !!this.altTextData?.altText\n        };\n    }\n    static computeTelemetryFinalData(data) {\n        const hasAltTextStats = data.get(\"hasAltText\");\n        return {\n            hasAltText: hasAltTextStats.get(true) ?? 0,\n            hasNoAltText: hasAltTextStats.get(false) ?? 0\n        };\n    }\n    #getBitmapFetched(data, fromId = false) {\n        if (!data) {\n            this.remove();\n            return;\n        }\n        this.#bitmap = data.bitmap;\n        if (!fromId) {\n            this.#bitmapId = data.id;\n            this.#isSvg = data.isSvg;\n        }\n        if (data.file) {\n            this.#bitmapFileName = data.file.name;\n        }\n        this.#createCanvas();\n    }\n    #getBitmapDone() {\n        this.#bitmapPromise = null;\n        this._uiManager.enableWaiting(false);\n        if (!this.#canvas) {\n            return;\n        }\n        if (this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#bitmap) {\n            this.addEditToolbar().then(()=>{\n                this._editToolbar.hide();\n                this._uiManager.editAltText(this, true);\n            });\n            return;\n        }\n        if (!this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#bitmap) {\n            this._reportTelemetry({\n                action: \"pdfjs.image.image_added\",\n                data: {\n                    alt_text_modal: false,\n                    alt_text_type: \"empty\"\n                }\n            });\n            try {\n                this.mlGuessAltText();\n            } catch  {}\n        }\n        this.div.focus();\n    }\n    async mlGuessAltText(imageData = null, updateAltTextData = true) {\n        if (this.hasAltTextData()) {\n            return null;\n        }\n        const { mlManager } = this._uiManager;\n        if (!mlManager) {\n            throw new Error(\"No ML.\");\n        }\n        if (!await mlManager.isEnabledFor(\"altText\")) {\n            throw new Error(\"ML isn't enabled for alt text.\");\n        }\n        const { data, width, height } = imageData || this.copyCanvas(null, null, true).imageData;\n        const response = await mlManager.guess({\n            name: \"altText\",\n            request: {\n                data,\n                width,\n                height,\n                channels: data.length / (width * height)\n            }\n        });\n        if (!response) {\n            throw new Error(\"No response from the AI service.\");\n        }\n        if (response.error) {\n            throw new Error(\"Error from the AI service.\");\n        }\n        if (response.cancel) {\n            return null;\n        }\n        if (!response.output) {\n            throw new Error(\"No valid response from the AI service.\");\n        }\n        const altText = response.output;\n        await this.setGuessedAltText(altText);\n        if (updateAltTextData && !this.hasAltTextData()) {\n            this.altTextData = {\n                alt: altText,\n                decorative: false\n            };\n        }\n        return altText;\n    }\n    #getBitmap() {\n        if (this.#bitmapId) {\n            this._uiManager.enableWaiting(true);\n            this._uiManager.imageManager.getFromId(this.#bitmapId).then((data)=>this.#getBitmapFetched(data, true)).finally(()=>this.#getBitmapDone());\n            return;\n        }\n        if (this.#bitmapUrl) {\n            const url = this.#bitmapUrl;\n            this.#bitmapUrl = null;\n            this._uiManager.enableWaiting(true);\n            this.#bitmapPromise = this._uiManager.imageManager.getFromUrl(url).then((data)=>this.#getBitmapFetched(data)).finally(()=>this.#getBitmapDone());\n            return;\n        }\n        if (this.#bitmapFile) {\n            const file = this.#bitmapFile;\n            this.#bitmapFile = null;\n            this._uiManager.enableWaiting(true);\n            this.#bitmapPromise = this._uiManager.imageManager.getFromFile(file).then((data)=>this.#getBitmapFetched(data)).finally(()=>this.#getBitmapDone());\n            return;\n        }\n        const input = document.createElement(\"input\");\n        input.type = \"file\";\n        input.accept = SupportedImageMimeTypes.join(\",\");\n        const signal = this._uiManager._signal;\n        this.#bitmapPromise = new Promise((resolve)=>{\n            input.addEventListener(\"change\", async ()=>{\n                if (!input.files || input.files.length === 0) {\n                    this.remove();\n                } else {\n                    this._uiManager.enableWaiting(true);\n                    const data = await this._uiManager.imageManager.getFromFile(input.files[0]);\n                    this._reportTelemetry({\n                        action: \"pdfjs.image.image_selected\",\n                        data: {\n                            alt_text_modal: this._uiManager.useNewAltTextFlow\n                        }\n                    });\n                    this.#getBitmapFetched(data);\n                }\n                resolve();\n            }, {\n                signal\n            });\n            input.addEventListener(\"cancel\", ()=>{\n                this.remove();\n                resolve();\n            }, {\n                signal\n            });\n        }).finally(()=>this.#getBitmapDone());\n        input.click();\n    }\n    remove() {\n        if (this.#bitmapId) {\n            this.#bitmap = null;\n            this._uiManager.imageManager.deleteId(this.#bitmapId);\n            this.#canvas?.remove();\n            this.#canvas = null;\n            if (this.#resizeTimeoutId) {\n                clearTimeout(this.#resizeTimeoutId);\n                this.#resizeTimeoutId = null;\n            }\n        }\n        super.remove();\n    }\n    rebuild() {\n        if (!this.parent) {\n            if (this.#bitmapId) {\n                this.#getBitmap();\n            }\n            return;\n        }\n        super.rebuild();\n        if (this.div === null) {\n            return;\n        }\n        if (this.#bitmapId && this.#canvas === null) {\n            this.#getBitmap();\n        }\n        if (!this.isAttachedToDOM) {\n            this.parent.add(this);\n        }\n    }\n    onceAdded(focus) {\n        this._isDraggable = true;\n        if (focus) {\n            this.div.focus();\n        }\n    }\n    isEmpty() {\n        return !(this.#bitmapPromise || this.#bitmap || this.#bitmapUrl || this.#bitmapFile || this.#bitmapId || this.#missingCanvas);\n    }\n    get toolbarButtons() {\n        return [\n            [\n                \"altText\",\n                this.createAltText()\n            ]\n        ];\n    }\n    get isResizable() {\n        return true;\n    }\n    render() {\n        if (this.div) {\n            return this.div;\n        }\n        let baseX, baseY;\n        if (this._isCopy) {\n            baseX = this.x;\n            baseY = this.y;\n        }\n        super.render();\n        this.div.hidden = true;\n        this.createAltText();\n        if (!this.#missingCanvas) {\n            if (this.#bitmap) {\n                this.#createCanvas();\n            } else {\n                this.#getBitmap();\n            }\n        }\n        if (this._isCopy) {\n            this._moveAfterPaste(baseX, baseY);\n        }\n        this._uiManager.addShouldRescale(this);\n        return this.div;\n    }\n    setCanvas(annotationElementId, canvas) {\n        const { id: bitmapId, bitmap } = this._uiManager.imageManager.getFromCanvas(annotationElementId, canvas);\n        canvas.remove();\n        if (bitmapId && this._uiManager.imageManager.isValidId(bitmapId)) {\n            this.#bitmapId = bitmapId;\n            if (bitmap) {\n                this.#bitmap = bitmap;\n            }\n            this.#missingCanvas = false;\n            this.#createCanvas();\n        }\n    }\n    _onResized() {\n        this.onScaleChanging();\n    }\n    onScaleChanging() {\n        if (!this.parent) {\n            return;\n        }\n        if (this.#resizeTimeoutId !== null) {\n            clearTimeout(this.#resizeTimeoutId);\n        }\n        const TIME_TO_WAIT = 200;\n        this.#resizeTimeoutId = setTimeout(()=>{\n            this.#resizeTimeoutId = null;\n            this.#drawBitmap();\n        }, TIME_TO_WAIT);\n    }\n    #createCanvas() {\n        const { div } = this;\n        let { width, height } = this.#bitmap;\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        const MAX_RATIO = 0.75;\n        if (this.width) {\n            width = this.width * pageWidth;\n            height = this.height * pageHeight;\n        } else if (width > MAX_RATIO * pageWidth || height > MAX_RATIO * pageHeight) {\n            const factor = Math.min(MAX_RATIO * pageWidth / width, MAX_RATIO * pageHeight / height);\n            width *= factor;\n            height *= factor;\n        }\n        this._uiManager.enableWaiting(false);\n        const canvas = this.#canvas = document.createElement(\"canvas\");\n        canvas.setAttribute(\"role\", \"img\");\n        this.addContainer(canvas);\n        this.width = width / pageWidth;\n        this.height = height / pageHeight;\n        this.setDims();\n        if (this._initialOptions?.isCentered) {\n            this.center();\n        } else {\n            this.fixAndSetPosition();\n        }\n        this._initialOptions = null;\n        if (!this._uiManager.useNewAltTextWhenAddingImage || !this._uiManager.useNewAltTextFlow || this.annotationElementId) {\n            div.hidden = false;\n        }\n        this.#drawBitmap();\n        if (!this.#hasBeenAddedInUndoStack) {\n            this.parent.addUndoableEditor(this);\n            this.#hasBeenAddedInUndoStack = true;\n        }\n        this._reportTelemetry({\n            action: \"inserted_image\"\n        });\n        if (this.#bitmapFileName) {\n            this.div.setAttribute(\"aria-description\", this.#bitmapFileName);\n        }\n        if (!this.annotationElementId) {\n            this._uiManager.a11yAlert(\"pdfjs-editor-stamp-added-alert\");\n        }\n    }\n    copyCanvas(maxDataDimension, maxPreviewDimension, createImageData = false) {\n        if (!maxDataDimension) {\n            maxDataDimension = 224;\n        }\n        const { width: bitmapWidth, height: bitmapHeight } = this.#bitmap;\n        const outputScale = new OutputScale();\n        let bitmap = this.#bitmap;\n        let width = bitmapWidth, height = bitmapHeight;\n        let canvas = null;\n        if (maxPreviewDimension) {\n            if (bitmapWidth > maxPreviewDimension || bitmapHeight > maxPreviewDimension) {\n                const ratio = Math.min(maxPreviewDimension / bitmapWidth, maxPreviewDimension / bitmapHeight);\n                width = Math.floor(bitmapWidth * ratio);\n                height = Math.floor(bitmapHeight * ratio);\n            }\n            canvas = document.createElement(\"canvas\");\n            const scaledWidth = canvas.width = Math.ceil(width * outputScale.sx);\n            const scaledHeight = canvas.height = Math.ceil(height * outputScale.sy);\n            if (!this.#isSvg) {\n                bitmap = this.#scaleBitmap(scaledWidth, scaledHeight);\n            }\n            const ctx = canvas.getContext(\"2d\");\n            ctx.filter = this._uiManager.hcmFilter;\n            let white = \"white\", black = \"#cfcfd8\";\n            if (this._uiManager.hcmFilter !== \"none\") {\n                black = \"black\";\n            } else if (ColorScheme.isDarkMode) {\n                white = \"#8f8f9d\";\n                black = \"#42414d\";\n            }\n            const boxDim = 15;\n            const boxDimWidth = boxDim * outputScale.sx;\n            const boxDimHeight = boxDim * outputScale.sy;\n            const pattern = new OffscreenCanvas(boxDimWidth * 2, boxDimHeight * 2);\n            const patternCtx = pattern.getContext(\"2d\");\n            patternCtx.fillStyle = white;\n            patternCtx.fillRect(0, 0, boxDimWidth * 2, boxDimHeight * 2);\n            patternCtx.fillStyle = black;\n            patternCtx.fillRect(0, 0, boxDimWidth, boxDimHeight);\n            patternCtx.fillRect(boxDimWidth, boxDimHeight, boxDimWidth, boxDimHeight);\n            ctx.fillStyle = ctx.createPattern(pattern, \"repeat\");\n            ctx.fillRect(0, 0, scaledWidth, scaledHeight);\n            ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, scaledWidth, scaledHeight);\n        }\n        let imageData = null;\n        if (createImageData) {\n            let dataWidth, dataHeight;\n            if (outputScale.symmetric && bitmap.width < maxDataDimension && bitmap.height < maxDataDimension) {\n                dataWidth = bitmap.width;\n                dataHeight = bitmap.height;\n            } else {\n                bitmap = this.#bitmap;\n                if (bitmapWidth > maxDataDimension || bitmapHeight > maxDataDimension) {\n                    const ratio = Math.min(maxDataDimension / bitmapWidth, maxDataDimension / bitmapHeight);\n                    dataWidth = Math.floor(bitmapWidth * ratio);\n                    dataHeight = Math.floor(bitmapHeight * ratio);\n                    if (!this.#isSvg) {\n                        bitmap = this.#scaleBitmap(dataWidth, dataHeight);\n                    }\n                }\n            }\n            const offscreen = new OffscreenCanvas(dataWidth, dataHeight);\n            const offscreenCtx = offscreen.getContext(\"2d\", {\n                willReadFrequently: true\n            });\n            offscreenCtx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, dataWidth, dataHeight);\n            imageData = {\n                width: dataWidth,\n                height: dataHeight,\n                data: offscreenCtx.getImageData(0, 0, dataWidth, dataHeight).data\n            };\n        }\n        return {\n            canvas,\n            width,\n            height,\n            imageData\n        };\n    }\n    #scaleBitmap(width, height) {\n        const { width: bitmapWidth, height: bitmapHeight } = this.#bitmap;\n        let newWidth = bitmapWidth;\n        let newHeight = bitmapHeight;\n        let bitmap = this.#bitmap;\n        while(newWidth > 2 * width || newHeight > 2 * height){\n            const prevWidth = newWidth;\n            const prevHeight = newHeight;\n            if (newWidth > 2 * width) {\n                newWidth = newWidth >= 16384 ? Math.floor(newWidth / 2) - 1 : Math.ceil(newWidth / 2);\n            }\n            if (newHeight > 2 * height) {\n                newHeight = newHeight >= 16384 ? Math.floor(newHeight / 2) - 1 : Math.ceil(newHeight / 2);\n            }\n            const offscreen = new OffscreenCanvas(newWidth, newHeight);\n            const ctx = offscreen.getContext(\"2d\");\n            ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);\n            bitmap = offscreen.transferToImageBitmap();\n        }\n        return bitmap;\n    }\n    #drawBitmap() {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        const { width, height } = this;\n        const outputScale = new OutputScale();\n        const scaledWidth = Math.ceil(width * parentWidth * outputScale.sx);\n        const scaledHeight = Math.ceil(height * parentHeight * outputScale.sy);\n        const canvas = this.#canvas;\n        if (!canvas || canvas.width === scaledWidth && canvas.height === scaledHeight) {\n            return;\n        }\n        canvas.width = scaledWidth;\n        canvas.height = scaledHeight;\n        const bitmap = this.#isSvg ? this.#bitmap : this.#scaleBitmap(scaledWidth, scaledHeight);\n        const ctx = canvas.getContext(\"2d\");\n        ctx.filter = this._uiManager.hcmFilter;\n        ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, scaledWidth, scaledHeight);\n    }\n    #serializeBitmap(toUrl) {\n        if (toUrl) {\n            if (this.#isSvg) {\n                const url = this._uiManager.imageManager.getSvgUrl(this.#bitmapId);\n                if (url) {\n                    return url;\n                }\n            }\n            const canvas = document.createElement(\"canvas\");\n            ({ width: canvas.width, height: canvas.height } = this.#bitmap);\n            const ctx = canvas.getContext(\"2d\");\n            ctx.drawImage(this.#bitmap, 0, 0);\n            return canvas.toDataURL();\n        }\n        if (this.#isSvg) {\n            const [pageWidth, pageHeight] = this.pageDimensions;\n            const width = Math.round(this.width * pageWidth * PixelsPerInch.PDF_TO_CSS_UNITS);\n            const height = Math.round(this.height * pageHeight * PixelsPerInch.PDF_TO_CSS_UNITS);\n            const offscreen = new OffscreenCanvas(width, height);\n            const ctx = offscreen.getContext(\"2d\");\n            ctx.drawImage(this.#bitmap, 0, 0, this.#bitmap.width, this.#bitmap.height, 0, 0, width, height);\n            return offscreen.transferToImageBitmap();\n        }\n        return structuredClone(this.#bitmap);\n    }\n    static async deserialize(data, parent, uiManager) {\n        let initialData = null;\n        let missingCanvas = false;\n        if (data instanceof StampAnnotationElement) {\n            const { data: { rect: rect2, rotation, id, structParent, popupRef, richText, contentsObj, creationDate, modificationDate }, container, parent: { page: { pageNumber } }, canvas } = data;\n            let bitmapId2, bitmap2;\n            if (canvas) {\n                delete data.canvas;\n                ({ id: bitmapId2, bitmap: bitmap2 } = uiManager.imageManager.getFromCanvas(container.id, canvas));\n                canvas.remove();\n            } else {\n                missingCanvas = true;\n                data._hasNoCanvas = true;\n            }\n            const altText = (await parent._structTree.getAriaAttributes(`${AnnotationPrefix}${id}`))?.get(\"aria-label\") || \"\";\n            initialData = data = {\n                annotationType: AnnotationEditorType.STAMP,\n                bitmapId: bitmapId2,\n                bitmap: bitmap2,\n                pageIndex: pageNumber - 1,\n                rect: rect2.slice(0),\n                rotation,\n                annotationElementId: id,\n                id,\n                deleted: false,\n                accessibilityData: {\n                    decorative: false,\n                    altText\n                },\n                isSvg: false,\n                structParent,\n                popupRef,\n                richText,\n                comment: contentsObj?.str || null,\n                creationDate,\n                modificationDate\n            };\n        }\n        const editor = await super.deserialize(data, parent, uiManager);\n        const { rect, bitmap, bitmapUrl, bitmapId, isSvg, accessibilityData } = data;\n        if (missingCanvas) {\n            uiManager.addMissingCanvas(data.id, editor);\n            editor.#missingCanvas = true;\n        } else if (bitmapId && uiManager.imageManager.isValidId(bitmapId)) {\n            editor.#bitmapId = bitmapId;\n            if (bitmap) {\n                editor.#bitmap = bitmap;\n            }\n        } else {\n            editor.#bitmapUrl = bitmapUrl;\n        }\n        editor.#isSvg = isSvg;\n        const [parentWidth, parentHeight] = editor.pageDimensions;\n        editor.width = (rect[2] - rect[0]) / parentWidth;\n        editor.height = (rect[3] - rect[1]) / parentHeight;\n        if (accessibilityData) {\n            editor.altTextData = accessibilityData;\n        }\n        editor._initialData = initialData;\n        if (data.comment) {\n            editor.setCommentData(data);\n        }\n        editor.#hasBeenAddedInUndoStack = !!initialData;\n        return editor;\n    }\n    serialize(isForCopying = false, context = null) {\n        if (this.isEmpty()) {\n            return null;\n        }\n        if (this.deleted) {\n            return this.serializeDeleted();\n        }\n        const serialized = Object.assign(super.serialize(isForCopying), {\n            bitmapId: this.#bitmapId,\n            isSvg: this.#isSvg\n        });\n        this.addComment(serialized);\n        if (isForCopying) {\n            serialized.bitmapUrl = this.#serializeBitmap(true);\n            serialized.accessibilityData = this.serializeAltText(true);\n            serialized.isCopy = true;\n            return serialized;\n        }\n        const { decorative, altText } = this.serializeAltText(false);\n        if (!decorative && altText) {\n            serialized.accessibilityData = {\n                type: \"Figure\",\n                alt: altText\n            };\n        }\n        if (this.annotationElementId) {\n            const changes = this.#hasElementChanged(serialized);\n            if (changes.isSame) {\n                return null;\n            }\n            if (changes.isSameAltText) {\n                delete serialized.accessibilityData;\n            } else {\n                serialized.accessibilityData.structParent = this._initialData.structParent ?? -1;\n            }\n            serialized.id = this.annotationElementId;\n            delete serialized.bitmapId;\n            return serialized;\n        }\n        if (context === null) {\n            return serialized;\n        }\n        context.stamps ||= /* @__PURE__ */ new Map();\n        const area = this.#isSvg ? (serialized.rect[2] - serialized.rect[0]) * (serialized.rect[3] - serialized.rect[1]) : null;\n        if (!context.stamps.has(this.#bitmapId)) {\n            context.stamps.set(this.#bitmapId, {\n                area,\n                serialized\n            });\n            serialized.bitmap = this.#serializeBitmap(false);\n        } else if (this.#isSvg) {\n            const prevData = context.stamps.get(this.#bitmapId);\n            if (area > prevData.area) {\n                prevData.area = area;\n                prevData.serialized.bitmap.close();\n                prevData.serialized.bitmap = this.#serializeBitmap(false);\n            }\n        }\n        return serialized;\n    }\n    #hasElementChanged(serialized) {\n        const { pageIndex, accessibilityData: { altText } } = this._initialData;\n        const isSamePageIndex = serialized.pageIndex === pageIndex;\n        const isSameAltText = (serialized.accessibilityData?.alt || \"\") === altText;\n        return {\n            isSame: !this.hasEditedComment && !this._hasBeenMoved && !this._hasBeenResized && isSamePageIndex && isSameAltText,\n            isSameAltText\n        };\n    }\n    renderAnnotationElement(annotation) {\n        if (this.deleted) {\n            annotation.hide();\n            return null;\n        }\n        annotation.updateEdited({\n            rect: this.getPDFRect(),\n            popup: this.comment\n        });\n        return null;\n    }\n}\nclass AnnotationEditorLayer {\n    #accessibilityManager;\n    #allowClick;\n    #annotationLayer;\n    #clickAC;\n    #editorFocusTimeoutId;\n    #editors;\n    #hadPointerDown;\n    #isDisabling;\n    #isEnabling;\n    #drawingAC;\n    #focusedElement;\n    #textLayer;\n    #textSelectionAC;\n    #textLayerDblClickAC;\n    #lastPointerDownTimestamp;\n    #uiManager;\n    static{\n        this._initialized = false;\n    }\n    static #editorTypes = new Map([\n        FreeTextEditor,\n        InkEditor,\n        StampEditor,\n        HighlightEditor,\n        SignatureEditor\n    ].map((type)=>[\n            type._editorType,\n            type\n        ]));\n    constructor({ uiManager, pageIndex, div, structTreeLayer, accessibilityManager, annotationLayer, drawLayer, textLayer, viewport, l10n }){\n        this.#allowClick = false;\n        this.#annotationLayer = null;\n        this.#clickAC = null;\n        this.#editorFocusTimeoutId = null;\n        this.#editors = /* @__PURE__ */ new Map();\n        this.#hadPointerDown = false;\n        this.#isDisabling = false;\n        this.#isEnabling = false;\n        this.#drawingAC = null;\n        this.#focusedElement = null;\n        this.#textLayer = null;\n        this.#textSelectionAC = null;\n        this.#textLayerDblClickAC = null;\n        this.#lastPointerDownTimestamp = -1;\n        const editorTypes = [\n            ...AnnotationEditorLayer.#editorTypes.values()\n        ];\n        if (!AnnotationEditorLayer._initialized) {\n            AnnotationEditorLayer._initialized = true;\n            for (const editorType of editorTypes){\n                editorType.initialize(l10n, uiManager);\n            }\n        }\n        uiManager.registerEditorTypes(editorTypes);\n        this.#uiManager = uiManager;\n        this.pageIndex = pageIndex;\n        this.div = div;\n        this.#accessibilityManager = accessibilityManager;\n        this.#annotationLayer = annotationLayer;\n        this.viewport = viewport;\n        this.#textLayer = textLayer;\n        this.drawLayer = drawLayer;\n        this._structTree = structTreeLayer;\n        this.#uiManager.addLayer(this);\n    }\n    get isEmpty() {\n        return this.#editors.size === 0;\n    }\n    get isInvisible() {\n        return this.isEmpty && this.#uiManager.getMode() === AnnotationEditorType.NONE;\n    }\n    updateToolbar(options) {\n        this.#uiManager.updateToolbar(options);\n    }\n    updateMode(mode = this.#uiManager.getMode()) {\n        this.#cleanup();\n        switch(mode){\n            case AnnotationEditorType.NONE:\n                this.div.classList.toggle(\"nonEditing\", true);\n                this.disableTextSelection();\n                this.togglePointerEvents(false);\n                this.toggleAnnotationLayerPointerEvents(true);\n                this.disableClick();\n                return;\n            case AnnotationEditorType.INK:\n                this.disableTextSelection();\n                this.togglePointerEvents(true);\n                this.enableClick();\n                break;\n            case AnnotationEditorType.HIGHLIGHT:\n                this.enableTextSelection();\n                this.togglePointerEvents(false);\n                this.disableClick();\n                break;\n            default:\n                this.disableTextSelection();\n                this.togglePointerEvents(true);\n                this.enableClick();\n        }\n        this.toggleAnnotationLayerPointerEvents(false);\n        const { classList } = this.div;\n        classList.toggle(\"nonEditing\", false);\n        if (mode === AnnotationEditorType.POPUP) {\n            classList.toggle(\"commentEditing\", true);\n        } else {\n            classList.toggle(\"commentEditing\", false);\n            for (const editorType of AnnotationEditorLayer.#editorTypes.values()){\n                classList.toggle(`${editorType._type}Editing`, mode === editorType._editorType);\n            }\n        }\n        this.div.hidden = false;\n    }\n    hasTextLayer(textLayer) {\n        return textLayer === this.#textLayer?.div;\n    }\n    setEditingState(isEditing) {\n        this.#uiManager.setEditingState(isEditing);\n    }\n    addCommands(params) {\n        this.#uiManager.addCommands(params);\n    }\n    cleanUndoStack(type) {\n        this.#uiManager.cleanUndoStack(type);\n    }\n    toggleDrawing(enabled = false) {\n        this.div.classList.toggle(\"drawing\", !enabled);\n    }\n    togglePointerEvents(enabled = false) {\n        this.div.classList.toggle(\"disabled\", !enabled);\n    }\n    toggleAnnotationLayerPointerEvents(enabled = false) {\n        this.#annotationLayer?.div.classList.toggle(\"disabled\", !enabled);\n    }\n    get #allEditorsIterator() {\n        return this.#editors.size !== 0 ? this.#editors.values() : this.#uiManager.getEditors(this.pageIndex);\n    }\n    async enable() {\n        this.#isEnabling = true;\n        this.div.tabIndex = 0;\n        this.togglePointerEvents(true);\n        this.div.classList.toggle(\"nonEditing\", false);\n        this.#textLayerDblClickAC?.abort();\n        this.#textLayerDblClickAC = null;\n        const annotationElementIds = /* @__PURE__ */ new Set();\n        for (const editor of this.#allEditorsIterator){\n            editor.enableEditing();\n            editor.show(true);\n            if (editor.annotationElementId) {\n                this.#uiManager.removeChangedExistingAnnotation(editor);\n                annotationElementIds.add(editor.annotationElementId);\n            }\n        }\n        const annotationLayer = this.#annotationLayer;\n        if (annotationLayer) {\n            for (const editable of annotationLayer.getEditableAnnotations()){\n                editable.hide();\n                if (this.#uiManager.isDeletedAnnotationElement(editable.data.id)) {\n                    continue;\n                }\n                if (annotationElementIds.has(editable.data.id)) {\n                    continue;\n                }\n                const editor = await this.deserialize(editable);\n                if (!editor) {\n                    continue;\n                }\n                this.addOrRebuild(editor);\n                editor.enableEditing();\n            }\n        }\n        this.#isEnabling = false;\n        this.#uiManager._eventBus.dispatch(\"editorsrendered\", {\n            source: this,\n            pageNumber: this.pageIndex + 1\n        });\n    }\n    disable() {\n        this.#isDisabling = true;\n        this.div.tabIndex = -1;\n        this.togglePointerEvents(false);\n        this.div.classList.toggle(\"nonEditing\", true);\n        if (this.#textLayer && !this.#textLayerDblClickAC) {\n            this.#textLayerDblClickAC = new AbortController();\n            const signal = this.#uiManager.combinedSignal(this.#textLayerDblClickAC);\n            this.#textLayer.div.addEventListener(\"pointerdown\", (e)=>{\n                const DBL_CLICK_THRESHOLD = 500;\n                const { clientX, clientY, timeStamp } = e;\n                const lastPointerDownTimestamp = this.#lastPointerDownTimestamp;\n                if (timeStamp - lastPointerDownTimestamp > DBL_CLICK_THRESHOLD) {\n                    this.#lastPointerDownTimestamp = timeStamp;\n                    return;\n                }\n                this.#lastPointerDownTimestamp = -1;\n                const { classList: classList2 } = this.div;\n                classList2.toggle(\"getElements\", true);\n                const elements = document.elementsFromPoint(clientX, clientY);\n                classList2.toggle(\"getElements\", false);\n                if (!this.div.contains(elements[0])) {\n                    return;\n                }\n                let id;\n                const regex = new RegExp(`^${AnnotationEditorPrefix}[0-9]+$`);\n                for (const element of elements){\n                    if (regex.test(element.id)) {\n                        id = element.id;\n                        break;\n                    }\n                }\n                if (!id) {\n                    return;\n                }\n                const editor = this.#editors.get(id);\n                if (editor?.annotationElementId === null) {\n                    e.stopPropagation();\n                    e.preventDefault();\n                    editor.dblclick(e);\n                }\n            }, {\n                signal,\n                capture: true\n            });\n        }\n        const annotationLayer = this.#annotationLayer;\n        if (annotationLayer) {\n            const changedAnnotations = /* @__PURE__ */ new Map();\n            const resetAnnotations = /* @__PURE__ */ new Map();\n            for (const editor of this.#allEditorsIterator){\n                editor.disableEditing();\n                if (!editor.annotationElementId) {\n                    editor.updateFakeAnnotationElement(annotationLayer);\n                    continue;\n                }\n                if (editor.serialize() !== null) {\n                    changedAnnotations.set(editor.annotationElementId, editor);\n                    continue;\n                } else {\n                    resetAnnotations.set(editor.annotationElementId, editor);\n                }\n                this.getEditableAnnotation(editor.annotationElementId)?.show();\n                editor.remove();\n            }\n            const editables = annotationLayer.getEditableAnnotations();\n            for (const editable of editables){\n                const { id } = editable.data;\n                if (this.#uiManager.isDeletedAnnotationElement(id)) {\n                    editable.updateEdited({\n                        deleted: true\n                    });\n                    continue;\n                }\n                let editor = resetAnnotations.get(id);\n                if (editor) {\n                    editor.resetAnnotationElement(editable);\n                    editor.show(false);\n                    editable.show();\n                    continue;\n                }\n                editor = changedAnnotations.get(id);\n                if (editor) {\n                    this.#uiManager.addChangedExistingAnnotation(editor);\n                    if (editor.renderAnnotationElement(editable)) {\n                        editor.show(false);\n                    }\n                }\n                editable.show();\n            }\n        }\n        this.#cleanup();\n        if (this.isEmpty) {\n            this.div.hidden = true;\n        }\n        const { classList } = this.div;\n        for (const editorType of AnnotationEditorLayer.#editorTypes.values()){\n            classList.remove(`${editorType._type}Editing`);\n        }\n        this.disableTextSelection();\n        this.toggleAnnotationLayerPointerEvents(true);\n        this.#isDisabling = false;\n    }\n    getEditableAnnotation(id) {\n        return this.#annotationLayer?.getEditableAnnotation(id) || null;\n    }\n    setActiveEditor(editor) {\n        const currentActive = this.#uiManager.getActive();\n        if (currentActive === editor) {\n            return;\n        }\n        this.#uiManager.setActiveEditor(editor);\n    }\n    enableTextSelection() {\n        this.div.tabIndex = -1;\n        if (this.#textLayer?.div && !this.#textSelectionAC) {\n            this.#textSelectionAC = new AbortController();\n            const signal = this.#uiManager.combinedSignal(this.#textSelectionAC);\n            this.#textLayer.div.addEventListener(\"pointerdown\", this.#textLayerPointerDown.bind(this), {\n                signal\n            });\n            this.#textLayer.div.classList.add(\"highlighting\");\n        }\n    }\n    disableTextSelection() {\n        this.div.tabIndex = 0;\n        if (this.#textLayer?.div && this.#textSelectionAC) {\n            this.#textSelectionAC.abort();\n            this.#textSelectionAC = null;\n            this.#textLayer.div.classList.remove(\"highlighting\");\n        }\n    }\n    #textLayerPointerDown(event) {\n        this.#uiManager.unselectAll();\n        const { target } = event;\n        if (target === this.#textLayer.div || (target.getAttribute(\"role\") === \"img\" || target.classList.contains(\"endOfContent\")) && this.#textLayer.div.contains(target)) {\n            const { isMac } = util_FeatureTest.platform;\n            if (event.button !== 0 || event.ctrlKey && isMac) {\n                return;\n            }\n            this.#uiManager.showAllEditors(\"highlight\", true, true);\n            this.#textLayer.div.classList.add(\"free\");\n            this.toggleDrawing();\n            HighlightEditor.startHighlighting(this, this.#uiManager.direction === \"ltr\", {\n                target: this.#textLayer.div,\n                x: event.x,\n                y: event.y\n            });\n            this.#textLayer.div.addEventListener(\"pointerup\", ()=>{\n                this.#textLayer.div.classList.remove(\"free\");\n                this.toggleDrawing(true);\n            }, {\n                once: true,\n                signal: this.#uiManager._signal\n            });\n            event.preventDefault();\n        }\n    }\n    enableClick() {\n        if (this.#clickAC) {\n            return;\n        }\n        this.#clickAC = new AbortController();\n        const signal = this.#uiManager.combinedSignal(this.#clickAC);\n        this.div.addEventListener(\"pointerdown\", this.pointerdown.bind(this), {\n            signal\n        });\n        const pointerup = this.pointerup.bind(this);\n        this.div.addEventListener(\"pointerup\", pointerup, {\n            signal\n        });\n        this.div.addEventListener(\"pointercancel\", pointerup, {\n            signal\n        });\n    }\n    disableClick() {\n        this.#clickAC?.abort();\n        this.#clickAC = null;\n    }\n    attach(editor) {\n        this.#editors.set(editor.id, editor);\n        const { annotationElementId } = editor;\n        if (annotationElementId && this.#uiManager.isDeletedAnnotationElement(annotationElementId)) {\n            this.#uiManager.removeDeletedAnnotationElement(editor);\n        }\n    }\n    detach(editor) {\n        this.#editors.delete(editor.id);\n        this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);\n        if (!this.#isDisabling && editor.annotationElementId) {\n            this.#uiManager.addDeletedAnnotationElement(editor);\n        }\n    }\n    remove(editor) {\n        this.detach(editor);\n        this.#uiManager.removeEditor(editor);\n        editor.div.remove();\n        editor.isAttachedToDOM = false;\n    }\n    changeParent(editor) {\n        if (editor.parent === this) {\n            return;\n        }\n        if (editor.parent && editor.annotationElementId) {\n            this.#uiManager.addDeletedAnnotationElement(editor.annotationElementId);\n            AnnotationEditor.deleteAnnotationElement(editor);\n            editor.annotationElementId = null;\n        }\n        this.attach(editor);\n        editor.parent?.detach(editor);\n        editor.setParent(this);\n        if (editor.div && editor.isAttachedToDOM) {\n            editor.div.remove();\n            this.div.append(editor.div);\n        }\n    }\n    add(editor) {\n        if (editor.parent === this && editor.isAttachedToDOM) {\n            return;\n        }\n        this.changeParent(editor);\n        this.#uiManager.addEditor(editor);\n        this.attach(editor);\n        if (!editor.isAttachedToDOM) {\n            const div = editor.render();\n            this.div.append(div);\n            editor.isAttachedToDOM = true;\n        }\n        editor.fixAndSetPosition();\n        editor.onceAdded(!this.#isEnabling);\n        this.#uiManager.addToAnnotationStorage(editor);\n        editor._reportTelemetry(editor.telemetryInitialData);\n    }\n    moveEditorInDOM(editor) {\n        if (!editor.isAttachedToDOM) {\n            return;\n        }\n        const { activeElement } = document;\n        if (editor.div.contains(activeElement) && !this.#editorFocusTimeoutId) {\n            editor._focusEventsAllowed = false;\n            this.#editorFocusTimeoutId = setTimeout(()=>{\n                this.#editorFocusTimeoutId = null;\n                if (!editor.div.contains(document.activeElement)) {\n                    editor.div.addEventListener(\"focusin\", ()=>{\n                        editor._focusEventsAllowed = true;\n                    }, {\n                        once: true,\n                        signal: this.#uiManager._signal\n                    });\n                    activeElement.focus();\n                } else {\n                    editor._focusEventsAllowed = true;\n                }\n            }, 0);\n        }\n        editor._structTreeParentId = this.#accessibilityManager?.moveElementInDOM(this.div, editor.div, editor.contentDiv, true);\n    }\n    addOrRebuild(editor) {\n        if (editor.needsToBeRebuilt()) {\n            editor.parent ||= this;\n            editor.rebuild();\n            editor.show();\n        } else {\n            this.add(editor);\n        }\n    }\n    addUndoableEditor(editor) {\n        const cmd = ()=>editor._uiManager.rebuild(editor);\n        const undo = ()=>{\n            editor.remove();\n        };\n        this.addCommands({\n            cmd,\n            undo,\n            mustExec: false\n        });\n    }\n    getEditorByUID(uid) {\n        for (const editor of this.#editors.values()){\n            if (editor.uid === uid) {\n                return editor;\n            }\n        }\n        return null;\n    }\n    getNextId() {\n        return this.#uiManager.getId();\n    }\n    get #currentEditorType() {\n        return AnnotationEditorLayer.#editorTypes.get(this.#uiManager.getMode());\n    }\n    combinedSignal(ac) {\n        return this.#uiManager.combinedSignal(ac);\n    }\n    #createNewEditor(params) {\n        const editorType = this.#currentEditorType;\n        return editorType ? new editorType.prototype.constructor(params) : null;\n    }\n    canCreateNewEmptyEditor() {\n        return this.#currentEditorType?.canCreateNewEmptyEditor();\n    }\n    async pasteEditor(options, params) {\n        this.updateToolbar(options);\n        await this.#uiManager.updateMode(options.mode);\n        const { offsetX, offsetY } = this.#getCenterPoint();\n        const id = this.getNextId();\n        const editor = this.#createNewEditor({\n            parent: this,\n            id,\n            x: offsetX,\n            y: offsetY,\n            uiManager: this.#uiManager,\n            isCentered: true,\n            ...params\n        });\n        if (editor) {\n            this.add(editor);\n        }\n    }\n    async deserialize(data) {\n        return await AnnotationEditorLayer.#editorTypes.get(data.annotationType ?? data.annotationEditorType)?.deserialize(data, this, this.#uiManager) || null;\n    }\n    createAndAddNewEditor(event, isCentered, data = {}) {\n        const id = this.getNextId();\n        const editor = this.#createNewEditor({\n            parent: this,\n            id,\n            x: event.offsetX,\n            y: event.offsetY,\n            uiManager: this.#uiManager,\n            isCentered,\n            ...data\n        });\n        if (editor) {\n            this.add(editor);\n        }\n        return editor;\n    }\n    get boundingClientRect() {\n        return this.div.getBoundingClientRect();\n    }\n    #getCenterPoint() {\n        const { x, y, width, height } = this.boundingClientRect;\n        const tlX = Math.max(0, x);\n        const tlY = Math.max(0, y);\n        const brX = Math.min(window.innerWidth, x + width);\n        const brY = Math.min(window.innerHeight, y + height);\n        const centerX = (tlX + brX) / 2 - x;\n        const centerY = (tlY + brY) / 2 - y;\n        const [offsetX, offsetY] = this.viewport.rotation % 180 === 0 ? [\n            centerX,\n            centerY\n        ] : [\n            centerY,\n            centerX\n        ];\n        return {\n            offsetX,\n            offsetY\n        };\n    }\n    addNewEditor(data = {}) {\n        this.createAndAddNewEditor(this.#getCenterPoint(), true, data);\n    }\n    setSelected(editor) {\n        this.#uiManager.setSelected(editor);\n    }\n    toggleSelected(editor) {\n        this.#uiManager.toggleSelected(editor);\n    }\n    unselect(editor) {\n        this.#uiManager.unselect(editor);\n    }\n    pointerup(event) {\n        const { isMac } = util_FeatureTest.platform;\n        if (event.button !== 0 || event.ctrlKey && isMac) {\n            return;\n        }\n        if (event.target !== this.div) {\n            return;\n        }\n        if (!this.#hadPointerDown) {\n            return;\n        }\n        this.#hadPointerDown = false;\n        if (this.#currentEditorType?.isDrawer && this.#currentEditorType.supportMultipleDrawings) {\n            return;\n        }\n        if (!this.#allowClick) {\n            this.#allowClick = true;\n            return;\n        }\n        const currentMode = this.#uiManager.getMode();\n        if (currentMode === AnnotationEditorType.STAMP || currentMode === AnnotationEditorType.SIGNATURE) {\n            this.#uiManager.unselectAll();\n            return;\n        }\n        this.createAndAddNewEditor(event, false);\n    }\n    pointerdown(event) {\n        if (this.#uiManager.getMode() === AnnotationEditorType.HIGHLIGHT) {\n            this.enableTextSelection();\n        }\n        if (this.#hadPointerDown) {\n            this.#hadPointerDown = false;\n            return;\n        }\n        const { isMac } = util_FeatureTest.platform;\n        if (event.button !== 0 || event.ctrlKey && isMac) {\n            return;\n        }\n        if (event.target !== this.div) {\n            return;\n        }\n        this.#hadPointerDown = true;\n        if (this.#currentEditorType?.isDrawer) {\n            this.startDrawingSession(event);\n            return;\n        }\n        const editor = this.#uiManager.getActive();\n        this.#allowClick = !editor || editor.isEmpty();\n    }\n    startDrawingSession(event) {\n        this.div.focus({\n            preventScroll: true\n        });\n        if (this.#drawingAC) {\n            this.#currentEditorType.startDrawing(this, this.#uiManager, false, event);\n            return;\n        }\n        this.#uiManager.setCurrentDrawingSession(this);\n        this.#drawingAC = new AbortController();\n        const signal = this.#uiManager.combinedSignal(this.#drawingAC);\n        this.div.addEventListener(\"blur\", ({ relatedTarget })=>{\n            if (relatedTarget && !this.div.contains(relatedTarget)) {\n                this.#focusedElement = null;\n                this.commitOrRemove();\n            }\n        }, {\n            signal\n        });\n        this.#currentEditorType.startDrawing(this, this.#uiManager, false, event);\n    }\n    pause(on) {\n        if (on) {\n            const { activeElement } = document;\n            if (this.div.contains(activeElement)) {\n                this.#focusedElement = activeElement;\n            }\n            return;\n        }\n        if (this.#focusedElement) {\n            setTimeout(()=>{\n                this.#focusedElement?.focus();\n                this.#focusedElement = null;\n            }, 0);\n        }\n    }\n    endDrawingSession(isAborted = false) {\n        if (!this.#drawingAC) {\n            return null;\n        }\n        this.#uiManager.setCurrentDrawingSession(null);\n        this.#drawingAC.abort();\n        this.#drawingAC = null;\n        this.#focusedElement = null;\n        return this.#currentEditorType.endDrawing(isAborted);\n    }\n    findNewParent(editor, x, y) {\n        const layer = this.#uiManager.findParent(x, y);\n        if (layer === null || layer === this) {\n            return false;\n        }\n        layer.changeParent(editor);\n        return true;\n    }\n    commitOrRemove() {\n        if (this.#drawingAC) {\n            this.endDrawingSession();\n            return true;\n        }\n        return false;\n    }\n    onScaleChanging() {\n        if (!this.#drawingAC) {\n            return;\n        }\n        this.#currentEditorType.onScaleChangingWhenDrawing(this);\n    }\n    destroy() {\n        this.commitOrRemove();\n        if (this.#uiManager.getActive()?.parent === this) {\n            this.#uiManager.commitOrRemove();\n            this.#uiManager.setActiveEditor(null);\n        }\n        if (this.#editorFocusTimeoutId) {\n            clearTimeout(this.#editorFocusTimeoutId);\n            this.#editorFocusTimeoutId = null;\n        }\n        for (const editor of this.#editors.values()){\n            this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);\n            editor.setParent(null);\n            editor.isAttachedToDOM = false;\n            editor.div.remove();\n        }\n        this.div = null;\n        this.#editors.clear();\n        this.#uiManager.removeLayer(this);\n    }\n    #cleanup() {\n        for (const editor of this.#editors.values()){\n            if (editor.isEmpty()) {\n                editor.remove();\n            }\n        }\n    }\n    render({ viewport }) {\n        this.viewport = viewport;\n        setLayerDimensions(this.div, viewport);\n        for (const editor of this.#uiManager.getEditors(this.pageIndex)){\n            this.add(editor);\n            editor.rebuild();\n        }\n        this.updateMode();\n    }\n    update({ viewport }) {\n        this.#uiManager.commitOrRemove();\n        this.#cleanup();\n        const oldRotation = this.viewport.rotation;\n        const rotation = viewport.rotation;\n        this.viewport = viewport;\n        setLayerDimensions(this.div, {\n            rotation\n        });\n        if (oldRotation !== rotation) {\n            for (const editor of this.#editors.values()){\n                editor.rotate(rotation);\n            }\n        }\n    }\n    get pageDimensions() {\n        const { pageWidth, pageHeight } = this.viewport.rawDims;\n        return [\n            pageWidth,\n            pageHeight\n        ];\n    }\n    get scale() {\n        return this.#uiManager.viewParameters.realScale;\n    }\n}\nclass DrawLayer {\n    #parent;\n    #mapping;\n    #toUpdate;\n    static #id = 0;\n    constructor({ pageIndex }){\n        this.#parent = null;\n        this.#mapping = /* @__PURE__ */ new Map();\n        this.#toUpdate = /* @__PURE__ */ new Map();\n        this.pageIndex = pageIndex;\n    }\n    setParent(parent) {\n        if (!this.#parent) {\n            this.#parent = parent;\n            return;\n        }\n        if (this.#parent !== parent) {\n            if (this.#mapping.size > 0) {\n                for (const root of this.#mapping.values()){\n                    root.remove();\n                    parent.append(root);\n                }\n            }\n            this.#parent = parent;\n        }\n    }\n    static get _svgFactory() {\n        return shadow(this, \"_svgFactory\", new DOMSVGFactory());\n    }\n    static #setBox(element, [x, y, width, height]) {\n        const { style } = element;\n        style.top = `${100 * y}%`;\n        style.left = `${100 * x}%`;\n        style.width = `${100 * width}%`;\n        style.height = `${100 * height}%`;\n    }\n    #createSVG() {\n        const svg = DrawLayer._svgFactory.create(1, 1, true);\n        this.#parent.append(svg);\n        svg.setAttribute(\"aria-hidden\", true);\n        return svg;\n    }\n    #createClipPath(defs, pathId) {\n        const clipPath = DrawLayer._svgFactory.createElement(\"clipPath\");\n        defs.append(clipPath);\n        const clipPathId = `clip_${pathId}`;\n        clipPath.setAttribute(\"id\", clipPathId);\n        clipPath.setAttribute(\"clipPathUnits\", \"objectBoundingBox\");\n        const clipPathUse = DrawLayer._svgFactory.createElement(\"use\");\n        clipPath.append(clipPathUse);\n        clipPathUse.setAttribute(\"href\", `#${pathId}`);\n        clipPathUse.classList.add(\"clip\");\n        return clipPathId;\n    }\n    #updateProperties(element, properties) {\n        for (const [key, value1] of Object.entries(properties)){\n            if (value1 === null) {\n                element.removeAttribute(key);\n            } else {\n                element.setAttribute(key, value1);\n            }\n        }\n    }\n    draw(properties, isPathUpdatable = false, hasClip = false) {\n        const id = DrawLayer.#id++;\n        const root = this.#createSVG();\n        const defs = DrawLayer._svgFactory.createElement(\"defs\");\n        root.append(defs);\n        const path = DrawLayer._svgFactory.createElement(\"path\");\n        defs.append(path);\n        const pathId = `path_p${this.pageIndex}_${id}`;\n        path.setAttribute(\"id\", pathId);\n        path.setAttribute(\"vector-effect\", \"non-scaling-stroke\");\n        if (isPathUpdatable) {\n            this.#toUpdate.set(id, path);\n        }\n        const clipPathId = hasClip ? this.#createClipPath(defs, pathId) : null;\n        const use = DrawLayer._svgFactory.createElement(\"use\");\n        root.append(use);\n        use.setAttribute(\"href\", `#${pathId}`);\n        this.updateProperties(root, properties);\n        this.#mapping.set(id, root);\n        return {\n            id,\n            clipPathId: `url(#${clipPathId})`\n        };\n    }\n    drawOutline(properties, mustRemoveSelfIntersections) {\n        const id = DrawLayer.#id++;\n        const root = this.#createSVG();\n        const defs = DrawLayer._svgFactory.createElement(\"defs\");\n        root.append(defs);\n        const path = DrawLayer._svgFactory.createElement(\"path\");\n        defs.append(path);\n        const pathId = `path_p${this.pageIndex}_${id}`;\n        path.setAttribute(\"id\", pathId);\n        path.setAttribute(\"vector-effect\", \"non-scaling-stroke\");\n        let maskId;\n        if (mustRemoveSelfIntersections) {\n            const mask = DrawLayer._svgFactory.createElement(\"mask\");\n            defs.append(mask);\n            maskId = `mask_p${this.pageIndex}_${id}`;\n            mask.setAttribute(\"id\", maskId);\n            mask.setAttribute(\"maskUnits\", \"objectBoundingBox\");\n            const rect = DrawLayer._svgFactory.createElement(\"rect\");\n            mask.append(rect);\n            rect.setAttribute(\"width\", \"1\");\n            rect.setAttribute(\"height\", \"1\");\n            rect.setAttribute(\"fill\", \"white\");\n            const use = DrawLayer._svgFactory.createElement(\"use\");\n            mask.append(use);\n            use.setAttribute(\"href\", `#${pathId}`);\n            use.setAttribute(\"stroke\", \"none\");\n            use.setAttribute(\"fill\", \"black\");\n            use.setAttribute(\"fill-rule\", \"nonzero\");\n            use.classList.add(\"mask\");\n        }\n        const use1 = DrawLayer._svgFactory.createElement(\"use\");\n        root.append(use1);\n        use1.setAttribute(\"href\", `#${pathId}`);\n        if (maskId) {\n            use1.setAttribute(\"mask\", `url(#${maskId})`);\n        }\n        const use2 = use1.cloneNode();\n        root.append(use2);\n        use1.classList.add(\"mainOutline\");\n        use2.classList.add(\"secondaryOutline\");\n        this.updateProperties(root, properties);\n        this.#mapping.set(id, root);\n        return id;\n    }\n    finalizeDraw(id, properties) {\n        this.#toUpdate.delete(id);\n        this.updateProperties(id, properties);\n    }\n    updateProperties(elementOrId, properties) {\n        if (!properties) {\n            return;\n        }\n        const { root, bbox, rootClass, path } = properties;\n        const element = typeof elementOrId === \"number\" ? this.#mapping.get(elementOrId) : elementOrId;\n        if (!element) {\n            return;\n        }\n        if (root) {\n            this.#updateProperties(element, root);\n        }\n        if (bbox) {\n            DrawLayer.#setBox(element, bbox);\n        }\n        if (rootClass) {\n            const { classList } = element;\n            for (const [className, value1] of Object.entries(rootClass)){\n                classList.toggle(className, value1);\n            }\n        }\n        if (path) {\n            const defs = element.firstChild;\n            const pathElement = defs.firstChild;\n            this.#updateProperties(pathElement, path);\n        }\n    }\n    updateParent(id, layer) {\n        if (layer === this) {\n            return;\n        }\n        const root = this.#mapping.get(id);\n        if (!root) {\n            return;\n        }\n        layer.#parent.append(root);\n        this.#mapping.delete(id);\n        layer.#mapping.set(id, root);\n    }\n    remove(id) {\n        this.#toUpdate.delete(id);\n        if (this.#parent === null) {\n            return;\n        }\n        this.#mapping.get(id).remove();\n        this.#mapping.delete(id);\n    }\n    destroy() {\n        this.#parent = null;\n        for (const root of this.#mapping.values()){\n            root.remove();\n        }\n        this.#mapping.clear();\n        this.#toUpdate.clear();\n    }\n}\n{\n    globalThis._pdfjsTestingUtils = {\n        HighlightOutliner\n    };\n}globalThis.pdfjsLib = {\n    AbortException,\n    AnnotationEditorLayer,\n    AnnotationEditorParamsType,\n    AnnotationEditorType,\n    AnnotationEditorUIManager,\n    AnnotationLayer,\n    AnnotationMode,\n    AnnotationType,\n    applyOpacity,\n    build,\n    ColorPicker,\n    createValidAbsoluteUrl,\n    CSSConstants,\n    DOMSVGFactory,\n    DrawLayer,\n    FeatureTest: util_FeatureTest,\n    fetchData,\n    findContrastColor,\n    getDocument,\n    getFilenameFromUrl,\n    getPdfFilenameFromUrl,\n    getRGB,\n    getUuid,\n    getXfaPageViewport,\n    GlobalWorkerOptions,\n    ImageKind: util_ImageKind,\n    InvalidPDFException,\n    isDataScheme,\n    isPdfFile,\n    isValidExplicitDest,\n    MathClamp,\n    noContextMenu,\n    normalizeUnicode,\n    OPS,\n    OutputScale,\n    PasswordResponses,\n    PDFDataRangeTransport,\n    PDFDateString,\n    PDFWorker,\n    PermissionFlag,\n    PixelsPerInch,\n    RenderingCancelledException,\n    renderRichText,\n    ResponseException,\n    setLayerDimensions,\n    shadow,\n    SignatureExtractor,\n    stopEvent,\n    SupportedImageMimeTypes,\n    TextLayer,\n    TouchManager,\n    updateUrlHash,\n    Util,\n    VerbosityLevel,\n    version,\n    XfaLayer\n};\nconst pdfjs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n    __proto__: null,\n    AbortException,\n    AnnotationEditorLayer,\n    AnnotationEditorParamsType,\n    AnnotationEditorType,\n    AnnotationEditorUIManager,\n    AnnotationLayer,\n    AnnotationMode,\n    AnnotationType,\n    CSSConstants,\n    ColorPicker,\n    DOMSVGFactory,\n    DrawLayer,\n    FeatureTest: util_FeatureTest,\n    GlobalWorkerOptions,\n    ImageKind: util_ImageKind,\n    InvalidPDFException,\n    MathClamp,\n    OPS,\n    OutputScale,\n    PDFDataRangeTransport,\n    PDFDateString,\n    PDFWorker,\n    PasswordResponses,\n    PermissionFlag,\n    PixelsPerInch,\n    RenderingCancelledException,\n    ResponseException,\n    SignatureExtractor,\n    SupportedImageMimeTypes,\n    TextLayer,\n    TouchManager,\n    Util,\n    VerbosityLevel,\n    XfaLayer,\n    applyOpacity,\n    build,\n    createValidAbsoluteUrl,\n    fetchData,\n    findContrastColor,\n    getDocument,\n    getFilenameFromUrl,\n    getPdfFilenameFromUrl,\n    getRGB,\n    getUuid,\n    getXfaPageViewport,\n    isDataScheme,\n    isPdfFile,\n    isValidExplicitDest,\n    noContextMenu,\n    normalizeUnicode,\n    renderRichText,\n    setLayerDimensions,\n    shadow,\n    stopEvent,\n    updateUrlHash,\n    version\n}, Symbol.toStringTag, {\n    value: \"Module\"\n}));\nclass Shape {\n    static{\n        this.tolerance = 2;\n    }\n    static applyTransform(p, m) {\n        const xt = p[0] * m[0] + p[1] * m[2] + m[4];\n        const yt = p[0] * m[1] + p[1] * m[3] + m[5];\n        return [\n            xt,\n            yt\n        ];\n    }\n}\nclass Point extends Shape {\n    constructor(x, y){\n        super();\n        this.x = x;\n        this.y = y;\n    }\n    equal(point) {\n        return point.x === this.x && point.y === this.y;\n    }\n    transform(matrix) {\n        const p = Shape.applyTransform([\n            this.x,\n            this.y\n        ], matrix);\n        this.x = p[0];\n        this.y = p[1];\n        return this;\n    }\n}\nvar LineDirection = /* @__PURE__ */ ((LineDirection2)=>{\n    LineDirection2[LineDirection2[\"None\"] = 0] = \"None\";\n    LineDirection2[LineDirection2[\"Horizontal\"] = 1] = \"Horizontal\";\n    LineDirection2[LineDirection2[\"Vertical\"] = 2] = \"Vertical\";\n    return LineDirection2;\n})(LineDirection || {});\nclass Line extends Shape {\n    constructor(from, to){\n        super();\n        this.direction = 0;\n        this.length = 0;\n        this.intersections = [];\n        this.gaps = [];\n        this._valid = void 0;\n        this.from = from;\n        this.to = to;\n        this.init();\n    }\n    init() {\n        let from = this.from;\n        let to = this.to;\n        if (Math.abs(from.y - to.y) < Shape.tolerance) {\n            this.direction = 1;\n            to.y = from.y;\n            if (from.x > to.x) {\n                const temp = from;\n                from = to;\n                to = temp;\n            }\n            this.length = to.x - from.x;\n        } else if (Math.abs(from.x - to.x) < Shape.tolerance) {\n            this.direction = 2;\n            to.x = from.x;\n            if (from.y > to.y) {\n                const temp = from;\n                from = to;\n                to = temp;\n            }\n            this.length = to.y - from.y;\n        }\n        this.from = from;\n        this.to = to;\n    }\n    get valid() {\n        if (this._valid === void 0) {\n            this._valid = this.direction !== 0 && this.length > Shape.tolerance;\n        }\n        return this._valid;\n    }\n    get normalized() {\n        if (this.direction === 1) {\n            return new Line(new Point(this.from.x - Shape.tolerance, this.from.y), new Point(this.to.x + Shape.tolerance, this.from.y));\n        } else if (this.direction === 2) {\n            return new Line(new Point(this.from.x, this.from.y - Shape.tolerance), new Point(this.from.x, this.to.y + Shape.tolerance));\n        }\n        return this;\n    }\n    addGap(line) {\n        this.gaps.push(line);\n    }\n    containsPoint(p) {\n        if (this.direction === 2) {\n            return this.from.x === p.x && p.y >= this.from.y && p.y <= this.to.y;\n        } else if (this.direction === 1) {\n            return this.from.y === p.y && p.x >= this.from.x && p.x <= this.to.x;\n        }\n        return false;\n    }\n    // // todo implement\n    // public containsLine(l:Line):boolean{\n    //     if(this.direction === LineDirection.Vertical && l.direction === LineDirection.Vertical){\n    //         return this.from.x === l.from.x\n    //     }\n    //     else if(this.direction === LineDirection.Horizontal && l.direction === LineDirection.Horizontal){\n    //         return this.from.y === l.from.y\n    //     }\n    //     return false\n    // }\n    addIntersectionPoint(point) {\n        for (const intPoint of this.intersections){\n            if (intPoint.equal(point)) return;\n        }\n        this.intersections.push(point);\n    }\n    intersection(line) {\n        let result;\n        if (!this.valid || !line.valid) {\n            return result;\n        }\n        const thisNormalized = this.normalized;\n        const lineNormalized = line.normalized;\n        if (this.direction === 1 && line.direction === 2) {\n            const x = lineNormalized.from.x;\n            const y = thisNormalized.from.y;\n            const isOk = x > thisNormalized.from.x && x < thisNormalized.to.x && y > lineNormalized.from.y && y < lineNormalized.to.y;\n            if (isOk) {\n                const intPoint = new Point(x, y);\n                this.addIntersectionPoint(intPoint);\n                line.addIntersectionPoint(intPoint);\n                result = intPoint;\n            }\n        } else if (this.direction === 2 && line.direction === 1) {\n            const x = thisNormalized.from.x;\n            const y = lineNormalized.from.y;\n            const isOk = x > lineNormalized.from.x && x < lineNormalized.to.x && y > thisNormalized.from.y && y < thisNormalized.to.y;\n            if (isOk) {\n                const intPoint = new Point(x, y);\n                this.addIntersectionPoint(intPoint);\n                line.addIntersectionPoint(intPoint);\n                result = intPoint;\n            }\n        }\n        return result;\n    }\n    transform(matrix) {\n        const p1 = this.from.transform(matrix);\n        const p2 = this.to.transform(matrix);\n        const x = Math.min(p1.x, p2.x);\n        const y = Math.min(p1.y, p2.y);\n        const width = Math.abs(p1.x - p2.x);\n        const height = Math.abs(p1.y - p2.y);\n        this.from = new Point(x, y);\n        this.to = new Point(x + width, y + height);\n        this.init();\n        return this;\n    }\n}\nclass TableData {\n    constructor(minXY, maxXY, rowPivots, colPivots){\n        this.minXY = minXY;\n        this.maxXY = maxXY;\n        this.rows = [];\n        this.rowPivots = rowPivots;\n        this.colPivots = colPivots;\n    }\n    findCell(x, y) {\n        if (x >= this.minXY.x && y >= this.minXY.y && x <= this.maxXY.x && y <= this.maxXY.y) {\n            for (const row of this.rows){\n                for (const cell of row){\n                    if (cell.minXY.x <= x && cell.minXY.y <= y && cell.maxXY.x >= x && cell.maxXY.y >= y) {\n                        return cell;\n                    }\n                }\n            }\n        }\n        return void 0;\n    }\n    get cellCount() {\n        return this.rows.reduce((acc, row)=>acc + row.length, 0);\n    }\n    get rowCount() {\n        return this.rows.length;\n    }\n    check() {\n        const virtualCellCount = (this.colPivots.length - 1) * (this.rowPivots.length - 1);\n        let allCellCount = 0;\n        for (const row of this.rows){\n            for (const cell of row){\n                const count = (cell.colspan || 1) * (cell.rowspan || 1);\n                allCellCount += count;\n            }\n        }\n        if (virtualCellCount !== allCellCount) {\n            return false;\n        }\n        return true;\n    }\n    toArray() {\n        const tableArr = [];\n        for (const row of this.rows){\n            const rowArr = [];\n            for (const cell of row){\n                let text = cell.text.join(\"\");\n                text = text.replace(/^[\\s]+|[\\s]+$/g, \"\");\n                text = text.trim();\n                rowArr.push(text);\n            }\n            tableArr.push(rowArr);\n        }\n        return tableArr;\n    }\n}\nclass Table {\n    constructor(line){\n        this.hLines = [];\n        this.vLines = [];\n        if (line.direction === LineDirection.Horizontal) {\n            this.hLines.push(line);\n        } else if (line.direction === LineDirection.Vertical) {\n            this.vLines.push(line);\n        }\n    }\n    get isValid() {\n        return this.hLines.length + this.vLines.length > 4;\n    }\n    get rowPivots() {\n        const rowSet = /* @__PURE__ */ new Set();\n        for (const line of this.hLines){\n            rowSet.add(line.from.y);\n        }\n        return [\n            ...rowSet\n        ].sort((a, b)=>a - b);\n    }\n    get colPivots() {\n        const colSet = /* @__PURE__ */ new Set();\n        for (const line of this.vLines){\n            colSet.add(line.from.x);\n        }\n        return [\n            ...colSet\n        ].sort((a, b)=>a - b);\n    }\n    add(line) {\n        const hasIntersection = this.intersection(line);\n        if (hasIntersection) {\n            if (line.direction === LineDirection.Horizontal) {\n                this.hLines.push(line);\n                return true;\n            } else if (line.direction === LineDirection.Vertical) {\n                this.vLines.push(line);\n                return true;\n            }\n        }\n        return false;\n    }\n    intersection(line) {\n        let flag = false;\n        if (!line.valid) return flag;\n        if (line.direction === LineDirection.Horizontal) {\n            for (const vLine of this.vLines){\n                const p = line.intersection(vLine);\n                if (p) {\n                    flag = true;\n                }\n            }\n        } else if (line.direction === LineDirection.Vertical) {\n            for (const hLine of this.hLines){\n                const p = line.intersection(hLine);\n                if (p) {\n                    flag = true;\n                }\n            }\n        }\n        return flag;\n    }\n    getSameHorizontal(line) {\n        const same = [\n            line\n        ];\n        const other = [];\n        while(this.hLines.length > 0){\n            const hLine = this.hLines.shift();\n            if (!hLine) continue;\n            if (hLine.from.y === line.from.y) {\n                same.push(hLine);\n            } else {\n                other.push(hLine);\n            }\n        }\n        this.hLines = other;\n        return same;\n    }\n    getSameVertical(line) {\n        const same = [\n            line\n        ];\n        const other = [];\n        while(this.vLines.length > 0){\n            const vLine = this.vLines.shift();\n            if (!vLine) continue;\n            if (vLine.from.x === line.from.x) {\n                same.push(vLine);\n            } else {\n                other.push(vLine);\n            }\n        }\n        this.vLines = other;\n        return same;\n    }\n    mergeHorizontalLines(lines) {\n        lines.sort((l1, l2)=>l1.from.x - l2.from.x);\n        const minX = lines[0].from.x;\n        const maxX = lines[lines.length - 1].to.x;\n        const resultLine = new Line(new Point(minX, lines[0].from.y), new Point(maxX, lines[0].from.y));\n        for(let i = 1; i < lines.length; i++){\n            const prevLine = lines[i - 1];\n            const currLine = lines[i];\n            if (Math.abs(prevLine.to.x - currLine.from.x) > Shape.tolerance) {\n                const gapLine = new Line(new Point(prevLine.to.x, prevLine.from.y), new Point(currLine.from.x, currLine.from.y));\n                resultLine.addGap(gapLine);\n            }\n        }\n        return resultLine;\n    }\n    mergeVerticalLines(lines) {\n        lines.sort((l1, l2)=>l1.from.y - l2.from.y);\n        const minY = lines[0].from.y;\n        const maxY = lines[lines.length - 1].to.y;\n        const resultLine = new Line(new Point(lines[0].from.x, minY), new Point(lines[0].from.x, maxY));\n        for(let i = 1; i < lines.length; i++){\n            const prevLine = lines[i - 1];\n            const currLine = lines[i];\n            if (Math.abs(prevLine.to.y - currLine.from.y) > Shape.tolerance) {\n                const gapLine = new Line(new Point(prevLine.to.x, prevLine.to.y), new Point(prevLine.to.x, currLine.from.y));\n                resultLine.addGap(gapLine);\n            }\n        }\n        return resultLine;\n    }\n    normalize() {\n        this.hLines = this.hLines.filter((l)=>l.intersections.length > 1);\n        this.vLines = this.vLines.filter((l)=>l.intersections.length > 1);\n        this.hLines.sort((l1, l2)=>l1.from.y - l2.from.y);\n        this.vLines.sort((l1, l2)=>l1.from.x - l2.from.x);\n        const newHLines = [];\n        while(this.hLines.length > 0){\n            const line = this.hLines.shift();\n            if (!line) continue;\n            const lines = this.getSameHorizontal(line);\n            const merged = this.mergeHorizontalLines(lines);\n            newHLines.push(merged);\n        }\n        this.hLines = newHLines;\n        const newVLines = [];\n        while(this.vLines.length > 0){\n            const line = this.vLines.shift();\n            if (!line) continue;\n            const lines = this.getSameVertical(line);\n            const merged = this.mergeVerticalLines(lines);\n            newVLines.push(merged);\n        }\n        this.vLines = newVLines;\n    }\n    verticalExists(line, y1, y2) {\n        if (line.direction !== LineDirection.Vertical) {\n            throw new Error(\"Line is not vertical\");\n        }\n        if (y1 >= y2) {\n            throw new Error(\"y1 must be less than y2\");\n        }\n        if (line.from.y <= y1 && line.to.y >= y2) {\n            for (const gap of line.gaps){\n                if (gap.from.y <= y1 && gap.to.y >= y2) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    horizontalExists(line, x1, x2) {\n        if (line.direction !== LineDirection.Horizontal) {\n            throw new Error(\"Line is not horizontal\");\n        }\n        if (x1 >= x2) {\n            throw new Error(\"x1 must be less than x2\");\n        }\n        if (line.from.x <= x1 && line.to.x >= x2) {\n            for (const gap of line.gaps){\n                if (gap.from.x <= x1 && gap.to.x >= x2) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    findBottomLineIndex(h2Index, xMiddle) {\n        for(let i = h2Index; i < this.hLines.length; i++){\n            const hLine = this.hLines[i];\n            if (hLine.from.x <= xMiddle && hLine.to.x >= xMiddle) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    findVerticalLineIndexs(topHLine, yMiddle) {\n        const result = [];\n        for(let i = 0; i < this.vLines.length; i++){\n            const vLine = this.vLines[i];\n            if (vLine.from.y <= yMiddle && vLine.to.y >= yMiddle && topHLine.intersection(vLine)) {\n                result.push(i);\n            }\n        }\n        return result;\n    }\n    getRow(h1Index, h2Index, yMiddle) {\n        const tableRow = [];\n        const topHLine = this.hLines[h1Index];\n        const vLineIndexes = this.findVerticalLineIndexs(topHLine, yMiddle);\n        for(let i = 1; i < vLineIndexes.length; i++){\n            const leftVLine = this.vLines[vLineIndexes[i - 1]];\n            const rightVLine = this.vLines[vLineIndexes[i]];\n            const xMiddle = (leftVLine.from.x + rightVLine.from.x) / 2;\n            const bottomHLineIndex = this.findBottomLineIndex(h2Index, xMiddle);\n            const bottomHLine = this.hLines[bottomHLineIndex];\n            const tableCell = {\n                minXY: new Point(leftVLine.from.x, topHLine.from.y),\n                maxXY: new Point(rightVLine.from.x, bottomHLine.from.y),\n                width: rightVLine.from.x - leftVLine.from.x,\n                height: bottomHLine.from.y - topHLine.from.y,\n                text: []\n            };\n            const colSpan = vLineIndexes[i] - vLineIndexes[i - 1];\n            const rowSpan = bottomHLineIndex - h1Index;\n            if (colSpan > 1) {\n                tableCell.colspan = colSpan;\n            }\n            if (rowSpan > 1) {\n                tableCell.rowspan = rowSpan;\n            }\n            tableRow.push(tableCell);\n        }\n        return tableRow;\n    }\n    toData() {\n        const rowPivots = this.rowPivots;\n        const colPivots = this.colPivots;\n        const minXY = new Point(colPivots[0], rowPivots[0]);\n        const maxXY = new Point(colPivots[colPivots.length - 1], rowPivots[rowPivots.length - 1]);\n        const result = new TableData(minXY, maxXY, rowPivots, colPivots);\n        for(let h1 = 1; h1 < this.hLines.length; h1++){\n            const prevHLine = this.hLines[h1 - 1];\n            const currHLine = this.hLines[h1];\n            const YMiddle = (prevHLine.from.y + currHLine.from.y) / 2;\n            const rowData = this.getRow(h1 - 1, h1, YMiddle);\n            result.rows.push(rowData);\n        }\n        return result;\n    }\n}\nclass LineStore {\n    add(line) {\n        if (line.valid) {\n            if (line.direction === LineDirection.Horizontal) {\n                this.hLines.push(line);\n            } else if (line.direction === LineDirection.Vertical) {\n                this.vLines.push(line);\n            }\n        }\n    }\n    addRectangle(rect) {\n        for (const line of rect.getLines()){\n            this.add(line);\n        }\n    }\n    getTableData() {\n        const result = [];\n        const tables = this.getTables();\n        for (const table of tables){\n            const data = table.toData();\n            if (data) {\n                result.push(data);\n            }\n        }\n        return result;\n    }\n    getTables() {\n        const result = [];\n        while(this.hLines.length !== 0){\n            const hLine = this.hLines.shift();\n            if (!hLine) continue;\n            const filled = this.tryFill(result, hLine);\n            if (filled) continue;\n            const table = new Table(hLine);\n            this.fillTable(table);\n            result.push(table);\n        }\n        while(this.vLines.length !== 0){\n            const vLine = this.vLines.shift();\n            if (!vLine) continue;\n            const filled = this.tryFill(result, vLine);\n            if (filled) continue;\n            const table = new Table(vLine);\n            this.fillTable(table);\n            result.push(table);\n        }\n        const validTables = result.filter((t)=>t.isValid);\n        for (const table of validTables){\n            table.normalize();\n        }\n        return validTables;\n    }\n    normalize() {\n        this.normalizeHorizontal();\n        this.normalizeVertical();\n    }\n    normalizeHorizontal() {\n        this.hLines.sort((l1, l2)=>l1.from.y - l2.from.y);\n        const newLines = [];\n        let sameY = [];\n        for (const line of this.hLines){\n            if (sameY.length === 0) {\n                sameY.push(line);\n            } else if (Math.abs(sameY[0]?.from.y - line.from.y) < Shape.tolerance) {\n                sameY.push(line);\n            } else {\n                const merged = this.margeHorizontalLines(sameY);\n                newLines.push(...merged);\n                sameY = [\n                    line\n                ];\n            }\n        }\n        if (sameY.length > 0) {\n            const merged = this.margeHorizontalLines(sameY);\n            newLines.push(...merged);\n        }\n        this.hLines = newLines;\n    }\n    normalizeVertical() {\n        this.vLines.sort((l1, l2)=>l1.from.x - l2.from.x);\n        const newLines = [];\n        let sameX = [];\n        for (const line of this.vLines){\n            if (sameX.length === 0) {\n                sameX.push(line);\n            } else if (Math.abs(sameX[0]?.from.x - line.from.x) < Shape.tolerance) {\n                sameX.push(line);\n            } else {\n                const merged = this.margeVerticalLines(sameX);\n                newLines.push(...merged);\n                sameX = [\n                    line\n                ];\n            }\n        }\n        if (sameX.length > 0) {\n            const merged = this.margeVerticalLines(sameX);\n            newLines.push(...merged);\n        }\n        this.vLines = newLines;\n    }\n    fillTable(table) {\n        const newVLines = [];\n        const newHLines = [];\n        for (const vLine of this.vLines){\n            if (!table.add(vLine)) {\n                newVLines.push(vLine);\n            }\n        }\n        for (const hLine of this.hLines){\n            if (!table.add(hLine)) {\n                newHLines.push(hLine);\n            }\n        }\n        this.hLines = newHLines;\n        this.vLines = newVLines;\n    }\n    tryFill(tables, line) {\n        for (const table of tables){\n            if (table.add(line)) {\n                this.fillTable(table);\n                return true;\n            }\n        }\n        return false;\n    }\n    margeHorizontalLines(sameYLines) {\n        const result = [];\n        sameYLines.sort((l1, l2)=>l1.from.x - l2.from.x);\n        const sameY = sameYLines[0]?.from.y;\n        if (sameY === void 0) return result;\n        let minX = Number.MAX_SAFE_INTEGER;\n        let maxX = Number.MIN_SAFE_INTEGER;\n        for (const line of sameYLines){\n            if (line.from.x - maxX < Shape.tolerance) {\n                if (line.from.x < minX) {\n                    minX = line.from.x;\n                }\n                if (line.to.x > maxX) {\n                    maxX = line.to.x;\n                }\n            } else {\n                if (maxX > minX) {\n                    result.push(new Line(new Point(minX, sameY), new Point(maxX, sameY)));\n                }\n                minX = line.from.x;\n                maxX = line.to.x;\n            }\n        }\n        const last = result[result.length - 1];\n        if (last) {\n            if (last.from.x !== minX && last.to.x !== maxX) {\n                result.push(new Line(new Point(minX, sameY), new Point(maxX, sameY)));\n            }\n        } else {\n            result.push(new Line(new Point(minX, sameY), new Point(maxX, sameY)));\n        }\n        return result;\n    }\n    margeVerticalLines(sameXLines) {\n        const result = [];\n        sameXLines.sort((l1, l2)=>l1.from.y - l2.from.y);\n        const sameX = sameXLines[0]?.from.x;\n        if (sameX === void 0) return result;\n        let minY = Number.MAX_SAFE_INTEGER;\n        let maxY = Number.MIN_SAFE_INTEGER;\n        for (const line of sameXLines){\n            if (line.from.y - maxY < Shape.tolerance) {\n                if (line.from.y < minY) {\n                    minY = line.from.y;\n                }\n                if (line.to.y > maxY) {\n                    maxY = line.to.y;\n                }\n            } else {\n                if (maxY > minY) {\n                    result.push(new Line(new Point(sameX, minY), new Point(sameX, maxY)));\n                }\n                minY = line.from.y;\n                maxY = line.to.y;\n            }\n        }\n        const last = result[result.length - 1];\n        if (last) {\n            if (last.from.y !== minY && last.to.y !== maxY) {\n                result.push(new Line(new Point(sameX, minY), new Point(sameX, maxY)));\n            }\n        } else {\n            result.push(new Line(new Point(sameX, minY), new Point(sameX, maxY)));\n        }\n        return result;\n    }\n    constructor(){\n        this.hLines = [];\n        this.vLines = [];\n    }\n}\nclass Rectangle extends Shape {\n    constructor(from, width, height){\n        super();\n        this.from = from;\n        this.width = width;\n        this.height = height;\n    }\n    get to() {\n        return new Point(this.from.x + this.width, this.from.y + this.height);\n    }\n    getLines() {\n        const to = this.to;\n        const lines = [\n            new Line(this.from, new Point(to.x, this.from.y)),\n            new Line(this.from, new Point(this.from.x, to.y)),\n            new Line(new Point(to.x, this.from.y), to),\n            new Line(new Point(this.from.x, to.y), to)\n        ];\n        return lines.filter((l)=>l.valid);\n    }\n    transform(matrix) {\n        const p1 = Shape.applyTransform([\n            this.from.x,\n            this.from.y\n        ], matrix);\n        const p2 = Shape.applyTransform([\n            this.from.x + this.width,\n            this.from.y + this.height\n        ], matrix);\n        const x = Math.min(p1[0], p2[0]);\n        const y = Math.min(p1[1], p2[1]);\n        const width = Math.abs(p1[0] - p2[0]);\n        const height = Math.abs(p1[1] - p2[1]);\n        this.from = new Point(x, y);\n        this.width = width;\n        this.height = height;\n        return this;\n    }\n}\nasync function getHeader(url, check = false) {\n    try {\n        const fetch2 = globalThis.fetch;\n        if (typeof fetch2 === \"function\") {\n            const headResp = await fetch2(url, {\n                method: \"HEAD\"\n            });\n            const headersObj = {};\n            headResp.headers.forEach((v, k)=>{\n                headersObj[k] = v;\n            });\n            const size = headResp.headers.get(\"content-length\") ? parseInt(headResp.headers.get(\"content-length\"), 10) : void 0;\n            let isPdf;\n            if (check) {\n                const rangeResp = await fetch2(url, {\n                    method: \"GET\",\n                    headers: {\n                        Range: \"bytes=0-4\"\n                    }\n                });\n                if (rangeResp.ok) {\n                    const buf = new Uint8Array(await rangeResp.arrayBuffer());\n                    const headerStr = Array.from(buf).map((b)=>String.fromCharCode(b)).join(\"\");\n                    isPdf = headerStr.startsWith(\"%PDF\");\n                } else {\n                    isPdf = false;\n                }\n            }\n            return {\n                ok: headResp.ok,\n                status: headResp.status,\n                size,\n                isPdf,\n                headers: headersObj\n            };\n        }\n        throw new Error(\"Fetch API not available\");\n    } catch (error) {\n        return {\n            ok: false,\n            status: void 0,\n            size: void 0,\n            isPdf: false,\n            headers: {},\n            error: new Error(String(error))\n        };\n    }\n}\nclass ImageResult {\n    getPageImage(num, name) {\n        for (const pageData of this.pages){\n            if (pageData.pageNumber === num) {\n                for (const img of pageData.images){\n                    if (img.name === name) {\n                        return img;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    constructor(total){\n        this.pages = [];\n        this.total = 0;\n        this.total = total;\n    }\n}\nconst XMP_DATE_PROPERTIES = [\n    \"xmp:createdate\",\n    \"xmp:modifydate\",\n    \"xmp:metadatadate\",\n    \"xap:createdate\",\n    \"xap:modifydate\",\n    \"xap:metadatadate\"\n];\nclass InfoResult {\n    /**\n   * Collects dates from different sources (Info dictionary and XMP/XAP metadata)\n   * and returns them as a DateNode where available. This helps callers compare\n   * and choose the most relevant timestamp (for example a creation date vs XMP date).\n   */ getDateNode() {\n        const result = {};\n        const CreationDate = this.info?.CreationDate;\n        if (CreationDate) {\n            result.CreationDate = PDFDateString.toDateObject(CreationDate);\n        }\n        const ModDate = this.info?.ModDate;\n        if (ModDate) {\n            result.ModDate = PDFDateString.toDateObject(ModDate);\n        }\n        if (!this.metadata) {\n            return result;\n        }\n        for (const prop of XMP_DATE_PROPERTIES){\n            const value1 = this.metadata?.get(prop);\n            const date = this.parseISODateString(value1);\n            switch(prop){\n                case XMP_DATE_PROPERTIES[0]:\n                    result.XmpCreateDate = date;\n                    break;\n                case XMP_DATE_PROPERTIES[1]:\n                    result.XmpModifyDate = date;\n                    break;\n                case XMP_DATE_PROPERTIES[2]:\n                    result.XmpMetadataDate = date;\n                    break;\n                case XMP_DATE_PROPERTIES[3]:\n                    result.XapCreateDate = date;\n                    break;\n                case XMP_DATE_PROPERTIES[4]:\n                    result.XapModifyDate = date;\n                    break;\n                case XMP_DATE_PROPERTIES[5]:\n                    result.XapMetadataDate = date;\n                    break;\n            }\n        }\n        return result;\n    }\n    /**\n   * Try to parse an ISO-8601 date string from XMP/XAP metadata. If the\n   * value is falsy or cannot be parsed, undefined is returned to indicate\n   * absence or unparsable input.\n   */ parseISODateString(isoDateString) {\n        if (!isoDateString) return void 0;\n        const parsedDate = Date.parse(isoDateString);\n        if (!Number.isNaN(parsedDate)) {\n            return new Date(parsedDate);\n        }\n        return void 0;\n    }\n    constructor(total){\n        // Results with per-page hyperlink extraction. Empty array by default.\n        this.pages = [];\n        this.total = total;\n    }\n}\nfunction setDefaultParseParameters(params) {\n    params.lineThreshold = params?.lineThreshold ?? 4.6;\n    params.cellThreshold = params?.cellThreshold ?? 7;\n    params.cellSeparator = params?.cellSeparator ?? \"\t\";\n    params.lineEnforce = params?.lineEnforce ?? true;\n    params.pageJoiner = params?.pageJoiner ?? \"\\n-- page_number of total_number --\";\n    params.imageThreshold = params?.imageThreshold ?? 80;\n    params.imageDataUrl = params?.imageDataUrl ?? true;\n    params.imageBuffer = params?.imageBuffer ?? true;\n    params.scale = params?.scale ?? 1;\n    return params;\n}\nvar PathGeometry = /* @__PURE__ */ ((PathGeometry2)=>{\n    PathGeometry2[PathGeometry2[\"undefined\"] = 0] = \"undefined\";\n    PathGeometry2[PathGeometry2[\"hline\"] = 1] = \"hline\";\n    PathGeometry2[PathGeometry2[\"vline\"] = 2] = \"vline\";\n    PathGeometry2[PathGeometry2[\"rectangle\"] = 3] = \"rectangle\";\n    return PathGeometry2;\n})(PathGeometry || {});\nclass ScreenshotResult {\n    constructor(total){\n        this.pages = [];\n        this.total = 0;\n        this.total = total;\n    }\n}\nclass TableResult {\n    constructor(total){\n        this.pages = [];\n        this.mergedTables = [];\n        this.total = 0;\n        this.total = total;\n    }\n}\nclass TextResult {\n    getPageText(num) {\n        for (const pageData of this.pages){\n            if (pageData.num === num) return pageData.text;\n        }\n        return \"\";\n    }\n    constructor(total){\n        this.pages = [];\n        this.text = \"\";\n        this.total = 0;\n        this.total = total;\n    }\n}\nclass PDFParse {\n    /**\n   * Create a new parser with `DocumentInitParameters`.\n   * Converts Node.js `Buffer` data to `Uint8Array` automatically and ensures a default verbosity level.\n   * @param options Initialization parameters.\n   */ constructor(options){\n        this.progress = {\n            loaded: -1,\n            total: 0\n        };\n        if (options.verbosity === void 0) {\n            options.verbosity = VerbosityLevel.ERRORS;\n        }\n        if (typeof Buffer !== \"undefined\" && options.data instanceof Buffer) {\n            options.data = new Uint8Array(options.data);\n        }\n        this.options = options;\n    }\n    async destroy() {\n        if (this.doc) {\n            await this.doc.destroy();\n            this.doc = void 0;\n        }\n    }\n    // biome-ignore-start lint/suspicious/noExplicitAny: unsupported underline type\n    static get isNodeJS() {\n        const isNodeJS2 = typeof process === \"object\" && `${process}` === \"[object process]\" && !process.versions.nw && !(process.versions.electron && typeof process.type !== \"undefined\" && process.type !== \"browser\");\n        return isNodeJS2;\n    }\n    static setWorker(workerSrc) {\n        if (typeof globalThis.pdfjs === \"undefined\") {\n            globalThis.pdfjs = pdfjs;\n        }\n        if (GlobalWorkerOptions === null) return \"\";\n        if (workerSrc !== void 0) {\n            GlobalWorkerOptions.workerSrc = workerSrc;\n            return GlobalWorkerOptions.workerSrc;\n        }\n        return GlobalWorkerOptions.workerSrc;\n    }\n    // biome-ignore-end lint/suspicious/noExplicitAny: unsupported underline type\n    /**\n   * Perform an HTTP HEAD request to retrieve the file size and verify existence;\n   * when `check` is true, fetch a small range and inspect the magic number to confirm the URL points to a valid PDF.\n   * @param check When `true`, download a small byte range to validate the file signature.\n   * Default: `false`.\n   */ async getHeader(check = false) {\n        if (!this.options.url) {\n            throw new Error(\"getHeader: options.url is not set\");\n        }\n        return await getHeader(this.options.url, check);\n    }\n    /**\n   * Load document-level metadata (info, outline, permissions, page labels) and optionally gather per-page link details.\n   * @param params Parse options; set `parsePageInfo` to collect per-page metadata described in `ParseParameters`.\n   * @returns Aggregated document metadata in an `InfoResult`.\n   */ async getInfo(params = {}) {\n        const doc = await this.load();\n        const result = new InfoResult(doc.numPages);\n        const { info: info2, metadata } = await doc.getMetadata();\n        result.info = info2;\n        result.metadata = metadata;\n        result.fingerprints = doc.fingerprints;\n        result.outline = await doc.getOutline();\n        result.permission = await doc.getPermissions();\n        const pageLabels = await doc.getPageLabels();\n        if (params.parsePageInfo) {\n            for(let i = 1; i <= result.total; i++){\n                if (this.shouldParse(i, result.total, params)) {\n                    const page = await doc.getPage(i);\n                    const pageLinkResult = await this.getPageLinks(page);\n                    pageLinkResult.pageLabel = pageLabels?.[page.pageNumber];\n                    result.pages.push(pageLinkResult);\n                    page.cleanup();\n                }\n            }\n        }\n        return result;\n    }\n    async getPageLinks(page) {\n        const viewport = page.getViewport({\n            scale: 1\n        });\n        const result = {\n            pageNumber: page.pageNumber,\n            links: [],\n            width: viewport.width,\n            height: viewport.height\n        };\n        const annotations = await page.getAnnotations({\n            intent: \"display\"\n        }) || [];\n        for (const i of annotations){\n            if (i.subtype !== \"Link\") continue;\n            const url = i.url ?? i.unsafeUrl;\n            if (!url) continue;\n            const text = i.overlaidText || \"\";\n            result.links.push({\n                url,\n                text\n            });\n        }\n        return result;\n    }\n    /**\n   * Extract plain text for each requested page, optionally enriching hyperlinks and enforcing line or cell separators.\n   * @param params Parse options controlling pagination, link handling, and line/cell thresholds.\n   * @returns A `TextResult` containing page-wise text and a concatenated document string.\n   */ async getText(params = {}) {\n        const doc = await this.load();\n        const result = new TextResult(doc.numPages);\n        for(let i = 1; i <= result.total; i++){\n            if (this.shouldParse(i, result.total, params)) {\n                const page = await doc.getPage(i);\n                const text = await this.getPageText(page, params, result.total);\n                result.pages.push({\n                    text,\n                    num: i\n                });\n                page.cleanup();\n            }\n        }\n        for (const page of result.pages){\n            result.text += `${page.text}\n\n`;\n        }\n        return result;\n    }\n    async load() {\n        if (this.doc === void 0) {\n            const loadingTask = getDocument(this.options);\n            loadingTask.onProgress = (progress)=>{\n                this.progress = progress;\n            };\n            this.doc = await loadingTask.promise;\n        }\n        return this.doc;\n    }\n    shouldParse(currentPage, totalPage, params) {\n        params.partial = params?.partial ?? [];\n        params.first = params?.first ?? 0;\n        params.last = params?.last ?? 0;\n        if (params.partial.length > 0) {\n            if (params.partial.includes(currentPage)) {\n                return true;\n            }\n            return false;\n        }\n        if (params.first > 0 && params.last > 0) {\n            if (currentPage >= params.first && currentPage <= params.last) {\n                return true;\n            }\n            return false;\n        }\n        if (params.first > 0) {\n            if (currentPage <= params.first) {\n                return true;\n            }\n            return false;\n        }\n        if (params.last > 0) {\n            if (currentPage > totalPage - params.last) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    }\n    async getPageText(page, parseParams, total) {\n        const viewport = page.getViewport({\n            scale: 1\n        });\n        const params = setDefaultParseParameters(parseParams);\n        const textContent = await page.getTextContent({\n            includeMarkedContent: !!params.includeMarkedContent,\n            disableNormalization: !!params.disableNormalization\n        });\n        let links = /* @__PURE__ */ new Map();\n        if (params.parseHyperlinks) {\n            links = await this.getHyperlinks(page, viewport);\n        }\n        const strBuf = [];\n        let lastX;\n        let lastY;\n        for (const item of textContent.items){\n            if (!(\"str\" in item)) continue;\n            const tm = item.transform ?? item.transform;\n            const [x, y] = viewport.convertToViewportPoint(tm[4], tm[5]);\n            if (params.parseHyperlinks) {\n                const posArr = links.get(item.str) || [];\n                const hit = posArr.find((l)=>x >= l.rect.left && x <= l.rect.right && y >= l.rect.top && y <= l.rect.bottom);\n                if (hit) {\n                    item.str = `[${item.str}](${hit.url})`;\n                }\n            }\n            if (params.lineEnforce) {\n                if (lastY !== void 0 && Math.abs(lastY - y) > params.lineThreshold) {\n                    const lastItem = strBuf.length ? strBuf[strBuf.length - 1] : void 0;\n                    const isCurrentItemHasNewLine = item.str.startsWith(\"\\n\") || item.str.trim() === \"\" && item.hasEOL;\n                    if (lastItem?.endsWith(\"\\n\") === false && !isCurrentItemHasNewLine) {\n                        strBuf.push(\"\\n\");\n                    }\n                }\n            }\n            if (params.cellSeparator) {\n                if (lastY !== void 0 && Math.abs(lastY - y) < params.lineThreshold) {\n                    if (lastX !== void 0 && Math.abs(lastX - x) > params.cellThreshold) {\n                        item.str = `${params.cellSeparator}${item.str}`;\n                    }\n                }\n            }\n            strBuf.push(item.str);\n            lastX = x + item.width;\n            lastY = y;\n            if (item.hasEOL) {\n                strBuf.push(\"\\n\");\n            }\n        }\n        if (params.pageJoiner) {\n            let pageNumber = params.pageJoiner.replace(\"page_number\", `${page.pageNumber}`);\n            pageNumber = pageNumber.replace(\"total_number\", `${total}`);\n            strBuf.push(pageNumber);\n        }\n        if (params.itemJoiner) {\n            return strBuf.join(params.itemJoiner);\n        }\n        return strBuf.join(\"\");\n    }\n    async getHyperlinks(page, viewport) {\n        const result = /* @__PURE__ */ new Map();\n        const annotations = await page.getAnnotations({\n            intent: \"display\"\n        }) || [];\n        for (const i of annotations){\n            if (i.subtype !== \"Link\") continue;\n            const url = i.url ?? i.unsafeUrl;\n            if (!url) continue;\n            const text = i.overlaidText;\n            if (!text) continue;\n            const rectVp = viewport.convertToViewportRectangle(i.rect);\n            const left = Math.min(rectVp[0], rectVp[2]) - 0.5;\n            const top = Math.min(rectVp[1], rectVp[3]) - 0.5;\n            const right = Math.max(rectVp[0], rectVp[2]) + 0.5;\n            const bottom = Math.max(rectVp[1], rectVp[3]) + 0.5;\n            const pos = {\n                rect: {\n                    left,\n                    top,\n                    right,\n                    bottom\n                },\n                url,\n                text,\n                used: false\n            };\n            const el = result.get(text);\n            if (el) {\n                el.push(pos);\n            } else {\n                result.set(text, [\n                    pos\n                ]);\n            }\n        }\n        return result;\n    }\n    /**\n   * Extract embedded images from requested pages.\n   *\n   * Behavior notes:\n   * - Pages are selected according to ParseParameters (partial, first, last).\n   * - Images smaller than `params.imageThreshold` (width OR height) are skipped.\n   * - Returned ImageResult contains per-page PageImages; each image entry includes:\n   *     - data: Uint8Array (present when params.imageBuffer === true)\n   *     - dataUrl: string (present when params.imageDataUrl === true)\n   *     - width, height, kind, name\n   * - Works in both Node.js (canvas.toBuffer) and browser (canvas.toDataURL) environments.\n   *\n   * @param params ParseParameters controlling page selection, thresholds and output format.\n   * @returns Promise<ImageResult> with extracted images grouped by page.\n   */ async getImage(params = {}) {\n        const doc = await this.load();\n        const result = new ImageResult(doc.numPages);\n        setDefaultParseParameters(params);\n        for(let i = 1; i <= result.total; i++){\n            if (this.shouldParse(i, result.total, params)) {\n                const page = await doc.getPage(i);\n                const ops = await page.getOperatorList();\n                const pageImages = {\n                    pageNumber: i,\n                    images: []\n                };\n                result.pages.push(pageImages);\n                for(let j = 0; j < ops.fnArray.length; j++){\n                    if (ops.fnArray[j] === OPS.paintInlineImageXObject || ops.fnArray[j] === OPS.paintImageXObject) {\n                        const name = ops.argsArray[j][0];\n                        const isCommon = page.commonObjs.has(name);\n                        const imgPromise = isCommon ? this.resolveEmbeddedImage(page.commonObjs, name) : this.resolveEmbeddedImage(page.objs, name);\n                        const { width, height, kind, data } = await imgPromise;\n                        if (params.imageThreshold) {\n                            if (params.imageThreshold >= width || params.imageThreshold >= height) {\n                                continue;\n                            }\n                        }\n                        const canvasFactory = doc.canvasFactory;\n                        const canvasAndContext = canvasFactory.create(width, height);\n                        const context = canvasAndContext.context;\n                        let imgData = null;\n                        if (kind === util_ImageKind.RGBA_32BPP) {\n                            imgData = context.createImageData(width, height);\n                            imgData.data.set(data);\n                        } else {\n                            imgData = context.createImageData(width, height);\n                            this.convertToRGBA({\n                                src: data,\n                                dest: new Uint32Array(imgData.data.buffer),\n                                width,\n                                height,\n                                kind\n                            });\n                        }\n                        context.putImageData(imgData, 0, 0);\n                        let buffer = new Uint8Array();\n                        let dataUrl = \"\";\n                        if (typeof canvasAndContext.canvas.toBuffer === \"function\") {\n                            let nodeBuffer;\n                            if (params.imageBuffer) {\n                                nodeBuffer = canvasAndContext.canvas.toBuffer(\"image/png\");\n                                buffer = new Uint8Array(nodeBuffer);\n                            }\n                            if (params.imageDataUrl) {\n                                if (nodeBuffer) {\n                                    dataUrl = `data:image/png;base64,${nodeBuffer.toString(\"base64\")}`;\n                                } else {\n                                    nodeBuffer = canvasAndContext.canvas.toBuffer(\"image/png\");\n                                    buffer = new Uint8Array(nodeBuffer);\n                                    dataUrl = `data:image/png;base64,${nodeBuffer.toString(\"base64\")}`;\n                                }\n                            }\n                        } else {\n                            if (params.imageBuffer) {\n                                const imageData = canvasAndContext.context.getImageData(0, 0, canvasAndContext.canvas.width, canvasAndContext.canvas.height);\n                                buffer = new Uint8Array(imageData.data);\n                            }\n                            if (params.imageDataUrl) {\n                                dataUrl = canvasAndContext.canvas.toDataURL(\"image/png\");\n                            }\n                        }\n                        pageImages.images.push({\n                            data: buffer,\n                            dataUrl,\n                            name,\n                            height,\n                            width,\n                            kind\n                        });\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    convertToRGBA({ src, dest, width, height, kind }) {\n        if (kind === util_ImageKind.RGB_24BPP) {\n            for(let i = 0, j = 0; i < src.length; i += 3, j++){\n                const r = src[i];\n                const g = src[i + 1];\n                const b = src[i + 2];\n                dest[j] = 255 << 24 | b << 16 | g << 8 | r;\n            }\n        } else if (kind === util_ImageKind.GRAYSCALE_1BPP) {\n            let pixelIndex = 0;\n            for(let i = 0; i < src.length; i++){\n                const byte = src[i];\n                for(let bit = 7; bit >= 0; bit--){\n                    if (pixelIndex >= width * height) break;\n                    const isWhite = (byte >> bit & 1) === 1;\n                    const gray = isWhite ? 255 : 0;\n                    dest[pixelIndex++] = 255 << 24 | gray << 16 | gray << 8 | gray;\n                }\n            }\n        } else if (kind === void 0 || kind === null) {\n            const bytesPerPixel = src.length / (width * height);\n            if (Math.abs(bytesPerPixel - 3) < 0.1) {\n                for(let i = 0, j = 0; i < src.length; i += 3, j++){\n                    const r = src[i];\n                    const g = src[i + 1];\n                    const b = src[i + 2];\n                    dest[j] = 255 << 24 | b << 16 | g << 8 | r;\n                }\n            } else if (Math.abs(bytesPerPixel - 4) < 0.1) {\n                for(let i = 0, j = 0; i < src.length; i += 4, j++){\n                    const r = src[i];\n                    const g = src[i + 1];\n                    const b = src[i + 2];\n                    const a = src[i + 3];\n                    dest[j] = a << 24 | b << 16 | g << 8 | r;\n                }\n            } else if (Math.abs(bytesPerPixel - 1) < 0.1) {\n                for(let i = 0; i < src.length; i++){\n                    const gray = src[i];\n                    dest[i] = 255 << 24 | gray << 16 | gray << 8 | gray;\n                }\n            } else {\n                throw new Error(`convertToRGBA: Cannot infer image format. kind: ${kind}, bytesPerPixel: ${bytesPerPixel}, width: ${width}, height: ${height}, dataLength: ${src.length}`);\n            }\n        } else {\n            throw new Error(`convertToRGBA: Unsupported image kind: ${kind}. Available kinds: GRAYSCALE_1BPP=${util_ImageKind.GRAYSCALE_1BPP}, RGB_24BPP=${util_ImageKind.RGB_24BPP}, RGBA_32BPP=${util_ImageKind.RGBA_32BPP}`);\n        }\n    }\n    resolveEmbeddedImage(pdfObjects, name) {\n        return new Promise((resolve, reject)=>{\n            pdfObjects.get(name, (imgData)=>{\n                if (imgData) {\n                    let dataBuff;\n                    if (imgData.data instanceof Uint8Array) {\n                        dataBuff = imgData.data;\n                    } else if (imgData.data instanceof Uint8ClampedArray) {\n                        dataBuff = new Uint8Array(imgData.data);\n                    } else if (imgData.data?.buffer) {\n                        dataBuff = new Uint8Array(imgData.data.buffer);\n                    } else if (imgData.bitmap) {\n                        const canvasFactory = this.doc.canvasFactory;\n                        const canvasAndContext = canvasFactory.create(imgData.bitmap.width, imgData.bitmap.height);\n                        canvasAndContext.context.drawImage(imgData.bitmap, 0, 0);\n                        const imageData = canvasAndContext.context.getImageData(0, 0, imgData.bitmap.width, imgData.bitmap.height);\n                        dataBuff = new Uint8Array(imageData.data.buffer);\n                    } else if (ArrayBuffer.isView(imgData.data)) {\n                        dataBuff = new Uint8Array(imgData.data.buffer, imgData.data.byteOffset, imgData.data.byteLength);\n                    }\n                    if (!dataBuff) {\n                        reject(new Error(`Image object ${name}: data field is empty or invalid. Available fields: ${Object.keys(imgData).join(\", \")}`));\n                        return;\n                    }\n                    if (dataBuff.length === 0) {\n                        reject(new Error(`Image object ${name}: data buffer is empty (length: 0)`));\n                        return;\n                    }\n                    resolve({\n                        width: imgData.width,\n                        height: imgData.height,\n                        kind: imgData.kind,\n                        data: dataBuff\n                    });\n                } else {\n                    reject(new Error(`Image object ${name} not found`));\n                }\n            });\n        });\n    }\n    /**\n   * Render pages to raster screenshots.\n   *\n   * Behavior notes:\n   * - Pages are selected according to ParseParameters (partial, first, last).\n   * - Use params.scale for zoom; if params.desiredWidth is specified it takes precedence.\n   * - Each ScreenshotResult page contains:\n   *     - data: Uint8Array (when params.imageBuffer === true)\n   *     - dataUrl: string (when params.imageDataUrl === true)\n   *     - pageNumber, width, height, scale\n   * - Works in both Node.js (canvas.toBuffer) and browser (canvas.toDataURL) environments.\n   *\n   * @param parseParams ParseParameters controlling page selection and render options.\n   * @returns Promise<ScreenshotResult> with rendered page images.\n   */ async getScreenshot(parseParams = {}) {\n        const params = setDefaultParseParameters(parseParams);\n        const doc = await this.load();\n        const result = new ScreenshotResult(doc.numPages);\n        if (this.doc === void 0) {\n            throw new Error(\"PDF document not loaded\");\n        }\n        for(let i = 1; i <= result.total; i++){\n            if (this.shouldParse(i, result.total, params)) {\n                const page = await this.doc.getPage(i);\n                let viewport = page.getViewport({\n                    scale: params.scale\n                });\n                if (params.desiredWidth) {\n                    viewport = page.getViewport({\n                        scale: 1\n                    });\n                    const scale = params.desiredWidth / viewport.width;\n                    viewport = page.getViewport({\n                        scale\n                    });\n                }\n                const canvasFactory = this.doc.canvasFactory;\n                const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n                const renderContext = {\n                    canvasContext: canvasAndContext.context,\n                    viewport,\n                    canvas: canvasAndContext.canvas\n                };\n                const renderTask = page.render(renderContext);\n                await renderTask.promise;\n                let data = new Uint8Array();\n                let dataUrl = \"\";\n                if (typeof canvasAndContext.canvas.toBuffer === \"function\") {\n                    let nodeBuffer;\n                    if (params.imageBuffer) {\n                        nodeBuffer = canvasAndContext.canvas.toBuffer(\"image/png\");\n                        data = new Uint8Array(nodeBuffer);\n                    }\n                    if (params.imageDataUrl) {\n                        if (nodeBuffer) {\n                            dataUrl = `data:image/png;base64,${nodeBuffer.toString(\"base64\")}`;\n                        } else {\n                            nodeBuffer = canvasAndContext.canvas.toBuffer(\"image/png\");\n                            data = new Uint8Array(nodeBuffer);\n                            dataUrl = `data:image/png;base64,${nodeBuffer.toString(\"base64\")}`;\n                        }\n                    }\n                } else {\n                    if (params.imageBuffer) {\n                        const imageData = canvasAndContext.context.getImageData(0, 0, canvasAndContext.canvas.width, canvasAndContext.canvas.height);\n                        data = new Uint8Array(imageData.data);\n                    }\n                    if (params.imageDataUrl) {\n                        dataUrl = canvasAndContext.canvas.toDataURL(\"image/png\");\n                    }\n                }\n                result.pages.push({\n                    data,\n                    dataUrl,\n                    pageNumber: i,\n                    width: viewport.width,\n                    height: viewport.height,\n                    scale: viewport.scale\n                });\n                page.cleanup();\n            }\n        }\n        return result;\n    }\n    /**\n   * Detect and extract tables from pages by analysing vector drawing operators, then populate cells with text.\n   *\n   * Behavior notes:\n   * - Scans operator lists for rectangles/lines that form table grids (uses PathGeometry and LineStore).\n   * - Normalizes detected geometry and matches positioned text to table cells.\n   * - Honors ParseParameters for page selection.\n   *\n   * @param params ParseParameters controlling which pages to analyse (partial/first/last).\n   * @returns Promise<TableResult> containing discovered tables per page.\n   */ async getTable(params = {}) {\n        const doc = await this.load();\n        const result = new TableResult(doc.numPages);\n        if (this.doc === void 0) {\n            throw new Error(\"PDF document not loaded\");\n        }\n        for(let i = 1; i <= result.total; i++){\n            if (this.shouldParse(i, result.total, params)) {\n                const page = await this.doc.getPage(i);\n                const store = await this.getPageTables(page);\n                store.normalize();\n                const tableDataArr = store.getTableData();\n                await this.fillPageTables(page, tableDataArr);\n                for (const table of tableDataArr){\n                    const pageTableResult = {\n                        num: i,\n                        tables: table.toArray()\n                    };\n                    result.pages.push(pageTableResult);\n                }\n                page.cleanup();\n            }\n        }\n        return result;\n    }\n    getPathGeometry(mm) {\n        const width = mm[2] - mm[0];\n        const height = mm[3] - mm[1];\n        if (mm[0] === Infinity) {\n            return PathGeometry.undefined;\n        }\n        if (width > 5 && height > 5) {\n            return PathGeometry.rectangle;\n        } else if (width > 5 && height === 0) {\n            return PathGeometry.hline;\n        } else if (width === 0 && height > 5) {\n            return PathGeometry.vline;\n        }\n        return PathGeometry.undefined;\n    }\n    async getPageTables(page) {\n        const lineStore = new LineStore();\n        const viewport = page.getViewport({\n            scale: 1\n        });\n        let transformMatrix = [\n            1,\n            0,\n            0,\n            1,\n            0,\n            0\n        ];\n        const transformStack = [];\n        const opList = await page.getOperatorList();\n        for(let i = 0; i < opList.fnArray.length; i++){\n            const fn = opList.fnArray[i];\n            const args = opList.argsArray[i];\n            const op = args?.[0] ?? 0;\n            const mm = args?.[2] ?? [\n                Infinity,\n                Infinity,\n                -Infinity,\n                -Infinity\n            ];\n            if (fn === OPS.constructPath) {\n                if (op === OPS.fill) ;\n                if (op !== OPS.stroke) {\n                    continue;\n                }\n                const pg = this.getPathGeometry(mm);\n                if (pg === PathGeometry.rectangle) {\n                    const rect = new Rectangle(new Point(mm[0], mm[1]), mm[2] - mm[0], mm[3] - mm[1]);\n                    rect.transform(transformMatrix);\n                    rect.transform(viewport.transform);\n                    lineStore.addRectangle(rect);\n                } else if (pg === PathGeometry.hline || pg === PathGeometry.vline) {\n                    const from = new Point(mm[0], mm[1]);\n                    const to = new Point(mm[2], mm[3]);\n                    const line = new Line(from, to);\n                    line.transform(transformMatrix);\n                    line.transform(viewport.transform);\n                    lineStore.add(line);\n                } else ;\n            } else if (fn === OPS.setLineWidth) ;\n            else if (fn === OPS.save) {\n                transformStack.push(transformMatrix);\n            } else if (fn === OPS.restore) {\n                const restoredMatrix = transformStack.pop();\n                if (restoredMatrix) {\n                    transformMatrix = restoredMatrix;\n                }\n            } else if (fn === OPS.transform) {\n                transformMatrix = Util.transform(transformMatrix, args);\n            }\n        }\n        return lineStore;\n    }\n    // private async getPageGeometry(page: PDFPageProxy): Promise<LineStore> {\n    // \tconst lineStore: LineStore = new LineStore();\n    // \tconst opList = await page.getOperatorList();\n    // \tconst viewport = page.getViewport({ scale: 1 });\n    // \tlet transformMatrix = [1, 0, 0, 1, 0, 0];\n    // \tconst transformStack: Array<Array<number>> = [];\n    // \tlet current_x: number = 0;\n    // \tlet current_y: number = 0;\n    // \tfor (let j = 0; j < opList.fnArray.length; j++) {\n    // \t\tconst fn = opList.fnArray[j];\n    // \t\tconst args = opList.argsArray[j];\n    // \t\tif (fn === pdfjs.OPS.constructPath) {\n    // \t\t\twhile (args[0].length) {\n    // \t\t\t\tconst op = args[0].shift();\n    // \t\t\t\tconst combinedMatrix = pdfjs.Util.transform(viewport.transform, transformMatrix);\n    // \t\t\t\tif (op === pdfjs.OPS.rectangle) {\n    // \t\t\t\t\tconst x = args[1].shift();\n    // \t\t\t\t\tconst y = args[1].shift();\n    // \t\t\t\t\tconst width = args[1].shift();\n    // \t\t\t\t\tconst height = args[1].shift();\n    // \t\t\t\t\tif (Math.min(width, height) <= 2) {\n    // \t\t\t\t\t\t// TODO remove\n    // \t\t\t\t\t\tdebugger;\n    // \t\t\t\t\t}\n    // \t\t\t\t\tconst rect = new Rectangle(new Point(x, y), width, height);\n    // \t\t\t\t\trect.transform(combinedMatrix);\n    // \t\t\t\t\t//rect.transform(viewport.transform);\n    // \t\t\t\t\tlineStore.addRectangle(rect);\n    // \t\t\t\t} else if (op === pdfjs.OPS.moveTo) {\n    // \t\t\t\t\tcurrent_x = args[1].shift();\n    // \t\t\t\t\tcurrent_y = args[1].shift();\n    // \t\t\t\t} else if (op === pdfjs.OPS.lineTo) {\n    // \t\t\t\t\tconst x = args[1].shift();\n    // \t\t\t\t\tconst y = args[1].shift();\n    // \t\t\t\t\t//default trasform\n    // \t\t\t\t\tconst from = new Point(current_x, current_y);\n    // \t\t\t\t\tconst to = new Point(x, y);\n    // \t\t\t\t\tconst line = new Line(from, to);\n    // \t\t\t\t\tline.transform(combinedMatrix);\n    // \t\t\t\t\t//line.transform(viewport.transform);\n    // \t\t\t\t\t// // viewport transform\n    // \t\t\t\t\t// const _from = viewport.convertToViewportPoint(line.from.x, line.from.y)\n    // \t\t\t\t\t// const _to = viewport.convertToViewportPoint(line.to.x, line.to.y)\n    // \t\t\t\t\t//\n    // \t\t\t\t\t// const transformedLine = new Line(new Point(_from[0], _from[1]), new Point(_to[0], _to[1]))\n    // \t\t\t\t\tlineStore.add(line);\n    // \t\t\t\t\tcurrent_x = x;\n    // \t\t\t\t\tcurrent_y = y;\n    // \t\t\t\t}\n    // \t\t\t}\n    // \t\t} else if (fn === pdfjs.OPS.save) {\n    // \t\t\ttransformStack.push(transformMatrix);\n    // \t\t} else if (fn === pdfjs.OPS.restore) {\n    // \t\t\tconst restoredMatrix = transformStack.pop();\n    // \t\t\tif (restoredMatrix) {\n    // \t\t\t\ttransformMatrix = restoredMatrix;\n    // \t\t\t}\n    // \t\t} else if (fn === pdfjs.OPS.transform) {\n    // \t\t\t//transformMatrix = this.transform_fn(transformMatrix, args);\n    // \t\t\ttransformMatrix = pdfjs.Util.transform(transformMatrix, args);\n    // \t\t}\n    // \t}\n    // \treturn lineStore;\n    // }\n    async fillPageTables(page, pageTables) {\n        const viewport = page.getViewport({\n            scale: 1\n        });\n        const textContent = await page.getTextContent({\n            includeMarkedContent: false,\n            disableNormalization: false\n        });\n        for (const textItem of textContent.items){\n            if (!(\"str\" in textItem)) continue;\n            const tx = Util.transform(Util.transform(viewport.transform, textItem.transform), [\n                1,\n                0,\n                0,\n                -1,\n                0,\n                0\n            ]);\n            for (const pageTable of pageTables){\n                const cell = pageTable.findCell(tx[4], tx[5]);\n                if (cell) {\n                    cell.text.push(textItem.str);\n                    if (textItem.hasEOL) {\n                        cell.text.push(\"\\n\");\n                    }\n                    break;\n                }\n            }\n        }\n    }\n}\nexports.PDFParse = PDFParse;\nexports.VerbosityLevel = VerbosityLevel;\nexports.getHeader = getHeader; //# sourceMappingURL=index.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmLXBhcnNlL2Rpc3QvY2pzL2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGNBQWMsQ0FBQ0M7SUFDakIsTUFBTUMsVUFBVUQ7QUFDbEI7QUFDQSxJQUFJRSxnQkFBZ0IsQ0FBQ0MsS0FBS0MsUUFBUUosTUFBUUksT0FBT0MsR0FBRyxDQUFDRixRQUFRSixZQUFZLFlBQVlDO0FBQ3JGLElBQUlNLGVBQWUsQ0FBQ0gsS0FBS0MsUUFBUUcsU0FBWUwsQ0FBQUEsY0FBY0MsS0FBS0MsUUFBUSw0QkFBNEJHLFNBQVNBLE9BQU9DLElBQUksQ0FBQ0wsT0FBT0MsT0FBT0ssR0FBRyxDQUFDTixJQUFHO0FBQzlJLElBQUlPLGVBQWUsQ0FBQ1AsS0FBS0MsUUFBUU8sU0FBVVAsT0FBT0MsR0FBRyxDQUFDRixPQUFPSixZQUFZLHVEQUF1REssa0JBQWtCUSxVQUFVUixPQUFPUyxHQUFHLENBQUNWLE9BQU9DLE9BQU9VLEdBQUcsQ0FBQ1gsS0FBS1E7QUFDOUwsSUFBSUksZUFBZSxDQUFDWixLQUFLQyxRQUFRTyxRQUFPSyxTQUFZZCxDQUFBQSxjQUFjQyxLQUFLQyxRQUFRLDJCQUEyQlksU0FBU0EsT0FBT1IsSUFBSSxDQUFDTCxLQUFLUSxVQUFTUCxPQUFPVSxHQUFHLENBQUNYLEtBQUtRLFNBQVFBLE1BQUk7QUFDekssSUFBSU0sa0JBQWtCLENBQUNkLEtBQUtDLFFBQVFjLFNBQVloQixDQUFBQSxjQUFjQyxLQUFLQyxRQUFRLDBCQUEwQmMsTUFBSztBQUMxRyxJQUFJQyxtQkFBbUIsQ0FBQ2hCLEtBQUtDLFFBQVFZLFFBQVFULFNBQVk7UUFDdkQsSUFBSWEsR0FBRVQsTUFBTztZQUNYSSxhQUFhWixLQUFLQyxRQUFRTyxPQUFPSztRQUNuQztRQUNBLElBQUlJLEtBQUk7WUFDTixPQUFPZCxhQUFhSCxLQUFLQyxRQUFRRztRQUNuQztJQUNGO0FBQ0EsSUFBSWMsYUFBYUMsaUJBQWlCQyxPQUFPQyxZQUFZQyxl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aUJBQWlCLEdBQUc0dUosV0FDcEIsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWllZXdhLy4vbm9kZV9tb2R1bGVzL3BkZi1wYXJzZS9kaXN0L2Nqcy9pbmRleC5janM/ZjYwYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3R5cGVFcnJvciA9IChtc2cpID0+IHtcbiAgdGhyb3cgVHlwZUVycm9yKG1zZyk7XG59O1xudmFyIF9fYWNjZXNzQ2hlY2sgPSAob2JqLCBtZW1iZXIsIG1zZykgPT4gbWVtYmVyLmhhcyhvYmopIHx8IF9fdHlwZUVycm9yKFwiQ2Fubm90IFwiICsgbXNnKTtcbnZhciBfX3ByaXZhdGVHZXQgPSAob2JqLCBtZW1iZXIsIGdldHRlcikgPT4gKF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwicmVhZCBmcm9tIHByaXZhdGUgZmllbGRcIiksIGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiBtZW1iZXIuZ2V0KG9iaikpO1xudmFyIF9fcHJpdmF0ZUFkZCA9IChvYmosIG1lbWJlciwgdmFsdWUpID0+IG1lbWJlci5oYXMob2JqKSA/IF9fdHlwZUVycm9yKFwiQ2Fubm90IGFkZCB0aGUgc2FtZSBwcml2YXRlIG1lbWJlciBtb3JlIHRoYW4gb25jZVwiKSA6IG1lbWJlciBpbnN0YW5jZW9mIFdlYWtTZXQgPyBtZW1iZXIuYWRkKG9iaikgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xudmFyIF9fcHJpdmF0ZVNldCA9IChvYmosIG1lbWJlciwgdmFsdWUsIHNldHRlcikgPT4gKF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwid3JpdGUgdG8gcHJpdmF0ZSBmaWVsZFwiKSwgc2V0dGVyID8gc2V0dGVyLmNhbGwob2JqLCB2YWx1ZSkgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpLCB2YWx1ZSk7XG52YXIgX19wcml2YXRlTWV0aG9kID0gKG9iaiwgbWVtYmVyLCBtZXRob2QpID0+IChfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcImFjY2VzcyBwcml2YXRlIG1ldGhvZFwiKSwgbWV0aG9kKTtcbnZhciBfX3ByaXZhdGVXcmFwcGVyID0gKG9iaiwgbWVtYmVyLCBzZXR0ZXIsIGdldHRlcikgPT4gKHtcbiAgc2V0IF8odmFsdWUpIHtcbiAgICBfX3ByaXZhdGVTZXQob2JqLCBtZW1iZXIsIHZhbHVlLCBzZXR0ZXIpO1xuICB9LFxuICBnZXQgXygpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KG9iaiwgbWVtYmVyLCBnZXR0ZXIpO1xuICB9XG59KTtcbnZhciBfY2FwYWJpbGl0eSwgX21lc3NhZ2VIYW5kbGVyLCBfcG9ydCwgX3dlYldvcmtlciwgX2Zha2VXb3JrZXJJZCwgX2lzV29ya2VyRGlzYWJsZWQsIF93b3JrZXJQb3J0cywgX1BERldvcmtlcl9pbnN0YW5jZXMsIHJlc29sdmVfZm4sIGluaXRpYWxpemVGcm9tUG9ydF9mbiwgaW5pdGlhbGl6ZV9mbiwgc2V0dXBGYWtlV29ya2VyX2ZuLCBfUERGV29ya2VyX3N0YXRpYywgbWFpblRocmVhZFdvcmtlck1lc3NhZ2VIYW5kbGVyX2dldDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSk7XG52YXIgX2RvY3VtZW50Q3VycmVudFNjcmlwdCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgOiBudWxsO1xudmFyIF9fd2VicGFja19tb2R1bGVzX18gPSB7XG4gIC8qKiovXG4gIDM0OiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNDkwMSk7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbihpdCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGl0ID09IFwib2JqZWN0XCIgPyBpdCAhPT0gbnVsbCA6IGlzQ2FsbGFibGUoaXQpO1xuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA4MTogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgY2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18yKDk1NjUpO1xuICAgICAgdmFyIGFDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDkzMDYpO1xuICAgICAgdmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoODU1MSk7XG4gICAgICB2YXIgdHJ5VG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2ODIzKTtcbiAgICAgIHZhciBnZXRJdGVyYXRvck1ldGhvZCA9IF9fd2VicGFja19yZXF1aXJlX18yKDg1MSk7XG4gICAgICB2YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKGFyZ3VtZW50LCB1c2luZ0l0ZXJhdG9yKSB7XG4gICAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gZ2V0SXRlcmF0b3JNZXRob2QoYXJndW1lbnQpIDogdXNpbmdJdGVyYXRvcjtcbiAgICAgICAgaWYgKGFDYWxsYWJsZShpdGVyYXRvck1ldGhvZCkpIHJldHVybiBhbk9iamVjdChjYWxsKGl0ZXJhdG9yTWV0aG9kLCBhcmd1bWVudCkpO1xuICAgICAgICB0aHJvdyBuZXcgJFR5cGVFcnJvcih0cnlUb1N0cmluZyhhcmd1bWVudCkgKyBcIiBpcyBub3QgaXRlcmFibGVcIik7XG4gICAgICB9O1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDExNjogKFxuICAgIC8qKiovXG4gICAgKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2NTE4KTtcbiAgICAgIHZhciBjYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoOTU2NSk7XG4gICAgICB2YXIgaXRlcmF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDI2NTIpO1xuICAgICAgdmFyIGFDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDkzMDYpO1xuICAgICAgdmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoODU1MSk7XG4gICAgICB2YXIgZ2V0SXRlcmF0b3JEaXJlY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigxNzY3KTtcbiAgICAgIHZhciBpdGVyYXRvckNsb3NlID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoOTUzOSk7XG4gICAgICB2YXIgaXRlcmF0b3JIZWxwZXJXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18yKDQ1NDkpO1xuICAgICAgdmFyIGZpbmRXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciA9IGl0ZXJhdG9ySGVscGVyV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IoXCJmaW5kXCIsIFR5cGVFcnJvcik7XG4gICAgICAkKHsgdGFyZ2V0OiBcIkl0ZXJhdG9yXCIsIHByb3RvOiB0cnVlLCByZWFsOiB0cnVlLCBmb3JjZWQ6IGZpbmRXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciB9LCB7XG4gICAgICAgIGZpbmQ6IGZ1bmN0aW9uIGZpbmQocHJlZGljYXRlKSB7XG4gICAgICAgICAgYW5PYmplY3QodGhpcyk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGFDYWxsYWJsZShwcmVkaWNhdGUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpdGVyYXRvckNsb3NlKHRoaXMsIFwidGhyb3dcIiwgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZmluZFdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yKSByZXR1cm4gY2FsbChmaW5kV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IsIHRoaXMsIHByZWRpY2F0ZSk7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGdldEl0ZXJhdG9yRGlyZWN0KHRoaXMpO1xuICAgICAgICAgIHZhciBjb3VudGVyID0gMDtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0ZShyZWNvcmQsIGZ1bmN0aW9uKHZhbHVlLCBzdG9wKSB7XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBjb3VudGVyKyspKSByZXR1cm4gc3RvcCh2YWx1ZSk7XG4gICAgICAgICAgfSwgeyBJU19SRUNPUkQ6IHRydWUsIElOVEVSUlVQVEVEOiB0cnVlIH0pLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgMjgzOiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18yKDk1MDQpO1xuICAgICAgdmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoOTAzOSk7XG4gICAgICB2YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDQ5MDEpO1xuICAgICAgdmFyIGhhc093biA9IF9fd2VicGFja19yZXF1aXJlX18yKDkyOTcpO1xuICAgICAgdmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMzcyNCk7XG4gICAgICB2YXIgQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigzNTApLkNPTkZJR1VSQUJMRTtcbiAgICAgIHZhciBpbnNwZWN0U291cmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMzcwNik7XG4gICAgICB2YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDExODEpO1xuICAgICAgdmFyIGVuZm9yY2VJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5lbmZvcmNlO1xuICAgICAgdmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldDtcbiAgICAgIHZhciAkU3RyaW5nID0gU3RyaW5nO1xuICAgICAgdmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuICAgICAgdmFyIHN0cmluZ1NsaWNlID0gdW5jdXJyeVRoaXMoXCJcIi5zbGljZSk7XG4gICAgICB2YXIgcmVwbGFjZSA9IHVuY3VycnlUaGlzKFwiXCIucmVwbGFjZSk7XG4gICAgICB2YXIgam9pbiA9IHVuY3VycnlUaGlzKFtdLmpvaW4pO1xuICAgICAgdmFyIENPTkZJR1VSQUJMRV9MRU5HVEggPSBERVNDUklQVE9SUyAmJiAhZmFpbHMoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jdGlvbigpIHtcbiAgICAgICAgfSwgXCJsZW5ndGhcIiwgeyB2YWx1ZTogOCB9KS5sZW5ndGggIT09IDg7XG4gICAgICB9KTtcbiAgICAgIHZhciBURU1QTEFURSA9IFN0cmluZyhTdHJpbmcpLnNwbGl0KFwiU3RyaW5nXCIpO1xuICAgICAgdmFyIG1ha2VCdWlsdEluID0gbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24odmFsdWUsIG5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHN0cmluZ1NsaWNlKCRTdHJpbmcobmFtZSksIDAsIDcpID09PSBcIlN5bWJvbChcIikge1xuICAgICAgICAgIG5hbWUgPSBcIltcIiArIHJlcGxhY2UoJFN0cmluZyhuYW1lKSwgL15TeW1ib2xcXCgoW14pXSopXFwpLiokLywgXCIkMVwiKSArIFwiXVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZ2V0dGVyKSBuYW1lID0gXCJnZXQgXCIgKyBuYW1lO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNldHRlcikgbmFtZSA9IFwic2V0IFwiICsgbmFtZTtcbiAgICAgICAgaWYgKCFoYXNPd24odmFsdWUsIFwibmFtZVwiKSB8fCBDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSAmJiB2YWx1ZS5uYW1lICE9PSBuYW1lKSB7XG4gICAgICAgICAgaWYgKERFU0NSSVBUT1JTKSBkZWZpbmVQcm9wZXJ0eSh2YWx1ZSwgXCJuYW1lXCIsIHsgdmFsdWU6IG5hbWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgICBlbHNlIHZhbHVlLm5hbWUgPSBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmIChDT05GSUdVUkFCTEVfTEVOR1RIICYmIG9wdGlvbnMgJiYgaGFzT3duKG9wdGlvbnMsIFwiYXJpdHlcIikgJiYgdmFsdWUubGVuZ3RoICE9PSBvcHRpb25zLmFyaXR5KSB7XG4gICAgICAgICAgZGVmaW5lUHJvcGVydHkodmFsdWUsIFwibGVuZ3RoXCIsIHsgdmFsdWU6IG9wdGlvbnMuYXJpdHkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAob3B0aW9ucyAmJiBoYXNPd24ob3B0aW9ucywgXCJjb25zdHJ1Y3RvclwiKSAmJiBvcHRpb25zLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBpZiAoREVTQ1JJUFRPUlMpIGRlZmluZVByb3BlcnR5KHZhbHVlLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlLnByb3RvdHlwZSkgdmFsdWUucHJvdG90eXBlID0gdm9pZCAwO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGF0ZSA9IGVuZm9yY2VJbnRlcm5hbFN0YXRlKHZhbHVlKTtcbiAgICAgICAgaWYgKCFoYXNPd24oc3RhdGUsIFwic291cmNlXCIpKSB7XG4gICAgICAgICAgc3RhdGUuc291cmNlID0gam9pbihURU1QTEFURSwgdHlwZW9mIG5hbWUgPT0gXCJzdHJpbmdcIiA/IG5hbWUgOiBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgICAgRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gbWFrZUJ1aWx0SW4oZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBpc0NhbGxhYmxlKHRoaXMpICYmIGdldEludGVybmFsU3RhdGUodGhpcykuc291cmNlIHx8IGluc3BlY3RTb3VyY2UodGhpcyk7XG4gICAgICB9LCBcInRvU3RyaW5nXCIpO1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDM1MDogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigzNzI0KTtcbiAgICAgIHZhciBoYXNPd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig5Mjk3KTtcbiAgICAgIHZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbiAgICAgIHZhciBnZXREZXNjcmlwdG9yID0gREVTQ1JJUFRPUlMgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgICAgIHZhciBFWElTVFMgPSBoYXNPd24oRnVuY3Rpb25Qcm90b3R5cGUsIFwibmFtZVwiKTtcbiAgICAgIHZhciBQUk9QRVIgPSBFWElTVFMgJiYgKGZ1bmN0aW9uIHNvbWV0aGluZygpIHtcbiAgICAgIH0pLm5hbWUgPT09IFwic29tZXRoaW5nXCI7XG4gICAgICB2YXIgQ09ORklHVVJBQkxFID0gRVhJU1RTICYmICghREVTQ1JJUFRPUlMgfHwgREVTQ1JJUFRPUlMgJiYgZ2V0RGVzY3JpcHRvcihGdW5jdGlvblByb3RvdHlwZSwgXCJuYW1lXCIpLmNvbmZpZ3VyYWJsZSk7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSB7XG4gICAgICAgIEVYSVNUUyxcbiAgICAgICAgUFJPUEVSLFxuICAgICAgICBDT05GSUdVUkFCTEVcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgMzk3OiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciBnZXRCdWlsdEluID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNzc1MSk7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBnZXRCdWlsdEluKFwiZG9jdW1lbnRcIiwgXCJkb2N1bWVudEVsZW1lbnRcIik7XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgNDIxOiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIpID0+IHtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IHt9O1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDQ1NjogKFxuICAgIC8qKiovXG4gICAgKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2NTE4KTtcbiAgICAgIHZhciBnbG9iYWxUaGlzMiA9IF9fd2VicGFja19yZXF1aXJlX18yKDQ1NzYpO1xuICAgICAgdmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoOTUwNCk7XG4gICAgICB2YXIgYW5VaW50OEFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNDE1NCk7XG4gICAgICB2YXIgbm90RGV0YWNoZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig1MTY5KTtcbiAgICAgIHZhciBudW1iZXJUb1N0cmluZyA9IHVuY3VycnlUaGlzKDEuMS50b1N0cmluZyk7XG4gICAgICB2YXIgVWludDhBcnJheTIgPSBnbG9iYWxUaGlzMi5VaW50OEFycmF5O1xuICAgICAgdmFyIElOQ09SUkVDVF9CRUhBVklPUl9PUl9ET0VTTlRfRVhJU1RTID0gIVVpbnQ4QXJyYXkyIHx8ICFVaW50OEFycmF5Mi5wcm90b3R5cGUudG9IZXggfHwgIShmdW5jdGlvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgdGFyZ2V0ID0gbmV3IFVpbnQ4QXJyYXkyKFsyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NV0pO1xuICAgICAgICAgIHJldHVybiB0YXJnZXQudG9IZXgoKSA9PT0gXCJmZmZmZmZmZmZmZmZmZmZmXCI7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KSgpO1xuICAgICAgaWYgKFVpbnQ4QXJyYXkyKSAkKHsgdGFyZ2V0OiBcIlVpbnQ4QXJyYXlcIiwgcHJvdG86IHRydWUsIGZvcmNlZDogSU5DT1JSRUNUX0JFSEFWSU9SX09SX0RPRVNOVF9FWElTVFMgfSwge1xuICAgICAgICB0b0hleDogZnVuY3Rpb24gdG9IZXgoKSB7XG4gICAgICAgICAgYW5VaW50OEFycmF5KHRoaXMpO1xuICAgICAgICAgIG5vdERldGFjaGVkKHRoaXMuYnVmZmVyKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdGhpcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGhleCA9IG51bWJlclRvU3RyaW5nKHRoaXNbaV0sIDE2KTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBoZXgubGVuZ3RoID09PSAxID8gXCIwXCIgKyBoZXggOiBoZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDUwNzogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgY2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18yKDk1NjUpO1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24ocmVjb3JkLCBmbiwgSVRFUkFUT1JfSU5TVEVBRF9PRl9SRUNPUkQpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gSVRFUkFUT1JfSU5TVEVBRF9PRl9SRUNPUkQgPyByZWNvcmQgOiByZWNvcmQuaXRlcmF0b3I7XG4gICAgICAgIHZhciBuZXh0ID0gcmVjb3JkLm5leHQ7XG4gICAgICAgIHZhciBzdGVwLCByZXN1bHQ7XG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBjYWxsKG5leHQsIGl0ZXJhdG9yKSkuZG9uZSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZuKHN0ZXAudmFsdWUpO1xuICAgICAgICAgIGlmIChyZXN1bHQgIT09IHZvaWQgMCkgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA1MzE6IChcbiAgICAvKioqL1xuICAgICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNjUxOCk7XG4gICAgICB2YXIgY2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18yKDk1NjUpO1xuICAgICAgdmFyIGFDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDkzMDYpO1xuICAgICAgdmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoODU1MSk7XG4gICAgICB2YXIgZ2V0SXRlcmF0b3JEaXJlY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigxNzY3KTtcbiAgICAgIHZhciBnZXRJdGVyYXRvckZsYXR0ZW5hYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoODY0Nik7XG4gICAgICB2YXIgY3JlYXRlSXRlcmF0b3JQcm94eSA9IF9fd2VicGFja19yZXF1aXJlX18yKDk0NjIpO1xuICAgICAgdmFyIGl0ZXJhdG9yQ2xvc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig5NTM5KTtcbiAgICAgIHZhciBJU19QVVJFID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNjM5NSk7XG4gICAgICB2YXIgaXRlcmF0b3JIZWxwZXJUaHJvd3NPbkludmFsaWRJdGVyYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18yKDY4NCk7XG4gICAgICB2YXIgaXRlcmF0b3JIZWxwZXJXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18yKDQ1NDkpO1xuICAgICAgdmFyIEZMQVRfTUFQX1dJVEhPVVRfVEhST1dJTkdfT05fSU5WQUxJRF9JVEVSQVRPUiA9ICFJU19QVVJFICYmICFpdGVyYXRvckhlbHBlclRocm93c09uSW52YWxpZEl0ZXJhdG9yKFwiZmxhdE1hcFwiLCBmdW5jdGlvbigpIHtcbiAgICAgIH0pO1xuICAgICAgdmFyIGZsYXRNYXBXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciA9ICFJU19QVVJFICYmICFGTEFUX01BUF9XSVRIT1VUX1RIUk9XSU5HX09OX0lOVkFMSURfSVRFUkFUT1IgJiYgaXRlcmF0b3JIZWxwZXJXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvcihcImZsYXRNYXBcIiwgVHlwZUVycm9yKTtcbiAgICAgIHZhciBGT1JDRUQgPSBJU19QVVJFIHx8IEZMQVRfTUFQX1dJVEhPVVRfVEhST1dJTkdfT05fSU5WQUxJRF9JVEVSQVRPUiB8fCBmbGF0TWFwV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3I7XG4gICAgICB2YXIgSXRlcmF0b3JQcm94eSA9IGNyZWF0ZUl0ZXJhdG9yUHJveHkoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMuaXRlcmF0b3I7XG4gICAgICAgIHZhciBtYXBwZXIgPSB0aGlzLm1hcHBlcjtcbiAgICAgICAgdmFyIHJlc3VsdCwgaW5uZXI7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgaWYgKGlubmVyID0gdGhpcy5pbm5lcikgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGFuT2JqZWN0KGNhbGwoaW5uZXIubmV4dCwgaW5uZXIuaXRlcmF0b3IpKTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0LmRvbmUpIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgICAgICAgICB0aGlzLmlubmVyID0gbnVsbDtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaXRlcmF0b3JDbG9zZShpdGVyYXRvciwgXCJ0aHJvd1wiLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IGFuT2JqZWN0KGNhbGwodGhpcy5uZXh0LCBpdGVyYXRvcikpO1xuICAgICAgICAgIGlmICh0aGlzLmRvbmUgPSAhIXJlc3VsdC5kb25lKSByZXR1cm47XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBnZXRJdGVyYXRvckZsYXR0ZW5hYmxlKG1hcHBlcihyZXN1bHQudmFsdWUsIHRoaXMuY291bnRlcisrKSwgZmFsc2UpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBcInRocm93XCIsIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgJCh7IHRhcmdldDogXCJJdGVyYXRvclwiLCBwcm90bzogdHJ1ZSwgcmVhbDogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQgfSwge1xuICAgICAgICBmbGF0TWFwOiBmdW5jdGlvbiBmbGF0TWFwKG1hcHBlcikge1xuICAgICAgICAgIGFuT2JqZWN0KHRoaXMpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhQ2FsbGFibGUobWFwcGVyKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaXRlcmF0b3JDbG9zZSh0aGlzLCBcInRocm93XCIsIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZsYXRNYXBXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvcikgcmV0dXJuIGNhbGwoZmxhdE1hcFdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yLCB0aGlzLCBtYXBwZXIpO1xuICAgICAgICAgIHJldHVybiBuZXcgSXRlcmF0b3JQcm94eShnZXRJdGVyYXRvckRpcmVjdCh0aGlzKSwge1xuICAgICAgICAgICAgbWFwcGVyLFxuICAgICAgICAgICAgaW5uZXI6IG51bGxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgNjE2OiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18yKDkwMzkpO1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdGVzdCA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgfSkuYmluZCgpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHRlc3QgIT0gXCJmdW5jdGlvblwiIHx8IHRlc3QuaGFzT3duUHJvcGVydHkoXCJwcm90b3R5cGVcIik7XG4gICAgICB9KTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA2NTU6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMiwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2OTU1KTtcbiAgICAgIHZhciAkU3RyaW5nID0gU3RyaW5nO1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24oYXJndW1lbnQpIHtcbiAgICAgICAgaWYgKGNsYXNzb2YoYXJndW1lbnQpID09PSBcIlN5bWJvbFwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmdcIik7XG4gICAgICAgIHJldHVybiAkU3RyaW5nKGFyZ3VtZW50KTtcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgNjc5OiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciBpc1Byb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMTYyNSk7XG4gICAgICB2YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBQcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKGlzUHJvdG90eXBlT2YoUHJvdG90eXBlLCBpdCkpIHJldHVybiBpdDtcbiAgICAgICAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoXCJJbmNvcnJlY3QgaW52b2NhdGlvblwiKTtcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgNjg0OiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIpID0+IHtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGFyZ3VtZW50KSB7XG4gICAgICAgIHZhciBtZXRob2QgPSB0eXBlb2YgSXRlcmF0b3IgPT0gXCJmdW5jdGlvblwiICYmIEl0ZXJhdG9yLnByb3RvdHlwZVttZXRob2ROYW1lXTtcbiAgICAgICAgaWYgKG1ldGhvZCkgdHJ5IHtcbiAgICAgICAgICBtZXRob2QuY2FsbCh7IG5leHQ6IG51bGwgfSwgYXJndW1lbnQpLm5leHQoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA3NDE6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMikgPT4ge1xuICAgICAgdmFyIGNlaWwyID0gTWF0aC5jZWlsO1xuICAgICAgdmFyIGZsb29yMiA9IE1hdGguZmxvb3I7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBNYXRoLnRydW5jIHx8IGZ1bmN0aW9uIHRydW5jKHgpIHtcbiAgICAgICAgdmFyIG4gPSAreDtcbiAgICAgICAgcmV0dXJuIChuID4gMCA/IGZsb29yMiA6IGNlaWwyKShuKTtcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgNzU3OiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciBnZXRCdWlsdEluID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNzc1MSk7XG4gICAgICB2YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDQ5MDEpO1xuICAgICAgdmFyIGlzUHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigxNjI1KTtcbiAgICAgIHZhciBVU0VfU1lNQk9MX0FTX1VJRCA9IF9fd2VicGFja19yZXF1aXJlX18yKDcwNDApO1xuICAgICAgdmFyICRPYmplY3QgPSBPYmplY3Q7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBVU0VfU1lNQk9MX0FTX1VJRCA/IGZ1bmN0aW9uKGl0KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgaXQgPT0gXCJzeW1ib2xcIjtcbiAgICAgIH0gOiBmdW5jdGlvbihpdCkge1xuICAgICAgICB2YXIgJFN5bWJvbCA9IGdldEJ1aWx0SW4oXCJTeW1ib2xcIik7XG4gICAgICAgIHJldHVybiBpc0NhbGxhYmxlKCRTeW1ib2wpICYmIGlzUHJvdG90eXBlT2YoJFN5bWJvbC5wcm90b3R5cGUsICRPYmplY3QoaXQpKTtcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgODUxOiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNjk1NSk7XG4gICAgICB2YXIgZ2V0TWV0aG9kID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNTk2Nik7XG4gICAgICB2YXIgaXNOdWxsT3JVbmRlZmluZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig0MTE3KTtcbiAgICAgIHZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2MjY5KTtcbiAgICAgIHZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig4MjI3KTtcbiAgICAgIHZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbChcIml0ZXJhdG9yXCIpO1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24oaXQpIHtcbiAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChpdCkpIHJldHVybiBnZXRNZXRob2QoaXQsIElURVJBVE9SKSB8fCBnZXRNZXRob2QoaXQsIFwiQEBpdGVyYXRvclwiKSB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA5NDQ6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMikgPT4ge1xuICAgICAgdmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBhbHBoYWJldCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5hbHBoYWJldDtcbiAgICAgICAgaWYgKGFscGhhYmV0ID09PSB2b2lkIDAgfHwgYWxwaGFiZXQgPT09IFwiYmFzZTY0XCIgfHwgYWxwaGFiZXQgPT09IFwiYmFzZTY0dXJsXCIpIHJldHVybiBhbHBoYWJldCB8fCBcImJhc2U2NFwiO1xuICAgICAgICB0aHJvdyBuZXcgJFR5cGVFcnJvcihcIkluY29ycmVjdCBgYWxwaGFiZXRgIG9wdGlvblwiKTtcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgMTA3MjogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMTgyOCk7XG4gICAgICB2YXIgZW51bUJ1Z0tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig4NzI3KTtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGVudW1CdWdLZXlzKTtcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgMTEwMzogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyKSA9PiB7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IGZhbHNlLCB2YWx1ZTogZXhlYygpIH07XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IHRydWUsIHZhbHVlOiBlcnJvciB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDExMDg6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMiwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2OTU1KTtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KSB7XG4gICAgICAgIHZhciBrbGFzcyA9IGNsYXNzb2YoaXQpO1xuICAgICAgICByZXR1cm4ga2xhc3MgPT09IFwiQmlnSW50NjRBcnJheVwiIHx8IGtsYXNzID09PSBcIkJpZ1VpbnQ2NEFycmF5XCI7XG4gICAgICB9O1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDExNDg6IChcbiAgICAvKioqL1xuICAgICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNjUxOCk7XG4gICAgICB2YXIgY2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18yKDk1NjUpO1xuICAgICAgdmFyIGl0ZXJhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigyNjUyKTtcbiAgICAgIHZhciBhQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig5MzA2KTtcbiAgICAgIHZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18yKDg1NTEpO1xuICAgICAgdmFyIGdldEl0ZXJhdG9yRGlyZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMTc2Nyk7XG4gICAgICB2YXIgaXRlcmF0b3JDbG9zZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDk1MzkpO1xuICAgICAgdmFyIGl0ZXJhdG9ySGVscGVyV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig0NTQ5KTtcbiAgICAgIHZhciBldmVyeVdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yID0gaXRlcmF0b3JIZWxwZXJXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvcihcImV2ZXJ5XCIsIFR5cGVFcnJvcik7XG4gICAgICAkKHsgdGFyZ2V0OiBcIkl0ZXJhdG9yXCIsIHByb3RvOiB0cnVlLCByZWFsOiB0cnVlLCBmb3JjZWQ6IGV2ZXJ5V2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IgfSwge1xuICAgICAgICBldmVyeTogZnVuY3Rpb24gZXZlcnkocHJlZGljYXRlKSB7XG4gICAgICAgICAgYW5PYmplY3QodGhpcyk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGFDYWxsYWJsZShwcmVkaWNhdGUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpdGVyYXRvckNsb3NlKHRoaXMsIFwidGhyb3dcIiwgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXZlcnlXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvcikgcmV0dXJuIGNhbGwoZXZlcnlXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciwgdGhpcywgcHJlZGljYXRlKTtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZ2V0SXRlcmF0b3JEaXJlY3QodGhpcyk7XG4gICAgICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgICAgICAgIHJldHVybiAhaXRlcmF0ZShyZWNvcmQsIGZ1bmN0aW9uKHZhbHVlLCBzdG9wKSB7XG4gICAgICAgICAgICBpZiAoIXByZWRpY2F0ZSh2YWx1ZSwgY291bnRlcisrKSkgcmV0dXJuIHN0b3AoKTtcbiAgICAgICAgICB9LCB7IElTX1JFQ09SRDogdHJ1ZSwgSU5URVJSVVBURUQ6IHRydWUgfSkuc3RvcHBlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgMTE4MTogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgTkFUSVZFX1dFQUtfTUFQID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoODYyMik7XG4gICAgICB2YXIgZ2xvYmFsVGhpczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig0NTc2KTtcbiAgICAgIHZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18yKDM0KTtcbiAgICAgIHZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2Njk5KTtcbiAgICAgIHZhciBoYXNPd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig5Mjk3KTtcbiAgICAgIHZhciBzaGFyZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig3NjI5KTtcbiAgICAgIHZhciBzaGFyZWRLZXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2MTE5KTtcbiAgICAgIHZhciBoaWRkZW5LZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNDIxKTtcbiAgICAgIHZhciBPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCA9IFwiT2JqZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWRcIjtcbiAgICAgIHZhciBUeXBlRXJyb3IyID0gZ2xvYmFsVGhpczIuVHlwZUVycm9yO1xuICAgICAgdmFyIFdlYWtNYXAyID0gZ2xvYmFsVGhpczIuV2Vha01hcDtcbiAgICAgIHZhciBzZXQsIGdldCwgaGFzO1xuICAgICAgdmFyIGVuZm9yY2UgPSBmdW5jdGlvbihpdCkge1xuICAgICAgICByZXR1cm4gaGFzKGl0KSA/IGdldChpdCkgOiBzZXQoaXQsIHt9KTtcbiAgICAgIH07XG4gICAgICB2YXIgZ2V0dGVyRm9yID0gZnVuY3Rpb24oVFlQRSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oaXQpIHtcbiAgICAgICAgICB2YXIgc3RhdGU7XG4gICAgICAgICAgaWYgKCFpc09iamVjdChpdCkgfHwgKHN0YXRlID0gZ2V0KGl0KSkudHlwZSAhPT0gVFlQRSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjIoXCJJbmNvbXBhdGlibGUgcmVjZWl2ZXIsIFwiICsgVFlQRSArIFwiIHJlcXVpcmVkXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgaWYgKE5BVElWRV9XRUFLX01BUCB8fCBzaGFyZWQuc3RhdGUpIHtcbiAgICAgICAgdmFyIHN0b3JlID0gc2hhcmVkLnN0YXRlIHx8IChzaGFyZWQuc3RhdGUgPSBuZXcgV2Vha01hcDIoKSk7XG4gICAgICAgIHN0b3JlLmdldCA9IHN0b3JlLmdldDtcbiAgICAgICAgc3RvcmUuaGFzID0gc3RvcmUuaGFzO1xuICAgICAgICBzdG9yZS5zZXQgPSBzdG9yZS5zZXQ7XG4gICAgICAgIHNldCA9IGZ1bmN0aW9uKGl0LCBtZXRhZGF0YSkge1xuICAgICAgICAgIGlmIChzdG9yZS5oYXMoaXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yMihPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgICAgICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgICAgICAgc3RvcmUuc2V0KGl0LCBtZXRhZGF0YSk7XG4gICAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgICAgICB9O1xuICAgICAgICBnZXQgPSBmdW5jdGlvbihpdCkge1xuICAgICAgICAgIHJldHVybiBzdG9yZS5nZXQoaXQpIHx8IHt9O1xuICAgICAgICB9O1xuICAgICAgICBoYXMgPSBmdW5jdGlvbihpdCkge1xuICAgICAgICAgIHJldHVybiBzdG9yZS5oYXMoaXQpO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIFNUQVRFID0gc2hhcmVkS2V5KFwic3RhdGVcIik7XG4gICAgICAgIGhpZGRlbktleXNbU1RBVEVdID0gdHJ1ZTtcbiAgICAgICAgc2V0ID0gZnVuY3Rpb24oaXQsIG1ldGFkYXRhKSB7XG4gICAgICAgICAgaWYgKGhhc093bihpdCwgU1RBVEUpKSB0aHJvdyBuZXcgVHlwZUVycm9yMihPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgICAgICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KGl0LCBTVEFURSwgbWV0YWRhdGEpO1xuICAgICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICAgICAgfTtcbiAgICAgICAgZ2V0ID0gZnVuY3Rpb24oaXQpIHtcbiAgICAgICAgICByZXR1cm4gaGFzT3duKGl0LCBTVEFURSkgPyBpdFtTVEFURV0gOiB7fTtcbiAgICAgICAgfTtcbiAgICAgICAgaGFzID0gZnVuY3Rpb24oaXQpIHtcbiAgICAgICAgICByZXR1cm4gaGFzT3duKGl0LCBTVEFURSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSB7XG4gICAgICAgIHNldCxcbiAgICAgICAgZ2V0LFxuICAgICAgICBoYXMsXG4gICAgICAgIGVuZm9yY2UsXG4gICAgICAgIGdldHRlckZvclxuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICAxMjkxOiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciB0cnVuYyA9IF9fd2VicGFja19yZXF1aXJlX18yKDc0MSk7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbihhcmd1bWVudCkge1xuICAgICAgICB2YXIgbnVtYmVyID0gK2FyZ3VtZW50O1xuICAgICAgICByZXR1cm4gbnVtYmVyICE9PSBudW1iZXIgfHwgbnVtYmVyID09PSAwID8gMCA6IHRydW5jKG51bWJlcik7XG4gICAgICB9O1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDEzODU6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMiwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyIGl0ZXJhdG9yQ2xvc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig5NTM5KTtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0ZXJzLCBraW5kLCB2YWx1ZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gaXRlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAoaXRlcnNbaV0gPT09IHZvaWQgMCkgY29udGludWU7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbHVlID0gaXRlcmF0b3JDbG9zZShpdGVyc1tpXS5pdGVyYXRvciwga2luZCwgdmFsdWUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBraW5kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgdmFsdWUgPSBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtpbmQgPT09IFwidGhyb3dcIikgdGhyb3cgdmFsdWU7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgMTU0ODogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgZ2xvYmFsVGhpczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig0NTc2KTtcbiAgICAgIHZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18yKDkwMzkpO1xuICAgICAgdmFyIFY4ID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoOTUxOSk7XG4gICAgICB2YXIgRU5WSVJPTk1FTlQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig0MjE1KTtcbiAgICAgIHZhciBzdHJ1Y3R1cmVkQ2xvbmUyID0gZ2xvYmFsVGhpczIuc3RydWN0dXJlZENsb25lO1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gISFzdHJ1Y3R1cmVkQ2xvbmUyICYmICFmYWlscyhmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKEVOVklST05NRU5UID09PSBcIkRFTk9cIiAmJiBWOCA+IDkyIHx8IEVOVklST05NRU5UID09PSBcIk5PREVcIiAmJiBWOCA+IDk0IHx8IEVOVklST05NRU5UID09PSBcIkJST1dTRVJcIiAmJiBWOCA+IDk3KSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoOCk7XG4gICAgICAgIHZhciBjbG9uZSA9IHN0cnVjdHVyZWRDbG9uZTIoYnVmZmVyLCB7IHRyYW5zZmVyOiBbYnVmZmVyXSB9KTtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlci5ieXRlTGVuZ3RoICE9PSAwIHx8IGNsb25lLmJ5dGVMZW5ndGggIT09IDg7XG4gICAgICB9KTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICAxNTQ5OiAoXG4gICAgLyoqKi9cbiAgICAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fMig2NjMyKTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICAxNjI1OiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18yKDk1MDQpO1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gdW5jdXJyeVRoaXMoe30uaXNQcm90b3R5cGVPZik7XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgMTY4OTogKFxuICAgIC8qKiovXG4gICAgKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2NTE4KTtcbiAgICAgIHZhciBnbG9iYWxUaGlzMiA9IF9fd2VicGFja19yZXF1aXJlX18yKDQ1NzYpO1xuICAgICAgdmFyIGFwcGx5ID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoODc0NSk7XG4gICAgICB2YXIgc2xpY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig3NjgwKTtcbiAgICAgIHZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDYwNDMpO1xuICAgICAgdmFyIGFDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDkzMDYpO1xuICAgICAgdmFyIHBlcmZvcm0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigxMTAzKTtcbiAgICAgIHZhciBQcm9taXNlMiA9IGdsb2JhbFRoaXMyLlByb21pc2U7XG4gICAgICB2YXIgQUNDRVBUX0FSR1VNRU5UUyA9IGZhbHNlO1xuICAgICAgdmFyIEZPUkNFRCA9ICFQcm9taXNlMiB8fCAhUHJvbWlzZTJbXCJ0cnlcIl0gfHwgcGVyZm9ybShmdW5jdGlvbigpIHtcbiAgICAgICAgUHJvbWlzZTJbXCJ0cnlcIl0oZnVuY3Rpb24oYXJndW1lbnQpIHtcbiAgICAgICAgICBBQ0NFUFRfQVJHVU1FTlRTID0gYXJndW1lbnQgPT09IDg7XG4gICAgICAgIH0sIDgpO1xuICAgICAgfSkuZXJyb3IgfHwgIUFDQ0VQVF9BUkdVTUVOVFM7XG4gICAgICAkKHsgdGFyZ2V0OiBcIlByb21pc2VcIiwgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQgfSwge1xuICAgICAgICBcInRyeVwiOiBmdW5jdGlvbihjYWxsYmFja2ZuKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlKGFyZ3VtZW50cywgMSkgOiBbXTtcbiAgICAgICAgICB2YXIgcHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mKHRoaXMpO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KGFDYWxsYWJsZShjYWxsYmFja2ZuKSwgdm9pZCAwLCBhcmdzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAocmVzdWx0LmVycm9yID8gcHJvbWlzZUNhcGFiaWxpdHkucmVqZWN0IDogcHJvbWlzZUNhcGFiaWxpdHkucmVzb2x2ZSkocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHkucHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgMTY5ODogKFxuICAgIC8qKiovXG4gICAgKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2NTE4KTtcbiAgICAgIHZhciB1bmlvbiA9IF9fd2VicGFja19yZXF1aXJlX18yKDQyMDQpO1xuICAgICAgdmFyIHNldE1ldGhvZEdldEtleXNCZWZvcmVDbG9uaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoOTgzNSk7XG4gICAgICB2YXIgc2V0TWV0aG9kQWNjZXB0U2V0TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDQ5MTYpO1xuICAgICAgdmFyIEZPUkNFRCA9ICFzZXRNZXRob2RBY2NlcHRTZXRMaWtlKFwidW5pb25cIikgfHwgIXNldE1ldGhvZEdldEtleXNCZWZvcmVDbG9uaW5nKFwidW5pb25cIik7XG4gICAgICAkKHsgdGFyZ2V0OiBcIlNldFwiLCBwcm90bzogdHJ1ZSwgcmVhbDogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQgfSwge1xuICAgICAgICB1bmlvblxuICAgICAgfSk7XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgMTcwMTogKFxuICAgIC8qKiovXG4gICAgKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2NTE4KTtcbiAgICAgIHZhciBjYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoOTU2NSk7XG4gICAgICB2YXIgYUNhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoOTMwNik7XG4gICAgICB2YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig4NTUxKTtcbiAgICAgIHZhciBnZXRJdGVyYXRvckRpcmVjdCA9IF9fd2VicGFja19yZXF1aXJlX18yKDE3NjcpO1xuICAgICAgdmFyIGNyZWF0ZUl0ZXJhdG9yUHJveHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig5NDYyKTtcbiAgICAgIHZhciBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNjMxOSk7XG4gICAgICB2YXIgaXRlcmF0b3JDbG9zZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDk1MzkpO1xuICAgICAgdmFyIGl0ZXJhdG9ySGVscGVyVGhyb3dzT25JbnZhbGlkSXRlcmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2ODQpO1xuICAgICAgdmFyIGl0ZXJhdG9ySGVscGVyV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig0NTQ5KTtcbiAgICAgIHZhciBJU19QVVJFID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNjM5NSk7XG4gICAgICB2YXIgTUFQX1dJVEhPVVRfVEhST1dJTkdfT05fSU5WQUxJRF9JVEVSQVRPUiA9ICFJU19QVVJFICYmICFpdGVyYXRvckhlbHBlclRocm93c09uSW52YWxpZEl0ZXJhdG9yKFwibWFwXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgfSk7XG4gICAgICB2YXIgbWFwV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IgPSAhSVNfUFVSRSAmJiAhTUFQX1dJVEhPVVRfVEhST1dJTkdfT05fSU5WQUxJRF9JVEVSQVRPUiAmJiBpdGVyYXRvckhlbHBlcldpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yKFwibWFwXCIsIFR5cGVFcnJvcik7XG4gICAgICB2YXIgRk9SQ0VEID0gSVNfUFVSRSB8fCBNQVBfV0lUSE9VVF9USFJPV0lOR19PTl9JTlZBTElEX0lURVJBVE9SIHx8IG1hcFdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yO1xuICAgICAgdmFyIEl0ZXJhdG9yUHJveHkgPSBjcmVhdGVJdGVyYXRvclByb3h5KGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLml0ZXJhdG9yO1xuICAgICAgICB2YXIgcmVzdWx0ID0gYW5PYmplY3QoY2FsbCh0aGlzLm5leHQsIGl0ZXJhdG9yKSk7XG4gICAgICAgIHZhciBkb25lID0gdGhpcy5kb25lID0gISFyZXN1bHQuZG9uZTtcbiAgICAgICAgaWYgKCFkb25lKSByZXR1cm4gY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyhpdGVyYXRvciwgdGhpcy5tYXBwZXIsIFtyZXN1bHQudmFsdWUsIHRoaXMuY291bnRlcisrXSwgdHJ1ZSk7XG4gICAgICB9KTtcbiAgICAgICQoeyB0YXJnZXQ6IFwiSXRlcmF0b3JcIiwgcHJvdG86IHRydWUsIHJlYWw6IHRydWUsIGZvcmNlZDogRk9SQ0VEIH0sIHtcbiAgICAgICAgbWFwOiBmdW5jdGlvbiBtYXAobWFwcGVyKSB7XG4gICAgICAgICAgYW5PYmplY3QodGhpcyk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGFDYWxsYWJsZShtYXBwZXIpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpdGVyYXRvckNsb3NlKHRoaXMsIFwidGhyb3dcIiwgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWFwV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IpIHJldHVybiBjYWxsKG1hcFdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yLCB0aGlzLCBtYXBwZXIpO1xuICAgICAgICAgIHJldHVybiBuZXcgSXRlcmF0b3JQcm94eShnZXRJdGVyYXRvckRpcmVjdCh0aGlzKSwge1xuICAgICAgICAgICAgbWFwcGVyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDE3Njc6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMikgPT4ge1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXRlcmF0b3I6IG9iaixcbiAgICAgICAgICBuZXh0OiBvYmoubmV4dCxcbiAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICAxODI4OiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18yKDk1MDQpO1xuICAgICAgdmFyIGhhc093biA9IF9fd2VicGFja19yZXF1aXJlX18yKDkyOTcpO1xuICAgICAgdmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18yKDUzOTcpO1xuICAgICAgdmFyIGluZGV4T2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig5NjE3KS5pbmRleE9mO1xuICAgICAgdmFyIGhpZGRlbktleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig0MjEpO1xuICAgICAgdmFyIHB1c2ggPSB1bmN1cnJ5VGhpcyhbXS5wdXNoKTtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgbmFtZXMpIHtcbiAgICAgICAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3Qob2JqZWN0KTtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoa2V5IGluIE8pICFoYXNPd24oaGlkZGVuS2V5cywga2V5KSAmJiBoYXNPd24oTywga2V5KSAmJiBwdXNoKHJlc3VsdCwga2V5KTtcbiAgICAgICAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXNPd24oTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICAgICAgICB+aW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcHVzaChyZXN1bHQsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgMjEwNjogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgbWFrZUJ1aWx0SW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigyODMpO1xuICAgICAgdmFyIGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNDkxMyk7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbih0YXJnZXQsIG5hbWUsIGRlc2NyaXB0b3IpIHtcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IuZ2V0KSBtYWtlQnVpbHRJbihkZXNjcmlwdG9yLmdldCwgbmFtZSwgeyBnZXR0ZXI6IHRydWUgfSk7XG4gICAgICAgIGlmIChkZXNjcmlwdG9yLnNldCkgbWFrZUJ1aWx0SW4oZGVzY3JpcHRvci5zZXQsIG5hbWUsIHsgc2V0dGVyOiB0cnVlIH0pO1xuICAgICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkuZih0YXJnZXQsIG5hbWUsIGRlc2NyaXB0b3IpO1xuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICAyMTQwOiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig4MjI3KTtcbiAgICAgIHZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKFwidG9TdHJpbmdUYWdcIik7XG4gICAgICB2YXIgdGVzdCA9IHt9O1xuICAgICAgdGVzdFtUT19TVFJJTkdfVEFHXSA9IFwielwiO1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gU3RyaW5nKHRlc3QpID09PSBcIltvYmplY3Qgel1cIjtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICAyMTk1OiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18yKDk1MDQpO1xuICAgICAgdmFyIHRvU3RyaW5nID0gdW5jdXJyeVRoaXMoe30udG9TdHJpbmcpO1xuICAgICAgdmFyIHN0cmluZ1NsaWNlID0gdW5jdXJyeVRoaXMoXCJcIi5zbGljZSk7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbihpdCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nU2xpY2UodG9TdHJpbmcoaXQpLCA4LCAtMSk7XG4gICAgICB9O1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDIyMTE6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMiwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoOTAzOSk7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIEYoKSB7XG4gICAgICAgIH1cbiAgICAgICAgRi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBudWxsO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBGKCkpICE9PSBGLnByb3RvdHlwZTtcbiAgICAgIH0pO1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDIzMDM6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMiwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyIGdsb2JhbFRoaXMyID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNDU3Nik7XG4gICAgICB2YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig5NTA0KTtcbiAgICAgIHZhciBVaW50OEFycmF5MiA9IGdsb2JhbFRoaXMyLlVpbnQ4QXJyYXk7XG4gICAgICB2YXIgU3ludGF4RXJyb3IyID0gZ2xvYmFsVGhpczIuU3ludGF4RXJyb3I7XG4gICAgICB2YXIgcGFyc2VJbnQyID0gZ2xvYmFsVGhpczIucGFyc2VJbnQ7XG4gICAgICB2YXIgbWluID0gTWF0aC5taW47XG4gICAgICB2YXIgTk9UX0hFWCA9IC9bXlxcZGEtZl0vaTtcbiAgICAgIHZhciBleGVjID0gdW5jdXJyeVRoaXMoTk9UX0hFWC5leGVjKTtcbiAgICAgIHZhciBzdHJpbmdTbGljZSA9IHVuY3VycnlUaGlzKFwiXCIuc2xpY2UpO1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24oc3RyaW5nLCBpbnRvKSB7XG4gICAgICAgIHZhciBzdHJpbmdMZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgICBpZiAoc3RyaW5nTGVuZ3RoICUgMiAhPT0gMCkgdGhyb3cgbmV3IFN5bnRheEVycm9yMihcIlN0cmluZyBzaG91bGQgYmUgYW4gZXZlbiBudW1iZXIgb2YgY2hhcmFjdGVyc1wiKTtcbiAgICAgICAgdmFyIG1heExlbmd0aCA9IGludG8gPyBtaW4oaW50by5sZW5ndGgsIHN0cmluZ0xlbmd0aCAvIDIpIDogc3RyaW5nTGVuZ3RoIC8gMjtcbiAgICAgICAgdmFyIGJ5dGVzID0gaW50byB8fCBuZXcgVWludDhBcnJheTIobWF4TGVuZ3RoKTtcbiAgICAgICAgdmFyIHJlYWQgPSAwO1xuICAgICAgICB2YXIgd3JpdHRlbiA9IDA7XG4gICAgICAgIHdoaWxlICh3cml0dGVuIDwgbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGhleGl0cyA9IHN0cmluZ1NsaWNlKHN0cmluZywgcmVhZCwgcmVhZCArPSAyKTtcbiAgICAgICAgICBpZiAoZXhlYyhOT1RfSEVYLCBoZXhpdHMpKSB0aHJvdyBuZXcgU3ludGF4RXJyb3IyKFwiU3RyaW5nIHNob3VsZCBvbmx5IGNvbnRhaW4gaGV4IGNoYXJhY3RlcnNcIik7XG4gICAgICAgICAgYnl0ZXNbd3JpdHRlbisrXSA9IHBhcnNlSW50MihoZXhpdHMsIDE2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBieXRlcywgcmVhZCB9O1xuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICAyMzYwOiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18yKDg1NTEpO1xuICAgICAgdmFyIGRlZmluZVByb3BlcnRpZXNNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2ODAxKTtcbiAgICAgIHZhciBlbnVtQnVnS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18yKDg3MjcpO1xuICAgICAgdmFyIGhpZGRlbktleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig0MjEpO1xuICAgICAgdmFyIGh0bWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigzOTcpO1xuICAgICAgdmFyIGRvY3VtZW50Q3JlYXRlRWxlbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18yKDQwNTUpO1xuICAgICAgdmFyIHNoYXJlZEtleSA9IF9fd2VicGFja19yZXF1aXJlX18yKDYxMTkpO1xuICAgICAgdmFyIEdUID0gXCI+XCI7XG4gICAgICB2YXIgTFQgPSBcIjxcIjtcbiAgICAgIHZhciBQUk9UT1RZUEUgPSBcInByb3RvdHlwZVwiO1xuICAgICAgdmFyIFNDUklQVCA9IFwic2NyaXB0XCI7XG4gICAgICB2YXIgSUVfUFJPVE8gPSBzaGFyZWRLZXkoXCJJRV9QUk9UT1wiKTtcbiAgICAgIHZhciBFbXB0eUNvbnN0cnVjdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgICB9O1xuICAgICAgdmFyIHNjcmlwdFRhZyA9IGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIExUICsgU0NSSVBUICsgR1QgKyBjb250ZW50ICsgTFQgKyBcIi9cIiArIFNDUklQVCArIEdUO1xuICAgICAgfTtcbiAgICAgIHZhciBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYID0gZnVuY3Rpb24oYWN0aXZlWERvY3VtZW50Mikge1xuICAgICAgICBhY3RpdmVYRG9jdW1lbnQyLndyaXRlKHNjcmlwdFRhZyhcIlwiKSk7XG4gICAgICAgIGFjdGl2ZVhEb2N1bWVudDIuY2xvc2UoKTtcbiAgICAgICAgdmFyIHRlbXAgPSBhY3RpdmVYRG9jdW1lbnQyLnBhcmVudFdpbmRvdy5PYmplY3Q7XG4gICAgICAgIGFjdGl2ZVhEb2N1bWVudDIgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGVtcDtcbiAgICAgIH07XG4gICAgICB2YXIgTnVsbFByb3RvT2JqZWN0VmlhSUZyYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7XG4gICAgICAgIHZhciBKUyA9IFwiamF2YVwiICsgU0NSSVBUICsgXCI6XCI7XG4gICAgICAgIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgICAgICAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgICAgICBpZnJhbWUuc3JjID0gU3RyaW5nKEpTKTtcbiAgICAgICAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgICAgICAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICAgICAgICBpZnJhbWVEb2N1bWVudC53cml0ZShzY3JpcHRUYWcoXCJkb2N1bWVudC5GPU9iamVjdFwiKSk7XG4gICAgICAgIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gICAgICAgIHJldHVybiBpZnJhbWVEb2N1bWVudC5GO1xuICAgICAgfTtcbiAgICAgIHZhciBhY3RpdmVYRG9jdW1lbnQ7XG4gICAgICB2YXIgTnVsbFByb3RvT2JqZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYWN0aXZlWERvY3VtZW50ID0gbmV3IEFjdGl2ZVhPYmplY3QoXCJodG1sZmlsZVwiKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgfVxuICAgICAgICBOdWxsUHJvdG9PYmplY3QgPSB0eXBlb2YgZG9jdW1lbnQgIT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50LmRvbWFpbiAmJiBhY3RpdmVYRG9jdW1lbnQgPyBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYKGFjdGl2ZVhEb2N1bWVudCkgOiBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUoKSA6IE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVgoYWN0aXZlWERvY3VtZW50KTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSBkZWxldGUgTnVsbFByb3RvT2JqZWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbbGVuZ3RoXV07XG4gICAgICAgIHJldHVybiBOdWxsUHJvdG9PYmplY3QoKTtcbiAgICAgIH07XG4gICAgICBoaWRkZW5LZXlzW0lFX1BST1RPXSA9IHRydWU7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGlmIChPICE9PSBudWxsKSB7XG4gICAgICAgICAgRW1wdHlDb25zdHJ1Y3RvcltQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgICAgICAgcmVzdWx0ID0gbmV3IEVtcHR5Q29uc3RydWN0b3IoKTtcbiAgICAgICAgICBFbXB0eUNvbnN0cnVjdG9yW1BST1RPVFlQRV0gPSBudWxsO1xuICAgICAgICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICAgICAgICB9IGVsc2UgcmVzdWx0ID0gTnVsbFByb3RvT2JqZWN0KCk7XG4gICAgICAgIHJldHVybiBQcm9wZXJ0aWVzID09PSB2b2lkIDAgPyByZXN1bHQgOiBkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlLmYocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgMjQ3NTogKFxuICAgIC8qKiovXG4gICAgKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2NTE4KTtcbiAgICAgIHZhciBpc1N1cGVyc2V0T2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig4NTI3KTtcbiAgICAgIHZhciBzZXRNZXRob2RBY2NlcHRTZXRMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNDkxNik7XG4gICAgICB2YXIgSU5DT1JSRUNUID0gIXNldE1ldGhvZEFjY2VwdFNldExpa2UoXCJpc1N1cGVyc2V0T2ZcIiwgZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiAhcmVzdWx0O1xuICAgICAgfSk7XG4gICAgICAkKHsgdGFyZ2V0OiBcIlNldFwiLCBwcm90bzogdHJ1ZSwgcmVhbDogdHJ1ZSwgZm9yY2VkOiBJTkNPUlJFQ1QgfSwge1xuICAgICAgICBpc1N1cGVyc2V0T2ZcbiAgICAgIH0pO1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDI0ODk6IChcbiAgICAvKioqL1xuICAgICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNjUxOCk7XG4gICAgICB2YXIgY2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18yKDk1NjUpO1xuICAgICAgdmFyIGFDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDkzMDYpO1xuICAgICAgdmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoODU1MSk7XG4gICAgICB2YXIgZ2V0SXRlcmF0b3JEaXJlY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigxNzY3KTtcbiAgICAgIHZhciBjcmVhdGVJdGVyYXRvclByb3h5ID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoOTQ2Mik7XG4gICAgICB2YXIgY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyA9IF9fd2VicGFja19yZXF1aXJlX18yKDYzMTkpO1xuICAgICAgdmFyIElTX1BVUkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2Mzk1KTtcbiAgICAgIHZhciBpdGVyYXRvckNsb3NlID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoOTUzOSk7XG4gICAgICB2YXIgaXRlcmF0b3JIZWxwZXJUaHJvd3NPbkludmFsaWRJdGVyYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18yKDY4NCk7XG4gICAgICB2YXIgaXRlcmF0b3JIZWxwZXJXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18yKDQ1NDkpO1xuICAgICAgdmFyIEZJTFRFUl9XSVRIT1VUX1RIUk9XSU5HX09OX0lOVkFMSURfSVRFUkFUT1IgPSAhSVNfUFVSRSAmJiAhaXRlcmF0b3JIZWxwZXJUaHJvd3NPbkludmFsaWRJdGVyYXRvcihcImZpbHRlclwiLCBmdW5jdGlvbigpIHtcbiAgICAgIH0pO1xuICAgICAgdmFyIGZpbHRlcldpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yID0gIUlTX1BVUkUgJiYgIUZJTFRFUl9XSVRIT1VUX1RIUk9XSU5HX09OX0lOVkFMSURfSVRFUkFUT1IgJiYgaXRlcmF0b3JIZWxwZXJXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvcihcImZpbHRlclwiLCBUeXBlRXJyb3IpO1xuICAgICAgdmFyIEZPUkNFRCA9IElTX1BVUkUgfHwgRklMVEVSX1dJVEhPVVRfVEhST1dJTkdfT05fSU5WQUxJRF9JVEVSQVRPUiB8fCBmaWx0ZXJXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvcjtcbiAgICAgIHZhciBJdGVyYXRvclByb3h5ID0gY3JlYXRlSXRlcmF0b3JQcm94eShmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5pdGVyYXRvcjtcbiAgICAgICAgdmFyIHByZWRpY2F0ZSA9IHRoaXMucHJlZGljYXRlO1xuICAgICAgICB2YXIgbmV4dCA9IHRoaXMubmV4dDtcbiAgICAgICAgdmFyIHJlc3VsdCwgZG9uZSwgdmFsdWU7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgcmVzdWx0ID0gYW5PYmplY3QoY2FsbChuZXh0LCBpdGVyYXRvcikpO1xuICAgICAgICAgIGRvbmUgPSB0aGlzLmRvbmUgPSAhIXJlc3VsdC5kb25lO1xuICAgICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgICAgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgICAgaWYgKGNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmcoaXRlcmF0b3IsIHByZWRpY2F0ZSwgW3ZhbHVlLCB0aGlzLmNvdW50ZXIrK10sIHRydWUpKSByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgJCh7IHRhcmdldDogXCJJdGVyYXRvclwiLCBwcm90bzogdHJ1ZSwgcmVhbDogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQgfSwge1xuICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihwcmVkaWNhdGUpIHtcbiAgICAgICAgICBhbk9iamVjdCh0aGlzKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYUNhbGxhYmxlKHByZWRpY2F0ZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yQ2xvc2UodGhpcywgXCJ0aHJvd1wiLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmaWx0ZXJXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvcikgcmV0dXJuIGNhbGwoZmlsdGVyV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IsIHRoaXMsIHByZWRpY2F0ZSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvclByb3h5KGdldEl0ZXJhdG9yRGlyZWN0KHRoaXMpLCB7XG4gICAgICAgICAgICBwcmVkaWNhdGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgMjUyOTogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyKSA9PiB7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbih2YWx1ZSwgZG9uZSkge1xuICAgICAgICByZXR1cm4geyB2YWx1ZSwgZG9uZSB9O1xuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICAyNjAzOiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciB0b1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18yKDY1NSk7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbihhcmd1bWVudCwgJGRlZmF1bHQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50ID09PSB2b2lkIDAgPyBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IFwiXCIgOiAkZGVmYXVsdCA6IHRvU3RyaW5nKGFyZ3VtZW50KTtcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgMjY1MjogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgYmluZCA9IF9fd2VicGFja19yZXF1aXJlX18yKDYwODApO1xuICAgICAgdmFyIGNhbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig5NTY1KTtcbiAgICAgIHZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18yKDg1NTEpO1xuICAgICAgdmFyIHRyeVRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNjgyMyk7XG4gICAgICB2YXIgaXNBcnJheUl0ZXJhdG9yTWV0aG9kID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNDIwOSk7XG4gICAgICB2YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2MTk4KTtcbiAgICAgIHZhciBpc1Byb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMTYyNSk7XG4gICAgICB2YXIgZ2V0SXRlcmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig4MSk7XG4gICAgICB2YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig4NTEpO1xuICAgICAgdmFyIGl0ZXJhdG9yQ2xvc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig5NTM5KTtcbiAgICAgIHZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuICAgICAgdmFyIFJlc3VsdCA9IGZ1bmN0aW9uKHN0b3BwZWQsIHJlc3VsdCkge1xuICAgICAgICB0aGlzLnN0b3BwZWQgPSBzdG9wcGVkO1xuICAgICAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAgIH07XG4gICAgICB2YXIgUmVzdWx0UHJvdG90eXBlID0gUmVzdWx0LnByb3RvdHlwZTtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0ZXJhYmxlLCB1bmJvdW5kRnVuY3Rpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHRoYXQgPSBvcHRpb25zICYmIG9wdGlvbnMudGhhdDtcbiAgICAgICAgdmFyIEFTX0VOVFJJRVMgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuQVNfRU5UUklFUyk7XG4gICAgICAgIHZhciBJU19SRUNPUkQgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuSVNfUkVDT1JEKTtcbiAgICAgICAgdmFyIElTX0lURVJBVE9SID0gISEob3B0aW9ucyAmJiBvcHRpb25zLklTX0lURVJBVE9SKTtcbiAgICAgICAgdmFyIElOVEVSUlVQVEVEID0gISEob3B0aW9ucyAmJiBvcHRpb25zLklOVEVSUlVQVEVEKTtcbiAgICAgICAgdmFyIGZuID0gYmluZCh1bmJvdW5kRnVuY3Rpb24sIHRoYXQpO1xuICAgICAgICB2YXIgaXRlcmF0b3IsIGl0ZXJGbiwgaW5kZXgsIGxlbmd0aCwgcmVzdWx0LCBuZXh0LCBzdGVwO1xuICAgICAgICB2YXIgc3RvcCA9IGZ1bmN0aW9uKGNvbmRpdGlvbikge1xuICAgICAgICAgIGlmIChpdGVyYXRvcikgaXRlcmF0b3JDbG9zZShpdGVyYXRvciwgXCJub3JtYWxcIik7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHQodHJ1ZSwgY29uZGl0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNhbGxGbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKEFTX0VOVFJJRVMpIHtcbiAgICAgICAgICAgIGFuT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBJTlRFUlJVUFRFRCA/IGZuKHZhbHVlWzBdLCB2YWx1ZVsxXSwgc3RvcCkgOiBmbih2YWx1ZVswXSwgdmFsdWVbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gSU5URVJSVVBURUQgPyBmbih2YWx1ZSwgc3RvcCkgOiBmbih2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChJU19SRUNPUkQpIHtcbiAgICAgICAgICBpdGVyYXRvciA9IGl0ZXJhYmxlLml0ZXJhdG9yO1xuICAgICAgICB9IGVsc2UgaWYgKElTX0lURVJBVE9SKSB7XG4gICAgICAgICAgaXRlcmF0b3IgPSBpdGVyYWJsZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVyRm4gPSBnZXRJdGVyYXRvck1ldGhvZChpdGVyYWJsZSk7XG4gICAgICAgICAgaWYgKCFpdGVyRm4pIHRocm93IG5ldyAkVHlwZUVycm9yKHRyeVRvU3RyaW5nKGl0ZXJhYmxlKSArIFwiIGlzIG5vdCBpdGVyYWJsZVwiKTtcbiAgICAgICAgICBpZiAoaXNBcnJheUl0ZXJhdG9yTWV0aG9kKGl0ZXJGbikpIHtcbiAgICAgICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZShpdGVyYWJsZSk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IGNhbGxGbihpdGVyYWJsZVtpbmRleF0pO1xuICAgICAgICAgICAgICBpZiAocmVzdWx0ICYmIGlzUHJvdG90eXBlT2YoUmVzdWx0UHJvdG90eXBlLCByZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHQoZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpdGVyYXRvciA9IGdldEl0ZXJhdG9yKGl0ZXJhYmxlLCBpdGVyRm4pO1xuICAgICAgICB9XG4gICAgICAgIG5leHQgPSBJU19SRUNPUkQgPyBpdGVyYWJsZS5uZXh0IDogaXRlcmF0b3IubmV4dDtcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGNhbGwobmV4dCwgaXRlcmF0b3IpKS5kb25lKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNhbGxGbihzdGVwLnZhbHVlKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaXRlcmF0b3JDbG9zZShpdGVyYXRvciwgXCJ0aHJvd1wiLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09IFwib2JqZWN0XCIgJiYgcmVzdWx0ICYmIGlzUHJvdG90eXBlT2YoUmVzdWx0UHJvdG90eXBlLCByZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVzdWx0KGZhbHNlKTtcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgMjc3NzogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgY2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18yKDk1NjUpO1xuICAgICAgdmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMzQpO1xuICAgICAgdmFyIGlzU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNzU3KTtcbiAgICAgIHZhciBnZXRNZXRob2QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig1OTY2KTtcbiAgICAgIHZhciBvcmRpbmFyeVRvUHJpbWl0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNDI3MCk7XG4gICAgICB2YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoODIyNyk7XG4gICAgICB2YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbiAgICAgIHZhciBUT19QUklNSVRJVkUgPSB3ZWxsS25vd25TeW1ib2woXCJ0b1ByaW1pdGl2ZVwiKTtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKGlucHV0LCBwcmVmKSB7XG4gICAgICAgIGlmICghaXNPYmplY3QoaW5wdXQpIHx8IGlzU3ltYm9sKGlucHV0KSkgcmV0dXJuIGlucHV0O1xuICAgICAgICB2YXIgZXhvdGljVG9QcmltID0gZ2V0TWV0aG9kKGlucHV0LCBUT19QUklNSVRJVkUpO1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICBpZiAoZXhvdGljVG9QcmltKSB7XG4gICAgICAgICAgaWYgKHByZWYgPT09IHZvaWQgMCkgcHJlZiA9IFwiZGVmYXVsdFwiO1xuICAgICAgICAgIHJlc3VsdCA9IGNhbGwoZXhvdGljVG9QcmltLCBpbnB1dCwgcHJlZik7XG4gICAgICAgICAgaWYgKCFpc09iamVjdChyZXN1bHQpIHx8IGlzU3ltYm9sKHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZWYgPT09IHZvaWQgMCkgcHJlZiA9IFwibnVtYmVyXCI7XG4gICAgICAgIHJldHVybiBvcmRpbmFyeVRvUHJpbWl0aXZlKGlucHV0LCBwcmVmKTtcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgMjc4NzogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgaGFzT3duID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoOTI5Nyk7XG4gICAgICB2YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDQ5MDEpO1xuICAgICAgdmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoODk4MSk7XG4gICAgICB2YXIgc2hhcmVkS2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNjExOSk7XG4gICAgICB2YXIgQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMjIxMSk7XG4gICAgICB2YXIgSUVfUFJPVE8gPSBzaGFyZWRLZXkoXCJJRV9QUk9UT1wiKTtcbiAgICAgIHZhciAkT2JqZWN0ID0gT2JqZWN0O1xuICAgICAgdmFyIE9iamVjdFByb3RvdHlwZSA9ICRPYmplY3QucHJvdG90eXBlO1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSID8gJE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uKE8pIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IHRvT2JqZWN0KE8pO1xuICAgICAgICBpZiAoaGFzT3duKG9iamVjdCwgSUVfUFJPVE8pKSByZXR1cm4gb2JqZWN0W0lFX1BST1RPXTtcbiAgICAgICAgdmFyIGNvbnN0cnVjdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICAgICAgICBpZiAoaXNDYWxsYWJsZShjb25zdHJ1Y3RvcikgJiYgb2JqZWN0IGluc3RhbmNlb2YgY29uc3RydWN0b3IpIHtcbiAgICAgICAgICByZXR1cm4gY29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiAkT2JqZWN0ID8gT2JqZWN0UHJvdG90eXBlIDogbnVsbDtcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgMjc5NjogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig5MDM5KTtcbiAgICAgIHZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNDkwMSk7XG4gICAgICB2YXIgcmVwbGFjZW1lbnQgPSAvI3xcXC5wcm90b3R5cGVcXC4vO1xuICAgICAgdmFyIGlzRm9yY2VkID0gZnVuY3Rpb24oZmVhdHVyZSwgZGV0ZWN0aW9uKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGRhdGFbbm9ybWFsaXplKGZlYXR1cmUpXTtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBQT0xZRklMTCA/IHRydWUgOiB2YWx1ZSA9PT0gTkFUSVZFID8gZmFsc2UgOiBpc0NhbGxhYmxlKGRldGVjdGlvbikgPyBmYWlscyhkZXRlY3Rpb24pIDogISFkZXRlY3Rpb247XG4gICAgICB9O1xuICAgICAgdmFyIG5vcm1hbGl6ZSA9IGlzRm9yY2VkLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZShyZXBsYWNlbWVudCwgXCIuXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9O1xuICAgICAgdmFyIGRhdGEgPSBpc0ZvcmNlZC5kYXRhID0ge307XG4gICAgICB2YXIgTkFUSVZFID0gaXNGb3JjZWQuTkFUSVZFID0gXCJOXCI7XG4gICAgICB2YXIgUE9MWUZJTEwgPSBpc0ZvcmNlZC5QT0xZRklMTCA9IFwiUFwiO1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gaXNGb3JjZWQ7XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgMjgwNDogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyKSA9PiB7XG4gICAgICB2YXIgY29tbW9uQWxwaGFiZXQgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5XCI7XG4gICAgICB2YXIgYmFzZTY0QWxwaGFiZXQgPSBjb21tb25BbHBoYWJldCArIFwiKy9cIjtcbiAgICAgIHZhciBiYXNlNjRVcmxBbHBoYWJldCA9IGNvbW1vbkFscGhhYmV0ICsgXCItX1wiO1xuICAgICAgdmFyIGludmVyc2UgPSBmdW5jdGlvbihjaGFyYWN0ZXJzKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgZm9yICg7IGluZGV4IDwgNjQ7IGluZGV4KyspIHJlc3VsdFtjaGFyYWN0ZXJzLmNoYXJBdChpbmRleCldID0gaW5kZXg7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0ge1xuICAgICAgICBpMmM6IGJhc2U2NEFscGhhYmV0LFxuICAgICAgICBjMmk6IGludmVyc2UoYmFzZTY0QWxwaGFiZXQpLFxuICAgICAgICBpMmNVcmw6IGJhc2U2NFVybEFscGhhYmV0LFxuICAgICAgICBjMmlVcmw6IGludmVyc2UoYmFzZTY0VXJsQWxwaGFiZXQpXG4gICAgICB9O1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDI4MTI6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMikgPT4ge1xuICAgICAgdmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbihwYXNzZWQsIHJlcXVpcmVkKSB7XG4gICAgICAgIGlmIChwYXNzZWQgPCByZXF1aXJlZCkgdGhyb3cgbmV3ICRUeXBlRXJyb3IoXCJOb3QgZW5vdWdoIGFyZ3VtZW50c1wiKTtcbiAgICAgICAgcmV0dXJuIHBhc3NlZDtcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgMjgzOTogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgZ2xvYmFsVGhpczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig0NTc2KTtcbiAgICAgIHZhciBuYXZpZ2F0b3IyID0gZ2xvYmFsVGhpczIubmF2aWdhdG9yO1xuICAgICAgdmFyIHVzZXJBZ2VudCA9IG5hdmlnYXRvcjIgJiYgbmF2aWdhdG9yMi51c2VyQWdlbnQ7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSB1c2VyQWdlbnQgPyBTdHJpbmcodXNlckFnZW50KSA6IFwiXCI7XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgMjk2NzogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgdW5jdXJyeVRoaXNBY2Nlc3NvciA9IF9fd2VicGFja19yZXF1aXJlX18yKDY3MDYpO1xuICAgICAgdmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMzQpO1xuICAgICAgdmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig3NzUwKTtcbiAgICAgIHZhciBhUG9zc2libGVQcm90b3R5cGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigzNTA2KTtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoXCJfX3Byb3RvX19cIiBpbiB7fSA/IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIENPUlJFQ1RfU0VUVEVSID0gZmFsc2U7XG4gICAgICAgIHZhciB0ZXN0ID0ge307XG4gICAgICAgIHZhciBzZXR0ZXI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2V0dGVyID0gdW5jdXJyeVRoaXNBY2Nlc3NvcihPYmplY3QucHJvdG90eXBlLCBcIl9fcHJvdG9fX1wiLCBcInNldFwiKTtcbiAgICAgICAgICBzZXR0ZXIodGVzdCwgW10pO1xuICAgICAgICAgIENPUlJFQ1RfU0VUVEVSID0gdGVzdCBpbnN0YW5jZW9mIEFycmF5O1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgICAgICAgIHJlcXVpcmVPYmplY3RDb2VyY2libGUoTyk7XG4gICAgICAgICAgYVBvc3NpYmxlUHJvdG90eXBlKHByb3RvKTtcbiAgICAgICAgICBpZiAoIWlzT2JqZWN0KE8pKSByZXR1cm4gTztcbiAgICAgICAgICBpZiAoQ09SUkVDVF9TRVRURVIpIHNldHRlcihPLCBwcm90byk7XG4gICAgICAgICAgZWxzZSBPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgICAgICAgIHJldHVybiBPO1xuICAgICAgICB9O1xuICAgICAgfSkoKSA6IHZvaWQgMCk7XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgMzA2ODogKFxuICAgIC8qKiovXG4gICAgKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2NTE4KTtcbiAgICAgIHZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18yKDk1MDQpO1xuICAgICAgdmFyIGl0ZXJhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigyNjUyKTtcbiAgICAgIHZhciAkUmFuZ2VFcnJvciA9IFJhbmdlRXJyb3I7XG4gICAgICB2YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbiAgICAgIHZhciAkSW5maW5pdHkgPSBJbmZpbml0eTtcbiAgICAgIHZhciAkTmFOID0gTmFOO1xuICAgICAgdmFyIGFicyA9IE1hdGguYWJzO1xuICAgICAgdmFyIHBvdyA9IE1hdGgucG93O1xuICAgICAgdmFyIHB1c2ggPSB1bmN1cnJ5VGhpcyhbXS5wdXNoKTtcbiAgICAgIHZhciBQT1dfMl8xMDIzID0gcG93KDIsIDEwMjMpO1xuICAgICAgdmFyIE1BWF9TQUZFX0lOVEVHRVIgPSBwb3coMiwgNTMpIC0gMTtcbiAgICAgIHZhciBNQVhfRE9VQkxFID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgIHZhciBNQVhfVUxQID0gcG93KDIsIDk3MSk7XG4gICAgICB2YXIgTk9UX0FfTlVNQkVSID0ge307XG4gICAgICB2YXIgTUlOVVNfSU5GSU5JVFkgPSB7fTtcbiAgICAgIHZhciBQTFVTX0lORklOSVRZID0ge307XG4gICAgICB2YXIgTUlOVVNfWkVSTyA9IHt9O1xuICAgICAgdmFyIEZJTklURSA9IHt9O1xuICAgICAgdmFyIHR3b3N1bSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdmFyIGhpID0geCArIHk7XG4gICAgICAgIHZhciBsbyA9IHkgLSAoaGkgLSB4KTtcbiAgICAgICAgcmV0dXJuIHsgaGksIGxvIH07XG4gICAgICB9O1xuICAgICAgJCh7IHRhcmdldDogXCJNYXRoXCIsIHN0YXQ6IHRydWUgfSwge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXN0YXRlbWVudHMgLS0gb2tcbiAgICAgICAgc3VtUHJlY2lzZTogZnVuY3Rpb24gc3VtUHJlY2lzZShpdGVtcykge1xuICAgICAgICAgIHZhciBudW1iZXJzID0gW107XG4gICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICB2YXIgc3RhdGUgPSBNSU5VU19aRVJPO1xuICAgICAgICAgIGl0ZXJhdGUoaXRlbXMsIGZ1bmN0aW9uKG4yKSB7XG4gICAgICAgICAgICBpZiAoKytjb3VudCA+PSBNQVhfU0FGRV9JTlRFR0VSKSB0aHJvdyBuZXcgJFJhbmdlRXJyb3IoXCJNYXhpbXVtIGFsbG93ZWQgaW5kZXggZXhjZWVkZWRcIik7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG4yICE9IFwibnVtYmVyXCIpIHRocm93IG5ldyAkVHlwZUVycm9yKFwiVmFsdWUgaXMgbm90IGEgbnVtYmVyXCIpO1xuICAgICAgICAgICAgaWYgKHN0YXRlICE9PSBOT1RfQV9OVU1CRVIpIHtcbiAgICAgICAgICAgICAgaWYgKG4yICE9PSBuMikgc3RhdGUgPSBOT1RfQV9OVU1CRVI7XG4gICAgICAgICAgICAgIGVsc2UgaWYgKG4yID09PSAkSW5maW5pdHkpIHN0YXRlID0gc3RhdGUgPT09IE1JTlVTX0lORklOSVRZID8gTk9UX0FfTlVNQkVSIDogUExVU19JTkZJTklUWTtcbiAgICAgICAgICAgICAgZWxzZSBpZiAobjIgPT09IC0kSW5maW5pdHkpIHN0YXRlID0gc3RhdGUgPT09IFBMVVNfSU5GSU5JVFkgPyBOT1RfQV9OVU1CRVIgOiBNSU5VU19JTkZJTklUWTtcbiAgICAgICAgICAgICAgZWxzZSBpZiAoKG4yICE9PSAwIHx8IDEgLyBuMiA9PT0gJEluZmluaXR5KSAmJiAoc3RhdGUgPT09IE1JTlVTX1pFUk8gfHwgc3RhdGUgPT09IEZJTklURSkpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IEZJTklURTtcbiAgICAgICAgICAgICAgICBwdXNoKG51bWJlcnMsIG4yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgTk9UX0FfTlVNQkVSOlxuICAgICAgICAgICAgICByZXR1cm4gJE5hTjtcbiAgICAgICAgICAgIGNhc2UgTUlOVVNfSU5GSU5JVFk6XG4gICAgICAgICAgICAgIHJldHVybiAtJEluZmluaXR5O1xuICAgICAgICAgICAgY2FzZSBQTFVTX0lORklOSVRZOlxuICAgICAgICAgICAgICByZXR1cm4gJEluZmluaXR5O1xuICAgICAgICAgICAgY2FzZSBNSU5VU19aRVJPOlxuICAgICAgICAgICAgICByZXR1cm4gLTA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBwYXJ0aWFscyA9IFtdO1xuICAgICAgICAgIHZhciBvdmVyZmxvdyA9IDA7XG4gICAgICAgICAgdmFyIHgsIHksIHN1bSwgaGksIGxvLCB0bXA7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1iZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB4ID0gbnVtYmVyc1tpXTtcbiAgICAgICAgICAgIHZhciBhY3R1YWxseVVzZWRQYXJ0aWFscyA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBhcnRpYWxzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIHkgPSBwYXJ0aWFsc1tqXTtcbiAgICAgICAgICAgICAgaWYgKGFicyh4KSA8IGFicyh5KSkge1xuICAgICAgICAgICAgICAgIHRtcCA9IHg7XG4gICAgICAgICAgICAgICAgeCA9IHk7XG4gICAgICAgICAgICAgICAgeSA9IHRtcDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdW0gPSB0d29zdW0oeCwgeSk7XG4gICAgICAgICAgICAgIGhpID0gc3VtLmhpO1xuICAgICAgICAgICAgICBsbyA9IHN1bS5sbztcbiAgICAgICAgICAgICAgaWYgKGFicyhoaSkgPT09ICRJbmZpbml0eSkge1xuICAgICAgICAgICAgICAgIHZhciBzaWduID0gaGkgPT09ICRJbmZpbml0eSA/IDEgOiAtMTtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyArPSBzaWduO1xuICAgICAgICAgICAgICAgIHggPSB4IC0gc2lnbiAqIFBPV18yXzEwMjMgLSBzaWduICogUE9XXzJfMTAyMztcbiAgICAgICAgICAgICAgICBpZiAoYWJzKHgpIDwgYWJzKHkpKSB7XG4gICAgICAgICAgICAgICAgICB0bXAgPSB4O1xuICAgICAgICAgICAgICAgICAgeCA9IHk7XG4gICAgICAgICAgICAgICAgICB5ID0gdG1wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdW0gPSB0d29zdW0oeCwgeSk7XG4gICAgICAgICAgICAgICAgaGkgPSBzdW0uaGk7XG4gICAgICAgICAgICAgICAgbG8gPSBzdW0ubG87XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGxvICE9PSAwKSBwYXJ0aWFsc1thY3R1YWxseVVzZWRQYXJ0aWFscysrXSA9IGxvO1xuICAgICAgICAgICAgICB4ID0gaGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJ0aWFscy5sZW5ndGggPSBhY3R1YWxseVVzZWRQYXJ0aWFscztcbiAgICAgICAgICAgIGlmICh4ICE9PSAwKSBwdXNoKHBhcnRpYWxzLCB4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG4gPSBwYXJ0aWFscy5sZW5ndGggLSAxO1xuICAgICAgICAgIGhpID0gMDtcbiAgICAgICAgICBsbyA9IDA7XG4gICAgICAgICAgaWYgKG92ZXJmbG93ICE9PSAwKSB7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IG4gPj0gMCA/IHBhcnRpYWxzW25dIDogMDtcbiAgICAgICAgICAgIG4tLTtcbiAgICAgICAgICAgIGlmIChhYnMob3ZlcmZsb3cpID4gMSB8fCBvdmVyZmxvdyA+IDAgJiYgbmV4dCA+IDAgfHwgb3ZlcmZsb3cgPCAwICYmIG5leHQgPCAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvdmVyZmxvdyA+IDAgPyAkSW5maW5pdHkgOiAtJEluZmluaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VtID0gdHdvc3VtKG92ZXJmbG93ICogUE9XXzJfMTAyMywgbmV4dCAvIDIpO1xuICAgICAgICAgICAgaGkgPSBzdW0uaGk7XG4gICAgICAgICAgICBsbyA9IHN1bS5sbztcbiAgICAgICAgICAgIGxvICo9IDI7XG4gICAgICAgICAgICBpZiAoYWJzKDIgKiBoaSkgPT09ICRJbmZpbml0eSkge1xuICAgICAgICAgICAgICBpZiAoaGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhpID09PSBQT1dfMl8xMDIzICYmIGxvID09PSAtKE1BWF9VTFAgLyAyKSAmJiBuID49IDAgJiYgcGFydGlhbHNbbl0gPCAwID8gTUFYX0RPVUJMRSA6ICRJbmZpbml0eTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gaGkgPT09IC1QT1dfMl8xMDIzICYmIGxvID09PSBNQVhfVUxQIC8gMiAmJiBuID49IDAgJiYgcGFydGlhbHNbbl0gPiAwID8gLU1BWF9ET1VCTEUgOiAtJEluZmluaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxvICE9PSAwKSB7XG4gICAgICAgICAgICAgIHBhcnRpYWxzWysrbl0gPSBsbztcbiAgICAgICAgICAgICAgbG8gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGkgKj0gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKG4gPj0gMCkge1xuICAgICAgICAgICAgc3VtID0gdHdvc3VtKGhpLCBwYXJ0aWFsc1tuLS1dKTtcbiAgICAgICAgICAgIGhpID0gc3VtLmhpO1xuICAgICAgICAgICAgbG8gPSBzdW0ubG87XG4gICAgICAgICAgICBpZiAobG8gIT09IDApIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobiA+PSAwICYmIChsbyA8IDAgJiYgcGFydGlhbHNbbl0gPCAwIHx8IGxvID4gMCAmJiBwYXJ0aWFsc1tuXSA+IDApKSB7XG4gICAgICAgICAgICB5ID0gbG8gKiAyO1xuICAgICAgICAgICAgeCA9IGhpICsgeTtcbiAgICAgICAgICAgIGlmICh5ID09PSB4IC0gaGkpIGhpID0geDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGhpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICAzMTY3OiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNDkwMSk7XG4gICAgICB2YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigzNCk7XG4gICAgICB2YXIgc2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigyOTY3KTtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKCR0aGlzLCBkdW1teSwgV3JhcHBlcikge1xuICAgICAgICB2YXIgTmV3VGFyZ2V0LCBOZXdUYXJnZXRQcm90b3R5cGU7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAvLyBpdCBjYW4gd29yayBvbmx5IHdpdGggbmF0aXZlIGBzZXRQcm90b3R5cGVPZmBcbiAgICAgICAgICBzZXRQcm90b3R5cGVPZiAmJiAvLyB3ZSBoYXZlbid0IGNvbXBsZXRlbHkgY29ycmVjdCBwcmUtRVM2IHdheSBmb3IgZ2V0dGluZyBgbmV3LnRhcmdldGAsIHNvIHVzZSB0aGlzXG4gICAgICAgICAgaXNDYWxsYWJsZShOZXdUYXJnZXQgPSBkdW1teS5jb25zdHJ1Y3RvcikgJiYgTmV3VGFyZ2V0ICE9PSBXcmFwcGVyICYmIGlzT2JqZWN0KE5ld1RhcmdldFByb3RvdHlwZSA9IE5ld1RhcmdldC5wcm90b3R5cGUpICYmIE5ld1RhcmdldFByb3RvdHlwZSAhPT0gV3JhcHBlci5wcm90b3R5cGVcbiAgICAgICAgKSBzZXRQcm90b3R5cGVPZigkdGhpcywgTmV3VGFyZ2V0UHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuICR0aGlzO1xuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICAzMjM4OiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciBnbG9iYWxUaGlzMiA9IF9fd2VicGFja19yZXF1aXJlX18yKDQ1NzYpO1xuICAgICAgdmFyIE5BVElWRV9BUlJBWV9CVUZGRVIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig3ODExKTtcbiAgICAgIHZhciBhcnJheUJ1ZmZlckJ5dGVMZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig3Mzk0KTtcbiAgICAgIHZhciBEYXRhVmlldzIgPSBnbG9iYWxUaGlzMi5EYXRhVmlldztcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKE8pIHtcbiAgICAgICAgaWYgKCFOQVRJVkVfQVJSQVlfQlVGRkVSIHx8IGFycmF5QnVmZmVyQnl0ZUxlbmd0aChPKSAhPT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5ldyBEYXRhVmlldzIoTyk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDMzOTI6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMiwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoOTUwNCk7XG4gICAgICB2YXIgaWQgPSAwO1xuICAgICAgdmFyIHBvc3RmaXggPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgdmFyIHRvU3RyaW5nID0gdW5jdXJyeVRoaXMoMS4xLnRvU3RyaW5nKTtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gXCJTeW1ib2woXCIgKyAoa2V5ID09PSB2b2lkIDAgPyBcIlwiIDoga2V5KSArIFwiKV9cIiArIHRvU3RyaW5nKCsraWQgKyBwb3N0Zml4LCAzNik7XG4gICAgICB9O1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDM0NDA6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMiwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyIGFTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig3MDgwKTtcbiAgICAgIHZhciBTZXRIZWxwZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNDQwMik7XG4gICAgICB2YXIgY2xvbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig5Mjg2KTtcbiAgICAgIHZhciBzaXplID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNTE3MCk7XG4gICAgICB2YXIgZ2V0U2V0UmVjb3JkID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMzc4OSk7XG4gICAgICB2YXIgaXRlcmF0ZVNldCA9IF9fd2VicGFja19yZXF1aXJlX18yKDg0NjkpO1xuICAgICAgdmFyIGl0ZXJhdGVTaW1wbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig1MDcpO1xuICAgICAgdmFyIGhhcyA9IFNldEhlbHBlcnMuaGFzO1xuICAgICAgdmFyIHJlbW92ZSA9IFNldEhlbHBlcnMucmVtb3ZlO1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24gZGlmZmVyZW5jZShvdGhlcikge1xuICAgICAgICB2YXIgTyA9IGFTZXQodGhpcyk7XG4gICAgICAgIHZhciBvdGhlclJlYyA9IGdldFNldFJlY29yZChvdGhlcik7XG4gICAgICAgIHZhciByZXN1bHQgPSBjbG9uZShPKTtcbiAgICAgICAgaWYgKHNpemUoTykgPD0gb3RoZXJSZWMuc2l6ZSkgaXRlcmF0ZVNldChPLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgaWYgKG90aGVyUmVjLmluY2x1ZGVzKGUpKSByZW1vdmUocmVzdWx0LCBlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVsc2UgaXRlcmF0ZVNpbXBsZShvdGhlclJlYy5nZXRJdGVyYXRvcigpLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgaWYgKGhhcyhyZXN1bHQsIGUpKSByZW1vdmUocmVzdWx0LCBlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDM0NjM6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMikgPT4ge1xuICAgICAgdmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbihhcmd1bWVudCkge1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50ID09IFwic3RyaW5nXCIpIHJldHVybiBhcmd1bWVudDtcbiAgICAgICAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoXCJBcmd1bWVudCBpcyBub3QgYSBzdHJpbmdcIik7XG4gICAgICB9O1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDM1MDY6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMiwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyIGlzUG9zc2libGVQcm90b3R5cGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigzOTI1KTtcbiAgICAgIHZhciAkU3RyaW5nID0gU3RyaW5nO1xuICAgICAgdmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbihhcmd1bWVudCkge1xuICAgICAgICBpZiAoaXNQb3NzaWJsZVByb3RvdHlwZShhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgICAgICAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoXCJDYW4ndCBzZXQgXCIgKyAkU3RyaW5nKGFyZ3VtZW50KSArIFwiIGFzIGEgcHJvdG90eXBlXCIpO1xuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICAzNTc5OiAoXG4gICAgLyoqKi9cbiAgICAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18yKDY1MTgpO1xuICAgICAgdmFyIGNhbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig5NTY1KTtcbiAgICAgIHZhciBpdGVyYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMjY1Mik7XG4gICAgICB2YXIgYUNhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoOTMwNik7XG4gICAgICB2YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig4NTUxKTtcbiAgICAgIHZhciBnZXRJdGVyYXRvckRpcmVjdCA9IF9fd2VicGFja19yZXF1aXJlX18yKDE3NjcpO1xuICAgICAgdmFyIGl0ZXJhdG9yQ2xvc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig5NTM5KTtcbiAgICAgIHZhciBpdGVyYXRvckhlbHBlcldpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNDU0OSk7XG4gICAgICB2YXIgc29tZVdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yID0gaXRlcmF0b3JIZWxwZXJXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvcihcInNvbWVcIiwgVHlwZUVycm9yKTtcbiAgICAgICQoeyB0YXJnZXQ6IFwiSXRlcmF0b3JcIiwgcHJvdG86IHRydWUsIHJlYWw6IHRydWUsIGZvcmNlZDogc29tZVdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yIH0sIHtcbiAgICAgICAgc29tZTogZnVuY3Rpb24gc29tZShwcmVkaWNhdGUpIHtcbiAgICAgICAgICBhbk9iamVjdCh0aGlzKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYUNhbGxhYmxlKHByZWRpY2F0ZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yQ2xvc2UodGhpcywgXCJ0aHJvd1wiLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzb21lV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IpIHJldHVybiBjYWxsKHNvbWVXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciwgdGhpcywgcHJlZGljYXRlKTtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZ2V0SXRlcmF0b3JEaXJlY3QodGhpcyk7XG4gICAgICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgICAgICAgIHJldHVybiBpdGVyYXRlKHJlY29yZCwgZnVuY3Rpb24odmFsdWUsIHN0b3ApIHtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGNvdW50ZXIrKykpIHJldHVybiBzdG9wKCk7XG4gICAgICAgICAgfSwgeyBJU19SRUNPUkQ6IHRydWUsIElOVEVSUlVQVEVEOiB0cnVlIH0pLnN0b3BwZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDM2NTA6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMiwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyIGFTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig3MDgwKTtcbiAgICAgIHZhciBTZXRIZWxwZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNDQwMik7XG4gICAgICB2YXIgY2xvbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig5Mjg2KTtcbiAgICAgIHZhciBnZXRTZXRSZWNvcmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigzNzg5KTtcbiAgICAgIHZhciBpdGVyYXRlU2ltcGxlID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNTA3KTtcbiAgICAgIHZhciBhZGQgPSBTZXRIZWxwZXJzLmFkZDtcbiAgICAgIHZhciBoYXMgPSBTZXRIZWxwZXJzLmhhcztcbiAgICAgIHZhciByZW1vdmUgPSBTZXRIZWxwZXJzLnJlbW92ZTtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uIHN5bW1ldHJpY0RpZmZlcmVuY2Uob3RoZXIpIHtcbiAgICAgICAgdmFyIE8gPSBhU2V0KHRoaXMpO1xuICAgICAgICB2YXIga2V5c0l0ZXIgPSBnZXRTZXRSZWNvcmQob3RoZXIpLmdldEl0ZXJhdG9yKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBjbG9uZShPKTtcbiAgICAgICAgaXRlcmF0ZVNpbXBsZShrZXlzSXRlciwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGlmIChoYXMoTywgZSkpIHJlbW92ZShyZXN1bHQsIGUpO1xuICAgICAgICAgIGVsc2UgYWRkKHJlc3VsdCwgZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICAzNzA2OiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18yKDk1MDQpO1xuICAgICAgdmFyIGlzQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig0OTAxKTtcbiAgICAgIHZhciBzdG9yZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDc2MjkpO1xuICAgICAgdmFyIGZ1bmN0aW9uVG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyhGdW5jdGlvbi50b1N0cmluZyk7XG4gICAgICBpZiAoIWlzQ2FsbGFibGUoc3RvcmUuaW5zcGVjdFNvdXJjZSkpIHtcbiAgICAgICAgc3RvcmUuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uKGl0KSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uVG9TdHJpbmcoaXQpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgbW9kdWxlMi5leHBvcnRzID0gc3RvcmUuaW5zcGVjdFNvdXJjZTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICAzNzE3OiAoXG4gICAgLyoqKi9cbiAgICAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzMikgPT4ge1xuICAgICAgZXhwb3J0czIuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgMzcyNDogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig5MDM5KTtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9ICFmYWlscyhmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgMSwgeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiA3O1xuICAgICAgICB9IH0pWzFdICE9PSA3O1xuICAgICAgfSk7XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgMzc4OTogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgYUNhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoOTMwNik7XG4gICAgICB2YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig4NTUxKTtcbiAgICAgIHZhciBjYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoOTU2NSk7XG4gICAgICB2YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSA9IF9fd2VicGFja19yZXF1aXJlX18yKDEyOTEpO1xuICAgICAgdmFyIGdldEl0ZXJhdG9yRGlyZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMTc2Nyk7XG4gICAgICB2YXIgSU5WQUxJRF9TSVpFID0gXCJJbnZhbGlkIHNpemVcIjtcbiAgICAgIHZhciAkUmFuZ2VFcnJvciA9IFJhbmdlRXJyb3I7XG4gICAgICB2YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbiAgICAgIHZhciBtYXggPSBNYXRoLm1heDtcbiAgICAgIHZhciBTZXRSZWNvcmQgPSBmdW5jdGlvbihzZXQsIGludFNpemUpIHtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgICAgIHRoaXMuc2l6ZSA9IG1heChpbnRTaXplLCAwKTtcbiAgICAgICAgdGhpcy5oYXMgPSBhQ2FsbGFibGUoc2V0Lmhhcyk7XG4gICAgICAgIHRoaXMua2V5cyA9IGFDYWxsYWJsZShzZXQua2V5cyk7XG4gICAgICB9O1xuICAgICAgU2V0UmVjb3JkLnByb3RvdHlwZSA9IHtcbiAgICAgICAgZ2V0SXRlcmF0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBnZXRJdGVyYXRvckRpcmVjdChhbk9iamVjdChjYWxsKHRoaXMua2V5cywgdGhpcy5zZXQpKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGluY2x1ZGVzOiBmdW5jdGlvbihpdCkge1xuICAgICAgICAgIHJldHVybiBjYWxsKHRoaXMuaGFzLCB0aGlzLnNldCwgaXQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIGFuT2JqZWN0KG9iaik7XG4gICAgICAgIHZhciBudW1TaXplID0gK29iai5zaXplO1xuICAgICAgICBpZiAobnVtU2l6ZSAhPT0gbnVtU2l6ZSkgdGhyb3cgbmV3ICRUeXBlRXJyb3IoSU5WQUxJRF9TSVpFKTtcbiAgICAgICAgdmFyIGludFNpemUgPSB0b0ludGVnZXJPckluZmluaXR5KG51bVNpemUpO1xuICAgICAgICBpZiAoaW50U2l6ZSA8IDApIHRocm93IG5ldyAkUmFuZ2VFcnJvcihJTlZBTElEX1NJWkUpO1xuICAgICAgICByZXR1cm4gbmV3IFNldFJlY29yZChvYmosIGludFNpemUpO1xuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICAzODM4OiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciBhU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNzA4MCk7XG4gICAgICB2YXIgc2l6ZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDUxNzApO1xuICAgICAgdmFyIGl0ZXJhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig4NDY5KTtcbiAgICAgIHZhciBnZXRTZXRSZWNvcmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigzNzg5KTtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzU3Vic2V0T2Yob3RoZXIpIHtcbiAgICAgICAgdmFyIE8gPSBhU2V0KHRoaXMpO1xuICAgICAgICB2YXIgb3RoZXJSZWMgPSBnZXRTZXRSZWNvcmQob3RoZXIpO1xuICAgICAgICBpZiAoc2l6ZShPKSA+IG90aGVyUmVjLnNpemUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdGUoTywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGlmICghb3RoZXJSZWMuaW5jbHVkZXMoZSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSwgdHJ1ZSkgIT09IGZhbHNlO1xuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICAzODUzOiAoXG4gICAgLyoqKi9cbiAgICAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18yKDY1MTgpO1xuICAgICAgdmFyIGlzRGlzam9pbnRGcm9tID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNDQ0OSk7XG4gICAgICB2YXIgc2V0TWV0aG9kQWNjZXB0U2V0TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDQ5MTYpO1xuICAgICAgdmFyIElOQ09SUkVDVCA9ICFzZXRNZXRob2RBY2NlcHRTZXRMaWtlKFwiaXNEaXNqb2ludEZyb21cIiwgZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiAhcmVzdWx0O1xuICAgICAgfSk7XG4gICAgICAkKHsgdGFyZ2V0OiBcIlNldFwiLCBwcm90bzogdHJ1ZSwgcmVhbDogdHJ1ZSwgZm9yY2VkOiBJTkNPUlJFQ1QgfSwge1xuICAgICAgICBpc0Rpc2pvaW50RnJvbVxuICAgICAgfSk7XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgMzkyNTogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigzNCk7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbihhcmd1bWVudCkge1xuICAgICAgICByZXR1cm4gaXNPYmplY3QoYXJndW1lbnQpIHx8IGFyZ3VtZW50ID09PSBudWxsO1xuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICAzOTcyOiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18yKDM0KTtcbiAgICAgIHZhciAkU3RyaW5nID0gU3RyaW5nO1xuICAgICAgdmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbihhcmd1bWVudCkge1xuICAgICAgICBpZiAoYXJndW1lbnQgPT09IHZvaWQgMCB8fCBpc09iamVjdChhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgICAgICAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoJFN0cmluZyhhcmd1bWVudCkgKyBcIiBpcyBub3QgYW4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgNDA1NTogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgZ2xvYmFsVGhpczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig0NTc2KTtcbiAgICAgIHZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18yKDM0KTtcbiAgICAgIHZhciBkb2N1bWVudDIgPSBnbG9iYWxUaGlzMi5kb2N1bWVudDtcbiAgICAgIHZhciBFWElTVFMgPSBpc09iamVjdChkb2N1bWVudDIpICYmIGlzT2JqZWN0KGRvY3VtZW50Mi5jcmVhdGVFbGVtZW50KTtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KSB7XG4gICAgICAgIHJldHVybiBFWElTVFMgPyBkb2N1bWVudDIuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgNDExNDogKFxuICAgIC8qKiovXG4gICAgKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2NTE4KTtcbiAgICAgIHZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18yKDg5ODEpO1xuICAgICAgdmFyIGxlbmd0aE9mQXJyYXlMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNjE5OCk7XG4gICAgICB2YXIgc2V0QXJyYXlMZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig0NTI3KTtcbiAgICAgIHZhciBkb2VzTm90RXhjZWVkU2FmZUludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2ODM3KTtcbiAgICAgIHZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18yKDkwMzkpO1xuICAgICAgdmFyIElOQ09SUkVDVF9UT19MRU5HVEggPSBmYWlscyhmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtdLnB1c2guY2FsbCh7IGxlbmd0aDogNDI5NDk2NzI5NiB9LCAxKSAhPT0gNDI5NDk2NzI5NztcbiAgICAgIH0pO1xuICAgICAgdmFyIHByb3BlckVycm9yT25Ob25Xcml0YWJsZUxlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShbXSwgXCJsZW5ndGhcIiwgeyB3cml0YWJsZTogZmFsc2UgfSkucHVzaCgpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvcjtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBGT1JDRUQgPSBJTkNPUlJFQ1RfVE9fTEVOR1RIIHx8ICFwcm9wZXJFcnJvck9uTm9uV3JpdGFibGVMZW5ndGgoKTtcbiAgICAgICQoeyB0YXJnZXQ6IFwiQXJyYXlcIiwgcHJvdG86IHRydWUsIGFyaXR5OiAxLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgYC5sZW5ndGhgXG4gICAgICAgIHB1c2g6IGZ1bmN0aW9uIHB1c2goaXRlbSkge1xuICAgICAgICAgIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gICAgICAgICAgdmFyIGxlbiA9IGxlbmd0aE9mQXJyYXlMaWtlKE8pO1xuICAgICAgICAgIHZhciBhcmdDb3VudCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgZG9lc05vdEV4Y2VlZFNhZmVJbnRlZ2VyKGxlbiArIGFyZ0NvdW50KTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ0NvdW50OyBpKyspIHtcbiAgICAgICAgICAgIE9bbGVuXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGxlbisrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXRBcnJheUxlbmd0aChPLCBsZW4pO1xuICAgICAgICAgIHJldHVybiBsZW47XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDQxMTc6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMikgPT4ge1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24oaXQpIHtcbiAgICAgICAgcmV0dXJuIGl0ID09PSBudWxsIHx8IGl0ID09PSB2b2lkIDA7XG4gICAgICB9O1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDQxNDk6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMikgPT4ge1xuICAgICAgdmFyICRSYW5nZUVycm9yID0gUmFuZ2VFcnJvcjtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KSB7XG4gICAgICAgIGlmIChpdCA9PT0gaXQpIHJldHVybiBpdDtcbiAgICAgICAgdGhyb3cgbmV3ICRSYW5nZUVycm9yKFwiTmFOIGlzIG5vdCBhbGxvd2VkXCIpO1xuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA0MTU0OiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNjk1NSk7XG4gICAgICB2YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKGFyZ3VtZW50KSB7XG4gICAgICAgIGlmIChjbGFzc29mKGFyZ3VtZW50KSA9PT0gXCJVaW50OEFycmF5XCIpIHJldHVybiBhcmd1bWVudDtcbiAgICAgICAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoXCJBcmd1bWVudCBpcyBub3QgYW4gVWludDhBcnJheVwiKTtcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgNDIwNDogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgYVNldCA9IF9fd2VicGFja19yZXF1aXJlX18yKDcwODApO1xuICAgICAgdmFyIGFkZCA9IF9fd2VicGFja19yZXF1aXJlX18yKDQ0MDIpLmFkZDtcbiAgICAgIHZhciBjbG9uZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDkyODYpO1xuICAgICAgdmFyIGdldFNldFJlY29yZCA9IF9fd2VicGFja19yZXF1aXJlX18yKDM3ODkpO1xuICAgICAgdmFyIGl0ZXJhdGVTaW1wbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig1MDcpO1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24gdW5pb24ob3RoZXIpIHtcbiAgICAgICAgdmFyIE8gPSBhU2V0KHRoaXMpO1xuICAgICAgICB2YXIga2V5c0l0ZXIgPSBnZXRTZXRSZWNvcmQob3RoZXIpLmdldEl0ZXJhdG9yKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBjbG9uZShPKTtcbiAgICAgICAgaXRlcmF0ZVNpbXBsZShrZXlzSXRlciwgZnVuY3Rpb24oaXQpIHtcbiAgICAgICAgICBhZGQocmVzdWx0LCBpdCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA0MjA5OiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig4MjI3KTtcbiAgICAgIHZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2MjY5KTtcbiAgICAgIHZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbChcIml0ZXJhdG9yXCIpO1xuICAgICAgdmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24oaXQpIHtcbiAgICAgICAgcmV0dXJuIGl0ICE9PSB2b2lkIDAgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b3R5cGVbSVRFUkFUT1JdID09PSBpdCk7XG4gICAgICB9O1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDQyMTU6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMiwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyIGdsb2JhbFRoaXMyID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNDU3Nik7XG4gICAgICB2YXIgdXNlckFnZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMjgzOSk7XG4gICAgICB2YXIgY2xhc3NvZiA9IF9fd2VicGFja19yZXF1aXJlX18yKDIxOTUpO1xuICAgICAgdmFyIHVzZXJBZ2VudFN0YXJ0c1dpdGggPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHVzZXJBZ2VudC5zbGljZSgwLCBzdHJpbmcubGVuZ3RoKSA9PT0gc3RyaW5nO1xuICAgICAgfTtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHVzZXJBZ2VudFN0YXJ0c1dpdGgoXCJCdW4vXCIpKSByZXR1cm4gXCJCVU5cIjtcbiAgICAgICAgaWYgKHVzZXJBZ2VudFN0YXJ0c1dpdGgoXCJDbG91ZGZsYXJlLVdvcmtlcnNcIikpIHJldHVybiBcIkNMT1VERkxBUkVcIjtcbiAgICAgICAgaWYgKHVzZXJBZ2VudFN0YXJ0c1dpdGgoXCJEZW5vL1wiKSkgcmV0dXJuIFwiREVOT1wiO1xuICAgICAgICBpZiAodXNlckFnZW50U3RhcnRzV2l0aChcIk5vZGUuanMvXCIpKSByZXR1cm4gXCJOT0RFXCI7XG4gICAgICAgIGlmIChnbG9iYWxUaGlzMi5CdW4gJiYgdHlwZW9mIEJ1bi52ZXJzaW9uID09IFwic3RyaW5nXCIpIHJldHVybiBcIkJVTlwiO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpczIuRGVubyAmJiB0eXBlb2YgRGVuby52ZXJzaW9uID09IFwib2JqZWN0XCIpIHJldHVybiBcIkRFTk9cIjtcbiAgICAgICAgaWYgKGNsYXNzb2YoZ2xvYmFsVGhpczIucHJvY2VzcykgPT09IFwicHJvY2Vzc1wiKSByZXR1cm4gXCJOT0RFXCI7XG4gICAgICAgIGlmIChnbG9iYWxUaGlzMi53aW5kb3cgJiYgZ2xvYmFsVGhpczIuZG9jdW1lbnQpIHJldHVybiBcIkJST1dTRVJcIjtcbiAgICAgICAgcmV0dXJuIFwiUkVTVFwiO1xuICAgICAgfSkoKTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA0MjI2OiAoXG4gICAgLyoqKi9cbiAgICAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18yKDY1MTgpO1xuICAgICAgdmFyIGdsb2JhbFRoaXMyID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNDU3Nik7XG4gICAgICB2YXIgYVN0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18yKDM0NjMpO1xuICAgICAgdmFyIGFuVWludDhBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18yKDQxNTQpO1xuICAgICAgdmFyIG5vdERldGFjaGVkID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNTE2OSk7XG4gICAgICB2YXIgJGZyb21IZXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigyMzAzKTtcbiAgICAgIGlmIChnbG9iYWxUaGlzMi5VaW50OEFycmF5KSAkKHsgdGFyZ2V0OiBcIlVpbnQ4QXJyYXlcIiwgcHJvdG86IHRydWUgfSwge1xuICAgICAgICBzZXRGcm9tSGV4OiBmdW5jdGlvbiBzZXRGcm9tSGV4KHN0cmluZykge1xuICAgICAgICAgIGFuVWludDhBcnJheSh0aGlzKTtcbiAgICAgICAgICBhU3RyaW5nKHN0cmluZyk7XG4gICAgICAgICAgbm90RGV0YWNoZWQodGhpcy5idWZmZXIpO1xuICAgICAgICAgIHZhciByZWFkID0gJGZyb21IZXgoc3RyaW5nLCB0aGlzKS5yZWFkO1xuICAgICAgICAgIHJldHVybiB7IHJlYWQsIHdyaXR0ZW46IHJlYWQgLyAyIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDQyMzU6IChcbiAgICAvKioqL1xuICAgICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIF9fd2VicGFja19yZXF1aXJlX18yKDMwNjgpO1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDQyNzA6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMiwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyIGNhbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig5NTY1KTtcbiAgICAgIHZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNDkwMSk7XG4gICAgICB2YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigzNCk7XG4gICAgICB2YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKGlucHV0LCBwcmVmKSB7XG4gICAgICAgIHZhciBmbiwgdmFsO1xuICAgICAgICBpZiAocHJlZiA9PT0gXCJzdHJpbmdcIiAmJiBpc0NhbGxhYmxlKGZuID0gaW5wdXQudG9TdHJpbmcpICYmICFpc09iamVjdCh2YWwgPSBjYWxsKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICAgICAgICBpZiAoaXNDYWxsYWJsZShmbiA9IGlucHV0LnZhbHVlT2YpICYmICFpc09iamVjdCh2YWwgPSBjYWxsKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICAgICAgICBpZiAocHJlZiAhPT0gXCJzdHJpbmdcIiAmJiBpc0NhbGxhYmxlKGZuID0gaW5wdXQudG9TdHJpbmcpICYmICFpc09iamVjdCh2YWwgPSBjYWxsKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICAgICAgICB0aHJvdyBuZXcgJFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgNDM3NjogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgY2xhc3NvZiA9IF9fd2VicGFja19yZXF1aXJlX18yKDIxOTUpO1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZ3VtZW50KSB7XG4gICAgICAgIHJldHVybiBjbGFzc29mKGFyZ3VtZW50KSA9PT0gXCJBcnJheVwiO1xuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA0NDAyOiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18yKDk1MDQpO1xuICAgICAgdmFyIFNldFByb3RvdHlwZSA9IFNldC5wcm90b3R5cGU7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1zZXQgLS0gc2FmZVxuICAgICAgICBTZXQsXG4gICAgICAgIGFkZDogdW5jdXJyeVRoaXMoU2V0UHJvdG90eXBlLmFkZCksXG4gICAgICAgIGhhczogdW5jdXJyeVRoaXMoU2V0UHJvdG90eXBlLmhhcyksXG4gICAgICAgIHJlbW92ZTogdW5jdXJyeVRoaXMoU2V0UHJvdG90eXBlW1wiZGVsZXRlXCJdKSxcbiAgICAgICAgcHJvdG86IFNldFByb3RvdHlwZVxuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA0NDQ5OiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciBhU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNzA4MCk7XG4gICAgICB2YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNDQwMikuaGFzO1xuICAgICAgdmFyIHNpemUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig1MTcwKTtcbiAgICAgIHZhciBnZXRTZXRSZWNvcmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigzNzg5KTtcbiAgICAgIHZhciBpdGVyYXRlU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoODQ2OSk7XG4gICAgICB2YXIgaXRlcmF0ZVNpbXBsZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDUwNyk7XG4gICAgICB2YXIgaXRlcmF0b3JDbG9zZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDk1MzkpO1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24gaXNEaXNqb2ludEZyb20ob3RoZXIpIHtcbiAgICAgICAgdmFyIE8gPSBhU2V0KHRoaXMpO1xuICAgICAgICB2YXIgb3RoZXJSZWMgPSBnZXRTZXRSZWNvcmQob3RoZXIpO1xuICAgICAgICBpZiAoc2l6ZShPKSA8PSBvdGhlclJlYy5zaXplKSByZXR1cm4gaXRlcmF0ZVNldChPLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgaWYgKG90aGVyUmVjLmluY2x1ZGVzKGUpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sIHRydWUpICE9PSBmYWxzZTtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gb3RoZXJSZWMuZ2V0SXRlcmF0b3IoKTtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdGVTaW1wbGUoaXRlcmF0b3IsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBpZiAoaGFzKE8sIGUpKSByZXR1cm4gaXRlcmF0b3JDbG9zZShpdGVyYXRvciwgXCJub3JtYWxcIiwgZmFsc2UpO1xuICAgICAgICB9KSAhPT0gZmFsc2U7XG4gICAgICB9O1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDQ0ODM6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMiwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyIGdsb2JhbFRoaXMyID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNDU3Nik7XG4gICAgICB2YXIgZ2V0QnVpbHRJbk5vZGVNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig5NDI5KTtcbiAgICAgIHZhciBQUk9QRVJfU1RSVUNUVVJFRF9DTE9ORV9UUkFOU0ZFUiA9IF9fd2VicGFja19yZXF1aXJlX18yKDE1NDgpO1xuICAgICAgdmFyIHN0cnVjdHVyZWRDbG9uZTIgPSBnbG9iYWxUaGlzMi5zdHJ1Y3R1cmVkQ2xvbmU7XG4gICAgICB2YXIgJEFycmF5QnVmZmVyID0gZ2xvYmFsVGhpczIuQXJyYXlCdWZmZXI7XG4gICAgICB2YXIgJE1lc3NhZ2VDaGFubmVsID0gZ2xvYmFsVGhpczIuTWVzc2FnZUNoYW5uZWw7XG4gICAgICB2YXIgZGV0YWNoID0gZmFsc2U7XG4gICAgICB2YXIgV29ya2VyVGhyZWFkcywgY2hhbm5lbCwgYnVmZmVyLCAkZGV0YWNoO1xuICAgICAgaWYgKFBST1BFUl9TVFJVQ1RVUkVEX0NMT05FX1RSQU5TRkVSKSB7XG4gICAgICAgIGRldGFjaCA9IGZ1bmN0aW9uKHRyYW5zZmVyYWJsZSkge1xuICAgICAgICAgIHN0cnVjdHVyZWRDbG9uZTIodHJhbnNmZXJhYmxlLCB7IHRyYW5zZmVyOiBbdHJhbnNmZXJhYmxlXSB9KTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoJEFycmF5QnVmZmVyKSB0cnkge1xuICAgICAgICBpZiAoISRNZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAgIFdvcmtlclRocmVhZHMgPSBnZXRCdWlsdEluTm9kZU1vZHVsZShcIndvcmtlcl90aHJlYWRzXCIpO1xuICAgICAgICAgIGlmIChXb3JrZXJUaHJlYWRzKSAkTWVzc2FnZUNoYW5uZWwgPSBXb3JrZXJUaHJlYWRzLk1lc3NhZ2VDaGFubmVsO1xuICAgICAgICB9XG4gICAgICAgIGlmICgkTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgICBjaGFubmVsID0gbmV3ICRNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICAgIGJ1ZmZlciA9IG5ldyAkQXJyYXlCdWZmZXIoMik7XG4gICAgICAgICAgJGRldGFjaCA9IGZ1bmN0aW9uKHRyYW5zZmVyYWJsZSkge1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0MS5wb3N0TWVzc2FnZShudWxsLCBbdHJhbnNmZXJhYmxlXSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoYnVmZmVyLmJ5dGVMZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICRkZXRhY2goYnVmZmVyKTtcbiAgICAgICAgICAgIGlmIChidWZmZXIuYnl0ZUxlbmd0aCA9PT0gMCkgZGV0YWNoID0gJGRldGFjaDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB9XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBkZXRhY2g7XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgNDQ5NTogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgVjhfVkVSU0lPTiA9IF9fd2VicGFja19yZXF1aXJlX18yKDk1MTkpO1xuICAgICAgdmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoOTAzOSk7XG4gICAgICB2YXIgZ2xvYmFsVGhpczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig0NTc2KTtcbiAgICAgIHZhciAkU3RyaW5nID0gZ2xvYmFsVGhpczIuU3RyaW5nO1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gISFPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICYmICFmYWlscyhmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN5bWJvbCA9IFN5bWJvbChcInN5bWJvbCBkZXRlY3Rpb25cIik7XG4gICAgICAgIHJldHVybiAhJFN0cmluZyhzeW1ib2wpIHx8ICEoT2JqZWN0KHN5bWJvbCkgaW5zdGFuY2VvZiBTeW1ib2wpIHx8IC8vIENocm9tZSAzOC00MCBzeW1ib2xzIGFyZSBub3QgaW5oZXJpdGVkIGZyb20gRE9NIGNvbGxlY3Rpb25zIHByb3RvdHlwZXMgdG8gaW5zdGFuY2VzXG4gICAgICAgICFTeW1ib2wuc2hhbSAmJiBWOF9WRVJTSU9OICYmIFY4X1ZFUlNJT04gPCA0MTtcbiAgICAgIH0pO1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDQ1Mjc6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMiwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMzcyNCk7XG4gICAgICB2YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18yKDQzNzYpO1xuICAgICAgdmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG4gICAgICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgICAgIHZhciBTSUxFTlRfT05fTk9OX1dSSVRBQkxFX0xFTkdUSF9TRVQgPSBERVNDUklQVE9SUyAmJiAhKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcyAhPT0gdm9pZCAwKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoW10sIFwibGVuZ3RoXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pLmxlbmd0aCA9IDE7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yO1xuICAgICAgICB9XG4gICAgICB9KSgpO1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gU0lMRU5UX09OX05PTl9XUklUQUJMRV9MRU5HVEhfU0VUID8gZnVuY3Rpb24oTywgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChpc0FycmF5KE8pICYmICFnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgXCJsZW5ndGhcIikud3JpdGFibGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgJFR5cGVFcnJvcihcIkNhbm5vdCBzZXQgcmVhZCBvbmx5IC5sZW5ndGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE8ubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgfSA6IGZ1bmN0aW9uKE8sIGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gTy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICB9O1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDQ1NDk6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMiwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyIGdsb2JhbFRoaXMyID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNDU3Nik7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbihNRVRIT0RfTkFNRSwgRXhwZWN0ZWRFcnJvcikge1xuICAgICAgICB2YXIgSXRlcmF0b3IyID0gZ2xvYmFsVGhpczIuSXRlcmF0b3I7XG4gICAgICAgIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IEl0ZXJhdG9yMiAmJiBJdGVyYXRvcjIucHJvdG90eXBlO1xuICAgICAgICB2YXIgbWV0aG9kID0gSXRlcmF0b3JQcm90b3R5cGUgJiYgSXRlcmF0b3JQcm90b3R5cGVbTUVUSE9EX05BTUVdO1xuICAgICAgICB2YXIgQ0xPU0VEID0gZmFsc2U7XG4gICAgICAgIGlmIChtZXRob2QpIHRyeSB7XG4gICAgICAgICAgbWV0aG9kLmNhbGwoe1xuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInJldHVyblwiOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgQ0xPU0VEID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAtMSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgaWYgKCEoZXJyb3IgaW5zdGFuY2VvZiBFeHBlY3RlZEVycm9yKSkgQ0xPU0VEID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFDTE9TRUQpIHJldHVybiBtZXRob2Q7XG4gICAgICB9O1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDQ1NzY6IChcbiAgICAvKioqL1xuICAgIChmdW5jdGlvbihtb2R1bGUyKSB7XG4gICAgICB2YXIgY2hlY2sgPSBmdW5jdGlvbihpdCkge1xuICAgICAgICByZXR1cm4gaXQgJiYgaXQuTWF0aCA9PT0gTWF0aCAmJiBpdDtcbiAgICAgIH07XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tZ2xvYmFsLXRoaXMgLS0gc2FmZVxuICAgICAgY2hlY2sodHlwZW9mIGdsb2JhbFRoaXMgPT0gXCJvYmplY3RcIiAmJiBnbG9iYWxUaGlzKSB8fCBjaGVjayh0eXBlb2Ygd2luZG93ID09IFwib2JqZWN0XCIgJiYgd2luZG93KSB8fCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzIC0tIHNhZmVcbiAgICAgIGNoZWNrKHR5cGVvZiBzZWxmID09IFwib2JqZWN0XCIgJiYgc2VsZikgfHwgY2hlY2sodHlwZW9mIGdsb2JhbCA9PSBcIm9iamVjdFwiICYmIGdsb2JhbCkgfHwgY2hlY2sodHlwZW9mIHRoaXMgPT0gXCJvYmplY3RcIiAmJiB0aGlzKSB8fCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmMgLS0gZmFsbGJhY2tcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSkoKSB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgNDYwMzogKFxuICAgIC8qKiovXG4gICAgKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyIGRlZmluZUJ1aWx0SW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2ODQwKTtcbiAgICAgIHZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18yKDk1MDQpO1xuICAgICAgdmFyIHRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNjU1KTtcbiAgICAgIHZhciB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18yKDI4MTIpO1xuICAgICAgdmFyICRVUkxTZWFyY2hQYXJhbXMgPSBVUkxTZWFyY2hQYXJhbXM7XG4gICAgICB2YXIgVVJMU2VhcmNoUGFyYW1zUHJvdG90eXBlID0gJFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGU7XG4gICAgICB2YXIgYXBwZW5kID0gdW5jdXJyeVRoaXMoVVJMU2VhcmNoUGFyYW1zUHJvdG90eXBlLmFwcGVuZCk7XG4gICAgICB2YXIgJGRlbGV0ZSA9IHVuY3VycnlUaGlzKFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZVtcImRlbGV0ZVwiXSk7XG4gICAgICB2YXIgZm9yRWFjaCA9IHVuY3VycnlUaGlzKFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZS5mb3JFYWNoKTtcbiAgICAgIHZhciBwdXNoID0gdW5jdXJyeVRoaXMoW10ucHVzaCk7XG4gICAgICB2YXIgcGFyYW1zID0gbmV3ICRVUkxTZWFyY2hQYXJhbXMoXCJhPTEmYT0yJmI9M1wiKTtcbiAgICAgIHBhcmFtc1tcImRlbGV0ZVwiXShcImFcIiwgMSk7XG4gICAgICBwYXJhbXNbXCJkZWxldGVcIl0oXCJiXCIsIHZvaWQgMCk7XG4gICAgICBpZiAocGFyYW1zICsgXCJcIiAhPT0gXCJhPTJcIikge1xuICAgICAgICBkZWZpbmVCdWlsdEluKFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZSwgXCJkZWxldGVcIiwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgIHZhciAkdmFsdWUgPSBsZW5ndGggPCAyID8gdm9pZCAwIDogYXJndW1lbnRzWzFdO1xuICAgICAgICAgIGlmIChsZW5ndGggJiYgJHZhbHVlID09PSB2b2lkIDApIHJldHVybiAkZGVsZXRlKHRoaXMsIG5hbWUpO1xuICAgICAgICAgIHZhciBlbnRyaWVzID0gW107XG4gICAgICAgICAgZm9yRWFjaCh0aGlzLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICBwdXNoKGVudHJpZXMsIHsga2V5OiBrLCB2YWx1ZTogdiB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aChsZW5ndGgsIDEpO1xuICAgICAgICAgIHZhciBrZXkgPSB0b1N0cmluZyhuYW1lKTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB0b1N0cmluZygkdmFsdWUpO1xuICAgICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgICAgdmFyIGRpbmRleCA9IDA7XG4gICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgdmFyIGVudHJpZXNMZW5ndGggPSBlbnRyaWVzLmxlbmd0aDtcbiAgICAgICAgICB2YXIgZW50cnk7XG4gICAgICAgICAgd2hpbGUgKGluZGV4IDwgZW50cmllc0xlbmd0aCkge1xuICAgICAgICAgICAgZW50cnkgPSBlbnRyaWVzW2luZGV4KytdO1xuICAgICAgICAgICAgaWYgKGZvdW5kIHx8IGVudHJ5LmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgJGRlbGV0ZSh0aGlzLCBlbnRyeS5rZXkpO1xuICAgICAgICAgICAgfSBlbHNlIGRpbmRleCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoZGluZGV4IDwgZW50cmllc0xlbmd0aCkge1xuICAgICAgICAgICAgZW50cnkgPSBlbnRyaWVzW2RpbmRleCsrXTtcbiAgICAgICAgICAgIGlmICghKGVudHJ5LmtleSA9PT0ga2V5ICYmIGVudHJ5LnZhbHVlID09PSB2YWx1ZSkpIGFwcGVuZCh0aGlzLCBlbnRyeS5rZXksIGVudHJ5LnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHsgZW51bWVyYWJsZTogdHJ1ZSwgdW5zYWZlOiB0cnVlIH0pO1xuICAgICAgfVxuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDQ2Mjg6IChcbiAgICAvKioqL1xuICAgICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNjUxOCk7XG4gICAgICB2YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2MDQzKTtcbiAgICAgICQoeyB0YXJnZXQ6IFwiUHJvbWlzZVwiLCBzdGF0OiB0cnVlIH0sIHtcbiAgICAgICAgd2l0aFJlc29sdmVyczogZnVuY3Rpb24gd2l0aFJlc29sdmVycygpIHtcbiAgICAgICAgICB2YXIgcHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mKHRoaXMpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcm9taXNlOiBwcm9taXNlQ2FwYWJpbGl0eS5wcm9taXNlLFxuICAgICAgICAgICAgcmVzb2x2ZTogcHJvbWlzZUNhcGFiaWxpdHkucmVzb2x2ZSxcbiAgICAgICAgICAgIHJlamVjdDogcHJvbWlzZUNhcGFiaWxpdHkucmVqZWN0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgNDY0NDogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgTkFUSVZFX0FSUkFZX0JVRkZFUiA9IF9fd2VicGFja19yZXF1aXJlX18yKDc4MTEpO1xuICAgICAgdmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMzcyNCk7XG4gICAgICB2YXIgZ2xvYmFsVGhpczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig0NTc2KTtcbiAgICAgIHZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNDkwMSk7XG4gICAgICB2YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigzNCk7XG4gICAgICB2YXIgaGFzT3duID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoOTI5Nyk7XG4gICAgICB2YXIgY2xhc3NvZiA9IF9fd2VicGFja19yZXF1aXJlX18yKDY5NTUpO1xuICAgICAgdmFyIHRyeVRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNjgyMyk7XG4gICAgICB2YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNjY5OSk7XG4gICAgICB2YXIgZGVmaW5lQnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18yKDY4NDApO1xuICAgICAgdmFyIGRlZmluZUJ1aWx0SW5BY2Nlc3NvciA9IF9fd2VicGFja19yZXF1aXJlX18yKDIxMDYpO1xuICAgICAgdmFyIGlzUHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigxNjI1KTtcbiAgICAgIHZhciBnZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18yKDI3ODcpO1xuICAgICAgdmFyIHNldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMjk2Nyk7XG4gICAgICB2YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoODIyNyk7XG4gICAgICB2YXIgdWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMzM5Mik7XG4gICAgICB2YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDExODEpO1xuICAgICAgdmFyIGVuZm9yY2VJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5lbmZvcmNlO1xuICAgICAgdmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldDtcbiAgICAgIHZhciBJbnQ4QXJyYXkyID0gZ2xvYmFsVGhpczIuSW50OEFycmF5O1xuICAgICAgdmFyIEludDhBcnJheVByb3RvdHlwZSA9IEludDhBcnJheTIgJiYgSW50OEFycmF5Mi5wcm90b3R5cGU7XG4gICAgICB2YXIgVWludDhDbGFtcGVkQXJyYXkyID0gZ2xvYmFsVGhpczIuVWludDhDbGFtcGVkQXJyYXk7XG4gICAgICB2YXIgVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUgPSBVaW50OENsYW1wZWRBcnJheTIgJiYgVWludDhDbGFtcGVkQXJyYXkyLnByb3RvdHlwZTtcbiAgICAgIHZhciBUeXBlZEFycmF5ID0gSW50OEFycmF5MiAmJiBnZXRQcm90b3R5cGVPZihJbnQ4QXJyYXkyKTtcbiAgICAgIHZhciBUeXBlZEFycmF5UHJvdG90eXBlID0gSW50OEFycmF5UHJvdG90eXBlICYmIGdldFByb3RvdHlwZU9mKEludDhBcnJheVByb3RvdHlwZSk7XG4gICAgICB2YXIgT2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgICAgIHZhciBUeXBlRXJyb3IyID0gZ2xvYmFsVGhpczIuVHlwZUVycm9yO1xuICAgICAgdmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woXCJ0b1N0cmluZ1RhZ1wiKTtcbiAgICAgIHZhciBUWVBFRF9BUlJBWV9UQUcgPSB1aWQoXCJUWVBFRF9BUlJBWV9UQUdcIik7XG4gICAgICB2YXIgVFlQRURfQVJSQVlfQ09OU1RSVUNUT1IgPSBcIlR5cGVkQXJyYXlDb25zdHJ1Y3RvclwiO1xuICAgICAgdmFyIE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgPSBOQVRJVkVfQVJSQVlfQlVGRkVSICYmICEhc2V0UHJvdG90eXBlT2YgJiYgY2xhc3NvZihnbG9iYWxUaGlzMi5vcGVyYSkgIT09IFwiT3BlcmFcIjtcbiAgICAgIHZhciBUWVBFRF9BUlJBWV9UQUdfUkVRVUlSRUQgPSBmYWxzZTtcbiAgICAgIHZhciBOQU1FLCBDb25zdHJ1Y3RvciwgUHJvdG90eXBlO1xuICAgICAgdmFyIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0ID0ge1xuICAgICAgICBJbnQ4QXJyYXk6IDEsXG4gICAgICAgIFVpbnQ4QXJyYXk6IDEsXG4gICAgICAgIFVpbnQ4Q2xhbXBlZEFycmF5OiAxLFxuICAgICAgICBJbnQxNkFycmF5OiAyLFxuICAgICAgICBVaW50MTZBcnJheTogMixcbiAgICAgICAgSW50MzJBcnJheTogNCxcbiAgICAgICAgVWludDMyQXJyYXk6IDQsXG4gICAgICAgIEZsb2F0MzJBcnJheTogNCxcbiAgICAgICAgRmxvYXQ2NEFycmF5OiA4XG4gICAgICB9O1xuICAgICAgdmFyIEJpZ0ludEFycmF5Q29uc3RydWN0b3JzTGlzdCA9IHtcbiAgICAgICAgQmlnSW50NjRBcnJheTogOCxcbiAgICAgICAgQmlnVWludDY0QXJyYXk6IDhcbiAgICAgIH07XG4gICAgICB2YXIgaXNWaWV3ID0gZnVuY3Rpb24gaXNWaWV3MihpdCkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIga2xhc3MgPSBjbGFzc29mKGl0KTtcbiAgICAgICAgcmV0dXJuIGtsYXNzID09PSBcIkRhdGFWaWV3XCIgfHwgaGFzT3duKFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0LCBrbGFzcykgfHwgaGFzT3duKEJpZ0ludEFycmF5Q29uc3RydWN0b3JzTGlzdCwga2xhc3MpO1xuICAgICAgfTtcbiAgICAgIHZhciBnZXRUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBmdW5jdGlvbihpdCkge1xuICAgICAgICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGVPZihpdCk7XG4gICAgICAgIGlmICghaXNPYmplY3QocHJvdG8pKSByZXR1cm47XG4gICAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUocHJvdG8pO1xuICAgICAgICByZXR1cm4gc3RhdGUgJiYgaGFzT3duKHN0YXRlLCBUWVBFRF9BUlJBWV9DT05TVFJVQ1RPUikgPyBzdGF0ZVtUWVBFRF9BUlJBWV9DT05TVFJVQ1RPUl0gOiBnZXRUeXBlZEFycmF5Q29uc3RydWN0b3IocHJvdG8pO1xuICAgICAgfTtcbiAgICAgIHZhciBpc1R5cGVkQXJyYXkgPSBmdW5jdGlvbihpdCkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIga2xhc3MgPSBjbGFzc29mKGl0KTtcbiAgICAgICAgcmV0dXJuIGhhc093bihUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCwga2xhc3MpIHx8IGhhc093bihCaWdJbnRBcnJheUNvbnN0cnVjdG9yc0xpc3QsIGtsYXNzKTtcbiAgICAgIH07XG4gICAgICB2YXIgYVR5cGVkQXJyYXkgPSBmdW5jdGlvbihpdCkge1xuICAgICAgICBpZiAoaXNUeXBlZEFycmF5KGl0KSkgcmV0dXJuIGl0O1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yMihcIlRhcmdldCBpcyBub3QgYSB0eXBlZCBhcnJheVwiKTtcbiAgICAgIH07XG4gICAgICB2YXIgYVR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKEMpIHtcbiAgICAgICAgaWYgKGlzQ2FsbGFibGUoQykgJiYgKCFzZXRQcm90b3R5cGVPZiB8fCBpc1Byb3RvdHlwZU9mKFR5cGVkQXJyYXksIEMpKSkgcmV0dXJuIEM7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IyKHRyeVRvU3RyaW5nKEMpICsgXCIgaXMgbm90IGEgdHlwZWQgYXJyYXkgY29uc3RydWN0b3JcIik7XG4gICAgICB9O1xuICAgICAgdmFyIGV4cG9ydFR5cGVkQXJyYXlNZXRob2QgPSBmdW5jdGlvbihLRVksIHByb3BlcnR5LCBmb3JjZWQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFERVNDUklQVE9SUykgcmV0dXJuO1xuICAgICAgICBpZiAoZm9yY2VkKSBmb3IgKHZhciBBUlJBWSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICAgICAgICAgIHZhciBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBnbG9iYWxUaGlzMltBUlJBWV07XG4gICAgICAgICAgaWYgKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciAmJiBoYXNPd24oVHlwZWRBcnJheUNvbnN0cnVjdG9yLnByb3RvdHlwZSwgS0VZKSkgdHJ5IHtcbiAgICAgICAgICAgIGRlbGV0ZSBUeXBlZEFycmF5Q29uc3RydWN0b3IucHJvdG90eXBlW0tFWV07XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5wcm90b3R5cGVbS0VZXSA9IHByb3BlcnR5O1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghVHlwZWRBcnJheVByb3RvdHlwZVtLRVldIHx8IGZvcmNlZCkge1xuICAgICAgICAgIGRlZmluZUJ1aWx0SW4oVHlwZWRBcnJheVByb3RvdHlwZSwgS0VZLCBmb3JjZWQgPyBwcm9wZXJ0eSA6IE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgJiYgSW50OEFycmF5UHJvdG90eXBlW0tFWV0gfHwgcHJvcGVydHksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdmFyIGV4cG9ydFR5cGVkQXJyYXlTdGF0aWNNZXRob2QgPSBmdW5jdGlvbihLRVksIHByb3BlcnR5LCBmb3JjZWQpIHtcbiAgICAgICAgdmFyIEFSUkFZLCBUeXBlZEFycmF5Q29uc3RydWN0b3I7XG4gICAgICAgIGlmICghREVTQ1JJUFRPUlMpIHJldHVybjtcbiAgICAgICAgaWYgKHNldFByb3RvdHlwZU9mKSB7XG4gICAgICAgICAgaWYgKGZvcmNlZCkgZm9yIChBUlJBWSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICAgICAgICAgICAgVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gZ2xvYmFsVGhpczJbQVJSQVldO1xuICAgICAgICAgICAgaWYgKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciAmJiBoYXNPd24oVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBLRVkpKSB0cnkge1xuICAgICAgICAgICAgICBkZWxldGUgVHlwZWRBcnJheUNvbnN0cnVjdG9yW0tFWV07XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIVR5cGVkQXJyYXlbS0VZXSB8fCBmb3JjZWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBkZWZpbmVCdWlsdEluKFR5cGVkQXJyYXksIEtFWSwgZm9yY2VkID8gcHJvcGVydHkgOiBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTICYmIFR5cGVkQXJyYXlbS0VZXSB8fCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChBUlJBWSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICAgICAgICAgIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGdsb2JhbFRoaXMyW0FSUkFZXTtcbiAgICAgICAgICBpZiAoVHlwZWRBcnJheUNvbnN0cnVjdG9yICYmICghVHlwZWRBcnJheUNvbnN0cnVjdG9yW0tFWV0gfHwgZm9yY2VkKSkge1xuICAgICAgICAgICAgZGVmaW5lQnVpbHRJbihUeXBlZEFycmF5Q29uc3RydWN0b3IsIEtFWSwgcHJvcGVydHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGZvciAoTkFNRSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICAgICAgICBDb25zdHJ1Y3RvciA9IGdsb2JhbFRoaXMyW05BTUVdO1xuICAgICAgICBQcm90b3R5cGUgPSBDb25zdHJ1Y3RvciAmJiBDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgICAgIGlmIChQcm90b3R5cGUpIGVuZm9yY2VJbnRlcm5hbFN0YXRlKFByb3RvdHlwZSlbVFlQRURfQVJSQVlfQ09OU1RSVUNUT1JdID0gQ29uc3RydWN0b3I7XG4gICAgICAgIGVsc2UgTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgZm9yIChOQU1FIGluIEJpZ0ludEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICAgICAgICBDb25zdHJ1Y3RvciA9IGdsb2JhbFRoaXMyW05BTUVdO1xuICAgICAgICBQcm90b3R5cGUgPSBDb25zdHJ1Y3RvciAmJiBDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgICAgIGlmIChQcm90b3R5cGUpIGVuZm9yY2VJbnRlcm5hbFN0YXRlKFByb3RvdHlwZSlbVFlQRURfQVJSQVlfQ09OU1RSVUNUT1JdID0gQ29uc3RydWN0b3I7XG4gICAgICB9XG4gICAgICBpZiAoIU5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgfHwgIWlzQ2FsbGFibGUoVHlwZWRBcnJheSkgfHwgVHlwZWRBcnJheSA9PT0gRnVuY3Rpb24ucHJvdG90eXBlKSB7XG4gICAgICAgIFR5cGVkQXJyYXkgPSBmdW5jdGlvbiBUeXBlZEFycmF5MigpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yMihcIkluY29ycmVjdCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUykgZm9yIChOQU1FIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG4gICAgICAgICAgaWYgKGdsb2JhbFRoaXMyW05BTUVdKSBzZXRQcm90b3R5cGVPZihnbG9iYWxUaGlzMltOQU1FXSwgVHlwZWRBcnJheSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyB8fCAhVHlwZWRBcnJheVByb3RvdHlwZSB8fCBUeXBlZEFycmF5UHJvdG90eXBlID09PSBPYmplY3RQcm90b3R5cGUpIHtcbiAgICAgICAgVHlwZWRBcnJheVByb3RvdHlwZSA9IFR5cGVkQXJyYXkucHJvdG90eXBlO1xuICAgICAgICBpZiAoTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUykgZm9yIChOQU1FIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG4gICAgICAgICAgaWYgKGdsb2JhbFRoaXMyW05BTUVdKSBzZXRQcm90b3R5cGVPZihnbG9iYWxUaGlzMltOQU1FXS5wcm90b3R5cGUsIFR5cGVkQXJyYXlQcm90b3R5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyAmJiBnZXRQcm90b3R5cGVPZihVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSkgIT09IFR5cGVkQXJyYXlQcm90b3R5cGUpIHtcbiAgICAgICAgc2V0UHJvdG90eXBlT2YoVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUsIFR5cGVkQXJyYXlQcm90b3R5cGUpO1xuICAgICAgfVxuICAgICAgaWYgKERFU0NSSVBUT1JTICYmICFoYXNPd24oVHlwZWRBcnJheVByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRykpIHtcbiAgICAgICAgVFlQRURfQVJSQVlfVEFHX1JFUVVJUkVEID0gdHJ1ZTtcbiAgICAgICAgZGVmaW5lQnVpbHRJbkFjY2Vzc29yKFR5cGVkQXJyYXlQcm90b3R5cGUsIFRPX1NUUklOR19UQUcsIHtcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBpc09iamVjdCh0aGlzKSA/IHRoaXNbVFlQRURfQVJSQVlfVEFHXSA6IHZvaWQgMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKE5BTUUgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIGlmIChnbG9iYWxUaGlzMltOQU1FXSkge1xuICAgICAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShnbG9iYWxUaGlzMltOQU1FXSwgVFlQRURfQVJSQVlfVEFHLCBOQU1FKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbW9kdWxlMi5leHBvcnRzID0ge1xuICAgICAgICBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTLFxuICAgICAgICBUWVBFRF9BUlJBWV9UQUc6IFRZUEVEX0FSUkFZX1RBR19SRVFVSVJFRCAmJiBUWVBFRF9BUlJBWV9UQUcsXG4gICAgICAgIGFUeXBlZEFycmF5LFxuICAgICAgICBhVHlwZWRBcnJheUNvbnN0cnVjdG9yLFxuICAgICAgICBleHBvcnRUeXBlZEFycmF5TWV0aG9kLFxuICAgICAgICBleHBvcnRUeXBlZEFycmF5U3RhdGljTWV0aG9kLFxuICAgICAgICBnZXRUeXBlZEFycmF5Q29uc3RydWN0b3IsXG4gICAgICAgIGlzVmlldyxcbiAgICAgICAgaXNUeXBlZEFycmF5LFxuICAgICAgICBUeXBlZEFycmF5LFxuICAgICAgICBUeXBlZEFycmF5UHJvdG90eXBlXG4gICAgICB9O1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDQ2NTk6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMiwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMzcyNCk7XG4gICAgICB2YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig0OTEzKTtcbiAgICAgIHZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2OTgwKTtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoREVTQ1JJUFRPUlMpIGRlZmluZVByb3BlcnR5TW9kdWxlLmYob2JqZWN0LCBrZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigwLCB2YWx1ZSkpO1xuICAgICAgICBlbHNlIG9iamVjdFtrZXldID0gdmFsdWU7XG4gICAgICB9O1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDQ5MDE6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMikgPT4ge1xuICAgICAgdmFyIGRvY3VtZW50QWxsID0gdHlwZW9mIGRvY3VtZW50ID09IFwib2JqZWN0XCIgJiYgZG9jdW1lbnQuYWxsO1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gdHlwZW9mIGRvY3VtZW50QWxsID09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRBbGwgIT09IHZvaWQgMCA/IGZ1bmN0aW9uKGFyZ3VtZW50KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgYXJndW1lbnQgPT0gXCJmdW5jdGlvblwiIHx8IGFyZ3VtZW50ID09PSBkb2N1bWVudEFsbDtcbiAgICAgIH0gOiBmdW5jdGlvbihhcmd1bWVudCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGFyZ3VtZW50ID09IFwiZnVuY3Rpb25cIjtcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgNDkxMzogKFxuICAgIC8qKiovXG4gICAgKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0czIsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigzNzI0KTtcbiAgICAgIHZhciBJRThfRE9NX0RFRklORSA9IF9fd2VicGFja19yZXF1aXJlX18yKDU5MTcpO1xuICAgICAgdmFyIFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoODY4Nik7XG4gICAgICB2YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig4NTUxKTtcbiAgICAgIHZhciB0b1Byb3BlcnR5S2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNjk2OSk7XG4gICAgICB2YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbiAgICAgIHZhciAkZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4gICAgICB2YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICAgICB2YXIgRU5VTUVSQUJMRSA9IFwiZW51bWVyYWJsZVwiO1xuICAgICAgdmFyIENPTkZJR1VSQUJMRSA9IFwiY29uZmlndXJhYmxlXCI7XG4gICAgICB2YXIgV1JJVEFCTEUgPSBcIndyaXRhYmxlXCI7XG4gICAgICBleHBvcnRzMi5mID0gREVTQ1JJUFRPUlMgPyBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA/IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgYW5PYmplY3QoTyk7XG4gICAgICAgIFAgPSB0b1Byb3BlcnR5S2V5KFApO1xuICAgICAgICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgICAgICAgaWYgKHR5cGVvZiBPID09PSBcImZ1bmN0aW9uXCIgJiYgUCA9PT0gXCJwcm90b3R5cGVcIiAmJiBcInZhbHVlXCIgaW4gQXR0cmlidXRlcyAmJiBXUklUQUJMRSBpbiBBdHRyaWJ1dGVzICYmICFBdHRyaWJ1dGVzW1dSSVRBQkxFXSkge1xuICAgICAgICAgIHZhciBjdXJyZW50ID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKTtcbiAgICAgICAgICBpZiAoY3VycmVudCAmJiBjdXJyZW50W1dSSVRBQkxFXSkge1xuICAgICAgICAgICAgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gICAgICAgICAgICBBdHRyaWJ1dGVzID0ge1xuICAgICAgICAgICAgICBjb25maWd1cmFibGU6IENPTkZJR1VSQUJMRSBpbiBBdHRyaWJ1dGVzID8gQXR0cmlidXRlc1tDT05GSUdVUkFCTEVdIDogY3VycmVudFtDT05GSUdVUkFCTEVdLFxuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBFTlVNRVJBQkxFIGluIEF0dHJpYnV0ZXMgPyBBdHRyaWJ1dGVzW0VOVU1FUkFCTEVdIDogY3VycmVudFtFTlVNRVJBQkxFXSxcbiAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xuICAgICAgfSA6ICRkZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgYW5PYmplY3QoTyk7XG4gICAgICAgIFAgPSB0b1Byb3BlcnR5S2V5KFApO1xuICAgICAgICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgICAgICAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgICAgICAgIHJldHVybiAkZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwiZ2V0XCIgaW4gQXR0cmlidXRlcyB8fCBcInNldFwiIGluIEF0dHJpYnV0ZXMpIHRocm93IG5ldyAkVHlwZUVycm9yKFwiQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgIGlmIChcInZhbHVlXCIgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gICAgICAgIHJldHVybiBPO1xuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA0OTE2OiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciBnZXRCdWlsdEluID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNzc1MSk7XG4gICAgICB2YXIgY3JlYXRlU2V0TGlrZSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzaXplLFxuICAgICAgICAgIGhhczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBrZXlzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgdmFyIGNyZWF0ZVNldExpa2VXaXRoSW5maW5pdHlTaXplID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNpemUsXG4gICAgICAgICAgaGFzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAga2V5czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgU2V0MiA9IGdldEJ1aWx0SW4oXCJTZXRcIik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbmV3IFNldDIoKVtuYW1lXShjcmVhdGVTZXRMaWtlKDApKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmV3IFNldDIoKVtuYW1lXShjcmVhdGVTZXRMaWtlKC0xKSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICAgICAgICBpZiAoIWNhbGxiYWNrKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIG5ldyBTZXQyKClbbmFtZV0oY3JlYXRlU2V0TGlrZVdpdGhJbmZpbml0eVNpemUoLUluZmluaXR5KSk7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIHZhciBzZXQgPSBuZXcgU2V0MigpO1xuICAgICAgICAgICAgICBzZXQuYWRkKDEpO1xuICAgICAgICAgICAgICBzZXQuYWRkKDIpO1xuICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soc2V0W25hbWVdKGNyZWF0ZVNldExpa2VXaXRoSW5maW5pdHlTaXplKEluZmluaXR5KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgNDk3MjogKFxuICAgIC8qKiovXG4gICAgKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2NTE4KTtcbiAgICAgIHZhciBjYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoOTU2NSk7XG4gICAgICB2YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig4NTUxKTtcbiAgICAgIHZhciBnZXRJdGVyYXRvckRpcmVjdCA9IF9fd2VicGFja19yZXF1aXJlX18yKDE3NjcpO1xuICAgICAgdmFyIG5vdEFOYU4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig0MTQ5KTtcbiAgICAgIHZhciB0b1Bvc2l0aXZlSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18yKDk1OTApO1xuICAgICAgdmFyIGNyZWF0ZUl0ZXJhdG9yUHJveHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig5NDYyKTtcbiAgICAgIHZhciBpdGVyYXRvckNsb3NlID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoOTUzOSk7XG4gICAgICB2YXIgaXRlcmF0b3JIZWxwZXJXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18yKDQ1NDkpO1xuICAgICAgdmFyIElTX1BVUkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2Mzk1KTtcbiAgICAgIHZhciB0YWtlV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IgPSAhSVNfUFVSRSAmJiBpdGVyYXRvckhlbHBlcldpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yKFwidGFrZVwiLCBSYW5nZUVycm9yKTtcbiAgICAgIHZhciBJdGVyYXRvclByb3h5ID0gY3JlYXRlSXRlcmF0b3JQcm94eShmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5pdGVyYXRvcjtcbiAgICAgICAgaWYgKCF0aGlzLnJlbWFpbmluZy0tKSB7XG4gICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JDbG9zZShpdGVyYXRvciwgXCJub3JtYWxcIiwgdm9pZCAwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gYW5PYmplY3QoY2FsbCh0aGlzLm5leHQsIGl0ZXJhdG9yKSk7XG4gICAgICAgIHZhciBkb25lID0gdGhpcy5kb25lID0gISFyZXN1bHQuZG9uZTtcbiAgICAgICAgaWYgKCFkb25lKSByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICAgICAgfSk7XG4gICAgICAkKHsgdGFyZ2V0OiBcIkl0ZXJhdG9yXCIsIHByb3RvOiB0cnVlLCByZWFsOiB0cnVlLCBmb3JjZWQ6IElTX1BVUkUgfHwgdGFrZVdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yIH0sIHtcbiAgICAgICAgdGFrZTogZnVuY3Rpb24gdGFrZShsaW1pdCkge1xuICAgICAgICAgIGFuT2JqZWN0KHRoaXMpO1xuICAgICAgICAgIHZhciByZW1haW5pbmc7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlbWFpbmluZyA9IHRvUG9zaXRpdmVJbnRlZ2VyKG5vdEFOYU4oK2xpbWl0KSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yQ2xvc2UodGhpcywgXCJ0aHJvd1wiLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0YWtlV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IpIHJldHVybiBjYWxsKHRha2VXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciwgdGhpcywgcmVtYWluaW5nKTtcbiAgICAgICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yUHJveHkoZ2V0SXRlcmF0b3JEaXJlY3QodGhpcyksIHtcbiAgICAgICAgICAgIHJlbWFpbmluZ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA0OTc5OiAoXG4gICAgLyoqKi9cbiAgICAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18yKDY1MTgpO1xuICAgICAgdmFyIGdsb2JhbFRoaXMyID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNDU3Nik7XG4gICAgICB2YXIgZ2V0QnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18yKDc3NTEpO1xuICAgICAgdmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IF9fd2VicGFja19yZXF1aXJlX18yKDY5ODApO1xuICAgICAgdmFyIGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNDkxMykuZjtcbiAgICAgIHZhciBoYXNPd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig5Mjk3KTtcbiAgICAgIHZhciBhbkluc3RhbmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNjc5KTtcbiAgICAgIHZhciBpbmhlcml0SWZSZXF1aXJlZCA9IF9fd2VicGFja19yZXF1aXJlX18yKDMxNjcpO1xuICAgICAgdmFyIG5vcm1hbGl6ZVN0cmluZ0FyZ3VtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMjYwMyk7XG4gICAgICB2YXIgRE9NRXhjZXB0aW9uQ29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNTAwMik7XG4gICAgICB2YXIgY2xlYXJFcnJvclN0YWNrID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoODU3NCk7XG4gICAgICB2YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigzNzI0KTtcbiAgICAgIHZhciBJU19QVVJFID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNjM5NSk7XG4gICAgICB2YXIgRE9NX0VYQ0VQVElPTiA9IFwiRE9NRXhjZXB0aW9uXCI7XG4gICAgICB2YXIgRXJyb3IyID0gZ2V0QnVpbHRJbihcIkVycm9yXCIpO1xuICAgICAgdmFyIE5hdGl2ZURPTUV4Y2VwdGlvbiA9IGdldEJ1aWx0SW4oRE9NX0VYQ0VQVElPTik7XG4gICAgICB2YXIgJERPTUV4Y2VwdGlvbiA9IGZ1bmN0aW9uIERPTUV4Y2VwdGlvbigpIHtcbiAgICAgICAgYW5JbnN0YW5jZSh0aGlzLCBET01FeGNlcHRpb25Qcm90b3R5cGUpO1xuICAgICAgICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBub3JtYWxpemVTdHJpbmdBcmd1bWVudChhcmd1bWVudHNMZW5ndGggPCAxID8gdm9pZCAwIDogYXJndW1lbnRzWzBdKTtcbiAgICAgICAgdmFyIG5hbWUgPSBub3JtYWxpemVTdHJpbmdBcmd1bWVudChhcmd1bWVudHNMZW5ndGggPCAyID8gdm9pZCAwIDogYXJndW1lbnRzWzFdLCBcIkVycm9yXCIpO1xuICAgICAgICB2YXIgdGhhdCA9IG5ldyBOYXRpdmVET01FeGNlcHRpb24obWVzc2FnZSwgbmFtZSk7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcjIobWVzc2FnZSk7XG4gICAgICAgIGVycm9yLm5hbWUgPSBET01fRVhDRVBUSU9OO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0aGF0LCBcInN0YWNrXCIsIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCBjbGVhckVycm9yU3RhY2soZXJyb3Iuc3RhY2ssIDEpKSk7XG4gICAgICAgIGluaGVyaXRJZlJlcXVpcmVkKHRoYXQsIHRoaXMsICRET01FeGNlcHRpb24pO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICAgIH07XG4gICAgICB2YXIgRE9NRXhjZXB0aW9uUHJvdG90eXBlID0gJERPTUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBOYXRpdmVET01FeGNlcHRpb24ucHJvdG90eXBlO1xuICAgICAgdmFyIEVSUk9SX0hBU19TVEFDSyA9IFwic3RhY2tcIiBpbiBuZXcgRXJyb3IyKERPTV9FWENFUFRJT04pO1xuICAgICAgdmFyIERPTV9FWENFUFRJT05fSEFTX1NUQUNLID0gXCJzdGFja1wiIGluIG5ldyBOYXRpdmVET01FeGNlcHRpb24oMSwgMik7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IE5hdGl2ZURPTUV4Y2VwdGlvbiAmJiBERVNDUklQVE9SUyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGdsb2JhbFRoaXMyLCBET01fRVhDRVBUSU9OKTtcbiAgICAgIHZhciBCVUdHWV9ERVNDUklQVE9SID0gISFkZXNjcmlwdG9yICYmICEoZGVzY3JpcHRvci53cml0YWJsZSAmJiBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSk7XG4gICAgICB2YXIgRk9SQ0VEX0NPTlNUUlVDVE9SID0gRVJST1JfSEFTX1NUQUNLICYmICFCVUdHWV9ERVNDUklQVE9SICYmICFET01fRVhDRVBUSU9OX0hBU19TVEFDSztcbiAgICAgICQoeyBnbG9iYWw6IHRydWUsIGNvbnN0cnVjdG9yOiB0cnVlLCBmb3JjZWQ6IElTX1BVUkUgfHwgRk9SQ0VEX0NPTlNUUlVDVE9SIH0sIHtcbiAgICAgICAgLy8gVE9ETzogZml4IGV4cG9ydCBsb2dpY1xuICAgICAgICBET01FeGNlcHRpb246IEZPUkNFRF9DT05TVFJVQ1RPUiA/ICRET01FeGNlcHRpb24gOiBOYXRpdmVET01FeGNlcHRpb25cbiAgICAgIH0pO1xuICAgICAgdmFyIFBvbHlmaWxsZWRET01FeGNlcHRpb24gPSBnZXRCdWlsdEluKERPTV9FWENFUFRJT04pO1xuICAgICAgdmFyIFBvbHlmaWxsZWRET01FeGNlcHRpb25Qcm90b3R5cGUgPSBQb2x5ZmlsbGVkRE9NRXhjZXB0aW9uLnByb3RvdHlwZTtcbiAgICAgIGlmIChQb2x5ZmlsbGVkRE9NRXhjZXB0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yICE9PSBQb2x5ZmlsbGVkRE9NRXhjZXB0aW9uKSB7XG4gICAgICAgIGlmICghSVNfUFVSRSkge1xuICAgICAgICAgIGRlZmluZVByb3BlcnR5KFBvbHlmaWxsZWRET01FeGNlcHRpb25Qcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIFBvbHlmaWxsZWRET01FeGNlcHRpb24pKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gRE9NRXhjZXB0aW9uQ29uc3RhbnRzKSBpZiAoaGFzT3duKERPTUV4Y2VwdGlvbkNvbnN0YW50cywga2V5KSkge1xuICAgICAgICAgIHZhciBjb25zdGFudCA9IERPTUV4Y2VwdGlvbkNvbnN0YW50c1trZXldO1xuICAgICAgICAgIHZhciBjb25zdGFudE5hbWUgPSBjb25zdGFudC5zO1xuICAgICAgICAgIGlmICghaGFzT3duKFBvbHlmaWxsZWRET01FeGNlcHRpb24sIGNvbnN0YW50TmFtZSkpIHtcbiAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KFBvbHlmaWxsZWRET01FeGNlcHRpb24sIGNvbnN0YW50TmFtZSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDYsIGNvbnN0YW50LmMpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICApLFxuICAvKioqL1xuICA1MDAyOiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIpID0+IHtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IHtcbiAgICAgICAgSW5kZXhTaXplRXJyb3I6IHsgczogXCJJTkRFWF9TSVpFX0VSUlwiLCBjOiAxLCBtOiAxIH0sXG4gICAgICAgIERPTVN0cmluZ1NpemVFcnJvcjogeyBzOiBcIkRPTVNUUklOR19TSVpFX0VSUlwiLCBjOiAyLCBtOiAwIH0sXG4gICAgICAgIEhpZXJhcmNoeVJlcXVlc3RFcnJvcjogeyBzOiBcIkhJRVJBUkNIWV9SRVFVRVNUX0VSUlwiLCBjOiAzLCBtOiAxIH0sXG4gICAgICAgIFdyb25nRG9jdW1lbnRFcnJvcjogeyBzOiBcIldST05HX0RPQ1VNRU5UX0VSUlwiLCBjOiA0LCBtOiAxIH0sXG4gICAgICAgIEludmFsaWRDaGFyYWN0ZXJFcnJvcjogeyBzOiBcIklOVkFMSURfQ0hBUkFDVEVSX0VSUlwiLCBjOiA1LCBtOiAxIH0sXG4gICAgICAgIE5vRGF0YUFsbG93ZWRFcnJvcjogeyBzOiBcIk5PX0RBVEFfQUxMT1dFRF9FUlJcIiwgYzogNiwgbTogMCB9LFxuICAgICAgICBOb01vZGlmaWNhdGlvbkFsbG93ZWRFcnJvcjogeyBzOiBcIk5PX01PRElGSUNBVElPTl9BTExPV0VEX0VSUlwiLCBjOiA3LCBtOiAxIH0sXG4gICAgICAgIE5vdEZvdW5kRXJyb3I6IHsgczogXCJOT1RfRk9VTkRfRVJSXCIsIGM6IDgsIG06IDEgfSxcbiAgICAgICAgTm90U3VwcG9ydGVkRXJyb3I6IHsgczogXCJOT1RfU1VQUE9SVEVEX0VSUlwiLCBjOiA5LCBtOiAxIH0sXG4gICAgICAgIEluVXNlQXR0cmlidXRlRXJyb3I6IHsgczogXCJJTlVTRV9BVFRSSUJVVEVfRVJSXCIsIGM6IDEwLCBtOiAxIH0sXG4gICAgICAgIEludmFsaWRTdGF0ZUVycm9yOiB7IHM6IFwiSU5WQUxJRF9TVEFURV9FUlJcIiwgYzogMTEsIG06IDEgfSxcbiAgICAgICAgU3ludGF4RXJyb3I6IHsgczogXCJTWU5UQVhfRVJSXCIsIGM6IDEyLCBtOiAxIH0sXG4gICAgICAgIEludmFsaWRNb2RpZmljYXRpb25FcnJvcjogeyBzOiBcIklOVkFMSURfTU9ESUZJQ0FUSU9OX0VSUlwiLCBjOiAxMywgbTogMSB9LFxuICAgICAgICBOYW1lc3BhY2VFcnJvcjogeyBzOiBcIk5BTUVTUEFDRV9FUlJcIiwgYzogMTQsIG06IDEgfSxcbiAgICAgICAgSW52YWxpZEFjY2Vzc0Vycm9yOiB7IHM6IFwiSU5WQUxJRF9BQ0NFU1NfRVJSXCIsIGM6IDE1LCBtOiAxIH0sXG4gICAgICAgIFZhbGlkYXRpb25FcnJvcjogeyBzOiBcIlZBTElEQVRJT05fRVJSXCIsIGM6IDE2LCBtOiAwIH0sXG4gICAgICAgIFR5cGVNaXNtYXRjaEVycm9yOiB7IHM6IFwiVFlQRV9NSVNNQVRDSF9FUlJcIiwgYzogMTcsIG06IDEgfSxcbiAgICAgICAgU2VjdXJpdHlFcnJvcjogeyBzOiBcIlNFQ1VSSVRZX0VSUlwiLCBjOiAxOCwgbTogMSB9LFxuICAgICAgICBOZXR3b3JrRXJyb3I6IHsgczogXCJORVRXT1JLX0VSUlwiLCBjOiAxOSwgbTogMSB9LFxuICAgICAgICBBYm9ydEVycm9yOiB7IHM6IFwiQUJPUlRfRVJSXCIsIGM6IDIwLCBtOiAxIH0sXG4gICAgICAgIFVSTE1pc21hdGNoRXJyb3I6IHsgczogXCJVUkxfTUlTTUFUQ0hfRVJSXCIsIGM6IDIxLCBtOiAxIH0sXG4gICAgICAgIFF1b3RhRXhjZWVkZWRFcnJvcjogeyBzOiBcIlFVT1RBX0VYQ0VFREVEX0VSUlwiLCBjOiAyMiwgbTogMSB9LFxuICAgICAgICBUaW1lb3V0RXJyb3I6IHsgczogXCJUSU1FT1VUX0VSUlwiLCBjOiAyMywgbTogMSB9LFxuICAgICAgICBJbnZhbGlkTm9kZVR5cGVFcnJvcjogeyBzOiBcIklOVkFMSURfTk9ERV9UWVBFX0VSUlwiLCBjOiAyNCwgbTogMSB9LFxuICAgICAgICBEYXRhQ2xvbmVFcnJvcjogeyBzOiBcIkRBVEFfQ0xPTkVfRVJSXCIsIGM6IDI1LCBtOiAxIH1cbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgNTAyNDogKFxuICAgIC8qKiovXG4gICAgKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2NTE4KTtcbiAgICAgIHZhciBzeW1tZXRyaWNEaWZmZXJlbmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMzY1MCk7XG4gICAgICB2YXIgc2V0TWV0aG9kR2V0S2V5c0JlZm9yZUNsb25pbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig5ODM1KTtcbiAgICAgIHZhciBzZXRNZXRob2RBY2NlcHRTZXRMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNDkxNik7XG4gICAgICB2YXIgRk9SQ0VEID0gIXNldE1ldGhvZEFjY2VwdFNldExpa2UoXCJzeW1tZXRyaWNEaWZmZXJlbmNlXCIpIHx8ICFzZXRNZXRob2RHZXRLZXlzQmVmb3JlQ2xvbmluZyhcInN5bW1ldHJpY0RpZmZlcmVuY2VcIik7XG4gICAgICAkKHsgdGFyZ2V0OiBcIlNldFwiLCBwcm90bzogdHJ1ZSwgcmVhbDogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQgfSwge1xuICAgICAgICBzeW1tZXRyaWNEaWZmZXJlbmNlXG4gICAgICB9KTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA1MDMxOiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciBnZXRCdWlsdEluID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNzc1MSk7XG4gICAgICB2YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig5NTA0KTtcbiAgICAgIHZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoODQ4MCk7XG4gICAgICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMzcxNyk7XG4gICAgICB2YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig4NTUxKTtcbiAgICAgIHZhciBjb25jYXQgPSB1bmN1cnJ5VGhpcyhbXS5jb25jYXQpO1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gZ2V0QnVpbHRJbihcIlJlZmxlY3RcIiwgXCJvd25LZXlzXCIpIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcbiAgICAgICAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYoYW5PYmplY3QoaXQpKTtcbiAgICAgICAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mO1xuICAgICAgICByZXR1cm4gZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gY29uY2F0KGtleXMsIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkpIDoga2V5cztcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgNTE2OTogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgaXNEZXRhY2hlZCA9IF9fd2VicGFja19yZXF1aXJlX18yKDMyMzgpO1xuICAgICAgdmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbihpdCkge1xuICAgICAgICBpZiAoaXNEZXRhY2hlZChpdCkpIHRocm93IG5ldyAkVHlwZUVycm9yKFwiQXJyYXlCdWZmZXIgaXMgZGV0YWNoZWRcIik7XG4gICAgICAgIHJldHVybiBpdDtcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgNTE3MDogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgdW5jdXJyeVRoaXNBY2Nlc3NvciA9IF9fd2VicGFja19yZXF1aXJlX18yKDY3MDYpO1xuICAgICAgdmFyIFNldEhlbHBlcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig0NDAyKTtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IHVuY3VycnlUaGlzQWNjZXNzb3IoU2V0SGVscGVycy5wcm90bywgXCJzaXplXCIsIFwiZ2V0XCIpIHx8IGZ1bmN0aW9uKHNldCkge1xuICAgICAgICByZXR1cm4gc2V0LnNpemU7XG4gICAgICB9O1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDUyMTM6IChcbiAgICAvKioqL1xuICAgICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNjUxOCk7XG4gICAgICB2YXIgZ2xvYmFsVGhpczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig0NTc2KTtcbiAgICAgIHZhciBhcnJheUZyb21Db25zdHJ1Y3RvckFuZExpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig1MzcwKTtcbiAgICAgIHZhciAkZnJvbUJhc2U2NCA9IF9fd2VicGFja19yZXF1aXJlX18yKDkxNDMpO1xuICAgICAgdmFyIFVpbnQ4QXJyYXkyID0gZ2xvYmFsVGhpczIuVWludDhBcnJheTtcbiAgICAgIHZhciBJTkNPUlJFQ1RfQkVIQVZJT1JfT1JfRE9FU05UX0VYSVNUUyA9ICFVaW50OEFycmF5MiB8fCAhVWludDhBcnJheTIuZnJvbUJhc2U2NCB8fCAhKGZ1bmN0aW9uKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIFVpbnQ4QXJyYXkyLmZyb21CYXNlNjQoXCJhXCIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIFVpbnQ4QXJyYXkyLmZyb21CYXNlNjQoXCJcIiwgbnVsbCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pKCk7XG4gICAgICBpZiAoVWludDhBcnJheTIpICQoeyB0YXJnZXQ6IFwiVWludDhBcnJheVwiLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IElOQ09SUkVDVF9CRUhBVklPUl9PUl9ET0VTTlRfRVhJU1RTIH0sIHtcbiAgICAgICAgZnJvbUJhc2U2NDogZnVuY3Rpb24gZnJvbUJhc2U2NChzdHJpbmcpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gJGZyb21CYXNlNjQoc3RyaW5nLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMCwgbnVsbCwgOTAwNzE5OTI1NDc0MDk5MSk7XG4gICAgICAgICAgcmV0dXJuIGFycmF5RnJvbUNvbnN0cnVjdG9yQW5kTGlzdChVaW50OEFycmF5MiwgcmVzdWx0LmJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgNTM3MDogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2MTk4KTtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBsaXN0LCAkbGVuZ3RoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/ICRsZW5ndGggOiBsZW5ndGhPZkFycmF5TGlrZShsaXN0KTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBDb25zdHJ1Y3RvcihsZW5ndGgpO1xuICAgICAgICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHJlc3VsdFtpbmRleF0gPSBsaXN0W2luZGV4KytdO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA1Mzk3OiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciBJbmRleGVkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNzA1NSk7XG4gICAgICB2YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDc3NTApO1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24oaXQpIHtcbiAgICAgICAgcmV0dXJuIEluZGV4ZWRPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZShpdCkpO1xuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA1NjEwOiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciB0b0ludGVnZXJPckluZmluaXR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMTI5MSk7XG4gICAgICB2YXIgbWF4ID0gTWF0aC5tYXg7XG4gICAgICB2YXIgbWluID0gTWF0aC5taW47XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbihpbmRleCwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBpbnRlZ2VyID0gdG9JbnRlZ2VyT3JJbmZpbml0eShpbmRleCk7XG4gICAgICAgIHJldHVybiBpbnRlZ2VyIDwgMCA/IG1heChpbnRlZ2VyICsgbGVuZ3RoLCAwKSA6IG1pbihpbnRlZ2VyLCBsZW5ndGgpO1xuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA1NjIzOiAoXG4gICAgLyoqKi9cbiAgICAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fMig0NTYpO1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDU2MzY6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMiwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyIGdsb2JhbFRoaXMyID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNDU3Nik7XG4gICAgICB2YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig5NTA0KTtcbiAgICAgIHZhciB1bmN1cnJ5VGhpc0FjY2Vzc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNjcwNik7XG4gICAgICB2YXIgdG9JbmRleCA9IF9fd2VicGFja19yZXF1aXJlX18yKDc2OTYpO1xuICAgICAgdmFyIG5vdERldGFjaGVkID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNTE2OSk7XG4gICAgICB2YXIgYXJyYXlCdWZmZXJCeXRlTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNzM5NCk7XG4gICAgICB2YXIgZGV0YWNoVHJhbnNmZXJhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNDQ4Myk7XG4gICAgICB2YXIgUFJPUEVSX1NUUlVDVFVSRURfQ0xPTkVfVFJBTlNGRVIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigxNTQ4KTtcbiAgICAgIHZhciBzdHJ1Y3R1cmVkQ2xvbmUyID0gZ2xvYmFsVGhpczIuc3RydWN0dXJlZENsb25lO1xuICAgICAgdmFyIEFycmF5QnVmZmVyMiA9IGdsb2JhbFRoaXMyLkFycmF5QnVmZmVyO1xuICAgICAgdmFyIERhdGFWaWV3MiA9IGdsb2JhbFRoaXMyLkRhdGFWaWV3O1xuICAgICAgdmFyIG1pbiA9IE1hdGgubWluO1xuICAgICAgdmFyIEFycmF5QnVmZmVyUHJvdG90eXBlID0gQXJyYXlCdWZmZXIyLnByb3RvdHlwZTtcbiAgICAgIHZhciBEYXRhVmlld1Byb3RvdHlwZSA9IERhdGFWaWV3Mi5wcm90b3R5cGU7XG4gICAgICB2YXIgc2xpY2UgPSB1bmN1cnJ5VGhpcyhBcnJheUJ1ZmZlclByb3RvdHlwZS5zbGljZSk7XG4gICAgICB2YXIgaXNSZXNpemFibGUgPSB1bmN1cnJ5VGhpc0FjY2Vzc29yKEFycmF5QnVmZmVyUHJvdG90eXBlLCBcInJlc2l6YWJsZVwiLCBcImdldFwiKTtcbiAgICAgIHZhciBtYXhCeXRlTGVuZ3RoID0gdW5jdXJyeVRoaXNBY2Nlc3NvcihBcnJheUJ1ZmZlclByb3RvdHlwZSwgXCJtYXhCeXRlTGVuZ3RoXCIsIFwiZ2V0XCIpO1xuICAgICAgdmFyIGdldEludDggPSB1bmN1cnJ5VGhpcyhEYXRhVmlld1Byb3RvdHlwZS5nZXRJbnQ4KTtcbiAgICAgIHZhciBzZXRJbnQ4ID0gdW5jdXJyeVRoaXMoRGF0YVZpZXdQcm90b3R5cGUuc2V0SW50OCk7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSAoUFJPUEVSX1NUUlVDVFVSRURfQ0xPTkVfVFJBTlNGRVIgfHwgZGV0YWNoVHJhbnNmZXJhYmxlKSAmJiBmdW5jdGlvbihhcnJheUJ1ZmZlciwgbmV3TGVuZ3RoLCBwcmVzZXJ2ZVJlc2l6YWJpbGl0eSkge1xuICAgICAgICB2YXIgYnl0ZUxlbmd0aCA9IGFycmF5QnVmZmVyQnl0ZUxlbmd0aChhcnJheUJ1ZmZlcik7XG4gICAgICAgIHZhciBuZXdCeXRlTGVuZ3RoID0gbmV3TGVuZ3RoID09PSB2b2lkIDAgPyBieXRlTGVuZ3RoIDogdG9JbmRleChuZXdMZW5ndGgpO1xuICAgICAgICB2YXIgZml4ZWRMZW5ndGggPSAhaXNSZXNpemFibGUgfHwgIWlzUmVzaXphYmxlKGFycmF5QnVmZmVyKTtcbiAgICAgICAgdmFyIG5ld0J1ZmZlcjtcbiAgICAgICAgbm90RGV0YWNoZWQoYXJyYXlCdWZmZXIpO1xuICAgICAgICBpZiAoUFJPUEVSX1NUUlVDVFVSRURfQ0xPTkVfVFJBTlNGRVIpIHtcbiAgICAgICAgICBhcnJheUJ1ZmZlciA9IHN0cnVjdHVyZWRDbG9uZTIoYXJyYXlCdWZmZXIsIHsgdHJhbnNmZXI6IFthcnJheUJ1ZmZlcl0gfSk7XG4gICAgICAgICAgaWYgKGJ5dGVMZW5ndGggPT09IG5ld0J5dGVMZW5ndGggJiYgKHByZXNlcnZlUmVzaXphYmlsaXR5IHx8IGZpeGVkTGVuZ3RoKSkgcmV0dXJuIGFycmF5QnVmZmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChieXRlTGVuZ3RoID49IG5ld0J5dGVMZW5ndGggJiYgKCFwcmVzZXJ2ZVJlc2l6YWJpbGl0eSB8fCBmaXhlZExlbmd0aCkpIHtcbiAgICAgICAgICBuZXdCdWZmZXIgPSBzbGljZShhcnJheUJ1ZmZlciwgMCwgbmV3Qnl0ZUxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSBwcmVzZXJ2ZVJlc2l6YWJpbGl0eSAmJiAhZml4ZWRMZW5ndGggJiYgbWF4Qnl0ZUxlbmd0aCA/IHsgbWF4Qnl0ZUxlbmd0aDogbWF4Qnl0ZUxlbmd0aChhcnJheUJ1ZmZlcikgfSA6IHZvaWQgMDtcbiAgICAgICAgICBuZXdCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIyKG5ld0J5dGVMZW5ndGgsIG9wdGlvbnMpO1xuICAgICAgICAgIHZhciBhID0gbmV3IERhdGFWaWV3MihhcnJheUJ1ZmZlcik7XG4gICAgICAgICAgdmFyIGIgPSBuZXcgRGF0YVZpZXcyKG5ld0J1ZmZlcik7XG4gICAgICAgICAgdmFyIGNvcHlMZW5ndGggPSBtaW4obmV3Qnl0ZUxlbmd0aCwgYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3B5TGVuZ3RoOyBpKyspIHNldEludDgoYiwgaSwgZ2V0SW50OChhLCBpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFQUk9QRVJfU1RSVUNUVVJFRF9DTE9ORV9UUkFOU0ZFUikgZGV0YWNoVHJhbnNmZXJhYmxlKGFycmF5QnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIG5ld0J1ZmZlcjtcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgNTc0NTogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgc3RvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig3NjI5KTtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB2YWx1ZSB8fCB7fSk7XG4gICAgICB9O1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDU3ODE6IChcbiAgICAvKioqL1xuICAgICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNjUxOCk7XG4gICAgICB2YXIgZ2V0QnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18yKDc3NTEpO1xuICAgICAgdmFyIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMjgxMik7XG4gICAgICB2YXIgdG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2NTUpO1xuICAgICAgdmFyIFVTRV9OQVRJVkVfVVJMID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNzQxNik7XG4gICAgICB2YXIgVVJMMiA9IGdldEJ1aWx0SW4oXCJVUkxcIik7XG4gICAgICAkKHsgdGFyZ2V0OiBcIlVSTFwiLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICFVU0VfTkFUSVZFX1VSTCB9LCB7XG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZSh1cmwpIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgoYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgICAgICAgdmFyIHVybFN0cmluZyA9IHRvU3RyaW5nKHVybCk7XG4gICAgICAgICAgdmFyIGJhc2UgPSBsZW5ndGggPCAyIHx8IGFyZ3VtZW50c1sxXSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdG9TdHJpbmcoYXJndW1lbnRzWzFdKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVUkwyKHVybFN0cmluZywgYmFzZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgNTg1NDogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgdG9QcmltaXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigyNzc3KTtcbiAgICAgIHZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24oYXJndW1lbnQpIHtcbiAgICAgICAgdmFyIHByaW0gPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgXCJudW1iZXJcIik7XG4gICAgICAgIGlmICh0eXBlb2YgcHJpbSA9PSBcIm51bWJlclwiKSB0aHJvdyBuZXcgJFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgbnVtYmVyIHRvIGJpZ2ludFwiKTtcbiAgICAgICAgcmV0dXJuIEJpZ0ludChwcmltKTtcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgNTg3NjogKFxuICAgIC8qKiovXG4gICAgKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2NTE4KTtcbiAgICAgIHZhciBpc1N1YnNldE9mID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMzgzOCk7XG4gICAgICB2YXIgc2V0TWV0aG9kQWNjZXB0U2V0TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDQ5MTYpO1xuICAgICAgdmFyIElOQ09SUkVDVCA9ICFzZXRNZXRob2RBY2NlcHRTZXRMaWtlKFwiaXNTdWJzZXRPZlwiLCBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0pO1xuICAgICAgJCh7IHRhcmdldDogXCJTZXRcIiwgcHJvdG86IHRydWUsIHJlYWw6IHRydWUsIGZvcmNlZDogSU5DT1JSRUNUIH0sIHtcbiAgICAgICAgaXNTdWJzZXRPZlxuICAgICAgfSk7XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgNTkxNzogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigzNzI0KTtcbiAgICAgIHZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18yKDkwMzkpO1xuICAgICAgdmFyIGNyZWF0ZUVsZW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig0MDU1KTtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9ICFERVNDUklQVE9SUyAmJiAhZmFpbHMoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3JlYXRlRWxlbWVudChcImRpdlwiKSwgXCJhXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIDc7XG4gICAgICAgICAgfVxuICAgICAgICB9KS5hICE9PSA3O1xuICAgICAgfSk7XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgNTk2NjogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgYUNhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoOTMwNik7XG4gICAgICB2YXIgaXNOdWxsT3JVbmRlZmluZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig0MTE3KTtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKFYsIFApIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBWW1BdO1xuICAgICAgICByZXR1cm4gaXNOdWxsT3JVbmRlZmluZWQoZnVuYykgPyB2b2lkIDAgOiBhQ2FsbGFibGUoZnVuYyk7XG4gICAgICB9O1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDYwNDM6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMiwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyIGFDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDkzMDYpO1xuICAgICAgdmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG4gICAgICB2YXIgUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbihDKSB7XG4gICAgICAgIHZhciByZXNvbHZlLCByZWplY3Q7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uKCQkcmVzb2x2ZSwgJCRyZWplY3QpIHtcbiAgICAgICAgICBpZiAocmVzb2x2ZSAhPT0gdm9pZCAwIHx8IHJlamVjdCAhPT0gdm9pZCAwKSB0aHJvdyBuZXcgJFR5cGVFcnJvcihcIkJhZCBQcm9taXNlIGNvbnN0cnVjdG9yXCIpO1xuICAgICAgICAgIHJlc29sdmUgPSAkJHJlc29sdmU7XG4gICAgICAgICAgcmVqZWN0ID0gJCRyZWplY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlc29sdmUgPSBhQ2FsbGFibGUocmVzb2x2ZSk7XG4gICAgICAgIHRoaXMucmVqZWN0ID0gYUNhbGxhYmxlKHJlamVjdCk7XG4gICAgICB9O1xuICAgICAgbW9kdWxlMi5leHBvcnRzLmYgPSBmdW5jdGlvbihDKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gICAgICB9O1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDYwODA6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMiwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNzQ3Nik7XG4gICAgICB2YXIgYUNhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoOTMwNik7XG4gICAgICB2YXIgTkFUSVZFX0JJTkQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2MTYpO1xuICAgICAgdmFyIGJpbmQgPSB1bmN1cnJ5VGhpcyh1bmN1cnJ5VGhpcy5iaW5kKTtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCB0aGF0KSB7XG4gICAgICAgIGFDYWxsYWJsZShmbik7XG4gICAgICAgIHJldHVybiB0aGF0ID09PSB2b2lkIDAgPyBmbiA6IE5BVElWRV9CSU5EID8gYmluZChmbiwgdGhhdCkgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgNjExOTogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgc2hhcmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNTc0NSk7XG4gICAgICB2YXIgdWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMzM5Mik7XG4gICAgICB2YXIga2V5cyA9IHNoYXJlZChcImtleXNcIik7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleXNba2V5XSB8fCAoa2V5c1trZXldID0gdWlkKGtleSkpO1xuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA2MTkzOiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciBFTlZJUk9OTUVOVCA9IF9fd2VicGFja19yZXF1aXJlX18yKDQyMTUpO1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gRU5WSVJPTk1FTlQgPT09IFwiTk9ERVwiO1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDYxOTg6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMiwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyIHRvTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoODAxNCk7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIHRvTGVuZ3RoKG9iai5sZW5ndGgpO1xuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA2MjY5OiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIpID0+IHtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IHt9O1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDYyNzk6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMiwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyIGRlZmluZUJ1aWx0SW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2ODQwKTtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKHRhcmdldCwgc3JjLCBvcHRpb25zKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzcmMpIGRlZmluZUJ1aWx0SW4odGFyZ2V0LCBrZXksIHNyY1trZXldLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgNjMxOTogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig4NTUxKTtcbiAgICAgIHZhciBpdGVyYXRvckNsb3NlID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoOTUzOSk7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYXRvciwgZm4sIHZhbHVlLCBFTlRSSUVTKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEVOVFJJRVMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBcInRocm93XCIsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA2Mzk1OiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIpID0+IHtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZhbHNlO1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDY1MTg6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMiwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyIGdsb2JhbFRoaXMyID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNDU3Nik7XG4gICAgICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNzM0NykuZjtcbiAgICAgIHZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2Njk5KTtcbiAgICAgIHZhciBkZWZpbmVCdWlsdEluID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNjg0MCk7XG4gICAgICB2YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig5NDMzKTtcbiAgICAgIHZhciBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNzc0MCk7XG4gICAgICB2YXIgaXNGb3JjZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigyNzk2KTtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdGlvbnMsIHNvdXJjZSkge1xuICAgICAgICB2YXIgVEFSR0VUID0gb3B0aW9ucy50YXJnZXQ7XG4gICAgICAgIHZhciBHTE9CQUwgPSBvcHRpb25zLmdsb2JhbDtcbiAgICAgICAgdmFyIFNUQVRJQyA9IG9wdGlvbnMuc3RhdDtcbiAgICAgICAgdmFyIEZPUkNFRCwgdGFyZ2V0LCBrZXksIHRhcmdldFByb3BlcnR5LCBzb3VyY2VQcm9wZXJ0eSwgZGVzY3JpcHRvcjtcbiAgICAgICAgaWYgKEdMT0JBTCkge1xuICAgICAgICAgIHRhcmdldCA9IGdsb2JhbFRoaXMyO1xuICAgICAgICB9IGVsc2UgaWYgKFNUQVRJQykge1xuICAgICAgICAgIHRhcmdldCA9IGdsb2JhbFRoaXMyW1RBUkdFVF0gfHwgZGVmaW5lR2xvYmFsUHJvcGVydHkoVEFSR0VULCB7fSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0ID0gZ2xvYmFsVGhpczJbVEFSR0VUXSAmJiBnbG9iYWxUaGlzMltUQVJHRVRdLnByb3RvdHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0KSBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICBzb3VyY2VQcm9wZXJ0eSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgIGlmIChvcHRpb25zLmRvbnRDYWxsR2V0U2V0KSB7XG4gICAgICAgICAgICBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcbiAgICAgICAgICAgIHRhcmdldFByb3BlcnR5ID0gZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnZhbHVlO1xuICAgICAgICAgIH0gZWxzZSB0YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFtrZXldO1xuICAgICAgICAgIEZPUkNFRCA9IGlzRm9yY2VkKEdMT0JBTCA/IGtleSA6IFRBUkdFVCArIChTVEFUSUMgPyBcIi5cIiA6IFwiI1wiKSArIGtleSwgb3B0aW9ucy5mb3JjZWQpO1xuICAgICAgICAgIGlmICghRk9SQ0VEICYmIHRhcmdldFByb3BlcnR5ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc291cmNlUHJvcGVydHkgPT0gdHlwZW9mIHRhcmdldFByb3BlcnR5KSBjb250aW51ZTtcbiAgICAgICAgICAgIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMoc291cmNlUHJvcGVydHksIHRhcmdldFByb3BlcnR5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdGlvbnMuc2hhbSB8fCB0YXJnZXRQcm9wZXJ0eSAmJiB0YXJnZXRQcm9wZXJ0eS5zaGFtKSB7XG4gICAgICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoc291cmNlUHJvcGVydHksIFwic2hhbVwiLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmaW5lQnVpbHRJbih0YXJnZXQsIGtleSwgc291cmNlUHJvcGVydHksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDY1NzM6IChcbiAgICAvKioqL1xuICAgICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18yKDM3MjQpO1xuICAgICAgdmFyIGRlZmluZUJ1aWx0SW5BY2Nlc3NvciA9IF9fd2VicGFja19yZXF1aXJlX18yKDIxMDYpO1xuICAgICAgdmFyIGlzRGV0YWNoZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigzMjM4KTtcbiAgICAgIHZhciBBcnJheUJ1ZmZlclByb3RvdHlwZSA9IEFycmF5QnVmZmVyLnByb3RvdHlwZTtcbiAgICAgIGlmIChERVNDUklQVE9SUyAmJiAhKFwiZGV0YWNoZWRcIiBpbiBBcnJheUJ1ZmZlclByb3RvdHlwZSkpIHtcbiAgICAgICAgZGVmaW5lQnVpbHRJbkFjY2Vzc29yKEFycmF5QnVmZmVyUHJvdG90eXBlLCBcImRldGFjaGVkXCIsIHtcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBkZXRhY2hlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0RldGFjaGVkKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgNjYzMjogKFxuICAgIC8qKiovXG4gICAgKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2NTE4KTtcbiAgICAgIHZhciBnbG9iYWxUaGlzMiA9IF9fd2VicGFja19yZXF1aXJlX18yKDQ1NzYpO1xuICAgICAgdmFyICRmcm9tQmFzZTY0ID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoOTE0Myk7XG4gICAgICB2YXIgYW5VaW50OEFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNDE1NCk7XG4gICAgICB2YXIgVWludDhBcnJheTIgPSBnbG9iYWxUaGlzMi5VaW50OEFycmF5O1xuICAgICAgdmFyIElOQ09SUkVDVF9CRUhBVklPUl9PUl9ET0VTTlRfRVhJU1RTID0gIVVpbnQ4QXJyYXkyIHx8ICFVaW50OEFycmF5Mi5wcm90b3R5cGUuc2V0RnJvbUJhc2U2NCB8fCAhKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gbmV3IFVpbnQ4QXJyYXkyKFsyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NV0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRhcmdldC5zZXRGcm9tQmFzZTY0KFwiXCIsIG51bGwpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRhcmdldC5zZXRGcm9tQmFzZTY0KFwiYVwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0YXJnZXQuc2V0RnJvbUJhc2U2NChcIk1qWXlaZz09PVwiKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gdGFyZ2V0WzBdID09PSA1MCAmJiB0YXJnZXRbMV0gPT09IDU0ICYmIHRhcmdldFsyXSA9PT0gNTAgJiYgdGFyZ2V0WzNdID09PSAyNTUgJiYgdGFyZ2V0WzRdID09PSAyNTU7XG4gICAgICAgIH1cbiAgICAgIH0pKCk7XG4gICAgICBpZiAoVWludDhBcnJheTIpICQoeyB0YXJnZXQ6IFwiVWludDhBcnJheVwiLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBJTkNPUlJFQ1RfQkVIQVZJT1JfT1JfRE9FU05UX0VYSVNUUyB9LCB7XG4gICAgICAgIHNldEZyb21CYXNlNjQ6IGZ1bmN0aW9uIHNldEZyb21CYXNlNjQoc3RyaW5nKSB7XG4gICAgICAgICAgYW5VaW50OEFycmF5KHRoaXMpO1xuICAgICAgICAgIHZhciByZXN1bHQgPSAkZnJvbUJhc2U2NChzdHJpbmcsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdm9pZCAwLCB0aGlzLCB0aGlzLmxlbmd0aCk7XG4gICAgICAgICAgcmV0dXJuIHsgcmVhZDogcmVzdWx0LnJlYWQsIHdyaXR0ZW46IHJlc3VsdC53cml0dGVuIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDY2OTk6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMiwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMzcyNCk7XG4gICAgICB2YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig0OTEzKTtcbiAgICAgIHZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2OTgwKTtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IERFU0NSSVBUT1JTID8gZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKG9iamVjdCwga2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgdmFsdWUpKTtcbiAgICAgIH0gOiBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgNjcwNjogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig5NTA0KTtcbiAgICAgIHZhciBhQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig5MzA2KTtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwga2V5LCBtZXRob2QpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gdW5jdXJyeVRoaXMoYUNhbGxhYmxlKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBrZXkpW21ldGhvZF0pKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA2ODAxOiAoXG4gICAgLyoqKi9cbiAgICAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzMiwgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18yKDM3MjQpO1xuICAgICAgdmFyIFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoODY4Nik7XG4gICAgICB2YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig0OTEzKTtcbiAgICAgIHZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18yKDg1NTEpO1xuICAgICAgdmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18yKDUzOTcpO1xuICAgICAgdmFyIG9iamVjdEtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigxMDcyKTtcbiAgICAgIGV4cG9ydHMyLmYgPSBERVNDUklQVE9SUyAmJiAhVjhfUFJPVE9UWVBFX0RFRklORV9CVUcgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICAgICAgICBhbk9iamVjdChPKTtcbiAgICAgICAgdmFyIHByb3BzID0gdG9JbmRleGVkT2JqZWN0KFByb3BlcnRpZXMpO1xuICAgICAgICB2YXIga2V5cyA9IG9iamVjdEtleXMoUHJvcGVydGllcyk7XG4gICAgICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKE8sIGtleSA9IGtleXNbaW5kZXgrK10sIHByb3BzW2tleV0pO1xuICAgICAgICByZXR1cm4gTztcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgNjgyMzogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyKSA9PiB7XG4gICAgICB2YXIgJFN0cmluZyA9IFN0cmluZztcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKGFyZ3VtZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuICRTdHJpbmcoYXJndW1lbnQpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBcIk9iamVjdFwiO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDY4Mzc6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMikgPT4ge1xuICAgICAgdmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG4gICAgICB2YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbihpdCkge1xuICAgICAgICBpZiAoaXQgPiBNQVhfU0FGRV9JTlRFR0VSKSB0aHJvdyAkVHlwZUVycm9yKFwiTWF4aW11bSBhbGxvd2VkIGluZGV4IGV4Y2VlZGVkXCIpO1xuICAgICAgICByZXR1cm4gaXQ7XG4gICAgICB9O1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDY4NDA6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMiwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyIGlzQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig0OTAxKTtcbiAgICAgIHZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDQ5MTMpO1xuICAgICAgdmFyIG1ha2VCdWlsdEluID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMjgzKTtcbiAgICAgIHZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18yKDk0MzMpO1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24oTywga2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgdmFyIHNpbXBsZSA9IG9wdGlvbnMuZW51bWVyYWJsZTtcbiAgICAgICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUgIT09IHZvaWQgMCA/IG9wdGlvbnMubmFtZSA6IGtleTtcbiAgICAgICAgaWYgKGlzQ2FsbGFibGUodmFsdWUpKSBtYWtlQnVpbHRJbih2YWx1ZSwgbmFtZSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChvcHRpb25zLmdsb2JhbCkge1xuICAgICAgICAgIGlmIChzaW1wbGUpIE9ba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIGVsc2UgZGVmaW5lR2xvYmFsUHJvcGVydHkoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy51bnNhZmUpIGRlbGV0ZSBPW2tleV07XG4gICAgICAgICAgICBlbHNlIGlmIChPW2tleV0pIHNpbXBsZSA9IHRydWU7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gICAgICAgICAgZWxzZSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKE8sIGtleSwge1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogIW9wdGlvbnMubm9uQ29uZmlndXJhYmxlLFxuICAgICAgICAgICAgd3JpdGFibGU6ICFvcHRpb25zLm5vbldyaXRhYmxlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE87XG4gICAgICB9O1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDY5NTU6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMiwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCA9IF9fd2VicGFja19yZXF1aXJlX18yKDIxNDApO1xuICAgICAgdmFyIGlzQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig0OTAxKTtcbiAgICAgIHZhciBjbGFzc29mUmF3ID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMjE5NSk7XG4gICAgICB2YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoODIyNyk7XG4gICAgICB2YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbChcInRvU3RyaW5nVGFnXCIpO1xuICAgICAgdmFyICRPYmplY3QgPSBPYmplY3Q7XG4gICAgICB2YXIgQ09SUkVDVF9BUkdVTUVOVFMgPSBjbGFzc29mUmF3KC8qIEBfX1BVUkVfXyAqLyAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHM7XG4gICAgICB9KSgpKSA9PT0gXCJBcmd1bWVudHNcIjtcbiAgICAgIHZhciB0cnlHZXQgPSBmdW5jdGlvbihpdCwga2V5KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGl0W2tleV07XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPyBjbGFzc29mUmF3IDogZnVuY3Rpb24oaXQpIHtcbiAgICAgICAgdmFyIE8sIHRhZywgcmVzdWx0O1xuICAgICAgICByZXR1cm4gaXQgPT09IHZvaWQgMCA/IFwiVW5kZWZpbmVkXCIgOiBpdCA9PT0gbnVsbCA/IFwiTnVsbFwiIDogdHlwZW9mICh0YWcgPSB0cnlHZXQoTyA9ICRPYmplY3QoaXQpLCBUT19TVFJJTkdfVEFHKSkgPT0gXCJzdHJpbmdcIiA/IHRhZyA6IENPUlJFQ1RfQVJHVU1FTlRTID8gY2xhc3NvZlJhdyhPKSA6IChyZXN1bHQgPSBjbGFzc29mUmF3KE8pKSA9PT0gXCJPYmplY3RcIiAmJiBpc0NhbGxhYmxlKE8uY2FsbGVlKSA/IFwiQXJndW1lbnRzXCIgOiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDY5Njk6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMiwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyIHRvUHJpbWl0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMjc3Nyk7XG4gICAgICB2YXIgaXNTeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig3NTcpO1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24oYXJndW1lbnQpIHtcbiAgICAgICAgdmFyIGtleSA9IHRvUHJpbWl0aXZlKGFyZ3VtZW50LCBcInN0cmluZ1wiKTtcbiAgICAgICAgcmV0dXJuIGlzU3ltYm9sKGtleSkgPyBrZXkgOiBrZXkgKyBcIlwiO1xuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA2OTgwOiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIpID0+IHtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKGJpdG1hcCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICAgICAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA3MDQwOiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciBOQVRJVkVfU1lNQk9MID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNDQ5NSk7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBOQVRJVkVfU1lNQk9MICYmICFTeW1ib2wuc2hhbSAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09IFwic3ltYm9sXCI7XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgNzA1NTogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig5NTA0KTtcbiAgICAgIHZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18yKDkwMzkpO1xuICAgICAgdmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigyMTk1KTtcbiAgICAgIHZhciAkT2JqZWN0ID0gT2JqZWN0O1xuICAgICAgdmFyIHNwbGl0ID0gdW5jdXJyeVRoaXMoXCJcIi5zcGxpdCk7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmYWlscyhmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEkT2JqZWN0KFwielwiKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKTtcbiAgICAgIH0pID8gZnVuY3Rpb24oaXQpIHtcbiAgICAgICAgcmV0dXJuIGNsYXNzb2YoaXQpID09PSBcIlN0cmluZ1wiID8gc3BsaXQoaXQsIFwiXCIpIDogJE9iamVjdChpdCk7XG4gICAgICB9IDogJE9iamVjdDtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA3MDgwOiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig0NDAyKS5oYXM7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbihpdCkge1xuICAgICAgICBoYXMoaXQpO1xuICAgICAgICByZXR1cm4gaXQ7XG4gICAgICB9O1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDczNDc6IChcbiAgICAvKioqL1xuICAgICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMyLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMzcyNCk7XG4gICAgICB2YXIgY2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18yKDk1NjUpO1xuICAgICAgdmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoODc3Myk7XG4gICAgICB2YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNjk4MCk7XG4gICAgICB2YXIgdG9JbmRleGVkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNTM5Nyk7XG4gICAgICB2YXIgdG9Qcm9wZXJ0eUtleSA9IF9fd2VicGFja19yZXF1aXJlX18yKDY5NjkpO1xuICAgICAgdmFyIGhhc093biA9IF9fd2VicGFja19yZXF1aXJlX18yKDkyOTcpO1xuICAgICAgdmFyIElFOF9ET01fREVGSU5FID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNTkxNyk7XG4gICAgICB2YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICAgICBleHBvcnRzMi5mID0gREVTQ1JJUFRPUlMgPyAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgICAgICAgTyA9IHRvSW5kZXhlZE9iamVjdChPKTtcbiAgICAgICAgUCA9IHRvUHJvcGVydHlLZXkoUCk7XG4gICAgICAgIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzT3duKE8sIFApKSByZXR1cm4gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKCFjYWxsKHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmYsIE8sIFApLCBPW1BdKTtcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgNzM5NDogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgZ2xvYmFsVGhpczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig0NTc2KTtcbiAgICAgIHZhciB1bmN1cnJ5VGhpc0FjY2Vzc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNjcwNik7XG4gICAgICB2YXIgY2xhc3NvZiA9IF9fd2VicGFja19yZXF1aXJlX18yKDIxOTUpO1xuICAgICAgdmFyIEFycmF5QnVmZmVyMiA9IGdsb2JhbFRoaXMyLkFycmF5QnVmZmVyO1xuICAgICAgdmFyIFR5cGVFcnJvcjIgPSBnbG9iYWxUaGlzMi5UeXBlRXJyb3I7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBBcnJheUJ1ZmZlcjIgJiYgdW5jdXJyeVRoaXNBY2Nlc3NvcihBcnJheUJ1ZmZlcjIucHJvdG90eXBlLCBcImJ5dGVMZW5ndGhcIiwgXCJnZXRcIikgfHwgZnVuY3Rpb24oTykge1xuICAgICAgICBpZiAoY2xhc3NvZihPKSAhPT0gXCJBcnJheUJ1ZmZlclwiKSB0aHJvdyBuZXcgVHlwZUVycm9yMihcIkFycmF5QnVmZmVyIGV4cGVjdGVkXCIpO1xuICAgICAgICByZXR1cm4gTy5ieXRlTGVuZ3RoO1xuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA3NDE2OiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18yKDkwMzkpO1xuICAgICAgdmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18yKDgyMjcpO1xuICAgICAgdmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMzcyNCk7XG4gICAgICB2YXIgSVNfUFVSRSA9IF9fd2VicGFja19yZXF1aXJlX18yKDYzOTUpO1xuICAgICAgdmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKFwiaXRlcmF0b3JcIik7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB1cmwgPSBuZXcgVVJMKFwiYj9hPTEmYj0yJmM9M1wiLCBcImh0dHBzOi8vYVwiKTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHVybC5zZWFyY2hQYXJhbXM7XG4gICAgICAgIHZhciBwYXJhbXMyID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhcImE9MSZhPTImYj0zXCIpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgdXJsLnBhdGhuYW1lID0gXCJjJTIwZFwiO1xuICAgICAgICBwYXJhbXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgcGFyYW1zW1wiZGVsZXRlXCJdKFwiYlwiKTtcbiAgICAgICAgICByZXN1bHQgKz0ga2V5ICsgdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICBwYXJhbXMyW1wiZGVsZXRlXCJdKFwiYVwiLCAyKTtcbiAgICAgICAgcGFyYW1zMltcImRlbGV0ZVwiXShcImJcIiwgdm9pZCAwKTtcbiAgICAgICAgcmV0dXJuIElTX1BVUkUgJiYgKCF1cmwudG9KU09OIHx8ICFwYXJhbXMyLmhhcyhcImFcIiwgMSkgfHwgcGFyYW1zMi5oYXMoXCJhXCIsIDIpIHx8ICFwYXJhbXMyLmhhcyhcImFcIiwgdm9pZCAwKSB8fCBwYXJhbXMyLmhhcyhcImJcIikpIHx8ICFwYXJhbXMuc2l6ZSAmJiAoSVNfUFVSRSB8fCAhREVTQ1JJUFRPUlMpIHx8ICFwYXJhbXMuc29ydCB8fCB1cmwuaHJlZiAhPT0gXCJodHRwczovL2EvYyUyMGQ/YT0xJmM9M1wiIHx8IHBhcmFtcy5nZXQoXCJjXCIpICE9PSBcIjNcIiB8fCBTdHJpbmcobmV3IFVSTFNlYXJjaFBhcmFtcyhcIj9hPTFcIikpICE9PSBcImE9MVwiIHx8ICFwYXJhbXNbSVRFUkFUT1JdIHx8IG5ldyBVUkwoXCJodHRwczovL2FAYlwiKS51c2VybmFtZSAhPT0gXCJhXCIgfHwgbmV3IFVSTFNlYXJjaFBhcmFtcyhuZXcgVVJMU2VhcmNoUGFyYW1zKFwiYT1iXCIpKS5nZXQoXCJhXCIpICE9PSBcImJcIiB8fCBuZXcgVVJMKFwiaHR0cHM6Ly/RgtC10YHRglwiKS5ob3N0ICE9PSBcInhuLS1lMWF5YmNcIiB8fCBuZXcgVVJMKFwiaHR0cHM6Ly9hI9CxXCIpLmhhc2ggIT09IFwiIyVEMCVCMVwiIHx8IHJlc3VsdCAhPT0gXCJhMWMzXCIgfHwgbmV3IFVSTChcImh0dHBzOi8veFwiLCB2b2lkIDApLmhvc3QgIT09IFwieFwiO1xuICAgICAgfSk7XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgNzQ3NjogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgY2xhc3NvZlJhdyA9IF9fd2VicGFja19yZXF1aXJlX18yKDIxOTUpO1xuICAgICAgdmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoOTUwNCk7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbihmbikge1xuICAgICAgICBpZiAoY2xhc3NvZlJhdyhmbikgPT09IFwiRnVuY3Rpb25cIikgcmV0dXJuIHVuY3VycnlUaGlzKGZuKTtcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgNzU2NjogKFxuICAgIC8qKiovXG4gICAgKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyIGRlZmluZUJ1aWx0SW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2ODQwKTtcbiAgICAgIHZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18yKDk1MDQpO1xuICAgICAgdmFyIHRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNjU1KTtcbiAgICAgIHZhciB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18yKDI4MTIpO1xuICAgICAgdmFyICRVUkxTZWFyY2hQYXJhbXMgPSBVUkxTZWFyY2hQYXJhbXM7XG4gICAgICB2YXIgVVJMU2VhcmNoUGFyYW1zUHJvdG90eXBlID0gJFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGU7XG4gICAgICB2YXIgZ2V0QWxsID0gdW5jdXJyeVRoaXMoVVJMU2VhcmNoUGFyYW1zUHJvdG90eXBlLmdldEFsbCk7XG4gICAgICB2YXIgJGhhcyA9IHVuY3VycnlUaGlzKFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZS5oYXMpO1xuICAgICAgdmFyIHBhcmFtcyA9IG5ldyAkVVJMU2VhcmNoUGFyYW1zKFwiYT0xXCIpO1xuICAgICAgaWYgKHBhcmFtcy5oYXMoXCJhXCIsIDIpIHx8ICFwYXJhbXMuaGFzKFwiYVwiLCB2b2lkIDApKSB7XG4gICAgICAgIGRlZmluZUJ1aWx0SW4oVVJMU2VhcmNoUGFyYW1zUHJvdG90eXBlLCBcImhhc1wiLCBmdW5jdGlvbiBoYXMobmFtZSkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgIHZhciAkdmFsdWUgPSBsZW5ndGggPCAyID8gdm9pZCAwIDogYXJndW1lbnRzWzFdO1xuICAgICAgICAgIGlmIChsZW5ndGggJiYgJHZhbHVlID09PSB2b2lkIDApIHJldHVybiAkaGFzKHRoaXMsIG5hbWUpO1xuICAgICAgICAgIHZhciB2YWx1ZXMgPSBnZXRBbGwodGhpcywgbmFtZSk7XG4gICAgICAgICAgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgobGVuZ3RoLCAxKTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB0b1N0cmluZygkdmFsdWUpO1xuICAgICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgICAgd2hpbGUgKGluZGV4IDwgdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHZhbHVlc1tpbmRleCsrXSA9PT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sIHsgZW51bWVyYWJsZTogdHJ1ZSwgdW5zYWZlOiB0cnVlIH0pO1xuICAgICAgfVxuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDc1ODg6IChcbiAgICAvKioqL1xuICAgICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNjUxOCk7XG4gICAgICB2YXIgY2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18yKDk1NjUpO1xuICAgICAgdmFyIGl0ZXJhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigyNjUyKTtcbiAgICAgIHZhciBhQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig5MzA2KTtcbiAgICAgIHZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18yKDg1NTEpO1xuICAgICAgdmFyIGdldEl0ZXJhdG9yRGlyZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMTc2Nyk7XG4gICAgICB2YXIgaXRlcmF0b3JDbG9zZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDk1MzkpO1xuICAgICAgdmFyIGl0ZXJhdG9ySGVscGVyV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig0NTQ5KTtcbiAgICAgIHZhciBmb3JFYWNoV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IgPSBpdGVyYXRvckhlbHBlcldpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yKFwiZm9yRWFjaFwiLCBUeXBlRXJyb3IpO1xuICAgICAgJCh7IHRhcmdldDogXCJJdGVyYXRvclwiLCBwcm90bzogdHJ1ZSwgcmVhbDogdHJ1ZSwgZm9yY2VkOiBmb3JFYWNoV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IgfSwge1xuICAgICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGZuKSB7XG4gICAgICAgICAgYW5PYmplY3QodGhpcyk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGFDYWxsYWJsZShmbik7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yQ2xvc2UodGhpcywgXCJ0aHJvd1wiLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmb3JFYWNoV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IpIHJldHVybiBjYWxsKGZvckVhY2hXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciwgdGhpcywgZm4pO1xuICAgICAgICAgIHZhciByZWNvcmQgPSBnZXRJdGVyYXRvckRpcmVjdCh0aGlzKTtcbiAgICAgICAgICB2YXIgY291bnRlciA9IDA7XG4gICAgICAgICAgaXRlcmF0ZShyZWNvcmQsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBmbih2YWx1ZSwgY291bnRlcisrKTtcbiAgICAgICAgICB9LCB7IElTX1JFQ09SRDogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgNzYyOTogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgSVNfUFVSRSA9IF9fd2VicGFja19yZXF1aXJlX18yKDYzOTUpO1xuICAgICAgdmFyIGdsb2JhbFRoaXMyID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNDU3Nik7XG4gICAgICB2YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig5NDMzKTtcbiAgICAgIHZhciBTSEFSRUQgPSBcIl9fY29yZS1qc19zaGFyZWRfX1wiO1xuICAgICAgdmFyIHN0b3JlID0gbW9kdWxlMi5leHBvcnRzID0gZ2xvYmFsVGhpczJbU0hBUkVEXSB8fCBkZWZpbmVHbG9iYWxQcm9wZXJ0eShTSEFSRUQsIHt9KTtcbiAgICAgIChzdG9yZS52ZXJzaW9ucyB8fCAoc3RvcmUudmVyc2lvbnMgPSBbXSkpLnB1c2goe1xuICAgICAgICB2ZXJzaW9uOiBcIjMuNDUuMVwiLFxuICAgICAgICBtb2RlOiBJU19QVVJFID8gXCJwdXJlXCIgOiBcImdsb2JhbFwiLFxuICAgICAgICBjb3B5cmlnaHQ6IFwiwqkgMjAxNC0yMDI1IERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpXCIsXG4gICAgICAgIGxpY2Vuc2U6IFwiaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvYmxvYi92My40NS4xL0xJQ0VOU0VcIixcbiAgICAgICAgc291cmNlOiBcImh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzXCJcbiAgICAgIH0pO1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDc2NDI6IChcbiAgICAvKioqL1xuICAgICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNjUxOCk7XG4gICAgICB2YXIgZGlmZmVyZW5jZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDM0NDApO1xuICAgICAgdmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoOTAzOSk7XG4gICAgICB2YXIgc2V0TWV0aG9kQWNjZXB0U2V0TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDQ5MTYpO1xuICAgICAgdmFyIFNFVF9MSUtFX0lOQ09SUkVDVF9CRUhBVklPUiA9ICFzZXRNZXRob2RBY2NlcHRTZXRMaWtlKFwiZGlmZmVyZW5jZVwiLCBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zaXplID09PSAwO1xuICAgICAgfSk7XG4gICAgICB2YXIgRk9SQ0VEID0gU0VUX0xJS0VfSU5DT1JSRUNUX0JFSEFWSU9SIHx8IGZhaWxzKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2V0TGlrZSA9IHtcbiAgICAgICAgICBzaXplOiAxLFxuICAgICAgICAgIGhhczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGtleXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBkb25lID0gaW5kZXgrKyA+IDE7XG4gICAgICAgICAgICAgICAgaWYgKGJhc2VTZXQuaGFzKDEpKSBiYXNlU2V0LmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZG9uZSwgdmFsdWU6IDIgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBiYXNlU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWzEsIDIsIDMsIDRdKTtcbiAgICAgICAgcmV0dXJuIGJhc2VTZXQuZGlmZmVyZW5jZShzZXRMaWtlKS5zaXplICE9PSAzO1xuICAgICAgfSk7XG4gICAgICAkKHsgdGFyZ2V0OiBcIlNldFwiLCBwcm90bzogdHJ1ZSwgcmVhbDogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQgfSwge1xuICAgICAgICBkaWZmZXJlbmNlXG4gICAgICB9KTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA3NjU3OiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18yKDkwMzkpO1xuICAgICAgdmFyIGlzQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig0OTAxKTtcbiAgICAgIHZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18yKDM0KTtcbiAgICAgIHZhciBjcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigyMzYwKTtcbiAgICAgIHZhciBnZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18yKDI3ODcpO1xuICAgICAgdmFyIGRlZmluZUJ1aWx0SW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2ODQwKTtcbiAgICAgIHZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig4MjI3KTtcbiAgICAgIHZhciBJU19QVVJFID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNjM5NSk7XG4gICAgICB2YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woXCJpdGVyYXRvclwiKTtcbiAgICAgIHZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gZmFsc2U7XG4gICAgICB2YXIgSXRlcmF0b3JQcm90b3R5cGUsIFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSwgYXJyYXlJdGVyYXRvcjtcbiAgICAgIGlmIChbXS5rZXlzKSB7XG4gICAgICAgIGFycmF5SXRlcmF0b3IgPSBbXS5rZXlzKCk7XG4gICAgICAgIGlmICghKFwibmV4dFwiIGluIGFycmF5SXRlcmF0b3IpKSBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gdHJ1ZTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoZ2V0UHJvdG90eXBlT2YoYXJyYXlJdGVyYXRvcikpO1xuICAgICAgICAgIGlmIChQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpIEl0ZXJhdG9yUHJvdG90eXBlID0gUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgTkVXX0lURVJBVE9SX1BST1RPVFlQRSA9ICFpc09iamVjdChJdGVyYXRvclByb3RvdHlwZSkgfHwgZmFpbHMoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0ZXN0ID0ge307XG4gICAgICAgIHJldHVybiBJdGVyYXRvclByb3RvdHlwZVtJVEVSQVRPUl0uY2FsbCh0ZXN0KSAhPT0gdGVzdDtcbiAgICAgIH0pO1xuICAgICAgaWYgKE5FV19JVEVSQVRPUl9QUk9UT1RZUEUpIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gICAgICBlbHNlIGlmIChJU19QVVJFKSBJdGVyYXRvclByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gICAgICBpZiAoIWlzQ2FsbGFibGUoSXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdKSkge1xuICAgICAgICBkZWZpbmVCdWlsdEluKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbW9kdWxlMi5leHBvcnRzID0ge1xuICAgICAgICBJdGVyYXRvclByb3RvdHlwZSxcbiAgICAgICAgQlVHR1lfU0FGQVJJX0lURVJBVE9SU1xuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA3NjgwOiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18yKDk1MDQpO1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gdW5jdXJyeVRoaXMoW10uc2xpY2UpO1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDc2OTY6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMiwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyIHRvSW50ZWdlck9ySW5maW5pdHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigxMjkxKTtcbiAgICAgIHZhciB0b0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18yKDgwMTQpO1xuICAgICAgdmFyICRSYW5nZUVycm9yID0gUmFuZ2VFcnJvcjtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KSB7XG4gICAgICAgIGlmIChpdCA9PT0gdm9pZCAwKSByZXR1cm4gMDtcbiAgICAgICAgdmFyIG51bWJlciA9IHRvSW50ZWdlck9ySW5maW5pdHkoaXQpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgobnVtYmVyKTtcbiAgICAgICAgaWYgKG51bWJlciAhPT0gbGVuZ3RoKSB0aHJvdyBuZXcgJFJhbmdlRXJyb3IoXCJXcm9uZyBsZW5ndGggb3IgaW5kZXhcIik7XG4gICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICB9O1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDc3NDA6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMiwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyIGhhc093biA9IF9fd2VicGFja19yZXF1aXJlX18yKDkyOTcpO1xuICAgICAgdmFyIG93bktleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig1MDMxKTtcbiAgICAgIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig3MzQ3KTtcbiAgICAgIHZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDQ5MTMpO1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24odGFyZ2V0LCBzb3VyY2UsIGV4Y2VwdGlvbnMpIHtcbiAgICAgICAgdmFyIGtleXMgPSBvd25LZXlzKHNvdXJjZSk7XG4gICAgICAgIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XG4gICAgICAgIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKCFoYXNPd24odGFyZ2V0LCBrZXkpICYmICEoZXhjZXB0aW9ucyAmJiBoYXNPd24oZXhjZXB0aW9ucywga2V5KSkpIHtcbiAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgNzc1MDogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgaXNOdWxsT3JVbmRlZmluZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig0MTE3KTtcbiAgICAgIHZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24oaXQpIHtcbiAgICAgICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKGl0KSkgdGhyb3cgbmV3ICRUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiBcIiArIGl0KTtcbiAgICAgICAgcmV0dXJuIGl0O1xuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA3NzUxOiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciBnbG9iYWxUaGlzMiA9IF9fd2VicGFja19yZXF1aXJlX18yKDQ1NzYpO1xuICAgICAgdmFyIGlzQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig0OTAxKTtcbiAgICAgIHZhciBhRnVuY3Rpb24gPSBmdW5jdGlvbihhcmd1bWVudCkge1xuICAgICAgICByZXR1cm4gaXNDYWxsYWJsZShhcmd1bWVudCkgPyBhcmd1bWVudCA6IHZvaWQgMDtcbiAgICAgIH07XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbihuYW1lc3BhY2UsIG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBhRnVuY3Rpb24oZ2xvYmFsVGhpczJbbmFtZXNwYWNlXSkgOiBnbG9iYWxUaGlzMltuYW1lc3BhY2VdICYmIGdsb2JhbFRoaXMyW25hbWVzcGFjZV1bbWV0aG9kXTtcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgNzgxMTogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyKSA9PiB7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSB0eXBlb2YgQXJyYXlCdWZmZXIgIT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgRGF0YVZpZXcgIT0gXCJ1bmRlZmluZWRcIjtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA3OTM2OiAoXG4gICAgLyoqKi9cbiAgICAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18yKDY1MTgpO1xuICAgICAgdmFyICR0cmFuc2ZlciA9IF9fd2VicGFja19yZXF1aXJlX18yKDU2MzYpO1xuICAgICAgaWYgKCR0cmFuc2ZlcikgJCh7IHRhcmdldDogXCJBcnJheUJ1ZmZlclwiLCBwcm90bzogdHJ1ZSB9LCB7XG4gICAgICAgIHRyYW5zZmVyVG9GaXhlZExlbmd0aDogZnVuY3Rpb24gdHJhbnNmZXJUb0ZpeGVkTGVuZ3RoKCkge1xuICAgICAgICAgIHJldHVybiAkdHJhbnNmZXIodGhpcywgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1swXSA6IHZvaWQgMCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA4MDA0OiAoXG4gICAgLyoqKi9cbiAgICAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18yKDY1MTgpO1xuICAgICAgdmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoOTAzOSk7XG4gICAgICB2YXIgaW50ZXJzZWN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoODc1MCk7XG4gICAgICB2YXIgc2V0TWV0aG9kQWNjZXB0U2V0TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDQ5MTYpO1xuICAgICAgdmFyIElOQ09SUkVDVCA9ICFzZXRNZXRob2RBY2NlcHRTZXRMaWtlKFwiaW50ZXJzZWN0aW9uXCIsIGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0LnNpemUgPT09IDIgJiYgcmVzdWx0LmhhcygxKSAmJiByZXN1bHQuaGFzKDIpO1xuICAgICAgfSkgfHwgZmFpbHMoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcoQXJyYXkuZnJvbSgoLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWzEsIDIsIDNdKSkuaW50ZXJzZWN0aW9uKC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFszLCAyXSkpKSkgIT09IFwiMywyXCI7XG4gICAgICB9KTtcbiAgICAgICQoeyB0YXJnZXQ6IFwiU2V0XCIsIHByb3RvOiB0cnVlLCByZWFsOiB0cnVlLCBmb3JjZWQ6IElOQ09SUkVDVCB9LCB7XG4gICAgICAgIGludGVyc2VjdGlvblxuICAgICAgfSk7XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgODAxNDogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSA9IF9fd2VicGFja19yZXF1aXJlX18yKDEyOTEpO1xuICAgICAgdmFyIG1pbiA9IE1hdGgubWluO1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24oYXJndW1lbnQpIHtcbiAgICAgICAgdmFyIGxlbiA9IHRvSW50ZWdlck9ySW5maW5pdHkoYXJndW1lbnQpO1xuICAgICAgICByZXR1cm4gbGVuID4gMCA/IG1pbihsZW4sIDkwMDcxOTkyNTQ3NDA5OTEpIDogMDtcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgODEwMDogKFxuICAgIC8qKiovXG4gICAgKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2NTE4KTtcbiAgICAgIHZhciAkdHJhbnNmZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig1NjM2KTtcbiAgICAgIGlmICgkdHJhbnNmZXIpICQoeyB0YXJnZXQ6IFwiQXJyYXlCdWZmZXJcIiwgcHJvdG86IHRydWUgfSwge1xuICAgICAgICB0cmFuc2ZlcjogZnVuY3Rpb24gdHJhbnNmZXIoKSB7XG4gICAgICAgICAgcmV0dXJuICR0cmFuc2Zlcih0aGlzLCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzBdIDogdm9pZCAwLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgODExMTogKFxuICAgIC8qKiovXG4gICAgKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2NTE4KTtcbiAgICAgIHZhciBnbG9iYWxUaGlzMiA9IF9fd2VicGFja19yZXF1aXJlX18yKDQ1NzYpO1xuICAgICAgdmFyIGFuSW5zdGFuY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2NzkpO1xuICAgICAgdmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoODU1MSk7XG4gICAgICB2YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDQ5MDEpO1xuICAgICAgdmFyIGdldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMjc4Nyk7XG4gICAgICB2YXIgZGVmaW5lQnVpbHRJbkFjY2Vzc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMjEwNik7XG4gICAgICB2YXIgY3JlYXRlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig0NjU5KTtcbiAgICAgIHZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18yKDkwMzkpO1xuICAgICAgdmFyIGhhc093biA9IF9fd2VicGFja19yZXF1aXJlX18yKDkyOTcpO1xuICAgICAgdmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18yKDgyMjcpO1xuICAgICAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNzY1NykuSXRlcmF0b3JQcm90b3R5cGU7XG4gICAgICB2YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigzNzI0KTtcbiAgICAgIHZhciBJU19QVVJFID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNjM5NSk7XG4gICAgICB2YXIgQ09OU1RSVUNUT1IgPSBcImNvbnN0cnVjdG9yXCI7XG4gICAgICB2YXIgSVRFUkFUT1IgPSBcIkl0ZXJhdG9yXCI7XG4gICAgICB2YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbChcInRvU3RyaW5nVGFnXCIpO1xuICAgICAgdmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG4gICAgICB2YXIgTmF0aXZlSXRlcmF0b3IgPSBnbG9iYWxUaGlzMltJVEVSQVRPUl07XG4gICAgICB2YXIgRk9SQ0VEID0gSVNfUFVSRSB8fCAhaXNDYWxsYWJsZShOYXRpdmVJdGVyYXRvcikgfHwgTmF0aXZlSXRlcmF0b3IucHJvdG90eXBlICE9PSBJdGVyYXRvclByb3RvdHlwZSB8fCAhZmFpbHMoZnVuY3Rpb24oKSB7XG4gICAgICAgIE5hdGl2ZUl0ZXJhdG9yKHt9KTtcbiAgICAgIH0pO1xuICAgICAgdmFyIEl0ZXJhdG9yQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBJdGVyYXRvcjIoKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGhpcywgSXRlcmF0b3JQcm90b3R5cGUpO1xuICAgICAgICBpZiAoZ2V0UHJvdG90eXBlT2YodGhpcykgPT09IEl0ZXJhdG9yUHJvdG90eXBlKSB0aHJvdyBuZXcgJFR5cGVFcnJvcihcIkFic3RyYWN0IGNsYXNzIEl0ZXJhdG9yIG5vdCBkaXJlY3RseSBjb25zdHJ1Y3RhYmxlXCIpO1xuICAgICAgfTtcbiAgICAgIHZhciBkZWZpbmVJdGVyYXRvclByb3RvdHlwZUFjY2Vzc29yID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoREVTQ1JJUFRPUlMpIHtcbiAgICAgICAgICBkZWZpbmVCdWlsdEluQWNjZXNzb3IoSXRlcmF0b3JQcm90b3R5cGUsIGtleSwge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24ocmVwbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgYW5PYmplY3QodGhpcyk7XG4gICAgICAgICAgICAgIGlmICh0aGlzID09PSBJdGVyYXRvclByb3RvdHlwZSkgdGhyb3cgbmV3ICRUeXBlRXJyb3IoXCJZb3UgY2FuJ3QgcmVkZWZpbmUgdGhpcyBwcm9wZXJ0eVwiKTtcbiAgICAgICAgICAgICAgaWYgKGhhc093bih0aGlzLCBrZXkpKSB0aGlzW2tleV0gPSByZXBsYWNlbWVudDtcbiAgICAgICAgICAgICAgZWxzZSBjcmVhdGVQcm9wZXJ0eSh0aGlzLCBrZXksIHJlcGxhY2VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIEl0ZXJhdG9yUHJvdG90eXBlW2tleV0gPSB2YWx1ZTtcbiAgICAgIH07XG4gICAgICBpZiAoIWhhc093bihJdGVyYXRvclByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRykpIGRlZmluZUl0ZXJhdG9yUHJvdG90eXBlQWNjZXNzb3IoVE9fU1RSSU5HX1RBRywgSVRFUkFUT1IpO1xuICAgICAgaWYgKEZPUkNFRCB8fCAhaGFzT3duKEl0ZXJhdG9yUHJvdG90eXBlLCBDT05TVFJVQ1RPUikgfHwgSXRlcmF0b3JQcm90b3R5cGVbQ09OU1RSVUNUT1JdID09PSBPYmplY3QpIHtcbiAgICAgICAgZGVmaW5lSXRlcmF0b3JQcm90b3R5cGVBY2Nlc3NvcihDT05TVFJVQ1RPUiwgSXRlcmF0b3JDb25zdHJ1Y3Rvcik7XG4gICAgICB9XG4gICAgICBJdGVyYXRvckNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IEl0ZXJhdG9yUHJvdG90eXBlO1xuICAgICAgJCh7IGdsb2JhbDogdHJ1ZSwgY29uc3RydWN0b3I6IHRydWUsIGZvcmNlZDogRk9SQ0VEIH0sIHtcbiAgICAgICAgSXRlcmF0b3I6IEl0ZXJhdG9yQ29uc3RydWN0b3JcbiAgICAgIH0pO1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDgyMjc6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMiwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyIGdsb2JhbFRoaXMyID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNDU3Nik7XG4gICAgICB2YXIgc2hhcmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNTc0NSk7XG4gICAgICB2YXIgaGFzT3duID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoOTI5Nyk7XG4gICAgICB2YXIgdWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMzM5Mik7XG4gICAgICB2YXIgTkFUSVZFX1NZTUJPTCA9IF9fd2VicGFja19yZXF1aXJlX18yKDQ0OTUpO1xuICAgICAgdmFyIFVTRV9TWU1CT0xfQVNfVUlEID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNzA0MCk7XG4gICAgICB2YXIgU3ltYm9sMiA9IGdsb2JhbFRoaXMyLlN5bWJvbDtcbiAgICAgIHZhciBXZWxsS25vd25TeW1ib2xzU3RvcmUgPSBzaGFyZWQoXCJ3a3NcIik7XG4gICAgICB2YXIgY3JlYXRlV2VsbEtub3duU3ltYm9sID0gVVNFX1NZTUJPTF9BU19VSUQgPyBTeW1ib2wyW1wiZm9yXCJdIHx8IFN5bWJvbDIgOiBTeW1ib2wyICYmIFN5bWJvbDIud2l0aG91dFNldHRlciB8fCB1aWQ7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGlmICghaGFzT3duKFdlbGxLbm93blN5bWJvbHNTdG9yZSwgbmFtZSkpIHtcbiAgICAgICAgICBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBOQVRJVkVfU1lNQk9MICYmIGhhc093bihTeW1ib2wyLCBuYW1lKSA/IFN5bWJvbDJbbmFtZV0gOiBjcmVhdGVXZWxsS25vd25TeW1ib2woXCJTeW1ib2wuXCIgKyBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdO1xuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA4MjM1OiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18yKDk1MDQpO1xuICAgICAgdmFyIGhhc093biA9IF9fd2VicGFja19yZXF1aXJlX18yKDkyOTcpO1xuICAgICAgdmFyICRTeW50YXhFcnJvciA9IFN5bnRheEVycm9yO1xuICAgICAgdmFyICRwYXJzZUludCA9IHBhcnNlSW50O1xuICAgICAgdmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG4gICAgICB2YXIgYXQgPSB1bmN1cnJ5VGhpcyhcIlwiLmNoYXJBdCk7XG4gICAgICB2YXIgc2xpY2UgPSB1bmN1cnJ5VGhpcyhcIlwiLnNsaWNlKTtcbiAgICAgIHZhciBleGVjID0gdW5jdXJyeVRoaXMoLy4vLmV4ZWMpO1xuICAgICAgdmFyIGNvZGVQb2ludHMgPSB7XG4gICAgICAgICdcXFxcXCInOiAnXCInLFxuICAgICAgICBcIlxcXFxcXFxcXCI6IFwiXFxcXFwiLFxuICAgICAgICBcIlxcXFwvXCI6IFwiL1wiLFxuICAgICAgICBcIlxcXFxiXCI6IFwiXFxiXCIsXG4gICAgICAgIFwiXFxcXGZcIjogXCJcXGZcIixcbiAgICAgICAgXCJcXFxcblwiOiBcIlxcblwiLFxuICAgICAgICBcIlxcXFxyXCI6IFwiXFxyXCIsXG4gICAgICAgIFwiXFxcXHRcIjogXCJcdFwiXG4gICAgICB9O1xuICAgICAgdmFyIElTXzRfSEVYX0RJR0lUUyA9IC9eW1xcZGEtZl17NH0kL2k7XG4gICAgICB2YXIgSVNfQzBfQ09OVFJPTF9DT0RFID0gL15bXFx1MDAwMC1cXHUwMDFGXSQvO1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24oc291cmNlLCBpKSB7XG4gICAgICAgIHZhciB1bnRlcm1pbmF0ZWQgPSB0cnVlO1xuICAgICAgICB2YXIgdmFsdWUgPSBcIlwiO1xuICAgICAgICB3aGlsZSAoaSA8IHNvdXJjZS5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgY2hyID0gYXQoc291cmNlLCBpKTtcbiAgICAgICAgICBpZiAoY2hyID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgdmFyIHR3b0NoYXJzID0gc2xpY2Uoc291cmNlLCBpLCBpICsgMik7XG4gICAgICAgICAgICBpZiAoaGFzT3duKGNvZGVQb2ludHMsIHR3b0NoYXJzKSkge1xuICAgICAgICAgICAgICB2YWx1ZSArPSBjb2RlUG9pbnRzW3R3b0NoYXJzXTtcbiAgICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0d29DaGFycyA9PT0gXCJcXFxcdVwiKSB7XG4gICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgICAgdmFyIGZvdXJIZXhEaWdpdHMgPSBzbGljZShzb3VyY2UsIGksIGkgKyA0KTtcbiAgICAgICAgICAgICAgaWYgKCFleGVjKElTXzRfSEVYX0RJR0lUUywgZm91ckhleERpZ2l0cykpIHRocm93IG5ldyAkU3ludGF4RXJyb3IoXCJCYWQgVW5pY29kZSBlc2NhcGUgYXQ6IFwiICsgaSk7XG4gICAgICAgICAgICAgIHZhbHVlICs9IGZyb21DaGFyQ29kZSgkcGFyc2VJbnQoZm91ckhleERpZ2l0cywgMTYpKTtcbiAgICAgICAgICAgICAgaSArPSA0O1xuICAgICAgICAgICAgfSBlbHNlIHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ1Vua25vd24gZXNjYXBlIHNlcXVlbmNlOiBcIicgKyB0d29DaGFycyArICdcIicpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hyID09PSAnXCInKSB7XG4gICAgICAgICAgICB1bnRlcm1pbmF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZXhlYyhJU19DMF9DT05UUk9MX0NPREUsIGNocikpIHRocm93IG5ldyAkU3ludGF4RXJyb3IoXCJCYWQgY29udHJvbCBjaGFyYWN0ZXIgaW4gc3RyaW5nIGxpdGVyYWwgYXQ6IFwiICsgaSk7XG4gICAgICAgICAgICB2YWx1ZSArPSBjaHI7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh1bnRlcm1pbmF0ZWQpIHRocm93IG5ldyAkU3ludGF4RXJyb3IoXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGF0OiBcIiArIGkpO1xuICAgICAgICByZXR1cm4geyB2YWx1ZSwgZW5kOiBpIH07XG4gICAgICB9O1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDgyMzc6IChcbiAgICAvKioqL1xuICAgICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNjUxOCk7XG4gICAgICB2YXIgaXRlcmF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDI2NTIpO1xuICAgICAgdmFyIGFDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDkzMDYpO1xuICAgICAgdmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoODU1MSk7XG4gICAgICB2YXIgZ2V0SXRlcmF0b3JEaXJlY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigxNzY3KTtcbiAgICAgIHZhciBpdGVyYXRvckNsb3NlID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoOTUzOSk7XG4gICAgICB2YXIgaXRlcmF0b3JIZWxwZXJXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18yKDQ1NDkpO1xuICAgICAgdmFyIGFwcGx5ID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoODc0NSk7XG4gICAgICB2YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig5MDM5KTtcbiAgICAgIHZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuICAgICAgdmFyIEZBSUxTX09OX0lOSVRJQUxfVU5ERUZJTkVEID0gZmFpbHMoZnVuY3Rpb24oKSB7XG4gICAgICAgIFtdLmtleXMoKS5yZWR1Y2UoZnVuY3Rpb24oKSB7XG4gICAgICAgIH0sIHZvaWQgMCk7XG4gICAgICB9KTtcbiAgICAgIHZhciByZWR1Y2VXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciA9ICFGQUlMU19PTl9JTklUSUFMX1VOREVGSU5FRCAmJiBpdGVyYXRvckhlbHBlcldpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yKFwicmVkdWNlXCIsICRUeXBlRXJyb3IpO1xuICAgICAgJCh7IHRhcmdldDogXCJJdGVyYXRvclwiLCBwcm90bzogdHJ1ZSwgcmVhbDogdHJ1ZSwgZm9yY2VkOiBGQUlMU19PTl9JTklUSUFMX1VOREVGSU5FRCB8fCByZWR1Y2VXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciB9LCB7XG4gICAgICAgIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKHJlZHVjZXIpIHtcbiAgICAgICAgICBhbk9iamVjdCh0aGlzKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYUNhbGxhYmxlKHJlZHVjZXIpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpdGVyYXRvckNsb3NlKHRoaXMsIFwidGhyb3dcIiwgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbm9Jbml0aWFsID0gYXJndW1lbnRzLmxlbmd0aCA8IDI7XG4gICAgICAgICAgdmFyIGFjY3VtdWxhdG9yID0gbm9Jbml0aWFsID8gdm9pZCAwIDogYXJndW1lbnRzWzFdO1xuICAgICAgICAgIGlmIChyZWR1Y2VXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHJlZHVjZVdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yLCB0aGlzLCBub0luaXRpYWwgPyBbcmVkdWNlcl0gOiBbcmVkdWNlciwgYWNjdW11bGF0b3JdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGdldEl0ZXJhdG9yRGlyZWN0KHRoaXMpO1xuICAgICAgICAgIHZhciBjb3VudGVyID0gMDtcbiAgICAgICAgICBpdGVyYXRlKHJlY29yZCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChub0luaXRpYWwpIHtcbiAgICAgICAgICAgICAgbm9Jbml0aWFsID0gZmFsc2U7XG4gICAgICAgICAgICAgIGFjY3VtdWxhdG9yID0gdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhY2N1bXVsYXRvciA9IHJlZHVjZXIoYWNjdW11bGF0b3IsIHZhbHVlLCBjb3VudGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvdW50ZXIrKztcbiAgICAgICAgICB9LCB7IElTX1JFQ09SRDogdHJ1ZSB9KTtcbiAgICAgICAgICBpZiAobm9Jbml0aWFsKSB0aHJvdyBuZXcgJFR5cGVFcnJvcihcIlJlZHVjZSBvZiBlbXB0eSBpdGVyYXRvciB3aXRoIG5vIGluaXRpYWwgdmFsdWVcIik7XG4gICAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA4MzM1OiAoXG4gICAgLyoqKi9cbiAgICAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18yKDY1MTgpO1xuICAgICAgdmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMzcyNCk7XG4gICAgICB2YXIgZ2xvYmFsVGhpczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig0NTc2KTtcbiAgICAgIHZhciBnZXRCdWlsdEluID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNzc1MSk7XG4gICAgICB2YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig5NTA0KTtcbiAgICAgIHZhciBjYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoOTU2NSk7XG4gICAgICB2YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDQ5MDEpO1xuICAgICAgdmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMzQpO1xuICAgICAgdmFyIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig0Mzc2KTtcbiAgICAgIHZhciBoYXNPd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig5Mjk3KTtcbiAgICAgIHZhciB0b1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18yKDY1NSk7XG4gICAgICB2YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2MTk4KTtcbiAgICAgIHZhciBjcmVhdGVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18yKDQ2NTkpO1xuICAgICAgdmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoOTAzOSk7XG4gICAgICB2YXIgcGFyc2VKU09OU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoODIzNSk7XG4gICAgICB2YXIgTkFUSVZFX1NZTUJPTCA9IF9fd2VicGFja19yZXF1aXJlX18yKDQ0OTUpO1xuICAgICAgdmFyIEpTT04yID0gZ2xvYmFsVGhpczIuSlNPTjtcbiAgICAgIHZhciBOdW1iZXIyID0gZ2xvYmFsVGhpczIuTnVtYmVyO1xuICAgICAgdmFyIFN5bnRheEVycm9yMiA9IGdsb2JhbFRoaXMyLlN5bnRheEVycm9yO1xuICAgICAgdmFyIG5hdGl2ZVBhcnNlID0gSlNPTjIgJiYgSlNPTjIucGFyc2U7XG4gICAgICB2YXIgZW51bWVyYWJsZU93blByb3BlcnRpZXMgPSBnZXRCdWlsdEluKFwiT2JqZWN0XCIsIFwia2V5c1wiKTtcbiAgICAgIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAgICAgdmFyIGF0ID0gdW5jdXJyeVRoaXMoXCJcIi5jaGFyQXQpO1xuICAgICAgdmFyIHNsaWNlID0gdW5jdXJyeVRoaXMoXCJcIi5zbGljZSk7XG4gICAgICB2YXIgZXhlYyA9IHVuY3VycnlUaGlzKC8uLy5leGVjKTtcbiAgICAgIHZhciBwdXNoID0gdW5jdXJyeVRoaXMoW10ucHVzaCk7XG4gICAgICB2YXIgSVNfRElHSVQgPSAvXlxcZCQvO1xuICAgICAgdmFyIElTX05PTl9aRVJPX0RJR0lUID0gL15bMS05XSQvO1xuICAgICAgdmFyIElTX05VTUJFUl9TVEFSVCA9IC9eW1xcZC1dJC87XG4gICAgICB2YXIgSVNfV0hJVEVTUEFDRSA9IC9eW1xcdFxcblxcciBdJC87XG4gICAgICB2YXIgUFJJTUlUSVZFID0gMDtcbiAgICAgIHZhciBPQkpFQ1QgPSAxO1xuICAgICAgdmFyICRwYXJzZSA9IGZ1bmN0aW9uKHNvdXJjZSwgcmV2aXZlcikge1xuICAgICAgICBzb3VyY2UgPSB0b1N0cmluZyhzb3VyY2UpO1xuICAgICAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHNvdXJjZSwgMCk7XG4gICAgICAgIHZhciByb290ID0gY29udGV4dC5wYXJzZSgpO1xuICAgICAgICB2YXIgdmFsdWUgPSByb290LnZhbHVlO1xuICAgICAgICB2YXIgZW5kSW5kZXggPSBjb250ZXh0LnNraXAoSVNfV0hJVEVTUEFDRSwgcm9vdC5lbmQpO1xuICAgICAgICBpZiAoZW5kSW5kZXggPCBzb3VyY2UubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yMignVW5leHBlY3RlZCBleHRyYSBjaGFyYWN0ZXI6IFwiJyArIGF0KHNvdXJjZSwgZW5kSW5kZXgpICsgJ1wiIGFmdGVyIHRoZSBwYXJzZWQgZGF0YSBhdDogJyArIGVuZEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNDYWxsYWJsZShyZXZpdmVyKSA/IGludGVybmFsaXplKHsgXCJcIjogdmFsdWUgfSwgXCJcIiwgcmV2aXZlciwgcm9vdCkgOiB2YWx1ZTtcbiAgICAgIH07XG4gICAgICB2YXIgaW50ZXJuYWxpemUgPSBmdW5jdGlvbihob2xkZXIsIG5hbWUsIHJldml2ZXIsIG5vZGUpIHtcbiAgICAgICAgdmFyIHZhbCA9IGhvbGRlcltuYW1lXTtcbiAgICAgICAgdmFyIHVubW9kaWZpZWQgPSBub2RlICYmIHZhbCA9PT0gbm9kZS52YWx1ZTtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB1bm1vZGlmaWVkICYmIHR5cGVvZiBub2RlLnNvdXJjZSA9PSBcInN0cmluZ1wiID8geyBzb3VyY2U6IG5vZGUuc291cmNlIH0gOiB7fTtcbiAgICAgICAgdmFyIGVsZW1lbnRSZWNvcmRzTGVuLCBrZXlzLCBsZW4sIGksIFA7XG4gICAgICAgIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAgICAgICAgdmFyIG5vZGVJc0FycmF5ID0gaXNBcnJheSh2YWwpO1xuICAgICAgICAgIHZhciBub2RlcyA9IHVubW9kaWZpZWQgPyBub2RlLm5vZGVzIDogbm9kZUlzQXJyYXkgPyBbXSA6IHt9O1xuICAgICAgICAgIGlmIChub2RlSXNBcnJheSkge1xuICAgICAgICAgICAgZWxlbWVudFJlY29yZHNMZW4gPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICBsZW4gPSBsZW5ndGhPZkFycmF5TGlrZSh2YWwpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgIGludGVybmFsaXplUHJvcGVydHkodmFsLCBpLCBpbnRlcm5hbGl6ZSh2YWwsIFwiXCIgKyBpLCByZXZpdmVyLCBpIDwgZWxlbWVudFJlY29yZHNMZW4gPyBub2Rlc1tpXSA6IHZvaWQgMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBrZXlzID0gZW51bWVyYWJsZU93blByb3BlcnRpZXModmFsKTtcbiAgICAgICAgICAgIGxlbiA9IGxlbmd0aE9mQXJyYXlMaWtlKGtleXMpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgIFAgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICBpbnRlcm5hbGl6ZVByb3BlcnR5KHZhbCwgUCwgaW50ZXJuYWxpemUodmFsLCBQLCByZXZpdmVyLCBoYXNPd24obm9kZXMsIFApID8gbm9kZXNbUF0gOiB2b2lkIDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGwocmV2aXZlciwgaG9sZGVyLCBuYW1lLCB2YWwsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHZhciBpbnRlcm5hbGl6ZVByb3BlcnR5ID0gZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChERVNDUklQVE9SUykge1xuICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwga2V5KTtcbiAgICAgICAgICBpZiAoZGVzY3JpcHRvciAmJiAhZGVzY3JpcHRvci5jb25maWd1cmFibGUpIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgZGVsZXRlIG9iamVjdFtrZXldO1xuICAgICAgICBlbHNlIGNyZWF0ZVByb3BlcnR5KG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gICAgICB9O1xuICAgICAgdmFyIE5vZGUyID0gZnVuY3Rpb24odmFsdWUsIGVuZCwgc291cmNlLCBub2Rlcykge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5ub2RlcyA9IG5vZGVzO1xuICAgICAgfTtcbiAgICAgIHZhciBDb250ZXh0ID0gZnVuY3Rpb24oc291cmNlLCBpbmRleCkge1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgfTtcbiAgICAgIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgICAgICBmb3JrOiBmdW5jdGlvbihuZXh0SW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENvbnRleHQodGhpcy5zb3VyY2UsIG5leHRJbmRleCk7XG4gICAgICAgIH0sXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgICAgICAgdmFyIGkgPSB0aGlzLnNraXAoSVNfV0hJVEVTUEFDRSwgdGhpcy5pbmRleCk7XG4gICAgICAgICAgdmFyIGZvcmsgPSB0aGlzLmZvcmsoaSk7XG4gICAgICAgICAgdmFyIGNociA9IGF0KHNvdXJjZSwgaSk7XG4gICAgICAgICAgaWYgKGV4ZWMoSVNfTlVNQkVSX1NUQVJULCBjaHIpKSByZXR1cm4gZm9yay5udW1iZXIoKTtcbiAgICAgICAgICBzd2l0Y2ggKGNocikge1xuICAgICAgICAgICAgY2FzZSBcIntcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIGZvcmsub2JqZWN0KCk7XG4gICAgICAgICAgICBjYXNlIFwiW1wiOlxuICAgICAgICAgICAgICByZXR1cm4gZm9yay5hcnJheSgpO1xuICAgICAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgICAgICByZXR1cm4gZm9yay5zdHJpbmcoKTtcbiAgICAgICAgICAgIGNhc2UgXCJ0XCI6XG4gICAgICAgICAgICAgIHJldHVybiBmb3JrLmtleXdvcmQodHJ1ZSk7XG4gICAgICAgICAgICBjYXNlIFwiZlwiOlxuICAgICAgICAgICAgICByZXR1cm4gZm9yay5rZXl3b3JkKGZhbHNlKTtcbiAgICAgICAgICAgIGNhc2UgXCJuXCI6XG4gICAgICAgICAgICAgIHJldHVybiBmb3JrLmtleXdvcmQobnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcjIoJ1VuZXhwZWN0ZWQgY2hhcmFjdGVyOiBcIicgKyBjaHIgKyAnXCIgYXQ6ICcgKyBpKTtcbiAgICAgICAgfSxcbiAgICAgICAgbm9kZTogZnVuY3Rpb24odHlwZSwgdmFsdWUsIHN0YXJ0LCBlbmQsIG5vZGVzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBOb2RlMih2YWx1ZSwgZW5kLCB0eXBlID8gbnVsbCA6IHNsaWNlKHRoaXMuc291cmNlLCBzdGFydCwgZW5kKSwgbm9kZXMpO1xuICAgICAgICB9LFxuICAgICAgICBvYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICAgICAgICB2YXIgaSA9IHRoaXMuaW5kZXggKyAxO1xuICAgICAgICAgIHZhciBleHBlY3RLZXlwYWlyID0gZmFsc2U7XG4gICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgIHZhciBub2RlcyA9IHt9O1xuICAgICAgICAgIHdoaWxlIChpIDwgc291cmNlLmxlbmd0aCkge1xuICAgICAgICAgICAgaSA9IHRoaXMudW50aWwoWydcIicsIFwifVwiXSwgaSk7XG4gICAgICAgICAgICBpZiAoYXQoc291cmNlLCBpKSA9PT0gXCJ9XCIgJiYgIWV4cGVjdEtleXBhaXIpIHtcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmZvcmsoaSkuc3RyaW5nKCk7XG4gICAgICAgICAgICB2YXIga2V5ID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgaSA9IHJlc3VsdC5lbmQ7XG4gICAgICAgICAgICBpID0gdGhpcy51bnRpbChbXCI6XCJdLCBpKSArIDE7XG4gICAgICAgICAgICBpID0gdGhpcy5za2lwKElTX1dISVRFU1BBQ0UsIGkpO1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5mb3JrKGkpLnBhcnNlKCk7XG4gICAgICAgICAgICBjcmVhdGVQcm9wZXJ0eShub2Rlcywga2V5LCByZXN1bHQpO1xuICAgICAgICAgICAgY3JlYXRlUHJvcGVydHkob2JqZWN0LCBrZXksIHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICBpID0gdGhpcy51bnRpbChbXCIsXCIsIFwifVwiXSwgcmVzdWx0LmVuZCk7XG4gICAgICAgICAgICB2YXIgY2hyID0gYXQoc291cmNlLCBpKTtcbiAgICAgICAgICAgIGlmIChjaHIgPT09IFwiLFwiKSB7XG4gICAgICAgICAgICAgIGV4cGVjdEtleXBhaXIgPSB0cnVlO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNociA9PT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMubm9kZShPQkpFQ1QsIG9iamVjdCwgdGhpcy5pbmRleCwgaSwgbm9kZXMpO1xuICAgICAgICB9LFxuICAgICAgICBhcnJheTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgICAgICAgIHZhciBpID0gdGhpcy5pbmRleCArIDE7XG4gICAgICAgICAgdmFyIGV4cGVjdEVsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICAgICAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICAgICAgICB3aGlsZSAoaSA8IHNvdXJjZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGkgPSB0aGlzLnNraXAoSVNfV0hJVEVTUEFDRSwgaSk7XG4gICAgICAgICAgICBpZiAoYXQoc291cmNlLCBpKSA9PT0gXCJdXCIgJiYgIWV4cGVjdEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmZvcmsoaSkucGFyc2UoKTtcbiAgICAgICAgICAgIHB1c2gobm9kZXMsIHJlc3VsdCk7XG4gICAgICAgICAgICBwdXNoKGFycmF5LCByZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgaSA9IHRoaXMudW50aWwoW1wiLFwiLCBcIl1cIl0sIHJlc3VsdC5lbmQpO1xuICAgICAgICAgICAgaWYgKGF0KHNvdXJjZSwgaSkgPT09IFwiLFwiKSB7XG4gICAgICAgICAgICAgIGV4cGVjdEVsZW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGF0KHNvdXJjZSwgaSkgPT09IFwiXVwiKSB7XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLm5vZGUoT0JKRUNULCBhcnJheSwgdGhpcy5pbmRleCwgaSwgbm9kZXMpO1xuICAgICAgICB9LFxuICAgICAgICBzdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlSlNPTlN0cmluZyh0aGlzLnNvdXJjZSwgdGhpcy5pbmRleCArIDEpO1xuICAgICAgICAgIHJldHVybiB0aGlzLm5vZGUoUFJJTUlUSVZFLCBwYXJzZWQudmFsdWUsIGluZGV4LCBwYXJzZWQuZW5kKTtcbiAgICAgICAgfSxcbiAgICAgICAgbnVtYmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICAgIHZhciBpID0gc3RhcnRJbmRleDtcbiAgICAgICAgICBpZiAoYXQoc291cmNlLCBpKSA9PT0gXCItXCIpIGkrKztcbiAgICAgICAgICBpZiAoYXQoc291cmNlLCBpKSA9PT0gXCIwXCIpIGkrKztcbiAgICAgICAgICBlbHNlIGlmIChleGVjKElTX05PTl9aRVJPX0RJR0lULCBhdChzb3VyY2UsIGkpKSkgaSA9IHRoaXMuc2tpcChJU19ESUdJVCwgaSArIDEpO1xuICAgICAgICAgIGVsc2UgdGhyb3cgbmV3IFN5bnRheEVycm9yMihcIkZhaWxlZCB0byBwYXJzZSBudW1iZXIgYXQ6IFwiICsgaSk7XG4gICAgICAgICAgaWYgKGF0KHNvdXJjZSwgaSkgPT09IFwiLlwiKSBpID0gdGhpcy5za2lwKElTX0RJR0lULCBpICsgMSk7XG4gICAgICAgICAgaWYgKGF0KHNvdXJjZSwgaSkgPT09IFwiZVwiIHx8IGF0KHNvdXJjZSwgaSkgPT09IFwiRVwiKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBpZiAoYXQoc291cmNlLCBpKSA9PT0gXCIrXCIgfHwgYXQoc291cmNlLCBpKSA9PT0gXCItXCIpIGkrKztcbiAgICAgICAgICAgIHZhciBleHBvbmVudFN0YXJ0SW5kZXggPSBpO1xuICAgICAgICAgICAgaSA9IHRoaXMuc2tpcChJU19ESUdJVCwgaSk7XG4gICAgICAgICAgICBpZiAoZXhwb25lbnRTdGFydEluZGV4ID09PSBpKSB0aHJvdyBuZXcgU3ludGF4RXJyb3IyKFwiRmFpbGVkIHRvIHBhcnNlIG51bWJlcidzIGV4cG9uZW50IHZhbHVlIGF0OiBcIiArIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlKFBSSU1JVElWRSwgTnVtYmVyMihzbGljZShzb3VyY2UsIHN0YXJ0SW5kZXgsIGkpKSwgc3RhcnRJbmRleCwgaSk7XG4gICAgICAgIH0sXG4gICAgICAgIGtleXdvcmQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIGtleXdvcmQgPSBcIlwiICsgdmFsdWU7XG4gICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgICB2YXIgZW5kSW5kZXggPSBpbmRleCArIGtleXdvcmQubGVuZ3RoO1xuICAgICAgICAgIGlmIChzbGljZSh0aGlzLnNvdXJjZSwgaW5kZXgsIGVuZEluZGV4KSAhPT0ga2V5d29yZCkgdGhyb3cgbmV3IFN5bnRheEVycm9yMihcIkZhaWxlZCB0byBwYXJzZSB2YWx1ZSBhdDogXCIgKyBpbmRleCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubm9kZShQUklNSVRJVkUsIHZhbHVlLCBpbmRleCwgZW5kSW5kZXgpO1xuICAgICAgICB9LFxuICAgICAgICBza2lwOiBmdW5jdGlvbihyZWdleCwgaSkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICAgICAgICBmb3IgKDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykgaWYgKCFleGVjKHJlZ2V4LCBhdChzb3VyY2UsIGkpKSkgYnJlYWs7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH0sXG4gICAgICAgIHVudGlsOiBmdW5jdGlvbihhcnJheSwgaSkge1xuICAgICAgICAgIGkgPSB0aGlzLnNraXAoSVNfV0hJVEVTUEFDRSwgaSk7XG4gICAgICAgICAgdmFyIGNociA9IGF0KHRoaXMuc291cmNlLCBpKTtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFycmF5Lmxlbmd0aDsgaisrKSBpZiAoYXJyYXlbal0gPT09IGNocikgcmV0dXJuIGk7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yMignVW5leHBlY3RlZCBjaGFyYWN0ZXI6IFwiJyArIGNociArICdcIiBhdDogJyArIGkpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdmFyIE5PX1NPVVJDRV9TVVBQT1JUID0gZmFpbHMoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB1bnNhZmVJbnQgPSBcIjkwMDcxOTkyNTQ3NDA5OTNcIjtcbiAgICAgICAgdmFyIHNvdXJjZTtcbiAgICAgICAgbmF0aXZlUGFyc2UodW5zYWZlSW50LCBmdW5jdGlvbihrZXksIHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgICAgc291cmNlID0gY29udGV4dC5zb3VyY2U7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc291cmNlICE9PSB1bnNhZmVJbnQ7XG4gICAgICB9KTtcbiAgICAgIHZhciBQUk9QRVJfQkFTRV9QQVJTRSA9IE5BVElWRV9TWU1CT0wgJiYgIWZhaWxzKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gMSAvIG5hdGl2ZVBhcnNlKFwiLTAgXHRcIikgIT09IC1JbmZpbml0eTtcbiAgICAgIH0pO1xuICAgICAgJCh7IHRhcmdldDogXCJKU09OXCIsIHN0YXQ6IHRydWUsIGZvcmNlZDogTk9fU09VUkNFX1NVUFBPUlQgfSwge1xuICAgICAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UodGV4dCwgcmV2aXZlcikge1xuICAgICAgICAgIHJldHVybiBQUk9QRVJfQkFTRV9QQVJTRSAmJiAhaXNDYWxsYWJsZShyZXZpdmVyKSA/IG5hdGl2ZVBhcnNlKHRleHQpIDogJHBhcnNlKHRleHQsIHJldml2ZXIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA4NDY5OiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18yKDk1MDQpO1xuICAgICAgdmFyIGl0ZXJhdGVTaW1wbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig1MDcpO1xuICAgICAgdmFyIFNldEhlbHBlcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig0NDAyKTtcbiAgICAgIHZhciBTZXQyID0gU2V0SGVscGVycy5TZXQ7XG4gICAgICB2YXIgU2V0UHJvdG90eXBlID0gU2V0SGVscGVycy5wcm90bztcbiAgICAgIHZhciBmb3JFYWNoID0gdW5jdXJyeVRoaXMoU2V0UHJvdG90eXBlLmZvckVhY2gpO1xuICAgICAgdmFyIGtleXMgPSB1bmN1cnJ5VGhpcyhTZXRQcm90b3R5cGUua2V5cyk7XG4gICAgICB2YXIgbmV4dCA9IGtleXMobmV3IFNldDIoKSkubmV4dDtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKHNldCwgZm4sIGludGVycnVwdGlibGUpIHtcbiAgICAgICAgcmV0dXJuIGludGVycnVwdGlibGUgPyBpdGVyYXRlU2ltcGxlKHsgaXRlcmF0b3I6IGtleXMoc2V0KSwgbmV4dCB9LCBmbikgOiBmb3JFYWNoKHNldCwgZm4pO1xuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA4NDgwOiAoXG4gICAgLyoqKi9cbiAgICAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzMiwgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciBpbnRlcm5hbE9iamVjdEtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigxODI4KTtcbiAgICAgIHZhciBlbnVtQnVnS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18yKDg3MjcpO1xuICAgICAgdmFyIGhpZGRlbktleXMgPSBlbnVtQnVnS2V5cy5jb25jYXQoXCJsZW5ndGhcIiwgXCJwcm90b3R5cGVcIik7XG4gICAgICBleHBvcnRzMi5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMoTywgaGlkZGVuS2V5cyk7XG4gICAgICB9O1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDg1Mjc6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMiwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyIGFTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig3MDgwKTtcbiAgICAgIHZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig0NDAyKS5oYXM7XG4gICAgICB2YXIgc2l6ZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDUxNzApO1xuICAgICAgdmFyIGdldFNldFJlY29yZCA9IF9fd2VicGFja19yZXF1aXJlX18yKDM3ODkpO1xuICAgICAgdmFyIGl0ZXJhdGVTaW1wbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig1MDcpO1xuICAgICAgdmFyIGl0ZXJhdG9yQ2xvc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig5NTM5KTtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzU3VwZXJzZXRPZihvdGhlcikge1xuICAgICAgICB2YXIgTyA9IGFTZXQodGhpcyk7XG4gICAgICAgIHZhciBvdGhlclJlYyA9IGdldFNldFJlY29yZChvdGhlcik7XG4gICAgICAgIGlmIChzaXplKE8pIDwgb3RoZXJSZWMuc2l6ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBvdGhlclJlYy5nZXRJdGVyYXRvcigpO1xuICAgICAgICByZXR1cm4gaXRlcmF0ZVNpbXBsZShpdGVyYXRvciwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGlmICghaGFzKE8sIGUpKSByZXR1cm4gaXRlcmF0b3JDbG9zZShpdGVyYXRvciwgXCJub3JtYWxcIiwgZmFsc2UpO1xuICAgICAgICB9KSAhPT0gZmFsc2U7XG4gICAgICB9O1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDg1NTE6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMiwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMzQpO1xuICAgICAgdmFyICRTdHJpbmcgPSBTdHJpbmc7XG4gICAgICB2YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKGFyZ3VtZW50KSB7XG4gICAgICAgIGlmIChpc09iamVjdChhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgICAgICAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoJFN0cmluZyhhcmd1bWVudCkgKyBcIiBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA4NTc0OiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18yKDk1MDQpO1xuICAgICAgdmFyICRFcnJvciA9IEVycm9yO1xuICAgICAgdmFyIHJlcGxhY2UgPSB1bmN1cnJ5VGhpcyhcIlwiLnJlcGxhY2UpO1xuICAgICAgdmFyIFRFU1QgPSAoZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcobmV3ICRFcnJvcihhcmcpLnN0YWNrKTtcbiAgICAgIH0pKFwienhjYXNkXCIpO1xuICAgICAgdmFyIFY4X09SX0NIQUtSQV9TVEFDS19FTlRSWSA9IC9cXG5cXHMqYXQgW146XSo6W15cXG5dKi87XG4gICAgICB2YXIgSVNfVjhfT1JfQ0hBS1JBX1NUQUNLID0gVjhfT1JfQ0hBS1JBX1NUQUNLX0VOVFJZLnRlc3QoVEVTVCk7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbihzdGFjaywgZHJvcEVudHJpZXMpIHtcbiAgICAgICAgaWYgKElTX1Y4X09SX0NIQUtSQV9TVEFDSyAmJiB0eXBlb2Ygc3RhY2sgPT0gXCJzdHJpbmdcIiAmJiAhJEVycm9yLnByZXBhcmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgd2hpbGUgKGRyb3BFbnRyaWVzLS0pIHN0YWNrID0gcmVwbGFjZShzdGFjaywgVjhfT1JfQ0hBS1JBX1NUQUNLX0VOVFJZLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhY2s7XG4gICAgICB9O1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDg2MjI6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMiwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyIGdsb2JhbFRoaXMyID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNDU3Nik7XG4gICAgICB2YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDQ5MDEpO1xuICAgICAgdmFyIFdlYWtNYXAyID0gZ2xvYmFsVGhpczIuV2Vha01hcDtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGlzQ2FsbGFibGUoV2Vha01hcDIpICYmIC9uYXRpdmUgY29kZS8udGVzdChTdHJpbmcoV2Vha01hcDIpKTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA4NjQ2OiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciBjYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoOTU2NSk7XG4gICAgICB2YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig4NTUxKTtcbiAgICAgIHZhciBnZXRJdGVyYXRvckRpcmVjdCA9IF9fd2VicGFja19yZXF1aXJlX18yKDE3NjcpO1xuICAgICAgdmFyIGdldEl0ZXJhdG9yTWV0aG9kID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoODUxKTtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc3RyaW5nSGFuZGxpbmcpIHtcbiAgICAgICAgaWYgKCFzdHJpbmdIYW5kbGluZyB8fCB0eXBlb2Ygb2JqICE9PSBcInN0cmluZ1wiKSBhbk9iamVjdChvYmopO1xuICAgICAgICB2YXIgbWV0aG9kID0gZ2V0SXRlcmF0b3JNZXRob2Qob2JqKTtcbiAgICAgICAgcmV0dXJuIGdldEl0ZXJhdG9yRGlyZWN0KGFuT2JqZWN0KG1ldGhvZCAhPT0gdm9pZCAwID8gY2FsbChtZXRob2QsIG9iaikgOiBvYmopKTtcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgODY4NjogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigzNzI0KTtcbiAgICAgIHZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18yKDkwMzkpO1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gREVTQ1JJUFRPUlMgJiYgZmFpbHMoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnVuY3Rpb24oKSB7XG4gICAgICAgIH0sIFwicHJvdG90eXBlXCIsIHtcbiAgICAgICAgICB2YWx1ZTogNDIsXG4gICAgICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgICAgIH0pLnByb3RvdHlwZSAhPT0gNDI7XG4gICAgICB9KTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA4NzIxOiAoXG4gICAgLyoqKi9cbiAgICAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigzNzI0KTtcbiAgICAgIHZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18yKDk1MDQpO1xuICAgICAgdmFyIGRlZmluZUJ1aWx0SW5BY2Nlc3NvciA9IF9fd2VicGFja19yZXF1aXJlX18yKDIxMDYpO1xuICAgICAgdmFyIFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZSA9IFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGU7XG4gICAgICB2YXIgZm9yRWFjaCA9IHVuY3VycnlUaGlzKFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZS5mb3JFYWNoKTtcbiAgICAgIGlmIChERVNDUklQVE9SUyAmJiAhKFwic2l6ZVwiIGluIFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZSkpIHtcbiAgICAgICAgZGVmaW5lQnVpbHRJbkFjY2Vzc29yKFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZSwgXCJzaXplXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIHNpemUoKSB7XG4gICAgICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICAgICAgZm9yRWFjaCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgODcyNzogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyKSA9PiB7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBbXG4gICAgICAgIFwiY29uc3RydWN0b3JcIixcbiAgICAgICAgXCJoYXNPd25Qcm9wZXJ0eVwiLFxuICAgICAgICBcImlzUHJvdG90eXBlT2ZcIixcbiAgICAgICAgXCJwcm9wZXJ0eUlzRW51bWVyYWJsZVwiLFxuICAgICAgICBcInRvTG9jYWxlU3RyaW5nXCIsXG4gICAgICAgIFwidG9TdHJpbmdcIixcbiAgICAgICAgXCJ2YWx1ZU9mXCJcbiAgICAgIF07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgODc0NTogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgTkFUSVZFX0JJTkQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2MTYpO1xuICAgICAgdmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuICAgICAgdmFyIGFwcGx5ID0gRnVuY3Rpb25Qcm90b3R5cGUuYXBwbHk7XG4gICAgICB2YXIgY2FsbCA9IEZ1bmN0aW9uUHJvdG90eXBlLmNhbGw7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSB0eXBlb2YgUmVmbGVjdCA9PSBcIm9iamVjdFwiICYmIFJlZmxlY3QuYXBwbHkgfHwgKE5BVElWRV9CSU5EID8gY2FsbC5iaW5kKGFwcGx5KSA6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY2FsbC5hcHBseShhcHBseSwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDg3NTA6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMiwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyIGFTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig3MDgwKTtcbiAgICAgIHZhciBTZXRIZWxwZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNDQwMik7XG4gICAgICB2YXIgc2l6ZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDUxNzApO1xuICAgICAgdmFyIGdldFNldFJlY29yZCA9IF9fd2VicGFja19yZXF1aXJlX18yKDM3ODkpO1xuICAgICAgdmFyIGl0ZXJhdGVTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig4NDY5KTtcbiAgICAgIHZhciBpdGVyYXRlU2ltcGxlID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNTA3KTtcbiAgICAgIHZhciBTZXQyID0gU2V0SGVscGVycy5TZXQ7XG4gICAgICB2YXIgYWRkID0gU2V0SGVscGVycy5hZGQ7XG4gICAgICB2YXIgaGFzID0gU2V0SGVscGVycy5oYXM7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbiBpbnRlcnNlY3Rpb24ob3RoZXIpIHtcbiAgICAgICAgdmFyIE8gPSBhU2V0KHRoaXMpO1xuICAgICAgICB2YXIgb3RoZXJSZWMgPSBnZXRTZXRSZWNvcmQob3RoZXIpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFNldDIoKTtcbiAgICAgICAgaWYgKHNpemUoTykgPiBvdGhlclJlYy5zaXplKSB7XG4gICAgICAgICAgaXRlcmF0ZVNpbXBsZShvdGhlclJlYy5nZXRJdGVyYXRvcigpLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoaGFzKE8sIGUpKSBhZGQocmVzdWx0LCBlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVyYXRlU2V0KE8sIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChvdGhlclJlYy5pbmNsdWRlcyhlKSkgYWRkKHJlc3VsdCwgZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgODc3MzogKFxuICAgIC8qKiovXG4gICAgKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0czIpID0+IHtcbiAgICAgIHZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgICAgIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAgICAgdmFyIE5BU0hPUk5fQlVHID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yICYmICEkcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh7IDE6IDIgfSwgMSk7XG4gICAgICBleHBvcnRzMi5mID0gTkFTSE9STl9CVUcgPyBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShWKSB7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRoaXMsIFYpO1xuICAgICAgICByZXR1cm4gISFkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IuZW51bWVyYWJsZTtcbiAgICAgIH0gOiAkcHJvcGVydHlJc0VudW1lcmFibGU7XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgODk4MTogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDc3NTApO1xuICAgICAgdmFyICRPYmplY3QgPSBPYmplY3Q7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbihhcmd1bWVudCkge1xuICAgICAgICByZXR1cm4gJE9iamVjdChyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KSk7XG4gICAgICB9O1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDkwMzk6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMikgPT4ge1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24oZXhlYykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA5MTQzOiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciBnbG9iYWxUaGlzMiA9IF9fd2VicGFja19yZXF1aXJlX18yKDQ1NzYpO1xuICAgICAgdmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoOTUwNCk7XG4gICAgICB2YXIgYW5PYmplY3RPclVuZGVmaW5lZCA9IF9fd2VicGFja19yZXF1aXJlX18yKDM5NzIpO1xuICAgICAgdmFyIGFTdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigzNDYzKTtcbiAgICAgIHZhciBoYXNPd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig5Mjk3KTtcbiAgICAgIHZhciBiYXNlNjRNYXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigyODA0KTtcbiAgICAgIHZhciBnZXRBbHBoYWJldE9wdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18yKDk0NCk7XG4gICAgICB2YXIgbm90RGV0YWNoZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig1MTY5KTtcbiAgICAgIHZhciBiYXNlNjRBbHBoYWJldCA9IGJhc2U2NE1hcC5jMmk7XG4gICAgICB2YXIgYmFzZTY0VXJsQWxwaGFiZXQgPSBiYXNlNjRNYXAuYzJpVXJsO1xuICAgICAgdmFyIFN5bnRheEVycm9yMiA9IGdsb2JhbFRoaXMyLlN5bnRheEVycm9yO1xuICAgICAgdmFyIFR5cGVFcnJvcjIgPSBnbG9iYWxUaGlzMi5UeXBlRXJyb3I7XG4gICAgICB2YXIgYXQgPSB1bmN1cnJ5VGhpcyhcIlwiLmNoYXJBdCk7XG4gICAgICB2YXIgc2tpcEFzY2lpV2hpdGVzcGFjZSA9IGZ1bmN0aW9uKHN0cmluZywgaW5kZXgpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIHZhciBjaHIgPSBhdChzdHJpbmcsIGluZGV4KTtcbiAgICAgICAgICBpZiAoY2hyICE9PSBcIiBcIiAmJiBjaHIgIT09IFwiXHRcIiAmJiBjaHIgIT09IFwiXFxuXCIgJiYgY2hyICE9PSBcIlxcZlwiICYmIGNociAhPT0gXCJcXHJcIikgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfTtcbiAgICAgIHZhciBkZWNvZGVCYXNlNjRDaHVuayA9IGZ1bmN0aW9uKGNodW5rLCBhbHBoYWJldCwgdGhyb3dPbkV4dHJhQml0cykge1xuICAgICAgICB2YXIgY2h1bmtMZW5ndGggPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIGlmIChjaHVua0xlbmd0aCA8IDQpIHtcbiAgICAgICAgICBjaHVuayArPSBjaHVua0xlbmd0aCA9PT0gMiA/IFwiQUFcIiA6IFwiQVwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0cmlwbGV0ID0gKGFscGhhYmV0W2F0KGNodW5rLCAwKV0gPDwgMTgpICsgKGFscGhhYmV0W2F0KGNodW5rLCAxKV0gPDwgMTIpICsgKGFscGhhYmV0W2F0KGNodW5rLCAyKV0gPDwgNikgKyBhbHBoYWJldFthdChjaHVuaywgMyldO1xuICAgICAgICB2YXIgY2h1bmtCeXRlcyA9IFtcbiAgICAgICAgICB0cmlwbGV0ID4+IDE2ICYgMjU1LFxuICAgICAgICAgIHRyaXBsZXQgPj4gOCAmIDI1NSxcbiAgICAgICAgICB0cmlwbGV0ICYgMjU1XG4gICAgICAgIF07XG4gICAgICAgIGlmIChjaHVua0xlbmd0aCA9PT0gMikge1xuICAgICAgICAgIGlmICh0aHJvd09uRXh0cmFCaXRzICYmIGNodW5rQnl0ZXNbMV0gIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcjIoXCJFeHRyYSBiaXRzXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW2NodW5rQnl0ZXNbMF1dO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaHVua0xlbmd0aCA9PT0gMykge1xuICAgICAgICAgIGlmICh0aHJvd09uRXh0cmFCaXRzICYmIGNodW5rQnl0ZXNbMl0gIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcjIoXCJFeHRyYSBiaXRzXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW2NodW5rQnl0ZXNbMF0sIGNodW5rQnl0ZXNbMV1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaHVua0J5dGVzO1xuICAgICAgfTtcbiAgICAgIHZhciB3cml0ZUJ5dGVzID0gZnVuY3Rpb24oYnl0ZXMsIGVsZW1lbnRzLCB3cml0dGVuKSB7XG4gICAgICAgIHZhciBlbGVtZW50c0xlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGVsZW1lbnRzTGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgYnl0ZXNbd3JpdHRlbiArIGluZGV4XSA9IGVsZW1lbnRzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdHRlbiArIGVsZW1lbnRzTGVuZ3RoO1xuICAgICAgfTtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKHN0cmluZywgb3B0aW9ucywgaW50bywgbWF4TGVuZ3RoKSB7XG4gICAgICAgIGFTdHJpbmcoc3RyaW5nKTtcbiAgICAgICAgYW5PYmplY3RPclVuZGVmaW5lZChvcHRpb25zKTtcbiAgICAgICAgdmFyIGFscGhhYmV0ID0gZ2V0QWxwaGFiZXRPcHRpb24ob3B0aW9ucykgPT09IFwiYmFzZTY0XCIgPyBiYXNlNjRBbHBoYWJldCA6IGJhc2U2NFVybEFscGhhYmV0O1xuICAgICAgICB2YXIgbGFzdENodW5rSGFuZGxpbmcgPSBvcHRpb25zID8gb3B0aW9ucy5sYXN0Q2h1bmtIYW5kbGluZyA6IHZvaWQgMDtcbiAgICAgICAgaWYgKGxhc3RDaHVua0hhbmRsaW5nID09PSB2b2lkIDApIGxhc3RDaHVua0hhbmRsaW5nID0gXCJsb29zZVwiO1xuICAgICAgICBpZiAobGFzdENodW5rSGFuZGxpbmcgIT09IFwibG9vc2VcIiAmJiBsYXN0Q2h1bmtIYW5kbGluZyAhPT0gXCJzdHJpY3RcIiAmJiBsYXN0Q2h1bmtIYW5kbGluZyAhPT0gXCJzdG9wLWJlZm9yZS1wYXJ0aWFsXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yMihcIkluY29ycmVjdCBgbGFzdENodW5rSGFuZGxpbmdgIG9wdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50bykgbm90RGV0YWNoZWQoaW50by5idWZmZXIpO1xuICAgICAgICB2YXIgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgdmFyIGJ5dGVzID0gaW50byB8fCBbXTtcbiAgICAgICAgdmFyIHdyaXR0ZW4gPSAwO1xuICAgICAgICB2YXIgcmVhZCA9IDA7XG4gICAgICAgIHZhciBjaHVuayA9IFwiXCI7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIGlmIChtYXhMZW5ndGgpIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgaW5kZXggPSBza2lwQXNjaWlXaGl0ZXNwYWNlKHN0cmluZywgaW5kZXgpO1xuICAgICAgICAgIGlmIChpbmRleCA9PT0gc3RyaW5nTGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoY2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBpZiAobGFzdENodW5rSGFuZGxpbmcgPT09IFwic3RvcC1iZWZvcmUtcGFydGlhbFwiKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGxhc3RDaHVua0hhbmRsaW5nID09PSBcImxvb3NlXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2h1bmsubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IyKFwiTWFsZm9ybWVkIHBhZGRpbmc6IGV4YWN0bHkgb25lIGFkZGl0aW9uYWwgY2hhcmFjdGVyXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3cml0dGVuID0gd3JpdGVCeXRlcyhieXRlcywgZGVjb2RlQmFzZTY0Q2h1bmsoY2h1bmssIGFscGhhYmV0LCBmYWxzZSksIHdyaXR0ZW4pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcjIoXCJNaXNzaW5nIHBhZGRpbmdcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWQgPSBzdHJpbmdMZW5ndGg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNociA9IGF0KHN0cmluZywgaW5kZXgpO1xuICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgaWYgKGNociA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgIGlmIChjaHVuay5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcjIoXCJQYWRkaW5nIGlzIHRvbyBlYXJseVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGV4ID0gc2tpcEFzY2lpV2hpdGVzcGFjZShzdHJpbmcsIGluZGV4KTtcbiAgICAgICAgICAgIGlmIChjaHVuay5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSBzdHJpbmdMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdENodW5rSGFuZGxpbmcgPT09IFwic3RvcC1iZWZvcmUtcGFydGlhbFwiKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yMihcIk1hbGZvcm1lZCBwYWRkaW5nOiBvbmx5IG9uZSA9XCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChhdChzdHJpbmcsIGluZGV4KSA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2tpcEFzY2lpV2hpdGVzcGFjZShzdHJpbmcsIGluZGV4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluZGV4IDwgc3RyaW5nTGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcjIoXCJVbmV4cGVjdGVkIGNoYXJhY3RlciBhZnRlciBwYWRkaW5nXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JpdHRlbiA9IHdyaXRlQnl0ZXMoYnl0ZXMsIGRlY29kZUJhc2U2NENodW5rKGNodW5rLCBhbHBoYWJldCwgbGFzdENodW5rSGFuZGxpbmcgPT09IFwic3RyaWN0XCIpLCB3cml0dGVuKTtcbiAgICAgICAgICAgIHJlYWQgPSBzdHJpbmdMZW5ndGg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFoYXNPd24oYWxwaGFiZXQsIGNocikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcjIoXCJVbmV4cGVjdGVkIGNoYXJhY3RlclwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlbWFpbmluZ0J5dGVzID0gbWF4TGVuZ3RoIC0gd3JpdHRlbjtcbiAgICAgICAgICBpZiAocmVtYWluaW5nQnl0ZXMgPT09IDEgJiYgY2h1bmsubGVuZ3RoID09PSAyIHx8IHJlbWFpbmluZ0J5dGVzID09PSAyICYmIGNodW5rLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNodW5rICs9IGNocjtcbiAgICAgICAgICBpZiAoY2h1bmsubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICB3cml0dGVuID0gd3JpdGVCeXRlcyhieXRlcywgZGVjb2RlQmFzZTY0Q2h1bmsoY2h1bmssIGFscGhhYmV0LCBmYWxzZSksIHdyaXR0ZW4pO1xuICAgICAgICAgICAgY2h1bmsgPSBcIlwiO1xuICAgICAgICAgICAgcmVhZCA9IGluZGV4O1xuICAgICAgICAgICAgaWYgKHdyaXR0ZW4gPT09IG1heExlbmd0aCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgYnl0ZXMsIHJlYWQsIHdyaXR0ZW4gfTtcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgOTI4NjogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgU2V0SGVscGVycyA9IF9fd2VicGFja19yZXF1aXJlX18yKDQ0MDIpO1xuICAgICAgdmFyIGl0ZXJhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig4NDY5KTtcbiAgICAgIHZhciBTZXQyID0gU2V0SGVscGVycy5TZXQ7XG4gICAgICB2YXIgYWRkID0gU2V0SGVscGVycy5hZGQ7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbihzZXQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBTZXQyKCk7XG4gICAgICAgIGl0ZXJhdGUoc2V0LCBmdW5jdGlvbihpdCkge1xuICAgICAgICAgIGFkZChyZXN1bHQsIGl0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDkyOTc6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMiwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoOTUwNCk7XG4gICAgICB2YXIgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig4OTgxKTtcbiAgICAgIHZhciBoYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzKHt9Lmhhc093blByb3BlcnR5KTtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IE9iamVjdC5oYXNPd24gfHwgZnVuY3Rpb24gaGFzT3duKGl0LCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIGhhc093blByb3BlcnR5KHRvT2JqZWN0KGl0KSwga2V5KTtcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgOTMwNjogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDQ5MDEpO1xuICAgICAgdmFyIHRyeVRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNjgyMyk7XG4gICAgICB2YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKGFyZ3VtZW50KSB7XG4gICAgICAgIGlmIChpc0NhbGxhYmxlKGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICAgICAgICB0aHJvdyBuZXcgJFR5cGVFcnJvcih0cnlUb1N0cmluZyhhcmd1bWVudCkgKyBcIiBpcyBub3QgYSBmdW5jdGlvblwiKTtcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgOTMxNDogKFxuICAgIC8qKiovXG4gICAgKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2NTE4KTtcbiAgICAgIHZhciBjYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoOTU2NSk7XG4gICAgICB2YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig4NTUxKTtcbiAgICAgIHZhciBnZXRJdGVyYXRvckRpcmVjdCA9IF9fd2VicGFja19yZXF1aXJlX18yKDE3NjcpO1xuICAgICAgdmFyIG5vdEFOYU4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig0MTQ5KTtcbiAgICAgIHZhciB0b1Bvc2l0aXZlSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18yKDk1OTApO1xuICAgICAgdmFyIGl0ZXJhdG9yQ2xvc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig5NTM5KTtcbiAgICAgIHZhciBjcmVhdGVJdGVyYXRvclByb3h5ID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoOTQ2Mik7XG4gICAgICB2YXIgaXRlcmF0b3JIZWxwZXJUaHJvd3NPbkludmFsaWRJdGVyYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18yKDY4NCk7XG4gICAgICB2YXIgaXRlcmF0b3JIZWxwZXJXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18yKDQ1NDkpO1xuICAgICAgdmFyIElTX1BVUkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2Mzk1KTtcbiAgICAgIHZhciBEUk9QX1dJVEhPVVRfVEhST1dJTkdfT05fSU5WQUxJRF9JVEVSQVRPUiA9ICFJU19QVVJFICYmICFpdGVyYXRvckhlbHBlclRocm93c09uSW52YWxpZEl0ZXJhdG9yKFwiZHJvcFwiLCAwKTtcbiAgICAgIHZhciBkcm9wV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IgPSAhSVNfUFVSRSAmJiAhRFJPUF9XSVRIT1VUX1RIUk9XSU5HX09OX0lOVkFMSURfSVRFUkFUT1IgJiYgaXRlcmF0b3JIZWxwZXJXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvcihcImRyb3BcIiwgUmFuZ2VFcnJvcik7XG4gICAgICB2YXIgRk9SQ0VEID0gSVNfUFVSRSB8fCBEUk9QX1dJVEhPVVRfVEhST1dJTkdfT05fSU5WQUxJRF9JVEVSQVRPUiB8fCBkcm9wV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3I7XG4gICAgICB2YXIgSXRlcmF0b3JQcm94eSA9IGNyZWF0ZUl0ZXJhdG9yUHJveHkoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMuaXRlcmF0b3I7XG4gICAgICAgIHZhciBuZXh0ID0gdGhpcy5uZXh0O1xuICAgICAgICB2YXIgcmVzdWx0LCBkb25lO1xuICAgICAgICB3aGlsZSAodGhpcy5yZW1haW5pbmcpIHtcbiAgICAgICAgICB0aGlzLnJlbWFpbmluZy0tO1xuICAgICAgICAgIHJlc3VsdCA9IGFuT2JqZWN0KGNhbGwobmV4dCwgaXRlcmF0b3IpKTtcbiAgICAgICAgICBkb25lID0gdGhpcy5kb25lID0gISFyZXN1bHQuZG9uZTtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IGFuT2JqZWN0KGNhbGwobmV4dCwgaXRlcmF0b3IpKTtcbiAgICAgICAgZG9uZSA9IHRoaXMuZG9uZSA9ICEhcmVzdWx0LmRvbmU7XG4gICAgICAgIGlmICghZG9uZSkgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgICAgIH0pO1xuICAgICAgJCh7IHRhcmdldDogXCJJdGVyYXRvclwiLCBwcm90bzogdHJ1ZSwgcmVhbDogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQgfSwge1xuICAgICAgICBkcm9wOiBmdW5jdGlvbiBkcm9wKGxpbWl0KSB7XG4gICAgICAgICAgYW5PYmplY3QodGhpcyk7XG4gICAgICAgICAgdmFyIHJlbWFpbmluZztcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVtYWluaW5nID0gdG9Qb3NpdGl2ZUludGVnZXIobm90QU5hTigrbGltaXQpKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaXRlcmF0b3JDbG9zZSh0aGlzLCBcInRocm93XCIsIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRyb3BXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvcikgcmV0dXJuIGNhbGwoZHJvcFdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yLCB0aGlzLCByZW1haW5pbmcpO1xuICAgICAgICAgIHJldHVybiBuZXcgSXRlcmF0b3JQcm94eShnZXRJdGVyYXRvckRpcmVjdCh0aGlzKSwge1xuICAgICAgICAgICAgcmVtYWluaW5nXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDk0Mjk6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMiwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyIGdsb2JhbFRoaXMyID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNDU3Nik7XG4gICAgICB2YXIgSVNfTk9ERSA9IF9fd2VicGFja19yZXF1aXJlX18yKDYxOTMpO1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBpZiAoSVNfTk9ERSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsVGhpczIucHJvY2Vzcy5nZXRCdWlsdGluTW9kdWxlKG5hbWUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24oJ3JldHVybiByZXF1aXJlKFwiJyArIG5hbWUgKyAnXCIpJykoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA5NDMyOiAoXG4gICAgLyoqKi9cbiAgICAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fMig1MjEzKTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA5NDMzOiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciBnbG9iYWxUaGlzMiA9IF9fd2VicGFja19yZXF1aXJlX18yKDQ1NzYpO1xuICAgICAgdmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGRlZmluZVByb3BlcnR5KGdsb2JhbFRoaXMyLCBrZXksIHsgdmFsdWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgZ2xvYmFsVGhpczJba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgOTQ2MjogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgY2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18yKDk1NjUpO1xuICAgICAgdmFyIGNyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDIzNjApO1xuICAgICAgdmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18yKDY2OTkpO1xuICAgICAgdmFyIGRlZmluZUJ1aWx0SW5zID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNjI3OSk7XG4gICAgICB2YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoODIyNyk7XG4gICAgICB2YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDExODEpO1xuICAgICAgdmFyIGdldE1ldGhvZCA9IF9fd2VicGFja19yZXF1aXJlX18yKDU5NjYpO1xuICAgICAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNzY1NykuSXRlcmF0b3JQcm90b3R5cGU7XG4gICAgICB2YXIgY3JlYXRlSXRlclJlc3VsdE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18yKDI1MjkpO1xuICAgICAgdmFyIGl0ZXJhdG9yQ2xvc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig5NTM5KTtcbiAgICAgIHZhciBpdGVyYXRvckNsb3NlQWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMTM4NSk7XG4gICAgICB2YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbChcInRvU3RyaW5nVGFnXCIpO1xuICAgICAgdmFyIElURVJBVE9SX0hFTFBFUiA9IFwiSXRlcmF0b3JIZWxwZXJcIjtcbiAgICAgIHZhciBXUkFQX0ZPUl9WQUxJRF9JVEVSQVRPUiA9IFwiV3JhcEZvclZhbGlkSXRlcmF0b3JcIjtcbiAgICAgIHZhciBOT1JNQUwgPSBcIm5vcm1hbFwiO1xuICAgICAgdmFyIFRIUk9XID0gXCJ0aHJvd1wiO1xuICAgICAgdmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbiAgICAgIHZhciBjcmVhdGVJdGVyYXRvclByb3h5UHJvdG90eXBlID0gZnVuY3Rpb24oSVNfSVRFUkFUT1IpIHtcbiAgICAgICAgdmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcihJU19JVEVSQVRPUiA/IFdSQVBfRk9SX1ZBTElEX0lURVJBVE9SIDogSVRFUkFUT1JfSEVMUEVSKTtcbiAgICAgICAgcmV0dXJuIGRlZmluZUJ1aWx0SW5zKGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSksIHtcbiAgICAgICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgICAgICAgICAgIGlmIChJU19JVEVSQVRPUikgcmV0dXJuIHN0YXRlLm5leHRIYW5kbGVyKCk7XG4gICAgICAgICAgICBpZiAoc3RhdGUuZG9uZSkgcmV0dXJuIGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3Qodm9pZCAwLCB0cnVlKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSBzdGF0ZS5uZXh0SGFuZGxlcigpO1xuICAgICAgICAgICAgICByZXR1cm4gc3RhdGUucmV0dXJuSGFuZGxlclJlc3VsdCA/IHJlc3VsdCA6IGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QocmVzdWx0LCBzdGF0ZS5kb25lKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmV0dXJuXCI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IHN0YXRlLml0ZXJhdG9yO1xuICAgICAgICAgICAgc3RhdGUuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICBpZiAoSVNfSVRFUkFUT1IpIHtcbiAgICAgICAgICAgICAgdmFyIHJldHVybk1ldGhvZCA9IGdldE1ldGhvZChpdGVyYXRvciwgXCJyZXR1cm5cIik7XG4gICAgICAgICAgICAgIHJldHVybiByZXR1cm5NZXRob2QgPyBjYWxsKHJldHVybk1ldGhvZCwgaXRlcmF0b3IpIDogY3JlYXRlSXRlclJlc3VsdE9iamVjdCh2b2lkIDAsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlLmlubmVyKSB0cnkge1xuICAgICAgICAgICAgICBpdGVyYXRvckNsb3NlKHN0YXRlLmlubmVyLml0ZXJhdG9yLCBOT1JNQUwpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIFRIUk9XLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUub3Blbkl0ZXJzKSB0cnkge1xuICAgICAgICAgICAgICBpdGVyYXRvckNsb3NlQWxsKHN0YXRlLm9wZW5JdGVycywgTk9STUFMKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBUSFJPVywgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0ZXJhdG9yKSBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBOT1JNQUwpO1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3Qodm9pZCAwLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHZhciBXcmFwRm9yVmFsaWRJdGVyYXRvclByb3RvdHlwZSA9IGNyZWF0ZUl0ZXJhdG9yUHJveHlQcm90b3R5cGUodHJ1ZSk7XG4gICAgICB2YXIgSXRlcmF0b3JIZWxwZXJQcm90b3R5cGUgPSBjcmVhdGVJdGVyYXRvclByb3h5UHJvdG90eXBlKGZhbHNlKTtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShJdGVyYXRvckhlbHBlclByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRywgXCJJdGVyYXRvciBIZWxwZXJcIik7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbihuZXh0SGFuZGxlciwgSVNfSVRFUkFUT1IsIFJFVFVSTl9IQU5ETEVSX1JFU1VMVCkge1xuICAgICAgICB2YXIgSXRlcmF0b3JQcm94eSA9IGZ1bmN0aW9uIEl0ZXJhdG9yMihyZWNvcmQsIHN0YXRlKSB7XG4gICAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICBzdGF0ZS5pdGVyYXRvciA9IHJlY29yZC5pdGVyYXRvcjtcbiAgICAgICAgICAgIHN0YXRlLm5leHQgPSByZWNvcmQubmV4dDtcbiAgICAgICAgICB9IGVsc2Ugc3RhdGUgPSByZWNvcmQ7XG4gICAgICAgICAgc3RhdGUudHlwZSA9IElTX0lURVJBVE9SID8gV1JBUF9GT1JfVkFMSURfSVRFUkFUT1IgOiBJVEVSQVRPUl9IRUxQRVI7XG4gICAgICAgICAgc3RhdGUucmV0dXJuSGFuZGxlclJlc3VsdCA9ICEhUkVUVVJOX0hBTkRMRVJfUkVTVUxUO1xuICAgICAgICAgIHN0YXRlLm5leHRIYW5kbGVyID0gbmV4dEhhbmRsZXI7XG4gICAgICAgICAgc3RhdGUuY291bnRlciA9IDA7XG4gICAgICAgICAgc3RhdGUuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHNldEludGVybmFsU3RhdGUodGhpcywgc3RhdGUpO1xuICAgICAgICB9O1xuICAgICAgICBJdGVyYXRvclByb3h5LnByb3RvdHlwZSA9IElTX0lURVJBVE9SID8gV3JhcEZvclZhbGlkSXRlcmF0b3JQcm90b3R5cGUgOiBJdGVyYXRvckhlbHBlclByb3RvdHlwZTtcbiAgICAgICAgcmV0dXJuIEl0ZXJhdG9yUHJveHk7XG4gICAgICB9O1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDk0ODY6IChcbiAgICAvKioqL1xuICAgICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNjUxOCk7XG4gICAgICB2YXIgZ2xvYmFsVGhpczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig0NTc2KTtcbiAgICAgIHZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18yKDk1MDQpO1xuICAgICAgdmFyIGFuT2JqZWN0T3JVbmRlZmluZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigzOTcyKTtcbiAgICAgIHZhciBhblVpbnQ4QXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig0MTU0KTtcbiAgICAgIHZhciBub3REZXRhY2hlZCA9IF9fd2VicGFja19yZXF1aXJlX18yKDUxNjkpO1xuICAgICAgdmFyIGJhc2U2NE1hcCA9IF9fd2VicGFja19yZXF1aXJlX18yKDI4MDQpO1xuICAgICAgdmFyIGdldEFscGhhYmV0T3B0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoOTQ0KTtcbiAgICAgIHZhciBiYXNlNjRBbHBoYWJldCA9IGJhc2U2NE1hcC5pMmM7XG4gICAgICB2YXIgYmFzZTY0VXJsQWxwaGFiZXQgPSBiYXNlNjRNYXAuaTJjVXJsO1xuICAgICAgdmFyIGNoYXJBdCA9IHVuY3VycnlUaGlzKFwiXCIuY2hhckF0KTtcbiAgICAgIHZhciBVaW50OEFycmF5MiA9IGdsb2JhbFRoaXMyLlVpbnQ4QXJyYXk7XG4gICAgICB2YXIgSU5DT1JSRUNUX0JFSEFWSU9SX09SX0RPRVNOVF9FWElTVFMgPSAhVWludDhBcnJheTIgfHwgIVVpbnQ4QXJyYXkyLnByb3RvdHlwZS50b0Jhc2U2NCB8fCAhKGZ1bmN0aW9uKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciB0YXJnZXQgPSBuZXcgVWludDhBcnJheTIoKTtcbiAgICAgICAgICB0YXJnZXQudG9CYXNlNjQobnVsbCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pKCk7XG4gICAgICBpZiAoVWludDhBcnJheTIpICQoeyB0YXJnZXQ6IFwiVWludDhBcnJheVwiLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBJTkNPUlJFQ1RfQkVIQVZJT1JfT1JfRE9FU05UX0VYSVNUUyB9LCB7XG4gICAgICAgIHRvQmFzZTY0OiBmdW5jdGlvbiB0b0Jhc2U2NCgpIHtcbiAgICAgICAgICB2YXIgYXJyYXkgPSBhblVpbnQ4QXJyYXkodGhpcyk7XG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID8gYW5PYmplY3RPclVuZGVmaW5lZChhcmd1bWVudHNbMF0pIDogdm9pZCAwO1xuICAgICAgICAgIHZhciBhbHBoYWJldCA9IGdldEFscGhhYmV0T3B0aW9uKG9wdGlvbnMpID09PSBcImJhc2U2NFwiID8gYmFzZTY0QWxwaGFiZXQgOiBiYXNlNjRVcmxBbHBoYWJldDtcbiAgICAgICAgICB2YXIgb21pdFBhZGRpbmcgPSAhIW9wdGlvbnMgJiYgISFvcHRpb25zLm9taXRQYWRkaW5nO1xuICAgICAgICAgIG5vdERldGFjaGVkKHRoaXMuYnVmZmVyKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICB2YXIgdHJpcGxldDtcbiAgICAgICAgICB2YXIgYXQgPSBmdW5jdGlvbihzaGlmdCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoYXJBdChhbHBoYWJldCwgdHJpcGxldCA+PiA2ICogc2hpZnQgJiA2Myk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBmb3IgKDsgaSArIDIgPCBsZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgdHJpcGxldCA9IChhcnJheVtpXSA8PCAxNikgKyAoYXJyYXlbaSArIDFdIDw8IDgpICsgYXJyYXlbaSArIDJdO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGF0KDMpICsgYXQoMikgKyBhdCgxKSArIGF0KDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaSArIDIgPT09IGxlbmd0aCkge1xuICAgICAgICAgICAgdHJpcGxldCA9IChhcnJheVtpXSA8PCAxNikgKyAoYXJyYXlbaSArIDFdIDw8IDgpO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGF0KDMpICsgYXQoMikgKyBhdCgxKSArIChvbWl0UGFkZGluZyA/IFwiXCIgOiBcIj1cIik7XG4gICAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICB0cmlwbGV0ID0gYXJyYXlbaV0gPDwgMTY7XG4gICAgICAgICAgICByZXN1bHQgKz0gYXQoMykgKyBhdCgyKSArIChvbWl0UGFkZGluZyA/IFwiXCIgOiBcIj09XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA5NTA0OiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciBOQVRJVkVfQklORCA9IF9fd2VicGFja19yZXF1aXJlX18yKDYxNik7XG4gICAgICB2YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4gICAgICB2YXIgY2FsbCA9IEZ1bmN0aW9uUHJvdG90eXBlLmNhbGw7XG4gICAgICB2YXIgdW5jdXJyeVRoaXNXaXRoQmluZCA9IE5BVElWRV9CSU5EICYmIEZ1bmN0aW9uUHJvdG90eXBlLmJpbmQuYmluZChjYWxsLCBjYWxsKTtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IE5BVElWRV9CSU5EID8gdW5jdXJyeVRoaXNXaXRoQmluZCA6IGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbC5hcHBseShmbiwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgOTUxOTogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgZ2xvYmFsVGhpczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig0NTc2KTtcbiAgICAgIHZhciB1c2VyQWdlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigyODM5KTtcbiAgICAgIHZhciBwcm9jZXNzMiA9IGdsb2JhbFRoaXMyLnByb2Nlc3M7XG4gICAgICB2YXIgRGVubzIgPSBnbG9iYWxUaGlzMi5EZW5vO1xuICAgICAgdmFyIHZlcnNpb25zID0gcHJvY2VzczIgJiYgcHJvY2VzczIudmVyc2lvbnMgfHwgRGVubzIgJiYgRGVubzIudmVyc2lvbjtcbiAgICAgIHZhciB2OCA9IHZlcnNpb25zICYmIHZlcnNpb25zLnY4O1xuICAgICAgdmFyIG1hdGNoLCB2ZXJzaW9uMjtcbiAgICAgIGlmICh2OCkge1xuICAgICAgICBtYXRjaCA9IHY4LnNwbGl0KFwiLlwiKTtcbiAgICAgICAgdmVyc2lvbjIgPSBtYXRjaFswXSA+IDAgJiYgbWF0Y2hbMF0gPCA0ID8gMSA6ICsobWF0Y2hbMF0gKyBtYXRjaFsxXSk7XG4gICAgICB9XG4gICAgICBpZiAoIXZlcnNpb24yICYmIHVzZXJBZ2VudCkge1xuICAgICAgICBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvRWRnZVxcLyhcXGQrKS8pO1xuICAgICAgICBpZiAoIW1hdGNoIHx8IG1hdGNoWzFdID49IDc0KSB7XG4gICAgICAgICAgbWF0Y2ggPSB1c2VyQWdlbnQubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS8pO1xuICAgICAgICAgIGlmIChtYXRjaCkgdmVyc2lvbjIgPSArbWF0Y2hbMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IHZlcnNpb24yO1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDk1Mzk6IChcbiAgICAvKioqL1xuICAgICgobW9kdWxlMiwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fMikgPT4ge1xuICAgICAgdmFyIGNhbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig5NTY1KTtcbiAgICAgIHZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18yKDg1NTEpO1xuICAgICAgdmFyIGdldE1ldGhvZCA9IF9fd2VicGFja19yZXF1aXJlX18yKDU5NjYpO1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24oaXRlcmF0b3IsIGtpbmQsIHZhbHVlKSB7XG4gICAgICAgIHZhciBpbm5lclJlc3VsdCwgaW5uZXJFcnJvcjtcbiAgICAgICAgYW5PYmplY3QoaXRlcmF0b3IpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlubmVyUmVzdWx0ID0gZ2V0TWV0aG9kKGl0ZXJhdG9yLCBcInJldHVyblwiKTtcbiAgICAgICAgICBpZiAoIWlubmVyUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoa2luZCA9PT0gXCJ0aHJvd1wiKSB0aHJvdyB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5uZXJSZXN1bHQgPSBjYWxsKGlubmVyUmVzdWx0LCBpdGVyYXRvcik7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgaW5uZXJFcnJvciA9IHRydWU7XG4gICAgICAgICAgaW5uZXJSZXN1bHQgPSBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2luZCA9PT0gXCJ0aHJvd1wiKSB0aHJvdyB2YWx1ZTtcbiAgICAgICAgaWYgKGlubmVyRXJyb3IpIHRocm93IGlubmVyUmVzdWx0O1xuICAgICAgICBhbk9iamVjdChpbm5lclJlc3VsdCk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG4gICAgfSlcbiAgKSxcbiAgLyoqKi9cbiAgOTU2NTogKFxuICAgIC8qKiovXG4gICAgKChtb2R1bGUyLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICB2YXIgTkFUSVZFX0JJTkQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig2MTYpO1xuICAgICAgdmFyIGNhbGwgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbDtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IE5BVElWRV9CSU5EID8gY2FsbC5iaW5kKGNhbGwpIDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjYWxsLmFwcGx5KGNhbGwsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH0pXG4gICksXG4gIC8qKiovXG4gIDk1Nzc6IChcbiAgICAvKioqL1xuICAgICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciBhcnJheVdpdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig5OTI4KTtcbiAgICAgIHZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoNDY0NCk7XG4gICAgICB2YXIgaXNCaWdJbnRBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18yKDExMDgpO1xuICAgICAgdmFyIHRvSW50ZWdlck9ySW5maW5pdHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigxMjkxKTtcbiAgICAgIHZhciB0b0JpZ0ludCA9IF9fd2VicGFja19yZXF1aXJlX18yKDU4NTQpO1xuICAgICAgdmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcbiAgICAgIHZhciBnZXRUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmdldFR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcbiAgICAgIHZhciBleHBvcnRUeXBlZEFycmF5TWV0aG9kID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRUeXBlZEFycmF5TWV0aG9kO1xuICAgICAgdmFyIFBST1BFUl9PUkRFUiA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBuZXcgSW50OEFycmF5KDEpW1wid2l0aFwiXSgyLCB7IHZhbHVlT2Y6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhyb3cgODtcbiAgICAgICAgICB9IH0pO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvciA9PT0gODtcbiAgICAgICAgfVxuICAgICAgfSkoKTtcbiAgICAgIHZhciBUSFJPV19PTl9ORUdBVElWRV9GUkFDVElPTkFMX0lOREVYID0gUFJPUEVSX09SREVSICYmIChmdW5jdGlvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBuZXcgSW50OEFycmF5KDEpW1wid2l0aFwiXSgtMC41LCAxKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSkoKTtcbiAgICAgIGV4cG9ydFR5cGVkQXJyYXlNZXRob2QoXCJ3aXRoXCIsIHsgXCJ3aXRoXCI6IGZ1bmN0aW9uKGluZGV4LCB2YWx1ZSkge1xuICAgICAgICB2YXIgTyA9IGFUeXBlZEFycmF5KHRoaXMpO1xuICAgICAgICB2YXIgcmVsYXRpdmVJbmRleCA9IHRvSW50ZWdlck9ySW5maW5pdHkoaW5kZXgpO1xuICAgICAgICB2YXIgYWN0dWFsVmFsdWUgPSBpc0JpZ0ludEFycmF5KE8pID8gdG9CaWdJbnQodmFsdWUpIDogK3ZhbHVlO1xuICAgICAgICByZXR1cm4gYXJyYXlXaXRoKE8sIGdldFR5cGVkQXJyYXlDb25zdHJ1Y3RvcihPKSwgcmVsYXRpdmVJbmRleCwgYWN0dWFsVmFsdWUpO1xuICAgICAgfSB9W1wid2l0aFwiXSwgIVBST1BFUl9PUkRFUiB8fCBUSFJPV19PTl9ORUdBVElWRV9GUkFDVElPTkFMX0lOREVYKTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA5NTkwOiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciB0b0ludGVnZXJPckluZmluaXR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXzIoMTI5MSk7XG4gICAgICB2YXIgJFJhbmdlRXJyb3IgPSBSYW5nZUVycm9yO1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24oaXQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRvSW50ZWdlck9ySW5maW5pdHkoaXQpO1xuICAgICAgICBpZiAocmVzdWx0IDwgMCkgdGhyb3cgbmV3ICRSYW5nZUVycm9yKFwiVGhlIGFyZ3VtZW50IGNhbid0IGJlIGxlc3MgdGhhbiAwXCIpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA5NjE3OiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciB0b0luZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig1Mzk3KTtcbiAgICAgIHZhciB0b0Fic29sdXRlSW5kZXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fMig1NjEwKTtcbiAgICAgIHZhciBsZW5ndGhPZkFycmF5TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDYxOTgpO1xuICAgICAgdmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uKElTX0lOQ0xVREVTKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgICAgICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KCR0aGlzKTtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UoTyk7XG4gICAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgICAgICAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT09IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgICAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGZvciAoOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICAgICAgaWYgKChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSAmJiBPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IHtcbiAgICAgICAgLy8gYEFycmF5LnByb3RvdHlwZS5pbmNsdWRlc2AgbWV0aG9kXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG4gICAgICAgIGluY2x1ZGVzOiBjcmVhdGVNZXRob2QodHJ1ZSksXG4gICAgICAgIC8vIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZmAgbWV0aG9kXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluZGV4b2ZcbiAgICAgICAgaW5kZXhPZjogY3JlYXRlTWV0aG9kKGZhbHNlKVxuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA5NjMxOiAoXG4gICAgLyoqKi9cbiAgICAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fMig5NDg2KTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA5Nzk3OiAoXG4gICAgLyoqKi9cbiAgICAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18yKSA9PiB7XG4gICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fMig0MjI2KTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA5ODM1OiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIpID0+IHtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKE1FVEhPRF9OQU1FKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGJhc2VTZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgICAgIHZhciBzZXRMaWtlID0ge1xuICAgICAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgICAgIGhhczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGtleXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCBcIm5leHRcIiwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICBiYXNlU2V0LmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgICBiYXNlU2V0LmFkZCg0KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGJhc2VTZXRbTUVUSE9EX05BTUVdKHNldExpa2UpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQuc2l6ZSA9PT0gMSAmJiByZXN1bHQudmFsdWVzKCkubmV4dCgpLnZhbHVlID09PSA0O1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KVxuICApLFxuICAvKioqL1xuICA5OTI4OiAoXG4gICAgLyoqKi9cbiAgICAoKG1vZHVsZTIsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXzIpID0+IHtcbiAgICAgIHZhciBsZW5ndGhPZkFycmF5TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18yKDYxOTgpO1xuICAgICAgdmFyIHRvSW50ZWdlck9ySW5maW5pdHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fMigxMjkxKTtcbiAgICAgIHZhciAkUmFuZ2VFcnJvciA9IFJhbmdlRXJyb3I7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbihPLCBDLCBpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGxlbiA9IGxlbmd0aE9mQXJyYXlMaWtlKE8pO1xuICAgICAgICB2YXIgcmVsYXRpdmVJbmRleCA9IHRvSW50ZWdlck9ySW5maW5pdHkoaW5kZXgpO1xuICAgICAgICB2YXIgYWN0dWFsSW5kZXggPSByZWxhdGl2ZUluZGV4IDwgMCA/IGxlbiArIHJlbGF0aXZlSW5kZXggOiByZWxhdGl2ZUluZGV4O1xuICAgICAgICBpZiAoYWN0dWFsSW5kZXggPj0gbGVuIHx8IGFjdHVhbEluZGV4IDwgMCkgdGhyb3cgbmV3ICRSYW5nZUVycm9yKFwiSW5jb3JyZWN0IGluZGV4XCIpO1xuICAgICAgICB2YXIgQSA9IG5ldyBDKGxlbik7XG4gICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgZm9yICg7IGsgPCBsZW47IGsrKykgQVtrXSA9IGsgPT09IGFjdHVhbEluZGV4ID8gdmFsdWUgOiBPW2tdO1xuICAgICAgICByZXR1cm4gQTtcbiAgICAgIH07XG4gICAgfSlcbiAgKVxuICAvKioqKioqL1xufTtcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbiAgdmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4gIGlmIChjYWNoZWRNb2R1bGUgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcbiAgfVxuICB2YXIgbW9kdWxlMiA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4gICAgLyoqKioqKi9cbiAgICAvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4gICAgLyoqKioqKi9cbiAgICAvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuICAgIC8qKioqKiovXG4gICAgZXhwb3J0czoge31cbiAgICAvKioqKioqL1xuICB9O1xuICBfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZTIuZXhwb3J0cywgbW9kdWxlMiwgbW9kdWxlMi5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbiAgcmV0dXJuIG1vZHVsZTIuZXhwb3J0cztcbn1cbigoKSA9PiB7XG4gIF9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzMiwgZGVmaW5pdGlvbikgPT4ge1xuICAgIGZvciAodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG4gICAgICBpZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzMiwga2V5KSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59KSgpO1xuKCgpID0+IHtcbiAgX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59KSgpO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg0MTE0KTtcbl9fd2VicGFja19yZXF1aXJlX18oNjU3Myk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDgxMDApO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg3OTM2KTtcbl9fd2VicGFja19yZXF1aXJlX18oODExMSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDgyMzcpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxNjg5KTtcbl9fd2VicGFja19yZXF1aXJlX18oOTU3Nyk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDQyMzUpO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg5NDMyKTtcbl9fd2VicGFja19yZXF1aXJlX18oMTU0OSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDk3OTcpO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg5NjMxKTtcbl9fd2VicGFja19yZXF1aXJlX18oNTYyMyk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDQ5NzkpO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg1NzgxKTtcbmNvbnN0IGlzTm9kZUpTID0gdHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2VzcyArIFwiXCIgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiICYmICFwcm9jZXNzLnZlcnNpb25zLm53ICYmICEocHJvY2Vzcy52ZXJzaW9ucy5lbGVjdHJvbiAmJiBwcm9jZXNzLnR5cGUgJiYgcHJvY2Vzcy50eXBlICE9PSBcImJyb3dzZXJcIik7XG5jb25zdCBGT05UX0lERU5USVRZX01BVFJJWCA9IFsxZS0zLCAwLCAwLCAxZS0zLCAwLCAwXTtcbmNvbnN0IExJTkVfRkFDVE9SID0gMS4zNTtcbmNvbnN0IFJlbmRlcmluZ0ludGVudEZsYWcgPSB7XG4gIEFOWTogMSxcbiAgRElTUExBWTogMixcbiAgUFJJTlQ6IDQsXG4gIEFOTk9UQVRJT05TX0ZPUk1TOiAxNixcbiAgQU5OT1RBVElPTlNfU1RPUkFHRTogMzIsXG4gIEFOTk9UQVRJT05TX0RJU0FCTEU6IDY0LFxuICBJU19FRElUSU5HOiAxMjgsXG4gIE9QTElTVDogMjU2XG59O1xuY29uc3QgQW5ub3RhdGlvbk1vZGUgPSB7XG4gIERJU0FCTEU6IDAsXG4gIEVOQUJMRTogMSxcbiAgRU5BQkxFX0ZPUk1TOiAyLFxuICBFTkFCTEVfU1RPUkFHRTogM1xufTtcbmNvbnN0IEFubm90YXRpb25FZGl0b3JQcmVmaXggPSBcInBkZmpzX2ludGVybmFsX2VkaXRvcl9cIjtcbmNvbnN0IEFubm90YXRpb25FZGl0b3JUeXBlID0ge1xuICBESVNBQkxFOiAtMSxcbiAgTk9ORTogMCxcbiAgRlJFRVRFWFQ6IDMsXG4gIEhJR0hMSUdIVDogOSxcbiAgU1RBTVA6IDEzLFxuICBJTks6IDE1LFxuICBQT1BVUDogMTYsXG4gIFNJR05BVFVSRTogMTAxLFxuICBDT01NRU5UOiAxMDJcbn07XG5jb25zdCBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZSA9IHtcbiAgUkVTSVpFOiAxLFxuICBDUkVBVEU6IDIsXG4gIEZSRUVURVhUX1NJWkU6IDExLFxuICBGUkVFVEVYVF9DT0xPUjogMTIsXG4gIEZSRUVURVhUX09QQUNJVFk6IDEzLFxuICBJTktfQ09MT1I6IDIxLFxuICBJTktfVEhJQ0tORVNTOiAyMixcbiAgSU5LX09QQUNJVFk6IDIzLFxuICBISUdITElHSFRfQ09MT1I6IDMxLFxuICBISUdITElHSFRfVEhJQ0tORVNTOiAzMixcbiAgSElHSExJR0hUX0ZSRUU6IDMzLFxuICBISUdITElHSFRfU0hPV19BTEw6IDM0LFxuICBEUkFXX1NURVA6IDQxXG59O1xuY29uc3QgUGVybWlzc2lvbkZsYWcgPSB7XG4gIFBSSU5UOiA0LFxuICBNT0RJRllfQ09OVEVOVFM6IDgsXG4gIENPUFk6IDE2LFxuICBNT0RJRllfQU5OT1RBVElPTlM6IDMyLFxuICBGSUxMX0lOVEVSQUNUSVZFX0ZPUk1TOiAyNTYsXG4gIENPUFlfRk9SX0FDQ0VTU0lCSUxJVFk6IDUxMixcbiAgQVNTRU1CTEU6IDEwMjQsXG4gIFBSSU5UX0hJR0hfUVVBTElUWTogMjA0OFxufTtcbmNvbnN0IFRleHRSZW5kZXJpbmdNb2RlID0ge1xuICBGSUxMOiAwLFxuICBTVFJPS0U6IDEsXG4gIEZJTExfU1RST0tFOiAyLFxuICBJTlZJU0lCTEU6IDMsXG4gIEZJTExfU1RST0tFX01BU0s6IDMsXG4gIEFERF9UT19QQVRIX0ZMQUc6IDRcbn07XG5jb25zdCB1dGlsX0ltYWdlS2luZCA9IHtcbiAgR1JBWVNDQUxFXzFCUFA6IDEsXG4gIFJHQl8yNEJQUDogMixcbiAgUkdCQV8zMkJQUDogM1xufTtcbmNvbnN0IEFubm90YXRpb25UeXBlID0ge1xuICBURVhUOiAxLFxuICBMSU5LOiAyLFxuICBGUkVFVEVYVDogMyxcbiAgTElORTogNCxcbiAgU1FVQVJFOiA1LFxuICBDSVJDTEU6IDYsXG4gIFBPTFlHT046IDcsXG4gIFBPTFlMSU5FOiA4LFxuICBISUdITElHSFQ6IDksXG4gIFVOREVSTElORTogMTAsXG4gIFNRVUlHR0xZOiAxMSxcbiAgU1RSSUtFT1VUOiAxMixcbiAgU1RBTVA6IDEzLFxuICBDQVJFVDogMTQsXG4gIElOSzogMTUsXG4gIFBPUFVQOiAxNixcbiAgRklMRUFUVEFDSE1FTlQ6IDE3LFxuICBTT1VORDogMTgsXG4gIE1PVklFOiAxOSxcbiAgV0lER0VUOiAyMCxcbiAgU0NSRUVOOiAyMSxcbiAgUFJJTlRFUk1BUks6IDIyLFxuICBUUkFQTkVUOiAyMyxcbiAgV0FURVJNQVJLOiAyNCxcbiAgVEhSRUVEOiAyNSxcbiAgUkVEQUNUOiAyNlxufTtcbmNvbnN0IEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUgPSB7XG4gIFNPTElEOiAxLFxuICBEQVNIRUQ6IDIsXG4gIEJFVkVMRUQ6IDMsXG4gIElOU0VUOiA0LFxuICBVTkRFUkxJTkU6IDVcbn07XG5jb25zdCBWZXJib3NpdHlMZXZlbCA9IHtcbiAgRVJST1JTOiAwLFxuICBXQVJOSU5HUzogMSxcbiAgSU5GT1M6IDVcbn07XG5jb25zdCBPUFMgPSB7XG4gIGRlcGVuZGVuY3k6IDEsXG4gIHNldExpbmVXaWR0aDogMixcbiAgc2V0TGluZUNhcDogMyxcbiAgc2V0TGluZUpvaW46IDQsXG4gIHNldE1pdGVyTGltaXQ6IDUsXG4gIHNldERhc2g6IDYsXG4gIHNldFJlbmRlcmluZ0ludGVudDogNyxcbiAgc2V0RmxhdG5lc3M6IDgsXG4gIHNldEdTdGF0ZTogOSxcbiAgc2F2ZTogMTAsXG4gIHJlc3RvcmU6IDExLFxuICB0cmFuc2Zvcm06IDEyLFxuICBtb3ZlVG86IDEzLFxuICBsaW5lVG86IDE0LFxuICBjdXJ2ZVRvOiAxNSxcbiAgY3VydmVUbzI6IDE2LFxuICBjdXJ2ZVRvMzogMTcsXG4gIGNsb3NlUGF0aDogMTgsXG4gIHJlY3RhbmdsZTogMTksXG4gIHN0cm9rZTogMjAsXG4gIGNsb3NlU3Ryb2tlOiAyMSxcbiAgZmlsbDogMjIsXG4gIGVvRmlsbDogMjMsXG4gIGZpbGxTdHJva2U6IDI0LFxuICBlb0ZpbGxTdHJva2U6IDI1LFxuICBjbG9zZUZpbGxTdHJva2U6IDI2LFxuICBjbG9zZUVPRmlsbFN0cm9rZTogMjcsXG4gIGVuZFBhdGg6IDI4LFxuICBjbGlwOiAyOSxcbiAgZW9DbGlwOiAzMCxcbiAgYmVnaW5UZXh0OiAzMSxcbiAgZW5kVGV4dDogMzIsXG4gIHNldENoYXJTcGFjaW5nOiAzMyxcbiAgc2V0V29yZFNwYWNpbmc6IDM0LFxuICBzZXRIU2NhbGU6IDM1LFxuICBzZXRMZWFkaW5nOiAzNixcbiAgc2V0Rm9udDogMzcsXG4gIHNldFRleHRSZW5kZXJpbmdNb2RlOiAzOCxcbiAgc2V0VGV4dFJpc2U6IDM5LFxuICBtb3ZlVGV4dDogNDAsXG4gIHNldExlYWRpbmdNb3ZlVGV4dDogNDEsXG4gIHNldFRleHRNYXRyaXg6IDQyLFxuICBuZXh0TGluZTogNDMsXG4gIHNob3dUZXh0OiA0NCxcbiAgc2hvd1NwYWNlZFRleHQ6IDQ1LFxuICBuZXh0TGluZVNob3dUZXh0OiA0NixcbiAgbmV4dExpbmVTZXRTcGFjaW5nU2hvd1RleHQ6IDQ3LFxuICBzZXRDaGFyV2lkdGg6IDQ4LFxuICBzZXRDaGFyV2lkdGhBbmRCb3VuZHM6IDQ5LFxuICBzZXRTdHJva2VDb2xvclNwYWNlOiA1MCxcbiAgc2V0RmlsbENvbG9yU3BhY2U6IDUxLFxuICBzZXRTdHJva2VDb2xvcjogNTIsXG4gIHNldFN0cm9rZUNvbG9yTjogNTMsXG4gIHNldEZpbGxDb2xvcjogNTQsXG4gIHNldEZpbGxDb2xvck46IDU1LFxuICBzZXRTdHJva2VHcmF5OiA1NixcbiAgc2V0RmlsbEdyYXk6IDU3LFxuICBzZXRTdHJva2VSR0JDb2xvcjogNTgsXG4gIHNldEZpbGxSR0JDb2xvcjogNTksXG4gIHNldFN0cm9rZUNNWUtDb2xvcjogNjAsXG4gIHNldEZpbGxDTVlLQ29sb3I6IDYxLFxuICBzaGFkaW5nRmlsbDogNjIsXG4gIGJlZ2luSW5saW5lSW1hZ2U6IDYzLFxuICBiZWdpbkltYWdlRGF0YTogNjQsXG4gIGVuZElubGluZUltYWdlOiA2NSxcbiAgcGFpbnRYT2JqZWN0OiA2NixcbiAgbWFya1BvaW50OiA2NyxcbiAgbWFya1BvaW50UHJvcHM6IDY4LFxuICBiZWdpbk1hcmtlZENvbnRlbnQ6IDY5LFxuICBiZWdpbk1hcmtlZENvbnRlbnRQcm9wczogNzAsXG4gIGVuZE1hcmtlZENvbnRlbnQ6IDcxLFxuICBiZWdpbkNvbXBhdDogNzIsXG4gIGVuZENvbXBhdDogNzMsXG4gIHBhaW50Rm9ybVhPYmplY3RCZWdpbjogNzQsXG4gIHBhaW50Rm9ybVhPYmplY3RFbmQ6IDc1LFxuICBiZWdpbkdyb3VwOiA3NixcbiAgZW5kR3JvdXA6IDc3LFxuICBiZWdpbkFubm90YXRpb246IDgwLFxuICBlbmRBbm5vdGF0aW9uOiA4MSxcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0OiA4MyxcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0R3JvdXA6IDg0LFxuICBwYWludEltYWdlWE9iamVjdDogODUsXG4gIHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0OiA4NixcbiAgcGFpbnRJbmxpbmVJbWFnZVhPYmplY3RHcm91cDogODcsXG4gIHBhaW50SW1hZ2VYT2JqZWN0UmVwZWF0OiA4OCxcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0UmVwZWF0OiA4OSxcbiAgcGFpbnRTb2xpZENvbG9ySW1hZ2VNYXNrOiA5MCxcbiAgY29uc3RydWN0UGF0aDogOTEsXG4gIHNldFN0cm9rZVRyYW5zcGFyZW50OiA5MixcbiAgc2V0RmlsbFRyYW5zcGFyZW50OiA5MyxcbiAgcmF3RmlsbFBhdGg6IDk0XG59O1xuY29uc3QgRHJhd09QUyA9IHtcbiAgbW92ZVRvOiAwLFxuICBsaW5lVG86IDEsXG4gIGN1cnZlVG86IDIsXG4gIGNsb3NlUGF0aDogM1xufTtcbmNvbnN0IFBhc3N3b3JkUmVzcG9uc2VzID0ge1xuICBORUVEX1BBU1NXT1JEOiAxLFxuICBJTkNPUlJFQ1RfUEFTU1dPUkQ6IDJcbn07XG5sZXQgdmVyYm9zaXR5ID0gVmVyYm9zaXR5TGV2ZWwuV0FSTklOR1M7XG5mdW5jdGlvbiBzZXRWZXJib3NpdHlMZXZlbChsZXZlbCkge1xuICBpZiAoTnVtYmVyLmlzSW50ZWdlcihsZXZlbCkpIHtcbiAgICB2ZXJib3NpdHkgPSBsZXZlbDtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VmVyYm9zaXR5TGV2ZWwoKSB7XG4gIHJldHVybiB2ZXJib3NpdHk7XG59XG5mdW5jdGlvbiBpbmZvKG1zZykge1xuICBpZiAodmVyYm9zaXR5ID49IFZlcmJvc2l0eUxldmVsLklORk9TKSB7XG4gICAgY29uc29sZS5pbmZvKGBJbmZvOiAke21zZ31gKTtcbiAgfVxufVxuZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgaWYgKHZlcmJvc2l0eSA+PSBWZXJib3NpdHlMZXZlbC5XQVJOSU5HUykge1xuICAgIGNvbnNvbGUud2FybihgV2FybmluZzogJHttc2d9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVucmVhY2hhYmxlKG1zZykge1xuICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbn1cbmZ1bmN0aW9uIGFzc2VydChjb25kLCBtc2cpIHtcbiAgaWYgKCFjb25kKSB7XG4gICAgdW5yZWFjaGFibGUobXNnKTtcbiAgfVxufVxuZnVuY3Rpb24gX2lzVmFsaWRQcm90b2NvbCh1cmwpIHtcbiAgc3dpdGNoICh1cmw/LnByb3RvY29sKSB7XG4gICAgY2FzZSBcImh0dHA6XCI6XG4gICAgY2FzZSBcImh0dHBzOlwiOlxuICAgIGNhc2UgXCJmdHA6XCI6XG4gICAgY2FzZSBcIm1haWx0bzpcIjpcbiAgICBjYXNlIFwidGVsOlwiOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlVmFsaWRBYnNvbHV0ZVVybCh1cmwsIGJhc2VVcmwgPSBudWxsLCBvcHRpb25zID0gbnVsbCkge1xuICBpZiAoIXVybCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiB1cmwgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAob3B0aW9ucy5hZGREZWZhdWx0UHJvdG9jb2wgJiYgdXJsLnN0YXJ0c1dpdGgoXCJ3d3cuXCIpKSB7XG4gICAgICBjb25zdCBkb3RzID0gdXJsLm1hdGNoKC9cXC4vZyk7XG4gICAgICBpZiAoZG90cz8ubGVuZ3RoID49IDIpIHtcbiAgICAgICAgdXJsID0gYGh0dHA6Ly8ke3VybH1gO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy50cnlDb252ZXJ0RW5jb2RpbmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHVybCA9IHN0cmluZ1RvVVRGOFN0cmluZyh1cmwpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IGFic29sdXRlVXJsID0gYmFzZVVybCA/IFVSTC5wYXJzZSh1cmwsIGJhc2VVcmwpIDogVVJMLnBhcnNlKHVybCk7XG4gIHJldHVybiBfaXNWYWxpZFByb3RvY29sKGFic29sdXRlVXJsKSA/IGFic29sdXRlVXJsIDogbnVsbDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVVybEhhc2godXJsLCBoYXNoLCBhbGxvd1JlbCA9IGZhbHNlKSB7XG4gIGNvbnN0IHJlcyA9IFVSTC5wYXJzZSh1cmwpO1xuICBpZiAocmVzKSB7XG4gICAgcmVzLmhhc2ggPSBoYXNoO1xuICAgIHJldHVybiByZXMuaHJlZjtcbiAgfVxuICBpZiAoYWxsb3dSZWwgJiYgY3JlYXRlVmFsaWRBYnNvbHV0ZVVybCh1cmwsIFwiaHR0cDovL2V4YW1wbGUuY29tXCIpKSB7XG4gICAgcmV0dXJuIHVybC5zcGxpdChcIiNcIiwgMSlbMF0gKyBgJHtoYXNoID8gYCMke2hhc2h9YCA6IFwiXCJ9YDtcbiAgfVxuICByZXR1cm4gXCJcIjtcbn1cbmZ1bmN0aW9uIHNoYWRvdyhvYmosIHByb3AsIHZhbHVlLCBub25TZXJpYWxpemFibGUgPSBmYWxzZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCB7XG4gICAgdmFsdWUsXG4gICAgZW51bWVyYWJsZTogIW5vblNlcmlhbGl6YWJsZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gdmFsdWU7XG59XG5jb25zdCBCYXNlRXhjZXB0aW9uID0gKGZ1bmN0aW9uIEJhc2VFeGNlcHRpb25DbG9zdXJlKCkge1xuICBmdW5jdGlvbiBCYXNlRXhjZXB0aW9uMihtZXNzYWdlLCBuYW1lKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICB9XG4gIEJhc2VFeGNlcHRpb24yLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuICBCYXNlRXhjZXB0aW9uMi5jb25zdHJ1Y3RvciA9IEJhc2VFeGNlcHRpb24yO1xuICByZXR1cm4gQmFzZUV4Y2VwdGlvbjI7XG59KSgpO1xuY2xhc3MgUGFzc3dvcmRFeGNlcHRpb24gZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnLCBjb2RlKSB7XG4gICAgc3VwZXIobXNnLCBcIlBhc3N3b3JkRXhjZXB0aW9uXCIpO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gIH1cbn1cbmNsYXNzIFVua25vd25FcnJvckV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2csIGRldGFpbHMpIHtcbiAgICBzdXBlcihtc2csIFwiVW5rbm93bkVycm9yRXhjZXB0aW9uXCIpO1xuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gIH1cbn1cbmNsYXNzIEludmFsaWRQREZFeGNlcHRpb24gZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgc3VwZXIobXNnLCBcIkludmFsaWRQREZFeGNlcHRpb25cIik7XG4gIH1cbn1cbmNsYXNzIFJlc3BvbnNlRXhjZXB0aW9uIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZywgc3RhdHVzLCBtaXNzaW5nKSB7XG4gICAgc3VwZXIobXNnLCBcIlJlc3BvbnNlRXhjZXB0aW9uXCIpO1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMubWlzc2luZyA9IG1pc3Npbmc7XG4gIH1cbn1cbmNsYXNzIEZvcm1hdEVycm9yIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZykge1xuICAgIHN1cGVyKG1zZywgXCJGb3JtYXRFcnJvclwiKTtcbiAgfVxufVxuY2xhc3MgQWJvcnRFeGNlcHRpb24gZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgc3VwZXIobXNnLCBcIkFib3J0RXhjZXB0aW9uXCIpO1xuICB9XG59XG5mdW5jdGlvbiBieXRlc1RvU3RyaW5nKGJ5dGVzKSB7XG4gIGlmICh0eXBlb2YgYnl0ZXMgIT09IFwib2JqZWN0XCIgfHwgYnl0ZXM/Lmxlbmd0aCA9PT0gdm9pZCAwKSB7XG4gICAgdW5yZWFjaGFibGUoXCJJbnZhbGlkIGFyZ3VtZW50IGZvciBieXRlc1RvU3RyaW5nXCIpO1xuICB9XG4gIGNvbnN0IGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcbiAgY29uc3QgTUFYX0FSR1VNRU5UX0NPVU5UID0gODE5MjtcbiAgaWYgKGxlbmd0aCA8IE1BWF9BUkdVTUVOVF9DT1VOVCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ5dGVzKTtcbiAgfVxuICBjb25zdCBzdHJCdWYgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gTUFYX0FSR1VNRU5UX0NPVU5UKSB7XG4gICAgY29uc3QgY2h1bmtFbmQgPSBNYXRoLm1pbihpICsgTUFYX0FSR1VNRU5UX0NPVU5ULCBsZW5ndGgpO1xuICAgIGNvbnN0IGNodW5rID0gYnl0ZXMuc3ViYXJyYXkoaSwgY2h1bmtFbmQpO1xuICAgIHN0ckJ1Zi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgY2h1bmspKTtcbiAgfVxuICByZXR1cm4gc3RyQnVmLmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBzdHJpbmdUb0J5dGVzKHN0cikge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gXCJzdHJpbmdcIikge1xuICAgIHVucmVhY2hhYmxlKFwiSW52YWxpZCBhcmd1bWVudCBmb3Igc3RyaW5nVG9CeXRlc1wiKTtcbiAgfVxuICBjb25zdCBsZW5ndGggPSBzdHIubGVuZ3RoO1xuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBieXRlc1tpXSA9IHN0ci5jaGFyQ29kZUF0KGkpICYgMjU1O1xuICB9XG4gIHJldHVybiBieXRlcztcbn1cbmZ1bmN0aW9uIHN0cmluZzMyKHZhbHVlKSB7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHZhbHVlID4+IDI0ICYgMjU1LCB2YWx1ZSA+PiAxNiAmIDI1NSwgdmFsdWUgPj4gOCAmIDI1NSwgdmFsdWUgJiAyNTUpO1xufVxuZnVuY3Rpb24gaXNMaXR0bGVFbmRpYW4oKSB7XG4gIGNvbnN0IGJ1ZmZlcjggPSBuZXcgVWludDhBcnJheSg0KTtcbiAgYnVmZmVyOFswXSA9IDE7XG4gIGNvbnN0IHZpZXczMiA9IG5ldyBVaW50MzJBcnJheShidWZmZXI4LmJ1ZmZlciwgMCwgMSk7XG4gIHJldHVybiB2aWV3MzJbMF0gPT09IDE7XG59XG5mdW5jdGlvbiBpc0V2YWxTdXBwb3J0ZWQoKSB7XG4gIHRyeSB7XG4gICAgbmV3IEZ1bmN0aW9uKFwiXCIpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmNsYXNzIHV0aWxfRmVhdHVyZVRlc3Qge1xuICBzdGF0aWMgZ2V0IGlzTGl0dGxlRW5kaWFuKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc0xpdHRsZUVuZGlhblwiLCBpc0xpdHRsZUVuZGlhbigpKTtcbiAgfVxuICBzdGF0aWMgZ2V0IGlzRXZhbFN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNFdmFsU3VwcG9ydGVkXCIsIGlzRXZhbFN1cHBvcnRlZCgpKTtcbiAgfVxuICBzdGF0aWMgZ2V0IGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZFwiLCB0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSBcInVuZGVmaW5lZFwiKTtcbiAgfVxuICBzdGF0aWMgZ2V0IGlzSW1hZ2VEZWNvZGVyU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc0ltYWdlRGVjb2RlclN1cHBvcnRlZFwiLCB0eXBlb2YgSW1hZ2VEZWNvZGVyICE9PSBcInVuZGVmaW5lZFwiKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHBsYXRmb3JtKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBsYXRmb3JtLFxuICAgICAgdXNlckFnZW50XG4gICAgfSA9IG5hdmlnYXRvcjtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwicGxhdGZvcm1cIiwge1xuICAgICAgaXNBbmRyb2lkOiB1c2VyQWdlbnQuaW5jbHVkZXMoXCJBbmRyb2lkXCIpLFxuICAgICAgaXNMaW51eDogcGxhdGZvcm0uaW5jbHVkZXMoXCJMaW51eFwiKSxcbiAgICAgIGlzTWFjOiBwbGF0Zm9ybS5pbmNsdWRlcyhcIk1hY1wiKSxcbiAgICAgIGlzV2luZG93czogcGxhdGZvcm0uaW5jbHVkZXMoXCJXaW5cIiksXG4gICAgICBpc0ZpcmVmb3g6IHVzZXJBZ2VudC5pbmNsdWRlcyhcIkZpcmVmb3hcIilcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0IGlzQ1NTUm91bmRTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzQ1NTUm91bmRTdXBwb3J0ZWRcIiwgZ2xvYmFsVGhpcy5DU1M/LnN1cHBvcnRzPy4oXCJ3aWR0aDogcm91bmQoMS41cHgsIDFweClcIikpO1xuICB9XG59XG5jb25zdCBoZXhOdW1iZXJzID0gQXJyYXkuZnJvbShBcnJheSgyNTYpLmtleXMoKSwgKG4pID0+IG4udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSk7XG5jbGFzcyBVdGlsIHtcbiAgc3RhdGljIG1ha2VIZXhDb2xvcihyLCBnLCBiKSB7XG4gICAgcmV0dXJuIGAjJHtoZXhOdW1iZXJzW3JdfSR7aGV4TnVtYmVyc1tnXX0ke2hleE51bWJlcnNbYl19YDtcbiAgfVxuICBzdGF0aWMgZG9tTWF0cml4VG9UcmFuc2Zvcm0oZG0pIHtcbiAgICByZXR1cm4gW2RtLmEsIGRtLmIsIGRtLmMsIGRtLmQsIGRtLmUsIGRtLmZdO1xuICB9XG4gIHN0YXRpYyBzY2FsZU1pbk1heCh0cmFuc2Zvcm0sIG1pbk1heCkge1xuICAgIGxldCB0ZW1wO1xuICAgIGlmICh0cmFuc2Zvcm1bMF0pIHtcbiAgICAgIGlmICh0cmFuc2Zvcm1bMF0gPCAwKSB7XG4gICAgICAgIHRlbXAgPSBtaW5NYXhbMF07XG4gICAgICAgIG1pbk1heFswXSA9IG1pbk1heFsyXTtcbiAgICAgICAgbWluTWF4WzJdID0gdGVtcDtcbiAgICAgIH1cbiAgICAgIG1pbk1heFswXSAqPSB0cmFuc2Zvcm1bMF07XG4gICAgICBtaW5NYXhbMl0gKj0gdHJhbnNmb3JtWzBdO1xuICAgICAgaWYgKHRyYW5zZm9ybVszXSA8IDApIHtcbiAgICAgICAgdGVtcCA9IG1pbk1heFsxXTtcbiAgICAgICAgbWluTWF4WzFdID0gbWluTWF4WzNdO1xuICAgICAgICBtaW5NYXhbM10gPSB0ZW1wO1xuICAgICAgfVxuICAgICAgbWluTWF4WzFdICo9IHRyYW5zZm9ybVszXTtcbiAgICAgIG1pbk1heFszXSAqPSB0cmFuc2Zvcm1bM107XG4gICAgfSBlbHNlIHtcbiAgICAgIHRlbXAgPSBtaW5NYXhbMF07XG4gICAgICBtaW5NYXhbMF0gPSBtaW5NYXhbMV07XG4gICAgICBtaW5NYXhbMV0gPSB0ZW1wO1xuICAgICAgdGVtcCA9IG1pbk1heFsyXTtcbiAgICAgIG1pbk1heFsyXSA9IG1pbk1heFszXTtcbiAgICAgIG1pbk1heFszXSA9IHRlbXA7XG4gICAgICBpZiAodHJhbnNmb3JtWzFdIDwgMCkge1xuICAgICAgICB0ZW1wID0gbWluTWF4WzFdO1xuICAgICAgICBtaW5NYXhbMV0gPSBtaW5NYXhbM107XG4gICAgICAgIG1pbk1heFszXSA9IHRlbXA7XG4gICAgICB9XG4gICAgICBtaW5NYXhbMV0gKj0gdHJhbnNmb3JtWzFdO1xuICAgICAgbWluTWF4WzNdICo9IHRyYW5zZm9ybVsxXTtcbiAgICAgIGlmICh0cmFuc2Zvcm1bMl0gPCAwKSB7XG4gICAgICAgIHRlbXAgPSBtaW5NYXhbMF07XG4gICAgICAgIG1pbk1heFswXSA9IG1pbk1heFsyXTtcbiAgICAgICAgbWluTWF4WzJdID0gdGVtcDtcbiAgICAgIH1cbiAgICAgIG1pbk1heFswXSAqPSB0cmFuc2Zvcm1bMl07XG4gICAgICBtaW5NYXhbMl0gKj0gdHJhbnNmb3JtWzJdO1xuICAgIH1cbiAgICBtaW5NYXhbMF0gKz0gdHJhbnNmb3JtWzRdO1xuICAgIG1pbk1heFsxXSArPSB0cmFuc2Zvcm1bNV07XG4gICAgbWluTWF4WzJdICs9IHRyYW5zZm9ybVs0XTtcbiAgICBtaW5NYXhbM10gKz0gdHJhbnNmb3JtWzVdO1xuICB9XG4gIHN0YXRpYyB0cmFuc2Zvcm0obTEsIG0yKSB7XG4gICAgcmV0dXJuIFttMVswXSAqIG0yWzBdICsgbTFbMl0gKiBtMlsxXSwgbTFbMV0gKiBtMlswXSArIG0xWzNdICogbTJbMV0sIG0xWzBdICogbTJbMl0gKyBtMVsyXSAqIG0yWzNdLCBtMVsxXSAqIG0yWzJdICsgbTFbM10gKiBtMlszXSwgbTFbMF0gKiBtMls0XSArIG0xWzJdICogbTJbNV0gKyBtMVs0XSwgbTFbMV0gKiBtMls0XSArIG0xWzNdICogbTJbNV0gKyBtMVs1XV07XG4gIH1cbiAgc3RhdGljIG11bHRpcGx5QnlET01NYXRyaXgobSwgbWQpIHtcbiAgICByZXR1cm4gW21bMF0gKiBtZC5hICsgbVsyXSAqIG1kLmIsIG1bMV0gKiBtZC5hICsgbVszXSAqIG1kLmIsIG1bMF0gKiBtZC5jICsgbVsyXSAqIG1kLmQsIG1bMV0gKiBtZC5jICsgbVszXSAqIG1kLmQsIG1bMF0gKiBtZC5lICsgbVsyXSAqIG1kLmYgKyBtWzRdLCBtWzFdICogbWQuZSArIG1bM10gKiBtZC5mICsgbVs1XV07XG4gIH1cbiAgc3RhdGljIGFwcGx5VHJhbnNmb3JtKHAsIG0sIHBvcyA9IDApIHtcbiAgICBjb25zdCBwMCA9IHBbcG9zXTtcbiAgICBjb25zdCBwMSA9IHBbcG9zICsgMV07XG4gICAgcFtwb3NdID0gcDAgKiBtWzBdICsgcDEgKiBtWzJdICsgbVs0XTtcbiAgICBwW3BvcyArIDFdID0gcDAgKiBtWzFdICsgcDEgKiBtWzNdICsgbVs1XTtcbiAgfVxuICBzdGF0aWMgYXBwbHlUcmFuc2Zvcm1Ub0JlemllcihwLCB0cmFuc2Zvcm0sIHBvcyA9IDApIHtcbiAgICBjb25zdCBtMCA9IHRyYW5zZm9ybVswXTtcbiAgICBjb25zdCBtMSA9IHRyYW5zZm9ybVsxXTtcbiAgICBjb25zdCBtMiA9IHRyYW5zZm9ybVsyXTtcbiAgICBjb25zdCBtMyA9IHRyYW5zZm9ybVszXTtcbiAgICBjb25zdCBtNCA9IHRyYW5zZm9ybVs0XTtcbiAgICBjb25zdCBtNSA9IHRyYW5zZm9ybVs1XTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkgKz0gMikge1xuICAgICAgY29uc3QgcEkgPSBwW3BvcyArIGldO1xuICAgICAgY29uc3QgcEkxID0gcFtwb3MgKyBpICsgMV07XG4gICAgICBwW3BvcyArIGldID0gcEkgKiBtMCArIHBJMSAqIG0yICsgbTQ7XG4gICAgICBwW3BvcyArIGkgKyAxXSA9IHBJICogbTEgKyBwSTEgKiBtMyArIG01O1xuICAgIH1cbiAgfVxuICBzdGF0aWMgYXBwbHlJbnZlcnNlVHJhbnNmb3JtKHAsIG0pIHtcbiAgICBjb25zdCBwMCA9IHBbMF07XG4gICAgY29uc3QgcDEgPSBwWzFdO1xuICAgIGNvbnN0IGQgPSBtWzBdICogbVszXSAtIG1bMV0gKiBtWzJdO1xuICAgIHBbMF0gPSAocDAgKiBtWzNdIC0gcDEgKiBtWzJdICsgbVsyXSAqIG1bNV0gLSBtWzRdICogbVszXSkgLyBkO1xuICAgIHBbMV0gPSAoLXAwICogbVsxXSArIHAxICogbVswXSArIG1bNF0gKiBtWzFdIC0gbVs1XSAqIG1bMF0pIC8gZDtcbiAgfVxuICBzdGF0aWMgYXhpYWxBbGlnbmVkQm91bmRpbmdCb3gocmVjdCwgdHJhbnNmb3JtLCBvdXRwdXQpIHtcbiAgICBjb25zdCBtMCA9IHRyYW5zZm9ybVswXTtcbiAgICBjb25zdCBtMSA9IHRyYW5zZm9ybVsxXTtcbiAgICBjb25zdCBtMiA9IHRyYW5zZm9ybVsyXTtcbiAgICBjb25zdCBtMyA9IHRyYW5zZm9ybVszXTtcbiAgICBjb25zdCBtNCA9IHRyYW5zZm9ybVs0XTtcbiAgICBjb25zdCBtNSA9IHRyYW5zZm9ybVs1XTtcbiAgICBjb25zdCByMCA9IHJlY3RbMF07XG4gICAgY29uc3QgcjEgPSByZWN0WzFdO1xuICAgIGNvbnN0IHIyID0gcmVjdFsyXTtcbiAgICBjb25zdCByMyA9IHJlY3RbM107XG4gICAgbGV0IGEwID0gbTAgKiByMCArIG00O1xuICAgIGxldCBhMiA9IGEwO1xuICAgIGxldCBhMSA9IG0wICogcjIgKyBtNDtcbiAgICBsZXQgYTMgPSBhMTtcbiAgICBsZXQgYjAgPSBtMyAqIHIxICsgbTU7XG4gICAgbGV0IGIyID0gYjA7XG4gICAgbGV0IGIxID0gbTMgKiByMyArIG01O1xuICAgIGxldCBiMyA9IGIxO1xuICAgIGlmIChtMSAhPT0gMCB8fCBtMiAhPT0gMCkge1xuICAgICAgY29uc3QgbTFyMCA9IG0xICogcjA7XG4gICAgICBjb25zdCBtMXIyID0gbTEgKiByMjtcbiAgICAgIGNvbnN0IG0ycjEgPSBtMiAqIHIxO1xuICAgICAgY29uc3QgbTJyMyA9IG0yICogcjM7XG4gICAgICBhMCArPSBtMnIxO1xuICAgICAgYTMgKz0gbTJyMTtcbiAgICAgIGExICs9IG0ycjM7XG4gICAgICBhMiArPSBtMnIzO1xuICAgICAgYjAgKz0gbTFyMDtcbiAgICAgIGIzICs9IG0xcjA7XG4gICAgICBiMSArPSBtMXIyO1xuICAgICAgYjIgKz0gbTFyMjtcbiAgICB9XG4gICAgb3V0cHV0WzBdID0gTWF0aC5taW4ob3V0cHV0WzBdLCBhMCwgYTEsIGEyLCBhMyk7XG4gICAgb3V0cHV0WzFdID0gTWF0aC5taW4ob3V0cHV0WzFdLCBiMCwgYjEsIGIyLCBiMyk7XG4gICAgb3V0cHV0WzJdID0gTWF0aC5tYXgob3V0cHV0WzJdLCBhMCwgYTEsIGEyLCBhMyk7XG4gICAgb3V0cHV0WzNdID0gTWF0aC5tYXgob3V0cHV0WzNdLCBiMCwgYjEsIGIyLCBiMyk7XG4gIH1cbiAgc3RhdGljIGludmVyc2VUcmFuc2Zvcm0obSkge1xuICAgIGNvbnN0IGQgPSBtWzBdICogbVszXSAtIG1bMV0gKiBtWzJdO1xuICAgIHJldHVybiBbbVszXSAvIGQsIC1tWzFdIC8gZCwgLW1bMl0gLyBkLCBtWzBdIC8gZCwgKG1bMl0gKiBtWzVdIC0gbVs0XSAqIG1bM10pIC8gZCwgKG1bNF0gKiBtWzFdIC0gbVs1XSAqIG1bMF0pIC8gZF07XG4gIH1cbiAgc3RhdGljIHNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKG1hdHJpeCwgb3V0cHV0KSB7XG4gICAgY29uc3QgbTAgPSBtYXRyaXhbMF07XG4gICAgY29uc3QgbTEgPSBtYXRyaXhbMV07XG4gICAgY29uc3QgbTIgPSBtYXRyaXhbMl07XG4gICAgY29uc3QgbTMgPSBtYXRyaXhbM107XG4gICAgY29uc3QgYSA9IG0wICoqIDIgKyBtMSAqKiAyO1xuICAgIGNvbnN0IGIgPSBtMCAqIG0yICsgbTEgKiBtMztcbiAgICBjb25zdCBjID0gbTIgKiogMiArIG0zICoqIDI7XG4gICAgY29uc3QgZmlyc3QgPSAoYSArIGMpIC8gMjtcbiAgICBjb25zdCBzZWNvbmQgPSBNYXRoLnNxcnQoZmlyc3QgKiogMiAtIChhICogYyAtIGIgKiogMikpO1xuICAgIG91dHB1dFswXSA9IE1hdGguc3FydChmaXJzdCArIHNlY29uZCB8fCAxKTtcbiAgICBvdXRwdXRbMV0gPSBNYXRoLnNxcnQoZmlyc3QgLSBzZWNvbmQgfHwgMSk7XG4gIH1cbiAgc3RhdGljIG5vcm1hbGl6ZVJlY3QocmVjdCkge1xuICAgIGNvbnN0IHIgPSByZWN0LnNsaWNlKDApO1xuICAgIGlmIChyZWN0WzBdID4gcmVjdFsyXSkge1xuICAgICAgclswXSA9IHJlY3RbMl07XG4gICAgICByWzJdID0gcmVjdFswXTtcbiAgICB9XG4gICAgaWYgKHJlY3RbMV0gPiByZWN0WzNdKSB7XG4gICAgICByWzFdID0gcmVjdFszXTtcbiAgICAgIHJbM10gPSByZWN0WzFdO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICBzdGF0aWMgaW50ZXJzZWN0KHJlY3QxLCByZWN0Mikge1xuICAgIGNvbnN0IHhMb3cgPSBNYXRoLm1heChNYXRoLm1pbihyZWN0MVswXSwgcmVjdDFbMl0pLCBNYXRoLm1pbihyZWN0MlswXSwgcmVjdDJbMl0pKTtcbiAgICBjb25zdCB4SGlnaCA9IE1hdGgubWluKE1hdGgubWF4KHJlY3QxWzBdLCByZWN0MVsyXSksIE1hdGgubWF4KHJlY3QyWzBdLCByZWN0MlsyXSkpO1xuICAgIGlmICh4TG93ID4geEhpZ2gpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB5TG93ID0gTWF0aC5tYXgoTWF0aC5taW4ocmVjdDFbMV0sIHJlY3QxWzNdKSwgTWF0aC5taW4ocmVjdDJbMV0sIHJlY3QyWzNdKSk7XG4gICAgY29uc3QgeUhpZ2ggPSBNYXRoLm1pbihNYXRoLm1heChyZWN0MVsxXSwgcmVjdDFbM10pLCBNYXRoLm1heChyZWN0MlsxXSwgcmVjdDJbM10pKTtcbiAgICBpZiAoeUxvdyA+IHlIaWdoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIFt4TG93LCB5TG93LCB4SGlnaCwgeUhpZ2hdO1xuICB9XG4gIHN0YXRpYyBwb2ludEJvdW5kaW5nQm94KHgsIHksIG1pbk1heCkge1xuICAgIG1pbk1heFswXSA9IE1hdGgubWluKG1pbk1heFswXSwgeCk7XG4gICAgbWluTWF4WzFdID0gTWF0aC5taW4obWluTWF4WzFdLCB5KTtcbiAgICBtaW5NYXhbMl0gPSBNYXRoLm1heChtaW5NYXhbMl0sIHgpO1xuICAgIG1pbk1heFszXSA9IE1hdGgubWF4KG1pbk1heFszXSwgeSk7XG4gIH1cbiAgc3RhdGljIHJlY3RCb3VuZGluZ0JveCh4MCwgeTAsIHgxLCB5MSwgbWluTWF4KSB7XG4gICAgbWluTWF4WzBdID0gTWF0aC5taW4obWluTWF4WzBdLCB4MCwgeDEpO1xuICAgIG1pbk1heFsxXSA9IE1hdGgubWluKG1pbk1heFsxXSwgeTAsIHkxKTtcbiAgICBtaW5NYXhbMl0gPSBNYXRoLm1heChtaW5NYXhbMl0sIHgwLCB4MSk7XG4gICAgbWluTWF4WzNdID0gTWF0aC5tYXgobWluTWF4WzNdLCB5MCwgeTEpO1xuICB9XG4gIHN0YXRpYyAjZ2V0RXh0cmVtdW1PbkN1cnZlKHgwLCB4MSwgeDIsIHgzLCB5MCwgeTEsIHkyLCB5MywgdCwgbWluTWF4KSB7XG4gICAgaWYgKHQgPD0gMCB8fCB0ID49IDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbXQgPSAxIC0gdDtcbiAgICBjb25zdCB0dCA9IHQgKiB0O1xuICAgIGNvbnN0IHR0dCA9IHR0ICogdDtcbiAgICBjb25zdCB4ID0gbXQgKiAobXQgKiAobXQgKiB4MCArIDMgKiB0ICogeDEpICsgMyAqIHR0ICogeDIpICsgdHR0ICogeDM7XG4gICAgY29uc3QgeSA9IG10ICogKG10ICogKG10ICogeTAgKyAzICogdCAqIHkxKSArIDMgKiB0dCAqIHkyKSArIHR0dCAqIHkzO1xuICAgIG1pbk1heFswXSA9IE1hdGgubWluKG1pbk1heFswXSwgeCk7XG4gICAgbWluTWF4WzFdID0gTWF0aC5taW4obWluTWF4WzFdLCB5KTtcbiAgICBtaW5NYXhbMl0gPSBNYXRoLm1heChtaW5NYXhbMl0sIHgpO1xuICAgIG1pbk1heFszXSA9IE1hdGgubWF4KG1pbk1heFszXSwgeSk7XG4gIH1cbiAgc3RhdGljICNnZXRFeHRyZW11bSh4MCwgeDEsIHgyLCB4MywgeTAsIHkxLCB5MiwgeTMsIGEsIGIsIGMsIG1pbk1heCkge1xuICAgIGlmIChNYXRoLmFicyhhKSA8IDFlLTEyKSB7XG4gICAgICBpZiAoTWF0aC5hYnMoYikgPj0gMWUtMTIpIHtcbiAgICAgICAgdGhpcy4jZ2V0RXh0cmVtdW1PbkN1cnZlKHgwLCB4MSwgeDIsIHgzLCB5MCwgeTEsIHkyLCB5MywgLWMgLyBiLCBtaW5NYXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkZWx0YSA9IGIgKiogMiAtIDQgKiBjICogYTtcbiAgICBpZiAoZGVsdGEgPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNxcnREZWx0YSA9IE1hdGguc3FydChkZWx0YSk7XG4gICAgY29uc3QgYTIgPSAyICogYTtcbiAgICB0aGlzLiNnZXRFeHRyZW11bU9uQ3VydmUoeDAsIHgxLCB4MiwgeDMsIHkwLCB5MSwgeTIsIHkzLCAoLWIgKyBzcXJ0RGVsdGEpIC8gYTIsIG1pbk1heCk7XG4gICAgdGhpcy4jZ2V0RXh0cmVtdW1PbkN1cnZlKHgwLCB4MSwgeDIsIHgzLCB5MCwgeTEsIHkyLCB5MywgKC1iIC0gc3FydERlbHRhKSAvIGEyLCBtaW5NYXgpO1xuICB9XG4gIHN0YXRpYyBiZXppZXJCb3VuZGluZ0JveCh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIG1pbk1heCkge1xuICAgIG1pbk1heFswXSA9IE1hdGgubWluKG1pbk1heFswXSwgeDAsIHgzKTtcbiAgICBtaW5NYXhbMV0gPSBNYXRoLm1pbihtaW5NYXhbMV0sIHkwLCB5Myk7XG4gICAgbWluTWF4WzJdID0gTWF0aC5tYXgobWluTWF4WzJdLCB4MCwgeDMpO1xuICAgIG1pbk1heFszXSA9IE1hdGgubWF4KG1pbk1heFszXSwgeTAsIHkzKTtcbiAgICB0aGlzLiNnZXRFeHRyZW11bSh4MCwgeDEsIHgyLCB4MywgeTAsIHkxLCB5MiwgeTMsIDMgKiAoLXgwICsgMyAqICh4MSAtIHgyKSArIHgzKSwgNiAqICh4MCAtIDIgKiB4MSArIHgyKSwgMyAqICh4MSAtIHgwKSwgbWluTWF4KTtcbiAgICB0aGlzLiNnZXRFeHRyZW11bSh4MCwgeDEsIHgyLCB4MywgeTAsIHkxLCB5MiwgeTMsIDMgKiAoLXkwICsgMyAqICh5MSAtIHkyKSArIHkzKSwgNiAqICh5MCAtIDIgKiB5MSArIHkyKSwgMyAqICh5MSAtIHkwKSwgbWluTWF4KTtcbiAgfVxufVxuZnVuY3Rpb24gc3RyaW5nVG9VVEY4U3RyaW5nKHN0cikge1xuICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShzdHIpKTtcbn1cbmxldCBOb3JtYWxpemVSZWdleCA9IG51bGw7XG5sZXQgTm9ybWFsaXphdGlvbk1hcCA9IG51bGw7XG5mdW5jdGlvbiBub3JtYWxpemVVbmljb2RlKHN0cikge1xuICBpZiAoIU5vcm1hbGl6ZVJlZ2V4KSB7XG4gICAgTm9ybWFsaXplUmVnZXggPSAvKFtcXHUwMGEwXFx1MDBiNVxcdTAzN2VcXHUwZWIzXFx1MjAwMC1cXHUyMDBhXFx1MjAyZlxcdTIxMjZcXHVmYjAwLVxcdWZiMDRcXHVmYjA2XFx1ZmIyMC1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDAtXFx1ZmI0MVxcdWZiNDMtXFx1ZmI0NFxcdWZiNDYtXFx1ZmJhMVxcdWZiYTQtXFx1ZmJhOVxcdWZiYWUtXFx1ZmJiMVxcdWZiZDMtXFx1ZmJkY1xcdWZiZGUtXFx1ZmJlN1xcdWZiZWEtXFx1ZmJmOFxcdWZiZmMtXFx1ZmJmZFxcdWZjMDAtXFx1ZmM1ZFxcdWZjNjQtXFx1ZmNmMVxcdWZjZjUtXFx1ZmQzZFxcdWZkODhcXHVmZGY0XFx1ZmRmYS1cXHVmZGZiXFx1ZmU3MVxcdWZlNzdcXHVmZTc5XFx1ZmU3YlxcdWZlN2RdKyl8KFxcdWZiMDUrKS9ndTtcbiAgICBOb3JtYWxpemF0aW9uTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1tcIu+shVwiLCBcIsW/dFwiXV0pO1xuICB9XG4gIHJldHVybiBzdHIucmVwbGFjZUFsbChOb3JtYWxpemVSZWdleCwgKF8sIHAxLCBwMikgPT4gcDEgPyBwMS5ub3JtYWxpemUoXCJORktDXCIpIDogTm9ybWFsaXphdGlvbk1hcC5nZXQocDIpKTtcbn1cbmZ1bmN0aW9uIGdldFV1aWQoKSB7XG4gIGlmICh0eXBlb2YgY3J5cHRvLnJhbmRvbVVVSUQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBjcnlwdG8ucmFuZG9tVVVJRCgpO1xuICB9XG4gIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhidWYpO1xuICByZXR1cm4gYnl0ZXNUb1N0cmluZyhidWYpO1xufVxuY29uc3QgQW5ub3RhdGlvblByZWZpeCA9IFwicGRmanNfaW50ZXJuYWxfaWRfXCI7XG5mdW5jdGlvbiBfaXNWYWxpZEV4cGxpY2l0RGVzdCh2YWxpZFJlZiwgdmFsaWROYW1lLCBkZXN0KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShkZXN0KSB8fCBkZXN0Lmxlbmd0aCA8IDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgW3BhZ2UsIHpvb20sIC4uLmFyZ3NdID0gZGVzdDtcbiAgaWYgKCF2YWxpZFJlZihwYWdlKSAmJiAhTnVtYmVyLmlzSW50ZWdlcihwYWdlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIXZhbGlkTmFtZSh6b29tKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBhcmdzTGVuID0gYXJncy5sZW5ndGg7XG4gIGxldCBhbGxvd051bGwgPSB0cnVlO1xuICBzd2l0Y2ggKHpvb20ubmFtZSkge1xuICAgIGNhc2UgXCJYWVpcIjpcbiAgICAgIGlmIChhcmdzTGVuIDwgMiB8fCBhcmdzTGVuID4gMykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiRml0XCI6XG4gICAgY2FzZSBcIkZpdEJcIjpcbiAgICAgIHJldHVybiBhcmdzTGVuID09PSAwO1xuICAgIGNhc2UgXCJGaXRIXCI6XG4gICAgY2FzZSBcIkZpdEJIXCI6XG4gICAgY2FzZSBcIkZpdFZcIjpcbiAgICBjYXNlIFwiRml0QlZcIjpcbiAgICAgIGlmIChhcmdzTGVuID4gMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiRml0UlwiOlxuICAgICAgaWYgKGFyZ3NMZW4gIT09IDQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgYWxsb3dOdWxsID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpIHtcbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gXCJudW1iZXJcIiB8fCBhbGxvd051bGwgJiYgYXJnID09PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gTWF0aENsYW1wKHYsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2LCBtaW4pLCBtYXgpO1xufVxuZnVuY3Rpb24gdG9CYXNlNjRVdGlsKGFycikge1xuICBpZiAoVWludDhBcnJheS5wcm90b3R5cGUudG9CYXNlNjQpIHtcbiAgICByZXR1cm4gYXJyLnRvQmFzZTY0KCk7XG4gIH1cbiAgcmV0dXJuIGJ0b2EoYnl0ZXNUb1N0cmluZyhhcnIpKTtcbn1cbmZ1bmN0aW9uIGZyb21CYXNlNjRVdGlsKHN0cikge1xuICBpZiAoVWludDhBcnJheS5mcm9tQmFzZTY0KSB7XG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbUJhc2U2NChzdHIpO1xuICB9XG4gIHJldHVybiBzdHJpbmdUb0J5dGVzKGF0b2Ioc3RyKSk7XG59XG5pZiAodHlwZW9mIE1hdGguc3VtUHJlY2lzZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gIE1hdGguc3VtUHJlY2lzZSA9IGZ1bmN0aW9uKG51bWJlcnMpIHtcbiAgICByZXR1cm4gbnVtYmVycy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKTtcbiAgfTtcbn1cbmlmICh0eXBlb2YgQWJvcnRTaWduYWwuYW55ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgQWJvcnRTaWduYWwuYW55ID0gZnVuY3Rpb24oaXRlcmFibGUpIHtcbiAgICBjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCB7XG4gICAgICBzaWduYWxcbiAgICB9ID0gYWM7XG4gICAgZm9yIChjb25zdCBzIG9mIGl0ZXJhYmxlKSB7XG4gICAgICBpZiAocy5hYm9ydGVkKSB7XG4gICAgICAgIGFjLmFib3J0KHMucmVhc29uKTtcbiAgICAgICAgcmV0dXJuIHNpZ25hbDtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBzIG9mIGl0ZXJhYmxlKSB7XG4gICAgICBzLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiB7XG4gICAgICAgIGFjLmFib3J0KHMucmVhc29uKTtcbiAgICAgIH0sIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHNpZ25hbDtcbiAgfTtcbn1cbl9fd2VicGFja19yZXF1aXJlX18oMTcwMSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDQ2MDMpO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg3NTY2KTtcbl9fd2VicGFja19yZXF1aXJlX18oODcyMSk7XG5jbGFzcyBYZmFUZXh0IHtcbiAgc3RhdGljIHRleHRDb250ZW50KHhmYSkge1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgY29uc3Qgb3V0cHV0ID0ge1xuICAgICAgaXRlbXMsXG4gICAgICBzdHlsZXM6IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgfTtcbiAgICBmdW5jdGlvbiB3YWxrKG5vZGUpIHtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgc3RyID0gbnVsbDtcbiAgICAgIGNvbnN0IG5hbWUgPSBub2RlLm5hbWU7XG4gICAgICBpZiAobmFtZSA9PT0gXCIjdGV4dFwiKSB7XG4gICAgICAgIHN0ciA9IG5vZGUudmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKCFYZmFUZXh0LnNob3VsZEJ1aWxkVGV4dChuYW1lKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKG5vZGU/LmF0dHJpYnV0ZXM/LnRleHRDb250ZW50KSB7XG4gICAgICAgIHN0ciA9IG5vZGUuYXR0cmlidXRlcy50ZXh0Q29udGVudDtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS52YWx1ZSkge1xuICAgICAgICBzdHIgPSBub2RlLnZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0ciAhPT0gbnVsbCkge1xuICAgICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgICBzdHJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIW5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIHdhbGsoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgICB3YWxrKHhmYSk7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuICBzdGF0aWMgc2hvdWxkQnVpbGRUZXh0KG5hbWUpIHtcbiAgICByZXR1cm4gIShuYW1lID09PSBcInRleHRhcmVhXCIgfHwgbmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwib3B0aW9uXCIgfHwgbmFtZSA9PT0gXCJzZWxlY3RcIik7XG4gIH1cbn1cbmNsYXNzIFhmYUxheWVyIHtcbiAgc3RhdGljIHNldHVwU3RvcmFnZShodG1sLCBpZCwgZWxlbWVudCwgc3RvcmFnZSwgaW50ZW50KSB7XG4gICAgY29uc3Qgc3RvcmVkRGF0YSA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgIHZhbHVlOiBudWxsXG4gICAgfSk7XG4gICAgc3dpdGNoIChlbGVtZW50Lm5hbWUpIHtcbiAgICAgIGNhc2UgXCJ0ZXh0YXJlYVwiOlxuICAgICAgICBpZiAoc3RvcmVkRGF0YS52YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGh0bWwudGV4dENvbnRlbnQgPSBzdG9yZWREYXRhLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlbnQgPT09IFwicHJpbnRcIikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGh0bWwuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIChldmVudCkgPT4ge1xuICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgIHZhbHVlOiBldmVudC50YXJnZXQudmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImlucHV0XCI6XG4gICAgICAgIGlmIChlbGVtZW50LmF0dHJpYnV0ZXMudHlwZSA9PT0gXCJyYWRpb1wiIHx8IGVsZW1lbnQuYXR0cmlidXRlcy50eXBlID09PSBcImNoZWNrYm94XCIpIHtcbiAgICAgICAgICBpZiAoc3RvcmVkRGF0YS52YWx1ZSA9PT0gZWxlbWVudC5hdHRyaWJ1dGVzLnhmYU9uKSB7XG4gICAgICAgICAgICBodG1sLnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIiwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdG9yZWREYXRhLnZhbHVlID09PSBlbGVtZW50LmF0dHJpYnV0ZXMueGZhT2ZmKSB7XG4gICAgICAgICAgICBodG1sLnJlbW92ZUF0dHJpYnV0ZShcImNoZWNrZWRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbnRlbnQgPT09IFwicHJpbnRcIikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGh0bWwuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGV2ZW50LnRhcmdldC5jaGVja2VkID8gZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZShcInhmYU9uXCIpIDogZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZShcInhmYU9mZlwiKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHN0b3JlZERhdGEudmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKFwidmFsdWVcIiwgc3RvcmVkRGF0YS52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbnRlbnQgPT09IFwicHJpbnRcIikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGh0bWwuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzZWxlY3RcIjpcbiAgICAgICAgaWYgKHN0b3JlZERhdGEudmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICBodG1sLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIHN0b3JlZERhdGEudmFsdWUpO1xuICAgICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIGVsZW1lbnQuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChvcHRpb24uYXR0cmlidXRlcy52YWx1ZSA9PT0gc3RvcmVkRGF0YS52YWx1ZSkge1xuICAgICAgICAgICAgICBvcHRpb24uYXR0cmlidXRlcy5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbi5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KFwic2VsZWN0ZWRcIikpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbi5hdHRyaWJ1dGVzLnNlbGVjdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBodG1sLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICBjb25zdCBvcHRpb25zID0gZXZlbnQudGFyZ2V0Lm9wdGlvbnM7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBvcHRpb25zLnNlbGVjdGVkSW5kZXggPT09IC0xID8gXCJcIiA6IG9wdGlvbnNbb3B0aW9ucy5zZWxlY3RlZEluZGV4XS52YWx1ZTtcbiAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBzZXRBdHRyaWJ1dGVzKHtcbiAgICBodG1sLFxuICAgIGVsZW1lbnQsXG4gICAgc3RvcmFnZSA9IG51bGwsXG4gICAgaW50ZW50LFxuICAgIGxpbmtTZXJ2aWNlXG4gIH0pIHtcbiAgICBjb25zdCB7XG4gICAgICBhdHRyaWJ1dGVzXG4gICAgfSA9IGVsZW1lbnQ7XG4gICAgY29uc3QgaXNIVE1MQW5jaG9yRWxlbWVudCA9IGh0bWwgaW5zdGFuY2VvZiBIVE1MQW5jaG9yRWxlbWVudDtcbiAgICBpZiAoYXR0cmlidXRlcy50eXBlID09PSBcInJhZGlvXCIpIHtcbiAgICAgIGF0dHJpYnV0ZXMubmFtZSA9IGAke2F0dHJpYnV0ZXMubmFtZX0tJHtpbnRlbnR9YDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcykpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgY2FzZSBcImNsYXNzXCI6XG4gICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgaHRtbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZS5qb2luKFwiIFwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGF0YUlkXCI6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJpZFwiOlxuICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihodG1sLnN0eWxlLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0ZXh0Q29udGVudFwiOlxuICAgICAgICAgIGh0bWwudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIWlzSFRNTEFuY2hvckVsZW1lbnQgfHwga2V5ICE9PSBcImhyZWZcIiAmJiBrZXkgIT09IFwibmV3V2luZG93XCIpIHtcbiAgICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzSFRNTEFuY2hvckVsZW1lbnQpIHtcbiAgICAgIGxpbmtTZXJ2aWNlLmFkZExpbmtBdHRyaWJ1dGVzKGh0bWwsIGF0dHJpYnV0ZXMuaHJlZiwgYXR0cmlidXRlcy5uZXdXaW5kb3cpO1xuICAgIH1cbiAgICBpZiAoc3RvcmFnZSAmJiBhdHRyaWJ1dGVzLmRhdGFJZCkge1xuICAgICAgdGhpcy5zZXR1cFN0b3JhZ2UoaHRtbCwgYXR0cmlidXRlcy5kYXRhSWQsIGVsZW1lbnQsIHN0b3JhZ2UpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgcmVuZGVyKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBzdG9yYWdlID0gcGFyYW1ldGVycy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBjb25zdCBsaW5rU2VydmljZSA9IHBhcmFtZXRlcnMubGlua1NlcnZpY2U7XG4gICAgY29uc3Qgcm9vdCA9IHBhcmFtZXRlcnMueGZhSHRtbDtcbiAgICBjb25zdCBpbnRlbnQgPSBwYXJhbWV0ZXJzLmludGVudCB8fCBcImRpc3BsYXlcIjtcbiAgICBjb25zdCByb290SHRtbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQocm9vdC5uYW1lKTtcbiAgICBpZiAocm9vdC5hdHRyaWJ1dGVzKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICBodG1sOiByb290SHRtbCxcbiAgICAgICAgZWxlbWVudDogcm9vdCxcbiAgICAgICAgaW50ZW50LFxuICAgICAgICBsaW5rU2VydmljZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGlzTm90Rm9yUmljaFRleHQgPSBpbnRlbnQgIT09IFwicmljaFRleHRcIjtcbiAgICBjb25zdCByb290RGl2ID0gcGFyYW1ldGVycy5kaXY7XG4gICAgcm9vdERpdi5hcHBlbmQocm9vdEh0bWwpO1xuICAgIGlmIChwYXJhbWV0ZXJzLnZpZXdwb3J0KSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBgbWF0cml4KCR7cGFyYW1ldGVycy52aWV3cG9ydC50cmFuc2Zvcm0uam9pbihcIixcIil9KWA7XG4gICAgICByb290RGl2LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICB9XG4gICAgaWYgKGlzTm90Rm9yUmljaFRleHQpIHtcbiAgICAgIHJvb3REaXYuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJ4ZmFMYXllciB4ZmFGb250XCIpO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0RGl2cyA9IFtdO1xuICAgIGlmIChyb290LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKHJvb3QudmFsdWUpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHJvb3QudmFsdWUpO1xuICAgICAgICByb290SHRtbC5hcHBlbmQobm9kZSk7XG4gICAgICAgIGlmIChpc05vdEZvclJpY2hUZXh0ICYmIFhmYVRleHQuc2hvdWxkQnVpbGRUZXh0KHJvb3QubmFtZSkpIHtcbiAgICAgICAgICB0ZXh0RGl2cy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0ZXh0RGl2c1xuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgc3RhY2sgPSBbW3Jvb3QsIC0xLCByb290SHRtbF1dO1xuICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBbcGFyZW50LCBpLCBodG1sXSA9IHN0YWNrLmF0KC0xKTtcbiAgICAgIGlmIChpICsgMSA9PT0gcGFyZW50LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGlsZCA9IHBhcmVudC5jaGlsZHJlblsrK3N0YWNrLmF0KC0xKVsxXV07XG4gICAgICBpZiAoY2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5hbWVcbiAgICAgIH0gPSBjaGlsZDtcbiAgICAgIGlmIChuYW1lID09PSBcIiN0ZXh0XCIpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNoaWxkLnZhbHVlKTtcbiAgICAgICAgdGV4dERpdnMucHVzaChub2RlKTtcbiAgICAgICAgaHRtbC5hcHBlbmQobm9kZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hpbGRIdG1sID0gY2hpbGQ/LmF0dHJpYnV0ZXM/LnhtbG5zID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGNoaWxkLmF0dHJpYnV0ZXMueG1sbnMsIG5hbWUpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKTtcbiAgICAgIGh0bWwuYXBwZW5kKGNoaWxkSHRtbCk7XG4gICAgICBpZiAoY2hpbGQuYXR0cmlidXRlcykge1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgIGh0bWw6IGNoaWxkSHRtbCxcbiAgICAgICAgICBlbGVtZW50OiBjaGlsZCxcbiAgICAgICAgICBzdG9yYWdlLFxuICAgICAgICAgIGludGVudCxcbiAgICAgICAgICBsaW5rU2VydmljZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZC5jaGlsZHJlbj8ubGVuZ3RoID4gMCkge1xuICAgICAgICBzdGFjay5wdXNoKFtjaGlsZCwgLTEsIGNoaWxkSHRtbF0pO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZC52YWx1ZSkge1xuICAgICAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY2hpbGQudmFsdWUpO1xuICAgICAgICBpZiAoaXNOb3RGb3JSaWNoVGV4dCAmJiBYZmFUZXh0LnNob3VsZEJ1aWxkVGV4dChuYW1lKSkge1xuICAgICAgICAgIHRleHREaXZzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRIdG1sLmFwcGVuZChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBlbCBvZiByb290RGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCIueGZhTm9uSW50ZXJhY3RpdmUgaW5wdXQsIC54ZmFOb25JbnRlcmFjdGl2ZSB0ZXh0YXJlYVwiKSkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKFwicmVhZE9ubHlcIiwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0ZXh0RGl2c1xuICAgIH07XG4gIH1cbiAgc3RhdGljIHVwZGF0ZShwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gYG1hdHJpeCgke3BhcmFtZXRlcnMudmlld3BvcnQudHJhbnNmb3JtLmpvaW4oXCIsXCIpfSlgO1xuICAgIHBhcmFtZXRlcnMuZGl2LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICBwYXJhbWV0ZXJzLmRpdi5oaWRkZW4gPSBmYWxzZTtcbiAgfVxufVxuY29uc3QgU1ZHX05TID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xuY2xhc3MgUGl4ZWxzUGVySW5jaCB7XG4gIHN0YXRpYyBDU1MgPSA5NjtcbiAgc3RhdGljIFBERiA9IDcyO1xuICBzdGF0aWMgUERGX1RPX0NTU19VTklUUyA9IHRoaXMuQ1NTIC8gdGhpcy5QREY7XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaERhdGEodXJsLCB0eXBlID0gXCJ0ZXh0XCIpIHtcbiAgaWYgKGlzVmFsaWRGZXRjaFVybCh1cmwsIGRvY3VtZW50LmJhc2VVUkkpKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0KTtcbiAgICB9XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwiYXJyYXlidWZmZXJcIjpcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICBjYXNlIFwiYmxvYlwiOlxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuYmxvYigpO1xuICAgICAgY2FzZSBcImpzb25cIjpcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICByZXF1ZXN0Lm9wZW4oXCJHRVRcIiwgdXJsLCB0cnVlKTtcbiAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IHR5cGU7XG4gICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICBpZiAocmVxdWVzdC5yZWFkeVN0YXRlICE9PSBYTUxIdHRwUmVxdWVzdC5ET05FKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMjAwIHx8IHJlcXVlc3Quc3RhdHVzID09PSAwKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJhcnJheWJ1ZmZlclwiOlxuICAgICAgICAgIGNhc2UgXCJibG9iXCI6XG4gICAgICAgICAgY2FzZSBcImpzb25cIjpcbiAgICAgICAgICAgIHJlc29sdmUocmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShyZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlamVjdChuZXcgRXJyb3IocmVxdWVzdC5zdGF0dXNUZXh0KSk7XG4gICAgfTtcbiAgICByZXF1ZXN0LnNlbmQobnVsbCk7XG4gIH0pO1xufVxuY2xhc3MgUGFnZVZpZXdwb3J0IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHZpZXdCb3gsXG4gICAgdXNlclVuaXQsXG4gICAgc2NhbGUsXG4gICAgcm90YXRpb24sXG4gICAgb2Zmc2V0WCA9IDAsXG4gICAgb2Zmc2V0WSA9IDAsXG4gICAgZG9udEZsaXAgPSBmYWxzZVxuICB9KSB7XG4gICAgdGhpcy52aWV3Qm94ID0gdmlld0JveDtcbiAgICB0aGlzLnVzZXJVbml0ID0gdXNlclVuaXQ7XG4gICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuICAgIHRoaXMucm90YXRpb24gPSByb3RhdGlvbjtcbiAgICB0aGlzLm9mZnNldFggPSBvZmZzZXRYO1xuICAgIHRoaXMub2Zmc2V0WSA9IG9mZnNldFk7XG4gICAgc2NhbGUgKj0gdXNlclVuaXQ7XG4gICAgY29uc3QgY2VudGVyWCA9ICh2aWV3Qm94WzJdICsgdmlld0JveFswXSkgLyAyO1xuICAgIGNvbnN0IGNlbnRlclkgPSAodmlld0JveFszXSArIHZpZXdCb3hbMV0pIC8gMjtcbiAgICBsZXQgcm90YXRlQSwgcm90YXRlQiwgcm90YXRlQywgcm90YXRlRDtcbiAgICByb3RhdGlvbiAlPSAzNjA7XG4gICAgaWYgKHJvdGF0aW9uIDwgMCkge1xuICAgICAgcm90YXRpb24gKz0gMzYwO1xuICAgIH1cbiAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcm90YXRlQSA9IC0xO1xuICAgICAgICByb3RhdGVCID0gMDtcbiAgICAgICAgcm90YXRlQyA9IDA7XG4gICAgICAgIHJvdGF0ZUQgPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJvdGF0ZUEgPSAwO1xuICAgICAgICByb3RhdGVCID0gMTtcbiAgICAgICAgcm90YXRlQyA9IDE7XG4gICAgICAgIHJvdGF0ZUQgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByb3RhdGVBID0gMDtcbiAgICAgICAgcm90YXRlQiA9IC0xO1xuICAgICAgICByb3RhdGVDID0gLTE7XG4gICAgICAgIHJvdGF0ZUQgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcm90YXRlQSA9IDE7XG4gICAgICAgIHJvdGF0ZUIgPSAwO1xuICAgICAgICByb3RhdGVDID0gMDtcbiAgICAgICAgcm90YXRlRCA9IC0xO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhZ2VWaWV3cG9ydDogSW52YWxpZCByb3RhdGlvbiwgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDkwIGRlZ3JlZXMuXCIpO1xuICAgIH1cbiAgICBpZiAoZG9udEZsaXApIHtcbiAgICAgIHJvdGF0ZUMgPSAtcm90YXRlQztcbiAgICAgIHJvdGF0ZUQgPSAtcm90YXRlRDtcbiAgICB9XG4gICAgbGV0IG9mZnNldENhbnZhc1gsIG9mZnNldENhbnZhc1k7XG4gICAgbGV0IHdpZHRoLCBoZWlnaHQ7XG4gICAgaWYgKHJvdGF0ZUEgPT09IDApIHtcbiAgICAgIG9mZnNldENhbnZhc1ggPSBNYXRoLmFicyhjZW50ZXJZIC0gdmlld0JveFsxXSkgKiBzY2FsZSArIG9mZnNldFg7XG4gICAgICBvZmZzZXRDYW52YXNZID0gTWF0aC5hYnMoY2VudGVyWCAtIHZpZXdCb3hbMF0pICogc2NhbGUgKyBvZmZzZXRZO1xuICAgICAgd2lkdGggPSAodmlld0JveFszXSAtIHZpZXdCb3hbMV0pICogc2NhbGU7XG4gICAgICBoZWlnaHQgPSAodmlld0JveFsyXSAtIHZpZXdCb3hbMF0pICogc2NhbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldENhbnZhc1ggPSBNYXRoLmFicyhjZW50ZXJYIC0gdmlld0JveFswXSkgKiBzY2FsZSArIG9mZnNldFg7XG4gICAgICBvZmZzZXRDYW52YXNZID0gTWF0aC5hYnMoY2VudGVyWSAtIHZpZXdCb3hbMV0pICogc2NhbGUgKyBvZmZzZXRZO1xuICAgICAgd2lkdGggPSAodmlld0JveFsyXSAtIHZpZXdCb3hbMF0pICogc2NhbGU7XG4gICAgICBoZWlnaHQgPSAodmlld0JveFszXSAtIHZpZXdCb3hbMV0pICogc2NhbGU7XG4gICAgfVxuICAgIHRoaXMudHJhbnNmb3JtID0gW3JvdGF0ZUEgKiBzY2FsZSwgcm90YXRlQiAqIHNjYWxlLCByb3RhdGVDICogc2NhbGUsIHJvdGF0ZUQgKiBzY2FsZSwgb2Zmc2V0Q2FudmFzWCAtIHJvdGF0ZUEgKiBzY2FsZSAqIGNlbnRlclggLSByb3RhdGVDICogc2NhbGUgKiBjZW50ZXJZLCBvZmZzZXRDYW52YXNZIC0gcm90YXRlQiAqIHNjYWxlICogY2VudGVyWCAtIHJvdGF0ZUQgKiBzY2FsZSAqIGNlbnRlclldO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgfVxuICBnZXQgcmF3RGltcygpIHtcbiAgICBjb25zdCBkaW1zID0gdGhpcy52aWV3Qm94O1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJyYXdEaW1zXCIsIHtcbiAgICAgIHBhZ2VXaWR0aDogZGltc1syXSAtIGRpbXNbMF0sXG4gICAgICBwYWdlSGVpZ2h0OiBkaW1zWzNdIC0gZGltc1sxXSxcbiAgICAgIHBhZ2VYOiBkaW1zWzBdLFxuICAgICAgcGFnZVk6IGRpbXNbMV1cbiAgICB9KTtcbiAgfVxuICBjbG9uZSh7XG4gICAgc2NhbGUgPSB0aGlzLnNjYWxlLFxuICAgIHJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbixcbiAgICBvZmZzZXRYID0gdGhpcy5vZmZzZXRYLFxuICAgIG9mZnNldFkgPSB0aGlzLm9mZnNldFksXG4gICAgZG9udEZsaXAgPSBmYWxzZVxuICB9ID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFBhZ2VWaWV3cG9ydCh7XG4gICAgICB2aWV3Qm94OiB0aGlzLnZpZXdCb3guc2xpY2UoKSxcbiAgICAgIHVzZXJVbml0OiB0aGlzLnVzZXJVbml0LFxuICAgICAgc2NhbGUsXG4gICAgICByb3RhdGlvbixcbiAgICAgIG9mZnNldFgsXG4gICAgICBvZmZzZXRZLFxuICAgICAgZG9udEZsaXBcbiAgICB9KTtcbiAgfVxuICBjb252ZXJ0VG9WaWV3cG9ydFBvaW50KHgsIHkpIHtcbiAgICBjb25zdCBwID0gW3gsIHldO1xuICAgIFV0aWwuYXBwbHlUcmFuc2Zvcm0ocCwgdGhpcy50cmFuc2Zvcm0pO1xuICAgIHJldHVybiBwO1xuICB9XG4gIGNvbnZlcnRUb1ZpZXdwb3J0UmVjdGFuZ2xlKHJlY3QpIHtcbiAgICBjb25zdCB0b3BMZWZ0ID0gW3JlY3RbMF0sIHJlY3RbMV1dO1xuICAgIFV0aWwuYXBwbHlUcmFuc2Zvcm0odG9wTGVmdCwgdGhpcy50cmFuc2Zvcm0pO1xuICAgIGNvbnN0IGJvdHRvbVJpZ2h0ID0gW3JlY3RbMl0sIHJlY3RbM11dO1xuICAgIFV0aWwuYXBwbHlUcmFuc2Zvcm0oYm90dG9tUmlnaHQsIHRoaXMudHJhbnNmb3JtKTtcbiAgICByZXR1cm4gW3RvcExlZnRbMF0sIHRvcExlZnRbMV0sIGJvdHRvbVJpZ2h0WzBdLCBib3R0b21SaWdodFsxXV07XG4gIH1cbiAgY29udmVydFRvUGRmUG9pbnQoeCwgeSkge1xuICAgIGNvbnN0IHAgPSBbeCwgeV07XG4gICAgVXRpbC5hcHBseUludmVyc2VUcmFuc2Zvcm0ocCwgdGhpcy50cmFuc2Zvcm0pO1xuICAgIHJldHVybiBwO1xuICB9XG59XG5jbGFzcyBSZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24gZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnLCBleHRyYURlbGF5ID0gMCkge1xuICAgIHN1cGVyKG1zZywgXCJSZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb25cIik7XG4gICAgdGhpcy5leHRyYURlbGF5ID0gZXh0cmFEZWxheTtcbiAgfVxufVxuZnVuY3Rpb24gaXNEYXRhU2NoZW1lKHVybCkge1xuICBjb25zdCBpaSA9IHVybC5sZW5ndGg7XG4gIGxldCBpID0gMDtcbiAgd2hpbGUgKGkgPCBpaSAmJiB1cmxbaV0udHJpbSgpID09PSBcIlwiKSB7XG4gICAgaSsrO1xuICB9XG4gIHJldHVybiB1cmwuc3Vic3RyaW5nKGksIGkgKyA1KS50b0xvd2VyQ2FzZSgpID09PSBcImRhdGE6XCI7XG59XG5mdW5jdGlvbiBpc1BkZkZpbGUoZmlsZW5hbWUpIHtcbiAgcmV0dXJuIHR5cGVvZiBmaWxlbmFtZSA9PT0gXCJzdHJpbmdcIiAmJiAvXFwucGRmJC9pLnRlc3QoZmlsZW5hbWUpO1xufVxuZnVuY3Rpb24gZ2V0RmlsZW5hbWVGcm9tVXJsKHVybCkge1xuICBbdXJsXSA9IHVybC5zcGxpdCgvWyM/XS8sIDEpO1xuICByZXR1cm4gdXJsLnN1YnN0cmluZyh1cmwubGFzdEluZGV4T2YoXCIvXCIpICsgMSk7XG59XG5mdW5jdGlvbiBnZXRQZGZGaWxlbmFtZUZyb21VcmwodXJsLCBkZWZhdWx0RmlsZW5hbWUgPSBcImRvY3VtZW50LnBkZlwiKSB7XG4gIGlmICh0eXBlb2YgdXJsICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRGaWxlbmFtZTtcbiAgfVxuICBpZiAoaXNEYXRhU2NoZW1lKHVybCkpIHtcbiAgICB3YXJuKCdnZXRQZGZGaWxlbmFtZUZyb21Vcmw6IGlnbm9yZSBcImRhdGE6XCItVVJMIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLicpO1xuICAgIHJldHVybiBkZWZhdWx0RmlsZW5hbWU7XG4gIH1cbiAgY29uc3QgZ2V0VVJMID0gKHVybFN0cmluZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IFVSTCh1cmxTdHJpbmcpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBVUkwoZGVjb2RlVVJJQ29tcG9uZW50KHVybFN0cmluZykpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBVUkwodXJsU3RyaW5nLCBcImh0dHBzOi8vZm9vLmJhclwiKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVVJMKGRlY29kZVVSSUNvbXBvbmVudCh1cmxTdHJpbmcpLCBcImh0dHBzOi8vZm9vLmJhclwiKTtcbiAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgbmV3VVJMID0gZ2V0VVJMKHVybCk7XG4gIGlmICghbmV3VVJMKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRGaWxlbmFtZTtcbiAgfVxuICBjb25zdCBkZWNvZGUgPSAobmFtZSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBsZXQgZGVjb2RlZCA9IGRlY29kZVVSSUNvbXBvbmVudChuYW1lKTtcbiAgICAgIGlmIChkZWNvZGVkLmluY2x1ZGVzKFwiL1wiKSkge1xuICAgICAgICBkZWNvZGVkID0gZGVjb2RlZC5zcGxpdChcIi9cIikuYXQoLTEpO1xuICAgICAgICBpZiAoZGVjb2RlZC50ZXN0KC9eXFwucGRmJC9pKSkge1xuICAgICAgICAgIHJldHVybiBkZWNvZGVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlY29kZWQ7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHBkZlJlZ2V4ID0gL1xcLnBkZiQvaTtcbiAgY29uc3QgZmlsZW5hbWUgPSBuZXdVUkwucGF0aG5hbWUuc3BsaXQoXCIvXCIpLmF0KC0xKTtcbiAgaWYgKHBkZlJlZ2V4LnRlc3QoZmlsZW5hbWUpKSB7XG4gICAgcmV0dXJuIGRlY29kZShmaWxlbmFtZSk7XG4gIH1cbiAgaWYgKG5ld1VSTC5zZWFyY2hQYXJhbXMuc2l6ZSA+IDApIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBBcnJheS5mcm9tKG5ld1VSTC5zZWFyY2hQYXJhbXMudmFsdWVzKCkpLnJldmVyc2UoKTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKHBkZlJlZ2V4LnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGUodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBrZXlzID0gQXJyYXkuZnJvbShuZXdVUkwuc2VhcmNoUGFyYW1zLmtleXMoKSkucmV2ZXJzZSgpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIGlmIChwZGZSZWdleC50ZXN0KGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAobmV3VVJMLmhhc2gpIHtcbiAgICBjb25zdCByZUZpbGVuYW1lID0gL1teLz8jPV0rXFwucGRmXFxiKD8hLipcXC5wZGZcXGIpL2k7XG4gICAgY29uc3QgaGFzaEZpbGVuYW1lID0gcmVGaWxlbmFtZS5leGVjKG5ld1VSTC5oYXNoKTtcbiAgICBpZiAoaGFzaEZpbGVuYW1lKSB7XG4gICAgICByZXR1cm4gZGVjb2RlKGhhc2hGaWxlbmFtZVswXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWZhdWx0RmlsZW5hbWU7XG59XG5jbGFzcyBTdGF0VGltZXIge1xuICBzdGFydGVkID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRpbWVzID0gW107XG4gIHRpbWUobmFtZSkge1xuICAgIGlmIChuYW1lIGluIHRoaXMuc3RhcnRlZCkge1xuICAgICAgd2FybihgVGltZXIgaXMgYWxyZWFkeSBydW5uaW5nIGZvciAke25hbWV9YCk7XG4gICAgfVxuICAgIHRoaXMuc3RhcnRlZFtuYW1lXSA9IERhdGUubm93KCk7XG4gIH1cbiAgdGltZUVuZChuYW1lKSB7XG4gICAgaWYgKCEobmFtZSBpbiB0aGlzLnN0YXJ0ZWQpKSB7XG4gICAgICB3YXJuKGBUaW1lciBoYXMgbm90IGJlZW4gc3RhcnRlZCBmb3IgJHtuYW1lfWApO1xuICAgIH1cbiAgICB0aGlzLnRpbWVzLnB1c2goe1xuICAgICAgbmFtZSxcbiAgICAgIHN0YXJ0OiB0aGlzLnN0YXJ0ZWRbbmFtZV0sXG4gICAgICBlbmQ6IERhdGUubm93KClcbiAgICB9KTtcbiAgICBkZWxldGUgdGhpcy5zdGFydGVkW25hbWVdO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IG91dEJ1ZiA9IFtdO1xuICAgIGxldCBsb25nZXN0ID0gMDtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIG5hbWVcbiAgICB9IG9mIHRoaXMudGltZXMpIHtcbiAgICAgIGxvbmdlc3QgPSBNYXRoLm1heChuYW1lLmxlbmd0aCwgbG9uZ2VzdCk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kXG4gICAgfSBvZiB0aGlzLnRpbWVzKSB7XG4gICAgICBvdXRCdWYucHVzaChgJHtuYW1lLnBhZEVuZChsb25nZXN0KX0gJHtlbmQgLSBzdGFydH1tc1xuYCk7XG4gICAgfVxuICAgIHJldHVybiBvdXRCdWYuam9pbihcIlwiKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNWYWxpZEZldGNoVXJsKHVybCwgYmFzZVVybCkge1xuICBjb25zdCByZXMgPSBiYXNlVXJsID8gVVJMLnBhcnNlKHVybCwgYmFzZVVybCkgOiBVUkwucGFyc2UodXJsKTtcbiAgcmV0dXJuIHJlcz8ucHJvdG9jb2wgPT09IFwiaHR0cDpcIiB8fCByZXM/LnByb3RvY29sID09PSBcImh0dHBzOlwiO1xufVxuZnVuY3Rpb24gbm9Db250ZXh0TWVudShlKSB7XG4gIGUucHJldmVudERlZmF1bHQoKTtcbn1cbmZ1bmN0aW9uIHN0b3BFdmVudChlKSB7XG4gIGUucHJldmVudERlZmF1bHQoKTtcbiAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbn1cbmZ1bmN0aW9uIGRlcHJlY2F0ZWQoZGV0YWlscykge1xuICBjb25zb2xlLmxvZyhcIkRlcHJlY2F0ZWQgQVBJIHVzYWdlOiBcIiArIGRldGFpbHMpO1xufVxuY2xhc3MgUERGRGF0ZVN0cmluZyB7XG4gIHN0YXRpYyAjcmVnZXg7XG4gIHN0YXRpYyB0b0RhdGVPYmplY3QoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICAgIGlmICghaW5wdXQgfHwgdHlwZW9mIGlucHV0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdGhpcy4jcmVnZXggfHw9IG5ldyBSZWdFeHAoXCJeRDooXFxcXGR7NH0pKFxcXFxkezJ9KT8oXFxcXGR7Mn0pPyhcXFxcZHsyfSk/KFxcXFxkezJ9KT8oXFxcXGR7Mn0pPyhbWnwrfC1dKT8oXFxcXGR7Mn0pPyc/KFxcXFxkezJ9KT8nP1wiKTtcbiAgICBjb25zdCBtYXRjaGVzID0gdGhpcy4jcmVnZXguZXhlYyhpbnB1dCk7XG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgeWVhciA9IHBhcnNlSW50KG1hdGNoZXNbMV0sIDEwKTtcbiAgICBsZXQgbW9udGggPSBwYXJzZUludChtYXRjaGVzWzJdLCAxMCk7XG4gICAgbW9udGggPSBtb250aCA+PSAxICYmIG1vbnRoIDw9IDEyID8gbW9udGggLSAxIDogMDtcbiAgICBsZXQgZGF5ID0gcGFyc2VJbnQobWF0Y2hlc1szXSwgMTApO1xuICAgIGRheSA9IGRheSA+PSAxICYmIGRheSA8PSAzMSA/IGRheSA6IDE7XG4gICAgbGV0IGhvdXIgPSBwYXJzZUludChtYXRjaGVzWzRdLCAxMCk7XG4gICAgaG91ciA9IGhvdXIgPj0gMCAmJiBob3VyIDw9IDIzID8gaG91ciA6IDA7XG4gICAgbGV0IG1pbnV0ZSA9IHBhcnNlSW50KG1hdGNoZXNbNV0sIDEwKTtcbiAgICBtaW51dGUgPSBtaW51dGUgPj0gMCAmJiBtaW51dGUgPD0gNTkgPyBtaW51dGUgOiAwO1xuICAgIGxldCBzZWNvbmQgPSBwYXJzZUludChtYXRjaGVzWzZdLCAxMCk7XG4gICAgc2Vjb25kID0gc2Vjb25kID49IDAgJiYgc2Vjb25kIDw9IDU5ID8gc2Vjb25kIDogMDtcbiAgICBjb25zdCB1bml2ZXJzYWxUaW1lUmVsYXRpb24gPSBtYXRjaGVzWzddIHx8IFwiWlwiO1xuICAgIGxldCBvZmZzZXRIb3VyID0gcGFyc2VJbnQobWF0Y2hlc1s4XSwgMTApO1xuICAgIG9mZnNldEhvdXIgPSBvZmZzZXRIb3VyID49IDAgJiYgb2Zmc2V0SG91ciA8PSAyMyA/IG9mZnNldEhvdXIgOiAwO1xuICAgIGxldCBvZmZzZXRNaW51dGUgPSBwYXJzZUludChtYXRjaGVzWzldLCAxMCkgfHwgMDtcbiAgICBvZmZzZXRNaW51dGUgPSBvZmZzZXRNaW51dGUgPj0gMCAmJiBvZmZzZXRNaW51dGUgPD0gNTkgPyBvZmZzZXRNaW51dGUgOiAwO1xuICAgIGlmICh1bml2ZXJzYWxUaW1lUmVsYXRpb24gPT09IFwiLVwiKSB7XG4gICAgICBob3VyICs9IG9mZnNldEhvdXI7XG4gICAgICBtaW51dGUgKz0gb2Zmc2V0TWludXRlO1xuICAgIH0gZWxzZSBpZiAodW5pdmVyc2FsVGltZVJlbGF0aW9uID09PSBcIitcIikge1xuICAgICAgaG91ciAtPSBvZmZzZXRIb3VyO1xuICAgICAgbWludXRlIC09IG9mZnNldE1pbnV0ZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFhmYVBhZ2VWaWV3cG9ydCh4ZmFQYWdlLCB7XG4gIHNjYWxlID0gMSxcbiAgcm90YXRpb24gPSAwXG59KSB7XG4gIGNvbnN0IHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSA9IHhmYVBhZ2UuYXR0cmlidXRlcy5zdHlsZTtcbiAgY29uc3Qgdmlld0JveCA9IFswLCAwLCBwYXJzZUludCh3aWR0aCksIHBhcnNlSW50KGhlaWdodCldO1xuICByZXR1cm4gbmV3IFBhZ2VWaWV3cG9ydCh7XG4gICAgdmlld0JveCxcbiAgICB1c2VyVW5pdDogMSxcbiAgICBzY2FsZSxcbiAgICByb3RhdGlvblxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFJHQihjb2xvcikge1xuICBpZiAoY29sb3Iuc3RhcnRzV2l0aChcIiNcIikpIHtcbiAgICBjb25zdCBjb2xvclJHQiA9IHBhcnNlSW50KGNvbG9yLnNsaWNlKDEpLCAxNik7XG4gICAgcmV0dXJuIFsoY29sb3JSR0IgJiAxNjcxMTY4MCkgPj4gMTYsIChjb2xvclJHQiAmIDY1MjgwKSA+PiA4LCBjb2xvclJHQiAmIDI1NV07XG4gIH1cbiAgaWYgKGNvbG9yLnN0YXJ0c1dpdGgoXCJyZ2IoXCIpKSB7XG4gICAgcmV0dXJuIGNvbG9yLnNsaWNlKDQsIC0xKS5zcGxpdChcIixcIikubWFwKCh4KSA9PiBwYXJzZUludCh4KSk7XG4gIH1cbiAgaWYgKGNvbG9yLnN0YXJ0c1dpdGgoXCJyZ2JhKFwiKSkge1xuICAgIHJldHVybiBjb2xvci5zbGljZSg1LCAtMSkuc3BsaXQoXCIsXCIpLm1hcCgoeCkgPT4gcGFyc2VJbnQoeCkpLnNsaWNlKDAsIDMpO1xuICB9XG4gIHdhcm4oYE5vdCBhIHZhbGlkIGNvbG9yIGZvcm1hdDogXCIke2NvbG9yfVwiYCk7XG4gIHJldHVybiBbMCwgMCwgMF07XG59XG5mdW5jdGlvbiBnZXRDb2xvclZhbHVlcyhjb2xvcnMpIHtcbiAgY29uc3Qgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICBzcGFuLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICBzcGFuLnN0eWxlLmNvbG9yU2NoZW1lID0gXCJvbmx5IGxpZ2h0XCI7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kKHNwYW4pO1xuICBmb3IgKGNvbnN0IG5hbWUgb2YgY29sb3JzLmtleXMoKSkge1xuICAgIHNwYW4uc3R5bGUuY29sb3IgPSBuYW1lO1xuICAgIGNvbnN0IGNvbXB1dGVkQ29sb3IgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzcGFuKS5jb2xvcjtcbiAgICBjb2xvcnMuc2V0KG5hbWUsIGdldFJHQihjb21wdXRlZENvbG9yKSk7XG4gIH1cbiAgc3Bhbi5yZW1vdmUoKTtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KSB7XG4gIGNvbnN0IHtcbiAgICBhLFxuICAgIGIsXG4gICAgYyxcbiAgICBkLFxuICAgIGUsXG4gICAgZlxuICB9ID0gY3R4LmdldFRyYW5zZm9ybSgpO1xuICByZXR1cm4gW2EsIGIsIGMsIGQsIGUsIGZdO1xufVxuZnVuY3Rpb24gZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoY3R4KSB7XG4gIGNvbnN0IHtcbiAgICBhLFxuICAgIGIsXG4gICAgYyxcbiAgICBkLFxuICAgIGUsXG4gICAgZlxuICB9ID0gY3R4LmdldFRyYW5zZm9ybSgpLmludmVydFNlbGYoKTtcbiAgcmV0dXJuIFthLCBiLCBjLCBkLCBlLCBmXTtcbn1cbmZ1bmN0aW9uIHNldExheWVyRGltZW5zaW9ucyhkaXYsIHZpZXdwb3J0LCBtdXN0RmxpcCA9IGZhbHNlLCBtdXN0Um90YXRlID0gdHJ1ZSkge1xuICBpZiAodmlld3BvcnQgaW5zdGFuY2VvZiBQYWdlVmlld3BvcnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYWdlV2lkdGgsXG4gICAgICBwYWdlSGVpZ2h0XG4gICAgfSA9IHZpZXdwb3J0LnJhd0RpbXM7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gZGl2O1xuICAgIGNvbnN0IHVzZVJvdW5kID0gdXRpbF9GZWF0dXJlVGVzdC5pc0NTU1JvdW5kU3VwcG9ydGVkO1xuICAgIGNvbnN0IHcgPSBgdmFyKC0tdG90YWwtc2NhbGUtZmFjdG9yKSAqICR7cGFnZVdpZHRofXB4YCwgaCA9IGB2YXIoLS10b3RhbC1zY2FsZS1mYWN0b3IpICogJHtwYWdlSGVpZ2h0fXB4YDtcbiAgICBjb25zdCB3aWR0aFN0ciA9IHVzZVJvdW5kID8gYHJvdW5kKGRvd24sICR7d30sIHZhcigtLXNjYWxlLXJvdW5kLXgpKWAgOiBgY2FsYygke3d9KWAsIGhlaWdodFN0ciA9IHVzZVJvdW5kID8gYHJvdW5kKGRvd24sICR7aH0sIHZhcigtLXNjYWxlLXJvdW5kLXkpKWAgOiBgY2FsYygke2h9KWA7XG4gICAgaWYgKCFtdXN0RmxpcCB8fCB2aWV3cG9ydC5yb3RhdGlvbiAlIDE4MCA9PT0gMCkge1xuICAgICAgc3R5bGUud2lkdGggPSB3aWR0aFN0cjtcbiAgICAgIHN0eWxlLmhlaWdodCA9IGhlaWdodFN0cjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUud2lkdGggPSBoZWlnaHRTdHI7XG4gICAgICBzdHlsZS5oZWlnaHQgPSB3aWR0aFN0cjtcbiAgICB9XG4gIH1cbiAgaWYgKG11c3RSb3RhdGUpIHtcbiAgICBkaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1tYWluLXJvdGF0aW9uXCIsIHZpZXdwb3J0LnJvdGF0aW9uKTtcbiAgfVxufVxuY2xhc3MgT3V0cHV0U2NhbGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBwaXhlbFJhdGlvXG4gICAgfSA9IE91dHB1dFNjYWxlO1xuICAgIHRoaXMuc3ggPSBwaXhlbFJhdGlvO1xuICAgIHRoaXMuc3kgPSBwaXhlbFJhdGlvO1xuICB9XG4gIGdldCBzY2FsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3ggIT09IDEgfHwgdGhpcy5zeSAhPT0gMTtcbiAgfVxuICBnZXQgc3ltbWV0cmljKCkge1xuICAgIHJldHVybiB0aGlzLnN4ID09PSB0aGlzLnN5O1xuICB9XG4gIGxpbWl0Q2FudmFzKHdpZHRoLCBoZWlnaHQsIG1heFBpeGVscywgbWF4RGltLCBjYXBBcmVhRmFjdG9yID0gLTEpIHtcbiAgICBsZXQgbWF4QXJlYVNjYWxlID0gSW5maW5pdHksIG1heFdpZHRoU2NhbGUgPSBJbmZpbml0eSwgbWF4SGVpZ2h0U2NhbGUgPSBJbmZpbml0eTtcbiAgICBtYXhQaXhlbHMgPSBPdXRwdXRTY2FsZS5jYXBQaXhlbHMobWF4UGl4ZWxzLCBjYXBBcmVhRmFjdG9yKTtcbiAgICBpZiAobWF4UGl4ZWxzID4gMCkge1xuICAgICAgbWF4QXJlYVNjYWxlID0gTWF0aC5zcXJ0KG1heFBpeGVscyAvICh3aWR0aCAqIGhlaWdodCkpO1xuICAgIH1cbiAgICBpZiAobWF4RGltICE9PSAtMSkge1xuICAgICAgbWF4V2lkdGhTY2FsZSA9IG1heERpbSAvIHdpZHRoO1xuICAgICAgbWF4SGVpZ2h0U2NhbGUgPSBtYXhEaW0gLyBoZWlnaHQ7XG4gICAgfVxuICAgIGNvbnN0IG1heFNjYWxlID0gTWF0aC5taW4obWF4QXJlYVNjYWxlLCBtYXhXaWR0aFNjYWxlLCBtYXhIZWlnaHRTY2FsZSk7XG4gICAgaWYgKHRoaXMuc3ggPiBtYXhTY2FsZSB8fCB0aGlzLnN5ID4gbWF4U2NhbGUpIHtcbiAgICAgIHRoaXMuc3ggPSBtYXhTY2FsZTtcbiAgICAgIHRoaXMuc3kgPSBtYXhTY2FsZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhdGljIGdldCBwaXhlbFJhdGlvKCkge1xuICAgIHJldHVybiBnbG9iYWxUaGlzLmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgfVxuICBzdGF0aWMgY2FwUGl4ZWxzKG1heFBpeGVscywgY2FwQXJlYUZhY3Rvcikge1xuICAgIGlmIChjYXBBcmVhRmFjdG9yID49IDApIHtcbiAgICAgIGNvbnN0IHdpblBpeGVscyA9IE1hdGguY2VpbCh3aW5kb3cuc2NyZWVuLmF2YWlsV2lkdGggKiB3aW5kb3cuc2NyZWVuLmF2YWlsSGVpZ2h0ICogdGhpcy5waXhlbFJhdGlvICoqIDIgKiAoMSArIGNhcEFyZWFGYWN0b3IgLyAxMDApKTtcbiAgICAgIHJldHVybiBtYXhQaXhlbHMgPiAwID8gTWF0aC5taW4obWF4UGl4ZWxzLCB3aW5QaXhlbHMpIDogd2luUGl4ZWxzO1xuICAgIH1cbiAgICByZXR1cm4gbWF4UGl4ZWxzO1xuICB9XG59XG5jb25zdCBTdXBwb3J0ZWRJbWFnZU1pbWVUeXBlcyA9IFtcImltYWdlL2FwbmdcIiwgXCJpbWFnZS9hdmlmXCIsIFwiaW1hZ2UvYm1wXCIsIFwiaW1hZ2UvZ2lmXCIsIFwiaW1hZ2UvanBlZ1wiLCBcImltYWdlL3BuZ1wiLCBcImltYWdlL3N2Zyt4bWxcIiwgXCJpbWFnZS93ZWJwXCIsIFwiaW1hZ2UveC1pY29uXCJdO1xuY2xhc3MgQ29sb3JTY2hlbWUge1xuICBzdGF0aWMgZ2V0IGlzRGFya01vZGUoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzRGFya01vZGVcIiwgISF3aW5kb3c/Lm1hdGNoTWVkaWE/LihcIihwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyaylcIikubWF0Y2hlcyk7XG4gIH1cbn1cbmNsYXNzIENTU0NvbnN0YW50cyB7XG4gIHN0YXRpYyBnZXQgY29tbWVudEZvcmVncm91bmRDb2xvcigpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiY29tbWVudFwiLCBcInNpZGViYXJcIik7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gZWxlbWVudDtcbiAgICBzdHlsZS53aWR0aCA9IHN0eWxlLmhlaWdodCA9IFwiMFwiO1xuICAgIHN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICBzdHlsZS5jb2xvciA9IFwidmFyKC0tY29tbWVudC1mZy1jb2xvcilcIjtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZChlbGVtZW50KTtcbiAgICBjb25zdCB7XG4gICAgICBjb2xvclxuICAgIH0gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgICBlbGVtZW50LnJlbW92ZSgpO1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJjb21tZW50Rm9yZWdyb3VuZENvbG9yXCIsIGdldFJHQihjb2xvcikpO1xuICB9XG59XG5mdW5jdGlvbiBhcHBseU9wYWNpdHkociwgZywgYiwgb3BhY2l0eSkge1xuICBvcGFjaXR5ID0gTWF0aC5taW4oTWF0aC5tYXgob3BhY2l0eSA/PyAxLCAwKSwgMSk7XG4gIGNvbnN0IHdoaXRlID0gMjU1ICogKDEgLSBvcGFjaXR5KTtcbiAgciA9IE1hdGgucm91bmQociAqIG9wYWNpdHkgKyB3aGl0ZSk7XG4gIGcgPSBNYXRoLnJvdW5kKGcgKiBvcGFjaXR5ICsgd2hpdGUpO1xuICBiID0gTWF0aC5yb3VuZChiICogb3BhY2l0eSArIHdoaXRlKTtcbiAgcmV0dXJuIFtyLCBnLCBiXTtcbn1cbmZ1bmN0aW9uIFJHQlRvSFNMKHJnYiwgb3V0cHV0KSB7XG4gIGNvbnN0IHIgPSByZ2JbMF0gLyAyNTU7XG4gIGNvbnN0IGcgPSByZ2JbMV0gLyAyNTU7XG4gIGNvbnN0IGIgPSByZ2JbMl0gLyAyNTU7XG4gIGNvbnN0IG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICBjb25zdCBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgY29uc3QgbCA9IChtYXggKyBtaW4pIC8gMjtcbiAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgb3V0cHV0WzBdID0gb3V0cHV0WzFdID0gMDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBkID0gbWF4IC0gbWluO1xuICAgIG91dHB1dFsxXSA9IGwgPCAwLjUgPyBkIC8gKG1heCArIG1pbikgOiBkIC8gKDIgLSBtYXggLSBtaW4pO1xuICAgIHN3aXRjaCAobWF4KSB7XG4gICAgICBjYXNlIHI6XG4gICAgICAgIG91dHB1dFswXSA9ICgoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKSkgKiA2MDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGc6XG4gICAgICAgIG91dHB1dFswXSA9ICgoYiAtIHIpIC8gZCArIDIpICogNjA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBiOlxuICAgICAgICBvdXRwdXRbMF0gPSAoKHIgLSBnKSAvIGQgKyA0KSAqIDYwO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgb3V0cHV0WzJdID0gbDtcbn1cbmZ1bmN0aW9uIEhTTFRvUkdCKGhzbCwgb3V0cHV0KSB7XG4gIGNvbnN0IGggPSBoc2xbMF07XG4gIGNvbnN0IHMgPSBoc2xbMV07XG4gIGNvbnN0IGwgPSBoc2xbMl07XG4gIGNvbnN0IGMgPSAoMSAtIE1hdGguYWJzKDIgKiBsIC0gMSkpICogcztcbiAgY29uc3QgeCA9IGMgKiAoMSAtIE1hdGguYWJzKGggLyA2MCAlIDIgLSAxKSk7XG4gIGNvbnN0IG0gPSBsIC0gYyAvIDI7XG4gIHN3aXRjaCAoTWF0aC5mbG9vcihoIC8gNjApKSB7XG4gICAgY2FzZSAwOlxuICAgICAgb3V0cHV0WzBdID0gYyArIG07XG4gICAgICBvdXRwdXRbMV0gPSB4ICsgbTtcbiAgICAgIG91dHB1dFsyXSA9IG07XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBvdXRwdXRbMF0gPSB4ICsgbTtcbiAgICAgIG91dHB1dFsxXSA9IGMgKyBtO1xuICAgICAgb3V0cHV0WzJdID0gbTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjpcbiAgICAgIG91dHB1dFswXSA9IG07XG4gICAgICBvdXRwdXRbMV0gPSBjICsgbTtcbiAgICAgIG91dHB1dFsyXSA9IHggKyBtO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgICAgb3V0cHV0WzBdID0gbTtcbiAgICAgIG91dHB1dFsxXSA9IHggKyBtO1xuICAgICAgb3V0cHV0WzJdID0gYyArIG07XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQ6XG4gICAgICBvdXRwdXRbMF0gPSB4ICsgbTtcbiAgICAgIG91dHB1dFsxXSA9IG07XG4gICAgICBvdXRwdXRbMl0gPSBjICsgbTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNTpcbiAgICBjYXNlIDY6XG4gICAgICBvdXRwdXRbMF0gPSBjICsgbTtcbiAgICAgIG91dHB1dFsxXSA9IG07XG4gICAgICBvdXRwdXRbMl0gPSB4ICsgbTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5mdW5jdGlvbiBjb21wdXRlTHVtaW5hbmNlKHgpIHtcbiAgcmV0dXJuIHggPD0gMC4wMzkyOCA/IHggLyAxMi45MiA6ICgoeCArIDAuMDU1KSAvIDEuMDU1KSAqKiAyLjQ7XG59XG5mdW5jdGlvbiBjb250cmFzdFJhdGlvKGhzbDEsIGhzbDIsIG91dHB1dCkge1xuICBIU0xUb1JHQihoc2wxLCBvdXRwdXQpO1xuICBvdXRwdXQubWFwKGNvbXB1dGVMdW1pbmFuY2UpO1xuICBjb25zdCBsdW0xID0gMC4yMTI2ICogb3V0cHV0WzBdICsgMC43MTUyICogb3V0cHV0WzFdICsgMC4wNzIyICogb3V0cHV0WzJdO1xuICBIU0xUb1JHQihoc2wyLCBvdXRwdXQpO1xuICBvdXRwdXQubWFwKGNvbXB1dGVMdW1pbmFuY2UpO1xuICBjb25zdCBsdW0yID0gMC4yMTI2ICogb3V0cHV0WzBdICsgMC43MTUyICogb3V0cHV0WzFdICsgMC4wNzIyICogb3V0cHV0WzJdO1xuICByZXR1cm4gbHVtMSA+IGx1bTIgPyAobHVtMSArIDAuMDUpIC8gKGx1bTIgKyAwLjA1KSA6IChsdW0yICsgMC4wNSkgLyAobHVtMSArIDAuMDUpO1xufVxuY29uc3QgY29udHJhc3RDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5mdW5jdGlvbiBmaW5kQ29udHJhc3RDb2xvcihiYXNlQ29sb3IsIGZpeGVkQ29sb3IpIHtcbiAgY29uc3Qga2V5ID0gYmFzZUNvbG9yWzBdICsgYmFzZUNvbG9yWzFdICogMjU2ICsgYmFzZUNvbG9yWzJdICogNjU1MzYgKyBmaXhlZENvbG9yWzBdICogMTY3NzcyMTYgKyBmaXhlZENvbG9yWzFdICogNDI5NDk2NzI5NiArIGZpeGVkQ29sb3JbMl0gKiAxMDk5NTExNjI3Nzc2O1xuICBsZXQgY2FjaGVkVmFsdWUgPSBjb250cmFzdENhY2hlLmdldChrZXkpO1xuICBpZiAoY2FjaGVkVmFsdWUpIHtcbiAgICByZXR1cm4gY2FjaGVkVmFsdWU7XG4gIH1cbiAgY29uc3QgYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDkpO1xuICBjb25zdCBvdXRwdXQgPSBhcnJheS5zdWJhcnJheSgwLCAzKTtcbiAgY29uc3QgYmFzZUhTTCA9IGFycmF5LnN1YmFycmF5KDMsIDYpO1xuICBSR0JUb0hTTChiYXNlQ29sb3IsIGJhc2VIU0wpO1xuICBjb25zdCBmaXhlZEhTTCA9IGFycmF5LnN1YmFycmF5KDYsIDkpO1xuICBSR0JUb0hTTChmaXhlZENvbG9yLCBmaXhlZEhTTCk7XG4gIGNvbnN0IGlzRml4ZWRDb2xvckRhcmsgPSBmaXhlZEhTTFsyXSA8IDAuNTtcbiAgY29uc3QgbWluQ29udHJhc3QgPSBpc0ZpeGVkQ29sb3JEYXJrID8gMTIgOiA0LjU7XG4gIGJhc2VIU0xbMl0gPSBpc0ZpeGVkQ29sb3JEYXJrID8gTWF0aC5zcXJ0KGJhc2VIU0xbMl0pIDogMSAtIE1hdGguc3FydCgxIC0gYmFzZUhTTFsyXSk7XG4gIGlmIChjb250cmFzdFJhdGlvKGJhc2VIU0wsIGZpeGVkSFNMLCBvdXRwdXQpIDwgbWluQ29udHJhc3QpIHtcbiAgICBsZXQgc3RhcnQsIGVuZDtcbiAgICBpZiAoaXNGaXhlZENvbG9yRGFyaykge1xuICAgICAgc3RhcnQgPSBiYXNlSFNMWzJdO1xuICAgICAgZW5kID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnQgPSAwO1xuICAgICAgZW5kID0gYmFzZUhTTFsyXTtcbiAgICB9XG4gICAgY29uc3QgUFJFQ0lTSU9OID0gNWUtMztcbiAgICB3aGlsZSAoZW5kIC0gc3RhcnQgPiBQUkVDSVNJT04pIHtcbiAgICAgIGNvbnN0IG1pZCA9IGJhc2VIU0xbMl0gPSAoc3RhcnQgKyBlbmQpIC8gMjtcbiAgICAgIGlmIChpc0ZpeGVkQ29sb3JEYXJrID09PSBjb250cmFzdFJhdGlvKGJhc2VIU0wsIGZpeGVkSFNMLCBvdXRwdXQpIDwgbWluQ29udHJhc3QpIHtcbiAgICAgICAgc3RhcnQgPSBtaWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmQgPSBtaWQ7XG4gICAgICB9XG4gICAgfVxuICAgIGJhc2VIU0xbMl0gPSBpc0ZpeGVkQ29sb3JEYXJrID8gZW5kIDogc3RhcnQ7XG4gIH1cbiAgSFNMVG9SR0IoYmFzZUhTTCwgb3V0cHV0KTtcbiAgY2FjaGVkVmFsdWUgPSBVdGlsLm1ha2VIZXhDb2xvcihNYXRoLnJvdW5kKG91dHB1dFswXSAqIDI1NSksIE1hdGgucm91bmQob3V0cHV0WzFdICogMjU1KSwgTWF0aC5yb3VuZChvdXRwdXRbMl0gKiAyNTUpKTtcbiAgY29udHJhc3RDYWNoZS5zZXQoa2V5LCBjYWNoZWRWYWx1ZSk7XG4gIHJldHVybiBjYWNoZWRWYWx1ZTtcbn1cbmZ1bmN0aW9uIHJlbmRlclJpY2hUZXh0KHtcbiAgaHRtbCxcbiAgZGlyLFxuICBjbGFzc05hbWVcbn0sIGNvbnRhaW5lcikge1xuICBjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgaWYgKHR5cGVvZiBodG1sID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29uc3QgcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwXCIpO1xuICAgIHAuZGlyID0gZGlyIHx8IFwiYXV0b1wiO1xuICAgIGNvbnN0IGxpbmVzID0gaHRtbC5zcGxpdCgvKD86XFxyXFxuP3xcXG4pLyk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gbGluZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgcC5hcHBlbmQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGluZSkpO1xuICAgICAgaWYgKGkgPCBpaSAtIDEpIHtcbiAgICAgICAgcC5hcHBlbmQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnJhZ21lbnQuYXBwZW5kKHApO1xuICB9IGVsc2Uge1xuICAgIFhmYUxheWVyLnJlbmRlcih7XG4gICAgICB4ZmFIdG1sOiBodG1sLFxuICAgICAgZGl2OiBmcmFnbWVudCxcbiAgICAgIGludGVudDogXCJyaWNoVGV4dFwiXG4gICAgfSk7XG4gIH1cbiAgZnJhZ21lbnQuZmlyc3RDaGlsZC5jbGFzc0xpc3QuYWRkKFwicmljaFRleHRcIiwgY2xhc3NOYW1lKTtcbiAgY29udGFpbmVyLmFwcGVuZChmcmFnbWVudCk7XG59XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDQ5NzIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg0NjI4KTtcbl9fd2VicGFja19yZXF1aXJlX18oNzY0Mik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDgwMDQpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygzODUzKTtcbl9fd2VicGFja19yZXF1aXJlX18oNTg3Nik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDI0NzUpO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg1MDI0KTtcbl9fd2VicGFja19yZXF1aXJlX18oMTY5OCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDkzMTQpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxMTQ4KTtcbl9fd2VicGFja19yZXF1aXJlX18oMzU3OSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDgzMzUpO1xuY2xhc3MgRWRpdG9yVG9vbGJhciB7XG4gICN0b29sYmFyID0gbnVsbDtcbiAgI2NvbG9yUGlja2VyID0gbnVsbDtcbiAgI2VkaXRvcjtcbiAgI2J1dHRvbnMgPSBudWxsO1xuICAjYWx0VGV4dCA9IG51bGw7XG4gICNjb21tZW50ID0gbnVsbDtcbiAgI2NvbW1lbnRCdXR0b25EaXZpZGVyID0gbnVsbDtcbiAgI3NpZ25hdHVyZURlc2NyaXB0aW9uQnV0dG9uID0gbnVsbDtcbiAgc3RhdGljICNsMTBuUmVtb3ZlID0gbnVsbDtcbiAgY29uc3RydWN0b3IoZWRpdG9yKSB7XG4gICAgdGhpcy4jZWRpdG9yID0gZWRpdG9yO1xuICAgIEVkaXRvclRvb2xiYXIuI2wxMG5SZW1vdmUgfHw9IE9iamVjdC5mcmVlemUoe1xuICAgICAgZnJlZXRleHQ6IFwicGRmanMtZWRpdG9yLXJlbW92ZS1mcmVldGV4dC1idXR0b25cIixcbiAgICAgIGhpZ2hsaWdodDogXCJwZGZqcy1lZGl0b3ItcmVtb3ZlLWhpZ2hsaWdodC1idXR0b25cIixcbiAgICAgIGluazogXCJwZGZqcy1lZGl0b3ItcmVtb3ZlLWluay1idXR0b25cIixcbiAgICAgIHN0YW1wOiBcInBkZmpzLWVkaXRvci1yZW1vdmUtc3RhbXAtYnV0dG9uXCIsXG4gICAgICBzaWduYXR1cmU6IFwicGRmanMtZWRpdG9yLXJlbW92ZS1zaWduYXR1cmUtYnV0dG9uXCJcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgZWRpdFRvb2xiYXIgPSB0aGlzLiN0b29sYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBlZGl0VG9vbGJhci5jbGFzc0xpc3QuYWRkKFwiZWRpdFRvb2xiYXJcIiwgXCJoaWRkZW5cIik7XG4gICAgZWRpdFRvb2xiYXIuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInRvb2xiYXJcIik7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jZWRpdG9yLl91aU1hbmFnZXIuX3NpZ25hbDtcbiAgICBpZiAoc2lnbmFsIGluc3RhbmNlb2YgQWJvcnRTaWduYWwgJiYgIXNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICBlZGl0VG9vbGJhci5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgZWRpdFRvb2xiYXIuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIEVkaXRvclRvb2xiYXIuI3BvaW50ZXJEb3duLCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGJ1dHRvbnMgPSB0aGlzLiNidXR0b25zID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBidXR0b25zLmNsYXNzTmFtZSA9IFwiYnV0dG9uc1wiO1xuICAgIGVkaXRUb29sYmFyLmFwcGVuZChidXR0b25zKTtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuI2VkaXRvci50b29sYmFyUG9zaXRpb247XG4gICAgaWYgKHBvc2l0aW9uKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHN0eWxlXG4gICAgICB9ID0gZWRpdFRvb2xiYXI7XG4gICAgICBjb25zdCB4ID0gdGhpcy4jZWRpdG9yLl91aU1hbmFnZXIuZGlyZWN0aW9uID09PSBcImx0clwiID8gMSAtIHBvc2l0aW9uWzBdIDogcG9zaXRpb25bMF07XG4gICAgICBzdHlsZS5pbnNldElubGluZUVuZCA9IGAkezEwMCAqIHh9JWA7XG4gICAgICBzdHlsZS50b3AgPSBgY2FsYygkezEwMCAqIHBvc2l0aW9uWzFdfSUgKyB2YXIoLS1lZGl0b3ItdG9vbGJhci12ZXJ0LW9mZnNldCkpYDtcbiAgICB9XG4gICAgcmV0dXJuIGVkaXRUb29sYmFyO1xuICB9XG4gIGdldCBkaXYoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3Rvb2xiYXI7XG4gIH1cbiAgc3RhdGljICNwb2ludGVyRG93bihlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxuICAjZm9jdXNJbihlKSB7XG4gICAgdGhpcy4jZWRpdG9yLl9mb2N1c0V2ZW50c0FsbG93ZWQgPSBmYWxzZTtcbiAgICBzdG9wRXZlbnQoZSk7XG4gIH1cbiAgI2ZvY3VzT3V0KGUpIHtcbiAgICB0aGlzLiNlZGl0b3IuX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IHRydWU7XG4gICAgc3RvcEV2ZW50KGUpO1xuICB9XG4gICNhZGRMaXN0ZW5lcnNUb0VsZW1lbnQoZWxlbWVudCkge1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI2VkaXRvci5fdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgaWYgKCEoc2lnbmFsIGluc3RhbmNlb2YgQWJvcnRTaWduYWwpIHx8IHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgdGhpcy4jZm9jdXNJbi5iaW5kKHRoaXMpLCB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgdGhpcy4jZm9jdXNPdXQuYmluZCh0aGlzKSwge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG5vQ29udGV4dE1lbnUsIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgdGhpcy4jdG9vbGJhci5jbGFzc0xpc3QuYWRkKFwiaGlkZGVuXCIpO1xuICAgIHRoaXMuI2NvbG9yUGlja2VyPy5oaWRlRHJvcGRvd24oKTtcbiAgfVxuICBzaG93KCkge1xuICAgIHRoaXMuI3Rvb2xiYXIuY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKTtcbiAgICB0aGlzLiNhbHRUZXh0Py5zaG93bigpO1xuICAgIHRoaXMuI2NvbW1lbnQ/LnNob3duKCk7XG4gIH1cbiAgYWRkRGVsZXRlQnV0dG9uKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVkaXRvclR5cGUsXG4gICAgICBfdWlNYW5hZ2VyXG4gICAgfSA9IHRoaXMuI2VkaXRvcjtcbiAgICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwiYmFzaWNcIiwgXCJkZWxldGVCdXR0b25cIik7XG4gICAgYnV0dG9uLnRhYkluZGV4ID0gMDtcbiAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIEVkaXRvclRvb2xiYXIuI2wxMG5SZW1vdmVbZWRpdG9yVHlwZV0pO1xuICAgIGlmICh0aGlzLiNhZGRMaXN0ZW5lcnNUb0VsZW1lbnQoYnV0dG9uKSkge1xuICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZSkgPT4ge1xuICAgICAgICBfdWlNYW5hZ2VyLmRlbGV0ZSgpO1xuICAgICAgfSwge1xuICAgICAgICBzaWduYWw6IF91aU1hbmFnZXIuX3NpZ25hbFxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuI2J1dHRvbnMuYXBwZW5kKGJ1dHRvbik7XG4gIH1cbiAgZ2V0ICNkaXZpZGVyKCkge1xuICAgIGNvbnN0IGRpdmlkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdmlkZXIuY2xhc3NOYW1lID0gXCJkaXZpZGVyXCI7XG4gICAgcmV0dXJuIGRpdmlkZXI7XG4gIH1cbiAgYXN5bmMgYWRkQWx0VGV4dChhbHRUZXh0KSB7XG4gICAgY29uc3QgYnV0dG9uID0gYXdhaXQgYWx0VGV4dC5yZW5kZXIoKTtcbiAgICB0aGlzLiNhZGRMaXN0ZW5lcnNUb0VsZW1lbnQoYnV0dG9uKTtcbiAgICB0aGlzLiNidXR0b25zLmFwcGVuZChidXR0b24sIHRoaXMuI2RpdmlkZXIpO1xuICAgIHRoaXMuI2FsdFRleHQgPSBhbHRUZXh0O1xuICB9XG4gIGFkZENvbW1lbnQoY29tbWVudCwgYmVmb3JlRWxlbWVudCA9IG51bGwpIHtcbiAgICBpZiAodGhpcy4jY29tbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBidXR0b24gPSBjb21tZW50LnJlbmRlckZvclRvb2xiYXIoKTtcbiAgICBpZiAoIWJ1dHRvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNhZGRMaXN0ZW5lcnNUb0VsZW1lbnQoYnV0dG9uKTtcbiAgICBjb25zdCBkaXZpZGVyID0gdGhpcy4jY29tbWVudEJ1dHRvbkRpdmlkZXIgPSB0aGlzLiNkaXZpZGVyO1xuICAgIGlmICghYmVmb3JlRWxlbWVudCkge1xuICAgICAgdGhpcy4jYnV0dG9ucy5hcHBlbmQoYnV0dG9uLCBkaXZpZGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jYnV0dG9ucy5pbnNlcnRCZWZvcmUoYnV0dG9uLCBiZWZvcmVFbGVtZW50KTtcbiAgICAgIHRoaXMuI2J1dHRvbnMuaW5zZXJ0QmVmb3JlKGRpdmlkZXIsIGJlZm9yZUVsZW1lbnQpO1xuICAgIH1cbiAgICB0aGlzLiNjb21tZW50ID0gY29tbWVudDtcbiAgICBjb21tZW50LnRvb2xiYXIgPSB0aGlzO1xuICB9XG4gIGFkZENvbG9yUGlja2VyKGNvbG9yUGlja2VyKSB7XG4gICAgaWYgKHRoaXMuI2NvbG9yUGlja2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvbG9yUGlja2VyID0gY29sb3JQaWNrZXI7XG4gICAgY29uc3QgYnV0dG9uID0gY29sb3JQaWNrZXIucmVuZGVyQnV0dG9uKCk7XG4gICAgdGhpcy4jYWRkTGlzdGVuZXJzVG9FbGVtZW50KGJ1dHRvbik7XG4gICAgdGhpcy4jYnV0dG9ucy5hcHBlbmQoYnV0dG9uLCB0aGlzLiNkaXZpZGVyKTtcbiAgfVxuICBhc3luYyBhZGRFZGl0U2lnbmF0dXJlQnV0dG9uKHNpZ25hdHVyZU1hbmFnZXIpIHtcbiAgICBjb25zdCBidXR0b24gPSB0aGlzLiNzaWduYXR1cmVEZXNjcmlwdGlvbkJ1dHRvbiA9IGF3YWl0IHNpZ25hdHVyZU1hbmFnZXIucmVuZGVyRWRpdEJ1dHRvbih0aGlzLiNlZGl0b3IpO1xuICAgIHRoaXMuI2FkZExpc3RlbmVyc1RvRWxlbWVudChidXR0b24pO1xuICAgIHRoaXMuI2J1dHRvbnMuYXBwZW5kKGJ1dHRvbiwgdGhpcy4jZGl2aWRlcik7XG4gIH1cbiAgcmVtb3ZlQnV0dG9uKG5hbWUpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgXCJjb21tZW50XCI6XG4gICAgICAgIHRoaXMuI2NvbW1lbnQ/LnJlbW92ZVRvb2xiYXJDb21tZW50QnV0dG9uKCk7XG4gICAgICAgIHRoaXMuI2NvbW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLiNjb21tZW50QnV0dG9uRGl2aWRlcj8ucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuI2NvbW1lbnRCdXR0b25EaXZpZGVyID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGFzeW5jIGFkZEJ1dHRvbihuYW1lLCB0b29sKSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlIFwiY29sb3JQaWNrZXJcIjpcbiAgICAgICAgdGhpcy5hZGRDb2xvclBpY2tlcih0b29sKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYWx0VGV4dFwiOlxuICAgICAgICBhd2FpdCB0aGlzLmFkZEFsdFRleHQodG9vbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImVkaXRTaWduYXR1cmVcIjpcbiAgICAgICAgYXdhaXQgdGhpcy5hZGRFZGl0U2lnbmF0dXJlQnV0dG9uKHRvb2wpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkZWxldGVcIjpcbiAgICAgICAgdGhpcy5hZGREZWxldGVCdXR0b24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiY29tbWVudFwiOlxuICAgICAgICB0aGlzLmFkZENvbW1lbnQodG9vbCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBhc3luYyBhZGRCdXR0b25CZWZvcmUobmFtZSwgdG9vbCwgYmVmb3JlU2VsZWN0b3IpIHtcbiAgICBjb25zdCBiZWZvcmVFbGVtZW50ID0gdGhpcy4jYnV0dG9ucy5xdWVyeVNlbGVjdG9yKGJlZm9yZVNlbGVjdG9yKTtcbiAgICBpZiAoIWJlZm9yZUVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT09IFwiY29tbWVudFwiKSB7XG4gICAgICB0aGlzLmFkZENvbW1lbnQodG9vbCwgYmVmb3JlRWxlbWVudCk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZUVkaXRTaWduYXR1cmVCdXR0b24oZGVzY3JpcHRpb24pIHtcbiAgICBpZiAodGhpcy4jc2lnbmF0dXJlRGVzY3JpcHRpb25CdXR0b24pIHtcbiAgICAgIHRoaXMuI3NpZ25hdHVyZURlc2NyaXB0aW9uQnV0dG9uLnRpdGxlID0gZGVzY3JpcHRpb247XG4gICAgfVxuICB9XG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLiN0b29sYmFyLnJlbW92ZSgpO1xuICAgIHRoaXMuI2NvbG9yUGlja2VyPy5kZXN0cm95KCk7XG4gICAgdGhpcy4jY29sb3JQaWNrZXIgPSBudWxsO1xuICB9XG59XG5jbGFzcyBGbG9hdGluZ1Rvb2xiYXIge1xuICAjYnV0dG9ucyA9IG51bGw7XG4gICN0b29sYmFyID0gbnVsbDtcbiAgI3VpTWFuYWdlcjtcbiAgY29uc3RydWN0b3IodWlNYW5hZ2VyKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyID0gdWlNYW5hZ2VyO1xuICB9XG4gICNyZW5kZXIoKSB7XG4gICAgY29uc3QgZWRpdFRvb2xiYXIgPSB0aGlzLiN0b29sYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBlZGl0VG9vbGJhci5jbGFzc05hbWUgPSBcImVkaXRUb29sYmFyXCI7XG4gICAgZWRpdFRvb2xiYXIuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInRvb2xiYXJcIik7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgaWYgKHNpZ25hbCBpbnN0YW5jZW9mIEFib3J0U2lnbmFsICYmICFzaWduYWwuYWJvcnRlZCkge1xuICAgICAgZWRpdFRvb2xiYXIuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG5vQ29udGV4dE1lbnUsIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgYnV0dG9ucyA9IHRoaXMuI2J1dHRvbnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGJ1dHRvbnMuY2xhc3NOYW1lID0gXCJidXR0b25zXCI7XG4gICAgZWRpdFRvb2xiYXIuYXBwZW5kKGJ1dHRvbnMpO1xuICAgIGlmICh0aGlzLiN1aU1hbmFnZXIuaGFzQ29tbWVudE1hbmFnZXIoKSkge1xuICAgICAgdGhpcy4jbWFrZUJ1dHRvbihcImNvbW1lbnRCdXR0b25cIiwgYHBkZmpzLWNvbW1lbnQtZmxvYXRpbmctYnV0dG9uYCwgXCJwZGZqcy1jb21tZW50LWZsb2F0aW5nLWJ1dHRvbi1sYWJlbFwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuI3VpTWFuYWdlci5jb21tZW50U2VsZWN0aW9uKFwiZmxvYXRpbmdfYnV0dG9uXCIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuI21ha2VCdXR0b24oXCJoaWdobGlnaHRCdXR0b25cIiwgYHBkZmpzLWhpZ2hsaWdodC1mbG9hdGluZy1idXR0b24xYCwgXCJwZGZqcy1oaWdobGlnaHQtZmxvYXRpbmctYnV0dG9uLWxhYmVsXCIsICgpID0+IHtcbiAgICAgIHRoaXMuI3VpTWFuYWdlci5oaWdobGlnaHRTZWxlY3Rpb24oXCJmbG9hdGluZ19idXR0b25cIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGVkaXRUb29sYmFyO1xuICB9XG4gICNnZXRMYXN0UG9pbnQoYm94ZXMsIGlzTFRSKSB7XG4gICAgbGV0IGxhc3RZID0gMDtcbiAgICBsZXQgbGFzdFggPSAwO1xuICAgIGZvciAoY29uc3QgYm94IG9mIGJveGVzKSB7XG4gICAgICBjb25zdCB5ID0gYm94LnkgKyBib3guaGVpZ2h0O1xuICAgICAgaWYgKHkgPCBsYXN0WSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHggPSBib3gueCArIChpc0xUUiA/IGJveC53aWR0aCA6IDApO1xuICAgICAgaWYgKHkgPiBsYXN0WSkge1xuICAgICAgICBsYXN0WCA9IHg7XG4gICAgICAgIGxhc3RZID0geTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNMVFIpIHtcbiAgICAgICAgaWYgKHggPiBsYXN0WCkge1xuICAgICAgICAgIGxhc3RYID0geDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh4IDwgbGFzdFgpIHtcbiAgICAgICAgbGFzdFggPSB4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW2lzTFRSID8gMSAtIGxhc3RYIDogbGFzdFgsIGxhc3RZXTtcbiAgfVxuICBzaG93KHBhcmVudCwgYm94ZXMsIGlzTFRSKSB7XG4gICAgY29uc3QgW3gsIHldID0gdGhpcy4jZ2V0TGFzdFBvaW50KGJveGVzLCBpc0xUUik7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gdGhpcy4jdG9vbGJhciB8fD0gdGhpcy4jcmVuZGVyKCk7XG4gICAgcGFyZW50LmFwcGVuZCh0aGlzLiN0b29sYmFyKTtcbiAgICBzdHlsZS5pbnNldElubGluZUVuZCA9IGAkezEwMCAqIHh9JWA7XG4gICAgc3R5bGUudG9wID0gYGNhbGMoJHsxMDAgKiB5fSUgKyB2YXIoLS1lZGl0b3ItdG9vbGJhci12ZXJ0LW9mZnNldCkpYDtcbiAgfVxuICBoaWRlKCkge1xuICAgIHRoaXMuI3Rvb2xiYXIucmVtb3ZlKCk7XG4gIH1cbiAgI21ha2VCdXR0b24oYnV0dG9uQ2xhc3MsIGwxMG5JZCwgbGFiZWxMMTBuSWQsIGNsaWNrSGFuZGxlcikge1xuICAgIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJiYXNpY1wiLCBidXR0b25DbGFzcyk7XG4gICAgYnV0dG9uLnRhYkluZGV4ID0gMDtcbiAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIGwxMG5JZCk7XG4gICAgY29uc3Qgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIGJ1dHRvbi5hcHBlbmQoc3Bhbik7XG4gICAgc3Bhbi5jbGFzc05hbWUgPSBcInZpc3VhbGx5SGlkZGVuXCI7XG4gICAgc3Bhbi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgbGFiZWxMMTBuSWQpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI3VpTWFuYWdlci5fc2lnbmFsO1xuICAgIGlmIChzaWduYWwgaW5zdGFuY2VvZiBBYm9ydFNpZ25hbCAmJiAhc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBjbGlja0hhbmRsZXIsIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy4jYnV0dG9ucy5hcHBlbmQoYnV0dG9uKTtcbiAgfVxufVxuZnVuY3Rpb24gYmluZEV2ZW50cyhvYmosIGVsZW1lbnQsIG5hbWVzKSB7XG4gIGZvciAoY29uc3QgbmFtZSBvZiBuYW1lcykge1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBvYmpbbmFtZV0uYmluZChvYmopKTtcbiAgfVxufVxuY2xhc3MgSWRNYW5hZ2VyIHtcbiAgI2lkID0gMDtcbiAgZ2V0IGlkKCkge1xuICAgIHJldHVybiBgJHtBbm5vdGF0aW9uRWRpdG9yUHJlZml4fSR7dGhpcy4jaWQrK31gO1xuICB9XG59XG5jbGFzcyBJbWFnZU1hbmFnZXIge1xuICAjYmFzZUlkID0gZ2V0VXVpZCgpO1xuICAjaWQgPSAwO1xuICAjY2FjaGUgPSBudWxsO1xuICBzdGF0aWMgZ2V0IF9pc1NWR0ZpdHRpbmdDYW52YXMoKSB7XG4gICAgY29uc3Qgc3ZnID0gYGRhdGE6aW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PVVURi04LDxzdmcgdmlld0JveD1cIjAgMCAxIDFcIiB3aWR0aD1cIjFcIiBoZWlnaHQ9XCIxXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxyZWN0IHdpZHRoPVwiMVwiIGhlaWdodD1cIjFcIiBzdHlsZT1cImZpbGw6cmVkO1wiLz48L3N2Zz5gO1xuICAgIGNvbnN0IGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMoMSwgMyk7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICB3aWxsUmVhZEZyZXF1ZW50bHk6IHRydWVcbiAgICB9KTtcbiAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgIGltYWdlLnNyYyA9IHN2ZztcbiAgICBjb25zdCBwcm9taXNlID0gaW1hZ2UuZGVjb2RlKCkudGhlbigoKSA9PiB7XG4gICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwLCAxLCAxLCAwLCAwLCAxLCAzKTtcbiAgICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkoY3R4LmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKS5kYXRhLmJ1ZmZlcilbMF0gPT09IDA7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9pc1NWR0ZpdHRpbmdDYW52YXNcIiwgcHJvbWlzZSk7XG4gIH1cbiAgYXN5bmMgI2dldChrZXksIHJhd0RhdGEpIHtcbiAgICB0aGlzLiNjYWNoZSB8fD0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBsZXQgZGF0YSA9IHRoaXMuI2NhY2hlLmdldChrZXkpO1xuICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGRhdGE/LmJpdG1hcCkge1xuICAgICAgZGF0YS5yZWZDb3VudGVyICs9IDE7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGRhdGEgfHw9IHtcbiAgICAgICAgYml0bWFwOiBudWxsLFxuICAgICAgICBpZDogYGltYWdlXyR7dGhpcy4jYmFzZUlkfV8ke3RoaXMuI2lkKyt9YCxcbiAgICAgICAgcmVmQ291bnRlcjogMCxcbiAgICAgICAgaXNTdmc6IGZhbHNlXG4gICAgICB9O1xuICAgICAgbGV0IGltYWdlO1xuICAgICAgaWYgKHR5cGVvZiByYXdEYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGRhdGEudXJsID0gcmF3RGF0YTtcbiAgICAgICAgaW1hZ2UgPSBhd2FpdCBmZXRjaERhdGEocmF3RGF0YSwgXCJibG9iXCIpO1xuICAgICAgfSBlbHNlIGlmIChyYXdEYXRhIGluc3RhbmNlb2YgRmlsZSkge1xuICAgICAgICBpbWFnZSA9IGRhdGEuZmlsZSA9IHJhd0RhdGE7XG4gICAgICB9IGVsc2UgaWYgKHJhd0RhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIGltYWdlID0gcmF3RGF0YTtcbiAgICAgIH1cbiAgICAgIGlmIChpbWFnZS50eXBlID09PSBcImltYWdlL3N2Zyt4bWxcIikge1xuICAgICAgICBjb25zdCBtdXN0UmVtb3ZlQXNwZWN0UmF0aW9Qcm9taXNlID0gSW1hZ2VNYW5hZ2VyLl9pc1NWR0ZpdHRpbmdDYW52YXM7XG4gICAgICAgIGNvbnN0IGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICBjb25zdCBpbWFnZUVsZW1lbnQgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgY29uc3QgaW1hZ2VQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGltYWdlRWxlbWVudC5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBkYXRhLmJpdG1hcCA9IGltYWdlRWxlbWVudDtcbiAgICAgICAgICAgIGRhdGEuaXNTdmcgPSB0cnVlO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBkYXRhLnN2Z1VybCA9IGZpbGVSZWFkZXIucmVzdWx0O1xuICAgICAgICAgICAgaW1hZ2VFbGVtZW50LnNyYyA9IGF3YWl0IG11c3RSZW1vdmVBc3BlY3RSYXRpb1Byb21pc2UgPyBgJHt1cmx9I3N2Z1ZpZXcocHJlc2VydmVBc3BlY3RSYXRpbyhub25lKSlgIDogdXJsO1xuICAgICAgICAgIH07XG4gICAgICAgICAgaW1hZ2VFbGVtZW50Lm9uZXJyb3IgPSBmaWxlUmVhZGVyLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICBmaWxlUmVhZGVyLnJlYWRBc0RhdGFVUkwoaW1hZ2UpO1xuICAgICAgICBhd2FpdCBpbWFnZVByb21pc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhLmJpdG1hcCA9IGF3YWl0IGNyZWF0ZUltYWdlQml0bWFwKGltYWdlKTtcbiAgICAgIH1cbiAgICAgIGRhdGEucmVmQ291bnRlciA9IDE7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgd2FybihlKTtcbiAgICAgIGRhdGEgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLiNjYWNoZS5zZXQoa2V5LCBkYXRhKTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgdGhpcy4jY2FjaGUuc2V0KGRhdGEuaWQsIGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBhc3luYyBnZXRGcm9tRmlsZShmaWxlKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGFzdE1vZGlmaWVkLFxuICAgICAgbmFtZSxcbiAgICAgIHNpemUsXG4gICAgICB0eXBlXG4gICAgfSA9IGZpbGU7XG4gICAgcmV0dXJuIHRoaXMuI2dldChgJHtsYXN0TW9kaWZpZWR9XyR7bmFtZX1fJHtzaXplfV8ke3R5cGV9YCwgZmlsZSk7XG4gIH1cbiAgYXN5bmMgZ2V0RnJvbVVybCh1cmwpIHtcbiAgICByZXR1cm4gdGhpcy4jZ2V0KHVybCwgdXJsKTtcbiAgfVxuICBhc3luYyBnZXRGcm9tQmxvYihpZCwgYmxvYlByb21pc2UpIHtcbiAgICBjb25zdCBibG9iID0gYXdhaXQgYmxvYlByb21pc2U7XG4gICAgcmV0dXJuIHRoaXMuI2dldChpZCwgYmxvYik7XG4gIH1cbiAgYXN5bmMgZ2V0RnJvbUlkKGlkKSB7XG4gICAgdGhpcy4jY2FjaGUgfHw9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuI2NhY2hlLmdldChpZCk7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGRhdGEuYml0bWFwKSB7XG4gICAgICBkYXRhLnJlZkNvdW50ZXIgKz0gMTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAoZGF0YS5maWxlKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRGcm9tRmlsZShkYXRhLmZpbGUpO1xuICAgIH1cbiAgICBpZiAoZGF0YS5ibG9iUHJvbWlzZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBibG9iUHJvbWlzZVxuICAgICAgfSA9IGRhdGE7XG4gICAgICBkZWxldGUgZGF0YS5ibG9iUHJvbWlzZTtcbiAgICAgIHJldHVybiB0aGlzLmdldEZyb21CbG9iKGRhdGEuaWQsIGJsb2JQcm9taXNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0RnJvbVVybChkYXRhLnVybCk7XG4gIH1cbiAgZ2V0RnJvbUNhbnZhcyhpZCwgY2FudmFzKSB7XG4gICAgdGhpcy4jY2FjaGUgfHw9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgbGV0IGRhdGEgPSB0aGlzLiNjYWNoZS5nZXQoaWQpO1xuICAgIGlmIChkYXRhPy5iaXRtYXApIHtcbiAgICAgIGRhdGEucmVmQ291bnRlciArPSAxO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGNvbnN0IG9mZnNjcmVlbiA9IG5ldyBPZmZzY3JlZW5DYW52YXMoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBjb25zdCBjdHggPSBvZmZzY3JlZW4uZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGN0eC5kcmF3SW1hZ2UoY2FudmFzLCAwLCAwKTtcbiAgICBkYXRhID0ge1xuICAgICAgYml0bWFwOiBvZmZzY3JlZW4udHJhbnNmZXJUb0ltYWdlQml0bWFwKCksXG4gICAgICBpZDogYGltYWdlXyR7dGhpcy4jYmFzZUlkfV8ke3RoaXMuI2lkKyt9YCxcbiAgICAgIHJlZkNvdW50ZXI6IDEsXG4gICAgICBpc1N2ZzogZmFsc2VcbiAgICB9O1xuICAgIHRoaXMuI2NhY2hlLnNldChpZCwgZGF0YSk7XG4gICAgdGhpcy4jY2FjaGUuc2V0KGRhdGEuaWQsIGRhdGEpO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIGdldFN2Z1VybChpZCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLiNjYWNoZS5nZXQoaWQpO1xuICAgIGlmICghZGF0YT8uaXNTdmcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YS5zdmdVcmw7XG4gIH1cbiAgZGVsZXRlSWQoaWQpIHtcbiAgICB0aGlzLiNjYWNoZSB8fD0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy4jY2FjaGUuZ2V0KGlkKTtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGF0YS5yZWZDb3VudGVyIC09IDE7XG4gICAgaWYgKGRhdGEucmVmQ291bnRlciAhPT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBiaXRtYXBcbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoIWRhdGEudXJsICYmICFkYXRhLmZpbGUpIHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMoYml0bWFwLndpZHRoLCBiaXRtYXAuaGVpZ2h0KTtcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiYml0bWFwcmVuZGVyZXJcIik7XG4gICAgICBjdHgudHJhbnNmZXJGcm9tSW1hZ2VCaXRtYXAoYml0bWFwKTtcbiAgICAgIGRhdGEuYmxvYlByb21pc2UgPSBjYW52YXMuY29udmVydFRvQmxvYigpO1xuICAgIH1cbiAgICBiaXRtYXAuY2xvc2U/LigpO1xuICAgIGRhdGEuYml0bWFwID0gbnVsbDtcbiAgfVxuICBpc1ZhbGlkSWQoaWQpIHtcbiAgICByZXR1cm4gaWQuc3RhcnRzV2l0aChgaW1hZ2VfJHt0aGlzLiNiYXNlSWR9X2ApO1xuICB9XG59XG5jbGFzcyBDb21tYW5kTWFuYWdlciB7XG4gICNjb21tYW5kcyA9IFtdO1xuICAjbG9ja2VkID0gZmFsc2U7XG4gICNtYXhTaXplO1xuICAjcG9zaXRpb24gPSAtMTtcbiAgY29uc3RydWN0b3IobWF4U2l6ZSA9IDEyOCkge1xuICAgIHRoaXMuI21heFNpemUgPSBtYXhTaXplO1xuICB9XG4gIGFkZCh7XG4gICAgY21kLFxuICAgIHVuZG8sXG4gICAgcG9zdCxcbiAgICBtdXN0RXhlYyxcbiAgICB0eXBlID0gTmFOLFxuICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGUgPSBmYWxzZSxcbiAgICBrZWVwVW5kbyA9IGZhbHNlXG4gIH0pIHtcbiAgICBpZiAobXVzdEV4ZWMpIHtcbiAgICAgIGNtZCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy4jbG9ja2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNhdmUgPSB7XG4gICAgICBjbWQsXG4gICAgICB1bmRvLFxuICAgICAgcG9zdCxcbiAgICAgIHR5cGVcbiAgICB9O1xuICAgIGlmICh0aGlzLiNwb3NpdGlvbiA9PT0gLTEpIHtcbiAgICAgIGlmICh0aGlzLiNjb21tYW5kcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuI2NvbW1hbmRzLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLiNwb3NpdGlvbiA9IDA7XG4gICAgICB0aGlzLiNjb21tYW5kcy5wdXNoKHNhdmUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob3ZlcndyaXRlSWZTYW1lVHlwZSAmJiB0aGlzLiNjb21tYW5kc1t0aGlzLiNwb3NpdGlvbl0udHlwZSA9PT0gdHlwZSkge1xuICAgICAgaWYgKGtlZXBVbmRvKSB7XG4gICAgICAgIHNhdmUudW5kbyA9IHRoaXMuI2NvbW1hbmRzW3RoaXMuI3Bvc2l0aW9uXS51bmRvO1xuICAgICAgfVxuICAgICAgdGhpcy4jY29tbWFuZHNbdGhpcy4jcG9zaXRpb25dID0gc2F2ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuI3Bvc2l0aW9uICsgMTtcbiAgICBpZiAobmV4dCA9PT0gdGhpcy4jbWF4U2l6ZSkge1xuICAgICAgdGhpcy4jY29tbWFuZHMuc3BsaWNlKDAsIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNwb3NpdGlvbiA9IG5leHQ7XG4gICAgICBpZiAobmV4dCA8IHRoaXMuI2NvbW1hbmRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLiNjb21tYW5kcy5zcGxpY2UobmV4dCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2NvbW1hbmRzLnB1c2goc2F2ZSk7XG4gIH1cbiAgdW5kbygpIHtcbiAgICBpZiAodGhpcy4jcG9zaXRpb24gPT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2xvY2tlZCA9IHRydWU7XG4gICAgY29uc3Qge1xuICAgICAgdW5kbyxcbiAgICAgIHBvc3RcbiAgICB9ID0gdGhpcy4jY29tbWFuZHNbdGhpcy4jcG9zaXRpb25dO1xuICAgIHVuZG8oKTtcbiAgICBwb3N0Py4oKTtcbiAgICB0aGlzLiNsb2NrZWQgPSBmYWxzZTtcbiAgICB0aGlzLiNwb3NpdGlvbiAtPSAxO1xuICB9XG4gIHJlZG8oKSB7XG4gICAgaWYgKHRoaXMuI3Bvc2l0aW9uIDwgdGhpcy4jY29tbWFuZHMubGVuZ3RoIC0gMSkge1xuICAgICAgdGhpcy4jcG9zaXRpb24gKz0gMTtcbiAgICAgIHRoaXMuI2xvY2tlZCA9IHRydWU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNtZCxcbiAgICAgICAgcG9zdFxuICAgICAgfSA9IHRoaXMuI2NvbW1hbmRzW3RoaXMuI3Bvc2l0aW9uXTtcbiAgICAgIGNtZCgpO1xuICAgICAgcG9zdD8uKCk7XG4gICAgICB0aGlzLiNsb2NrZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaGFzU29tZXRoaW5nVG9VbmRvKCkge1xuICAgIHJldHVybiB0aGlzLiNwb3NpdGlvbiAhPT0gLTE7XG4gIH1cbiAgaGFzU29tZXRoaW5nVG9SZWRvKCkge1xuICAgIHJldHVybiB0aGlzLiNwb3NpdGlvbiA8IHRoaXMuI2NvbW1hbmRzLmxlbmd0aCAtIDE7XG4gIH1cbiAgY2xlYW5UeXBlKHR5cGUpIHtcbiAgICBpZiAodGhpcy4jcG9zaXRpb24gPT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSB0aGlzLiNwb3NpdGlvbjsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmICh0aGlzLiNjb21tYW5kc1tpXS50eXBlICE9PSB0eXBlKSB7XG4gICAgICAgIHRoaXMuI2NvbW1hbmRzLnNwbGljZShpICsgMSwgdGhpcy4jcG9zaXRpb24gLSBpKTtcbiAgICAgICAgdGhpcy4jcG9zaXRpb24gPSBpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2NvbW1hbmRzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy4jcG9zaXRpb24gPSAtMTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI2NvbW1hbmRzID0gbnVsbDtcbiAgfVxufVxuY2xhc3MgS2V5Ym9hcmRNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoY2FsbGJhY2tzKSB7XG4gICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5hbGxLZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCB7XG4gICAgICBpc01hY1xuICAgIH0gPSB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGZvciAoY29uc3QgW2tleXMsIGNhbGxiYWNrLCBvcHRpb25zID0ge31dIG9mIGNhbGxiYWNrcykge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICBjb25zdCBpc01hY0tleSA9IGtleS5zdGFydHNXaXRoKFwibWFjK1wiKTtcbiAgICAgICAgaWYgKGlzTWFjICYmIGlzTWFjS2V5KSB7XG4gICAgICAgICAgdGhpcy5jYWxsYmFja3Muc2V0KGtleS5zbGljZSg0KSwge1xuICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5hbGxLZXlzLmFkZChrZXkuc3BsaXQoXCIrXCIpLmF0KC0xKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzTWFjICYmICFpc01hY0tleSkge1xuICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLnNldChrZXksIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuYWxsS2V5cy5hZGQoa2V5LnNwbGl0KFwiK1wiKS5hdCgtMSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gICNzZXJpYWxpemUoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuYWx0S2V5KSB7XG4gICAgICB0aGlzLmJ1ZmZlci5wdXNoKFwiYWx0XCIpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQuY3RybEtleSkge1xuICAgICAgdGhpcy5idWZmZXIucHVzaChcImN0cmxcIik7XG4gICAgfVxuICAgIGlmIChldmVudC5tZXRhS2V5KSB7XG4gICAgICB0aGlzLmJ1ZmZlci5wdXNoKFwibWV0YVwiKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICB0aGlzLmJ1ZmZlci5wdXNoKFwic2hpZnRcIik7XG4gICAgfVxuICAgIHRoaXMuYnVmZmVyLnB1c2goZXZlbnQua2V5KTtcbiAgICBjb25zdCBzdHIgPSB0aGlzLmJ1ZmZlci5qb2luKFwiK1wiKTtcbiAgICB0aGlzLmJ1ZmZlci5sZW5ndGggPSAwO1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgZXhlYyhzZWxmMiwgZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuYWxsS2V5cy5oYXMoZXZlbnQua2V5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbmZvMiA9IHRoaXMuY2FsbGJhY2tzLmdldCh0aGlzLiNzZXJpYWxpemUoZXZlbnQpKTtcbiAgICBpZiAoIWluZm8yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBidWJibGVzID0gZmFsc2UsXG4gICAgICAgIGFyZ3MgPSBbXSxcbiAgICAgICAgY2hlY2tlciA9IG51bGxcbiAgICAgIH1cbiAgICB9ID0gaW5mbzI7XG4gICAgaWYgKGNoZWNrZXIgJiYgIWNoZWNrZXIoc2VsZjIsIGV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFjay5iaW5kKHNlbGYyLCAuLi5hcmdzLCBldmVudCkoKTtcbiAgICBpZiAoIWJ1YmJsZXMpIHtcbiAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBDb2xvck1hbmFnZXIge1xuICBzdGF0aWMgX2NvbG9yc01hcHBpbmcgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbW1wiQ2FudmFzVGV4dFwiLCBbMCwgMCwgMF1dLCBbXCJDYW52YXNcIiwgWzI1NSwgMjU1LCAyNTVdXV0pO1xuICBnZXQgX2NvbG9ycygpIHtcbiAgICBjb25zdCBjb2xvcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbW1wiQ2FudmFzVGV4dFwiLCBudWxsXSwgW1wiQ2FudmFzXCIsIG51bGxdXSk7XG4gICAgZ2V0Q29sb3JWYWx1ZXMoY29sb3JzKTtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2NvbG9yc1wiLCBjb2xvcnMpO1xuICB9XG4gIGNvbnZlcnQoY29sb3IpIHtcbiAgICBjb25zdCByZ2IgPSBnZXRSR0IoY29sb3IpO1xuICAgIGlmICghd2luZG93Lm1hdGNoTWVkaWEoXCIoZm9yY2VkLWNvbG9yczogYWN0aXZlKVwiKS5tYXRjaGVzKSB7XG4gICAgICByZXR1cm4gcmdiO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtuYW1lLCBSR0JdIG9mIHRoaXMuX2NvbG9ycykge1xuICAgICAgaWYgKFJHQi5ldmVyeSgoeCwgaSkgPT4geCA9PT0gcmdiW2ldKSkge1xuICAgICAgICByZXR1cm4gQ29sb3JNYW5hZ2VyLl9jb2xvcnNNYXBwaW5nLmdldChuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJnYjtcbiAgfVxuICBnZXRIZXhDb2RlKG5hbWUpIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLl9jb2xvcnMuZ2V0KG5hbWUpO1xuICAgIGlmICghcmdiKSB7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIFV0aWwubWFrZUhleENvbG9yKC4uLnJnYik7XG4gIH1cbn1cbmNsYXNzIEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIge1xuICAjYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAjYWN0aXZlRWRpdG9yID0gbnVsbDtcbiAgI2FsbEVkaXRhYmxlQW5ub3RhdGlvbnMgPSBudWxsO1xuICAjYWxsRWRpdG9ycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICNhbGxMYXllcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAjYWx0VGV4dE1hbmFnZXIgPSBudWxsO1xuICAjYW5ub3RhdGlvblN0b3JhZ2UgPSBudWxsO1xuICAjY2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbnMgPSBudWxsO1xuICAjY29tbWFuZE1hbmFnZXIgPSBuZXcgQ29tbWFuZE1hbmFnZXIoKTtcbiAgI2NvbW1lbnRNYW5hZ2VyID0gbnVsbDtcbiAgI2NvcHlQYXN0ZUFDID0gbnVsbDtcbiAgI2N1cnJlbnREcmF3aW5nU2Vzc2lvbiA9IG51bGw7XG4gICNjdXJyZW50UGFnZUluZGV4ID0gMDtcbiAgI2RlbGV0ZWRBbm5vdGF0aW9uc0VsZW1lbnRJZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAjZHJhZ2dpbmdFZGl0b3JzID0gbnVsbDtcbiAgI2VkaXRvclR5cGVzID0gbnVsbDtcbiAgI2VkaXRvcnNUb1Jlc2NhbGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBfZWRpdG9yVW5kb0JhciA9IG51bGw7XG4gICNlbmFibGVIaWdobGlnaHRGbG9hdGluZ0J1dHRvbiA9IGZhbHNlO1xuICAjZW5hYmxlVXBkYXRlZEFkZEltYWdlID0gZmFsc2U7XG4gICNlbmFibGVOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlID0gZmFsc2U7XG4gICNmaWx0ZXJGYWN0b3J5ID0gbnVsbDtcbiAgI2ZvY3VzTWFpbkNvbnRhaW5lclRpbWVvdXRJZCA9IG51bGw7XG4gICNmb2N1c01hbmFnZXJBQyA9IG51bGw7XG4gICNoaWdobGlnaHRDb2xvcnMgPSBudWxsO1xuICAjaGlnaGxpZ2h0V2hlblNoaWZ0VXAgPSBmYWxzZTtcbiAgI2Zsb2F0aW5nVG9vbGJhciA9IG51bGw7XG4gICNpZE1hbmFnZXIgPSBuZXcgSWRNYW5hZ2VyKCk7XG4gICNpc0VuYWJsZWQgPSBmYWxzZTtcbiAgI2lzUG9pbnRlckRvd24gPSBmYWxzZTtcbiAgI2lzV2FpdGluZyA9IGZhbHNlO1xuICAja2V5Ym9hcmRNYW5hZ2VyQUMgPSBudWxsO1xuICAjbGFzdEFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICAjbWFpbkhpZ2hsaWdodENvbG9yUGlja2VyID0gbnVsbDtcbiAgI21pc3NpbmdDYW52YXNlcyA9IG51bGw7XG4gICNtbE1hbmFnZXIgPSBudWxsO1xuICAjbW9kZSA9IEFubm90YXRpb25FZGl0b3JUeXBlLk5PTkU7XG4gICNzZWxlY3RlZEVkaXRvcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAjc2VsZWN0ZWRUZXh0Tm9kZSA9IG51bGw7XG4gICNzaWduYXR1cmVNYW5hZ2VyID0gbnVsbDtcbiAgI3BhZ2VDb2xvcnMgPSBudWxsO1xuICAjc2hvd0FsbFN0YXRlcyA9IG51bGw7XG4gICNwZGZEb2N1bWVudCA9IG51bGw7XG4gICNwcmV2aW91c1N0YXRlcyA9IHtcbiAgICBpc0VkaXRpbmc6IGZhbHNlLFxuICAgIGlzRW1wdHk6IHRydWUsXG4gICAgaGFzU29tZXRoaW5nVG9VbmRvOiBmYWxzZSxcbiAgICBoYXNTb21ldGhpbmdUb1JlZG86IGZhbHNlLFxuICAgIGhhc1NlbGVjdGVkRWRpdG9yOiBmYWxzZSxcbiAgICBoYXNTZWxlY3RlZFRleHQ6IGZhbHNlXG4gIH07XG4gICN0cmFuc2xhdGlvbiA9IFswLCAwXTtcbiAgI3RyYW5zbGF0aW9uVGltZW91dElkID0gbnVsbDtcbiAgI2NvbnRhaW5lciA9IG51bGw7XG4gICN2aWV3ZXIgPSBudWxsO1xuICAjdmlld2VyQWxlcnQgPSBudWxsO1xuICAjdXBkYXRlTW9kZUNhcGFiaWxpdHkgPSBudWxsO1xuICBzdGF0aWMgVFJBTlNMQVRFX1NNQUxMID0gMTtcbiAgc3RhdGljIFRSQU5TTEFURV9CSUcgPSAxMDtcbiAgc3RhdGljIGdldCBfa2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIGNvbnN0IHByb3RvID0gQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlci5wcm90b3R5cGU7XG4gICAgY29uc3QgYXJyb3dDaGVja2VyID0gKHNlbGYyKSA9PiBzZWxmMi4jY29udGFpbmVyLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQudGFnTmFtZSAhPT0gXCJCVVRUT05cIiAmJiBzZWxmMi5oYXNTb21ldGhpbmdUb0NvbnRyb2woKTtcbiAgICBjb25zdCB0ZXh0SW5wdXRDaGVja2VyID0gKF9zZWxmLCB7XG4gICAgICB0YXJnZXQ6IGVsXG4gICAgfSkgPT4ge1xuICAgICAgaWYgKGVsIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgdHlwZVxuICAgICAgICB9ID0gZWw7XG4gICAgICAgIHJldHVybiB0eXBlICE9PSBcInRleHRcIiAmJiB0eXBlICE9PSBcIm51bWJlclwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBjb25zdCBzbWFsbCA9IHRoaXMuVFJBTlNMQVRFX1NNQUxMO1xuICAgIGNvbnN0IGJpZyA9IHRoaXMuVFJBTlNMQVRFX0JJRztcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2tleWJvYXJkTWFuYWdlclwiLCBuZXcgS2V5Ym9hcmRNYW5hZ2VyKFtbW1wiY3RybCthXCIsIFwibWFjK21ldGErYVwiXSwgcHJvdG8uc2VsZWN0QWxsLCB7XG4gICAgICBjaGVja2VyOiB0ZXh0SW5wdXRDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK3pcIiwgXCJtYWMrbWV0YSt6XCJdLCBwcm90by51bmRvLCB7XG4gICAgICBjaGVja2VyOiB0ZXh0SW5wdXRDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK3lcIiwgXCJjdHJsK3NoaWZ0K3pcIiwgXCJtYWMrbWV0YStzaGlmdCt6XCIsIFwiY3RybCtzaGlmdCtaXCIsIFwibWFjK21ldGErc2hpZnQrWlwiXSwgcHJvdG8ucmVkbywge1xuICAgICAgY2hlY2tlcjogdGV4dElucHV0Q2hlY2tlclxuICAgIH1dLCBbW1wiQmFja3NwYWNlXCIsIFwiYWx0K0JhY2tzcGFjZVwiLCBcImN0cmwrQmFja3NwYWNlXCIsIFwic2hpZnQrQmFja3NwYWNlXCIsIFwibWFjK0JhY2tzcGFjZVwiLCBcIm1hYythbHQrQmFja3NwYWNlXCIsIFwibWFjK2N0cmwrQmFja3NwYWNlXCIsIFwiRGVsZXRlXCIsIFwiY3RybCtEZWxldGVcIiwgXCJzaGlmdCtEZWxldGVcIiwgXCJtYWMrRGVsZXRlXCJdLCBwcm90by5kZWxldGUsIHtcbiAgICAgIGNoZWNrZXI6IHRleHRJbnB1dENoZWNrZXJcbiAgICB9XSwgW1tcIkVudGVyXCIsIFwibWFjK0VudGVyXCJdLCBwcm90by5hZGROZXdFZGl0b3JGcm9tS2V5Ym9hcmQsIHtcbiAgICAgIGNoZWNrZXI6IChzZWxmMiwge1xuICAgICAgICB0YXJnZXQ6IGVsXG4gICAgICB9KSA9PiAhKGVsIGluc3RhbmNlb2YgSFRNTEJ1dHRvbkVsZW1lbnQpICYmIHNlbGYyLiNjb250YWluZXIuY29udGFpbnMoZWwpICYmICFzZWxmMi5pc0VudGVySGFuZGxlZFxuICAgIH1dLCBbW1wiIFwiLCBcIm1hYysgXCJdLCBwcm90by5hZGROZXdFZGl0b3JGcm9tS2V5Ym9hcmQsIHtcbiAgICAgIGNoZWNrZXI6IChzZWxmMiwge1xuICAgICAgICB0YXJnZXQ6IGVsXG4gICAgICB9KSA9PiAhKGVsIGluc3RhbmNlb2YgSFRNTEJ1dHRvbkVsZW1lbnQpICYmIHNlbGYyLiNjb250YWluZXIuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudClcbiAgICB9XSwgW1tcIkVzY2FwZVwiLCBcIm1hYytFc2NhcGVcIl0sIHByb3RvLnVuc2VsZWN0QWxsXSwgW1tcIkFycm93TGVmdFwiLCBcIm1hYytBcnJvd0xlZnRcIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogWy1zbWFsbCwgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dMZWZ0XCIsIFwibWFjK3NoaWZ0K0Fycm93TGVmdFwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbLWJpZywgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcIkFycm93UmlnaHRcIiwgXCJtYWMrQXJyb3dSaWdodFwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbc21hbGwsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93UmlnaHRcIiwgXCJtYWMrc2hpZnQrQXJyb3dSaWdodFwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbYmlnLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiQXJyb3dVcFwiLCBcIm1hYytBcnJvd1VwXCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFswLCAtc21hbGxdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93VXBcIiwgXCJtYWMrc2hpZnQrQXJyb3dVcFwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbMCwgLWJpZ10sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcIkFycm93RG93blwiLCBcIm1hYytBcnJvd0Rvd25cIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogWzAsIHNtYWxsXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd0Rvd25cIiwgXCJtYWMrc2hpZnQrQXJyb3dEb3duXCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFswLCBiaWddLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV1dKSk7XG4gIH1cbiAgY29uc3RydWN0b3IoY29udGFpbmVyLCB2aWV3ZXIsIHZpZXdlckFsZXJ0LCBhbHRUZXh0TWFuYWdlciwgY29tbWVudE1hbmFnZXIsIHNpZ25hdHVyZU1hbmFnZXIsIGV2ZW50QnVzLCBwZGZEb2N1bWVudCwgcGFnZUNvbG9ycywgaGlnaGxpZ2h0Q29sb3JzLCBlbmFibGVIaWdobGlnaHRGbG9hdGluZ0J1dHRvbiwgZW5hYmxlVXBkYXRlZEFkZEltYWdlLCBlbmFibGVOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlLCBtbE1hbmFnZXIsIGVkaXRvclVuZG9CYXIsIHN1cHBvcnRzUGluY2hUb1pvb20pIHtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLl9zaWduYWwgPSB0aGlzLiNhYm9ydENvbnRyb2xsZXIuc2lnbmFsO1xuICAgIHRoaXMuI2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLiN2aWV3ZXIgPSB2aWV3ZXI7XG4gICAgdGhpcy4jdmlld2VyQWxlcnQgPSB2aWV3ZXJBbGVydDtcbiAgICB0aGlzLiNhbHRUZXh0TWFuYWdlciA9IGFsdFRleHRNYW5hZ2VyO1xuICAgIHRoaXMuI2NvbW1lbnRNYW5hZ2VyID0gY29tbWVudE1hbmFnZXI7XG4gICAgdGhpcy4jc2lnbmF0dXJlTWFuYWdlciA9IHNpZ25hdHVyZU1hbmFnZXI7XG4gICAgdGhpcy4jcGRmRG9jdW1lbnQgPSBwZGZEb2N1bWVudDtcbiAgICB0aGlzLl9ldmVudEJ1cyA9IGV2ZW50QnVzO1xuICAgIGV2ZW50QnVzLl9vbihcImVkaXRpbmdhY3Rpb25cIiwgdGhpcy5vbkVkaXRpbmdBY3Rpb24uYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZXZlbnRCdXMuX29uKFwicGFnZWNoYW5naW5nXCIsIHRoaXMub25QYWdlQ2hhbmdpbmcuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZXZlbnRCdXMuX29uKFwic2NhbGVjaGFuZ2luZ1wiLCB0aGlzLm9uU2NhbGVDaGFuZ2luZy5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBldmVudEJ1cy5fb24oXCJyb3RhdGlvbmNoYW5naW5nXCIsIHRoaXMub25Sb3RhdGlvbkNoYW5naW5nLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGV2ZW50QnVzLl9vbihcInNldHByZWZlcmVuY2VcIiwgdGhpcy5vblNldFByZWZlcmVuY2UuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZXZlbnRCdXMuX29uKFwic3dpdGNoYW5ub3RhdGlvbmVkaXRvcnBhcmFtc1wiLCAoZXZ0KSA9PiB0aGlzLnVwZGF0ZVBhcmFtcyhldnQudHlwZSwgZXZ0LnZhbHVlKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCAoKSA9PiB7XG4gICAgICB0aGlzLiNpc1BvaW50ZXJEb3duID0gdHJ1ZTtcbiAgICB9LCB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgKCkgPT4ge1xuICAgICAgdGhpcy4jaXNQb2ludGVyRG93biA9IGZhbHNlO1xuICAgIH0sIHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLiNhZGRTZWxlY3Rpb25MaXN0ZW5lcigpO1xuICAgIHRoaXMuI2FkZERyYWdBbmREcm9wTGlzdGVuZXJzKCk7XG4gICAgdGhpcy4jYWRkS2V5Ym9hcmRNYW5hZ2VyKCk7XG4gICAgdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2UgPSBwZGZEb2N1bWVudC5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICB0aGlzLiNmaWx0ZXJGYWN0b3J5ID0gcGRmRG9jdW1lbnQuZmlsdGVyRmFjdG9yeTtcbiAgICB0aGlzLiNwYWdlQ29sb3JzID0gcGFnZUNvbG9ycztcbiAgICB0aGlzLiNoaWdobGlnaHRDb2xvcnMgPSBoaWdobGlnaHRDb2xvcnMgfHwgbnVsbDtcbiAgICB0aGlzLiNlbmFibGVIaWdobGlnaHRGbG9hdGluZ0J1dHRvbiA9IGVuYWJsZUhpZ2hsaWdodEZsb2F0aW5nQnV0dG9uO1xuICAgIHRoaXMuI2VuYWJsZVVwZGF0ZWRBZGRJbWFnZSA9IGVuYWJsZVVwZGF0ZWRBZGRJbWFnZTtcbiAgICB0aGlzLiNlbmFibGVOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlID0gZW5hYmxlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZTtcbiAgICB0aGlzLiNtbE1hbmFnZXIgPSBtbE1hbmFnZXIgfHwgbnVsbDtcbiAgICB0aGlzLnZpZXdQYXJhbWV0ZXJzID0ge1xuICAgICAgcmVhbFNjYWxlOiBQaXhlbHNQZXJJbmNoLlBERl9UT19DU1NfVU5JVFMsXG4gICAgICByb3RhdGlvbjogMFxuICAgIH07XG4gICAgdGhpcy5pc1NoaWZ0S2V5RG93biA9IGZhbHNlO1xuICAgIHRoaXMuX2VkaXRvclVuZG9CYXIgPSBlZGl0b3JVbmRvQmFyIHx8IG51bGw7XG4gICAgdGhpcy5fc3VwcG9ydHNQaW5jaFRvWm9vbSA9IHN1cHBvcnRzUGluY2hUb1pvb20gIT09IGZhbHNlO1xuICAgIGNvbW1lbnRNYW5hZ2VyPy5zZXRTaWRlYmFyVWlNYW5hZ2VyKHRoaXMpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4jdXBkYXRlTW9kZUNhcGFiaWxpdHk/LnJlc29sdmUoKTtcbiAgICB0aGlzLiN1cGRhdGVNb2RlQ2FwYWJpbGl0eSA9IG51bGw7XG4gICAgdGhpcy4jYWJvcnRDb250cm9sbGVyPy5hYm9ydCgpO1xuICAgIHRoaXMuI2Fib3J0Q29udHJvbGxlciA9IG51bGw7XG4gICAgdGhpcy5fc2lnbmFsID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgbGF5ZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLiNhbGxMYXllcnMuY2xlYXIoKTtcbiAgICB0aGlzLiNhbGxFZGl0b3JzLmNsZWFyKCk7XG4gICAgdGhpcy4jZWRpdG9yc1RvUmVzY2FsZS5jbGVhcigpO1xuICAgIHRoaXMuI21pc3NpbmdDYW52YXNlcz8uY2xlYXIoKTtcbiAgICB0aGlzLiNhY3RpdmVFZGl0b3IgPSBudWxsO1xuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5jbGVhcigpO1xuICAgIHRoaXMuI2NvbW1hbmRNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB0aGlzLiNhbHRUZXh0TWFuYWdlcj8uZGVzdHJveSgpO1xuICAgIHRoaXMuI2NvbW1lbnRNYW5hZ2VyPy5kZXN0cm95KCk7XG4gICAgdGhpcy4jc2lnbmF0dXJlTWFuYWdlcj8uZGVzdHJveSgpO1xuICAgIHRoaXMuI2Zsb2F0aW5nVG9vbGJhcj8uaGlkZSgpO1xuICAgIHRoaXMuI2Zsb2F0aW5nVG9vbGJhciA9IG51bGw7XG4gICAgdGhpcy4jbWFpbkhpZ2hsaWdodENvbG9yUGlja2VyPy5kZXN0cm95KCk7XG4gICAgdGhpcy4jbWFpbkhpZ2hsaWdodENvbG9yUGlja2VyID0gbnVsbDtcbiAgICB0aGlzLiNhbGxFZGl0YWJsZUFubm90YXRpb25zID0gbnVsbDtcbiAgICBpZiAodGhpcy4jZm9jdXNNYWluQ29udGFpbmVyVGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jZm9jdXNNYWluQ29udGFpbmVyVGltZW91dElkKTtcbiAgICAgIHRoaXMuI2ZvY3VzTWFpbkNvbnRhaW5lclRpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLiN0cmFuc2xhdGlvblRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI3RyYW5zbGF0aW9uVGltZW91dElkKTtcbiAgICAgIHRoaXMuI3RyYW5zbGF0aW9uVGltZW91dElkID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5fZWRpdG9yVW5kb0Jhcj8uZGVzdHJveSgpO1xuICAgIHRoaXMuI3BkZkRvY3VtZW50ID0gbnVsbDtcbiAgfVxuICBjb21iaW5lZFNpZ25hbChhYykge1xuICAgIHJldHVybiBBYm9ydFNpZ25hbC5hbnkoW3RoaXMuX3NpZ25hbCwgYWMuc2lnbmFsXSk7XG4gIH1cbiAgZ2V0IG1sTWFuYWdlcigpIHtcbiAgICByZXR1cm4gdGhpcy4jbWxNYW5hZ2VyO1xuICB9XG4gIGdldCB1c2VOZXdBbHRUZXh0RmxvdygpIHtcbiAgICByZXR1cm4gdGhpcy4jZW5hYmxlVXBkYXRlZEFkZEltYWdlO1xuICB9XG4gIGdldCB1c2VOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlKCkge1xuICAgIHJldHVybiB0aGlzLiNlbmFibGVOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlO1xuICB9XG4gIGdldCBoY21GaWx0ZXIoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImhjbUZpbHRlclwiLCB0aGlzLiNwYWdlQ29sb3JzID8gdGhpcy4jZmlsdGVyRmFjdG9yeS5hZGRIQ01GaWx0ZXIodGhpcy4jcGFnZUNvbG9ycy5mb3JlZ3JvdW5kLCB0aGlzLiNwYWdlQ29sb3JzLmJhY2tncm91bmQpIDogXCJub25lXCIpO1xuICB9XG4gIGdldCBkaXJlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImRpcmVjdGlvblwiLCBnZXRDb21wdXRlZFN0eWxlKHRoaXMuI2NvbnRhaW5lcikuZGlyZWN0aW9uKTtcbiAgfVxuICBnZXQgX2hpZ2hsaWdodENvbG9ycygpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2hpZ2hsaWdodENvbG9yc1wiLCB0aGlzLiNoaWdobGlnaHRDb2xvcnMgPyBuZXcgTWFwKHRoaXMuI2hpZ2hsaWdodENvbG9ycy5zcGxpdChcIixcIikubWFwKChwYWlyKSA9PiB7XG4gICAgICBwYWlyID0gcGFpci5zcGxpdChcIj1cIikubWFwKCh4KSA9PiB4LnRyaW0oKSk7XG4gICAgICBwYWlyWzFdID0gcGFpclsxXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgcmV0dXJuIHBhaXI7XG4gICAgfSkpIDogbnVsbCk7XG4gIH1cbiAgZ2V0IGhpZ2hsaWdodENvbG9ycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBfaGlnaGxpZ2h0Q29sb3JzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFfaGlnaGxpZ2h0Q29sb3JzKSB7XG4gICAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaGlnaGxpZ2h0Q29sb3JzXCIsIG51bGwpO1xuICAgIH1cbiAgICBjb25zdCBtYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGhhc0hDTSA9ICEhdGhpcy4jcGFnZUNvbG9ycztcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCBjb2xvcl0gb2YgX2hpZ2hsaWdodENvbG9ycykge1xuICAgICAgY29uc3QgaXNOYW1lRm9ySENNID0gbmFtZS5lbmRzV2l0aChcIl9IQ01cIik7XG4gICAgICBpZiAoaGFzSENNICYmIGlzTmFtZUZvckhDTSkge1xuICAgICAgICBtYXAuc2V0KG5hbWUucmVwbGFjZShcIl9IQ01cIiwgXCJcIiksIGNvbG9yKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIWhhc0hDTSAmJiAhaXNOYW1lRm9ySENNKSB7XG4gICAgICAgIG1hcC5zZXQobmFtZSwgY29sb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaGlnaGxpZ2h0Q29sb3JzXCIsIG1hcCk7XG4gIH1cbiAgZ2V0IGhpZ2hsaWdodENvbG9yTmFtZXMoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImhpZ2hsaWdodENvbG9yTmFtZXNcIiwgdGhpcy5oaWdobGlnaHRDb2xvcnMgPyBuZXcgTWFwKEFycmF5LmZyb20odGhpcy5oaWdobGlnaHRDb2xvcnMsIChlKSA9PiBlLnJldmVyc2UoKSkpIDogbnVsbCk7XG4gIH1cbiAgZ2V0Tm9uSENNQ29sb3IoY29sb3IpIHtcbiAgICBpZiAoIXRoaXMuX2hpZ2hsaWdodENvbG9ycykge1xuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbiAgICBjb25zdCBjb2xvck5hbWUgPSB0aGlzLmhpZ2hsaWdodENvbG9yTmFtZXMuZ2V0KGNvbG9yKTtcbiAgICByZXR1cm4gdGhpcy5faGlnaGxpZ2h0Q29sb3JzLmdldChjb2xvck5hbWUpIHx8IGNvbG9yO1xuICB9XG4gIGdldE5vbkhDTUNvbG9yTmFtZShjb2xvcikge1xuICAgIHJldHVybiB0aGlzLmhpZ2hsaWdodENvbG9yTmFtZXMuZ2V0KGNvbG9yKSB8fCBjb2xvcjtcbiAgfVxuICBzZXRDdXJyZW50RHJhd2luZ1Nlc3Npb24obGF5ZXIpIHtcbiAgICBpZiAobGF5ZXIpIHtcbiAgICAgIHRoaXMudW5zZWxlY3RBbGwoKTtcbiAgICAgIHRoaXMuZGlzYWJsZVVzZXJTZWxlY3QodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGlzYWJsZVVzZXJTZWxlY3QoZmFsc2UpO1xuICAgIH1cbiAgICB0aGlzLiNjdXJyZW50RHJhd2luZ1Nlc3Npb24gPSBsYXllcjtcbiAgfVxuICBzZXRNYWluSGlnaGxpZ2h0Q29sb3JQaWNrZXIoY29sb3JQaWNrZXIpIHtcbiAgICB0aGlzLiNtYWluSGlnaGxpZ2h0Q29sb3JQaWNrZXIgPSBjb2xvclBpY2tlcjtcbiAgfVxuICBlZGl0QWx0VGV4dChlZGl0b3IsIGZpcnN0VGltZSA9IGZhbHNlKSB7XG4gICAgdGhpcy4jYWx0VGV4dE1hbmFnZXI/LmVkaXRBbHRUZXh0KHRoaXMsIGVkaXRvciwgZmlyc3RUaW1lKTtcbiAgfVxuICBoYXNDb21tZW50TWFuYWdlcigpIHtcbiAgICByZXR1cm4gISF0aGlzLiNjb21tZW50TWFuYWdlcjtcbiAgfVxuICBlZGl0Q29tbWVudChlZGl0b3IsIHBvc1gsIHBvc1ksIG9wdGlvbnMpIHtcbiAgICB0aGlzLiNjb21tZW50TWFuYWdlcj8uc2hvd0RpYWxvZyh0aGlzLCBlZGl0b3IsIHBvc1gsIHBvc1ksIG9wdGlvbnMpO1xuICB9XG4gIHNlbGVjdENvbW1lbnQocGFnZUluZGV4LCB1aWQpIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuI2FsbExheWVycy5nZXQocGFnZUluZGV4KTtcbiAgICBjb25zdCBlZGl0b3IgPSBsYXllcj8uZ2V0RWRpdG9yQnlVSUQodWlkKTtcbiAgICBlZGl0b3I/LnRvZ2dsZUNvbW1lbnQodHJ1ZSwgdHJ1ZSk7XG4gIH1cbiAgdXBkYXRlQ29tbWVudChlZGl0b3IpIHtcbiAgICB0aGlzLiNjb21tZW50TWFuYWdlcj8udXBkYXRlQ29tbWVudChlZGl0b3IuZ2V0RGF0YSgpKTtcbiAgfVxuICB1cGRhdGVQb3B1cENvbG9yKGVkaXRvcikge1xuICAgIHRoaXMuI2NvbW1lbnRNYW5hZ2VyPy51cGRhdGVQb3B1cENvbG9yKGVkaXRvcik7XG4gIH1cbiAgcmVtb3ZlQ29tbWVudChlZGl0b3IpIHtcbiAgICB0aGlzLiNjb21tZW50TWFuYWdlcj8ucmVtb3ZlQ29tbWVudHMoW2VkaXRvci51aWRdKTtcbiAgfVxuICB0b2dnbGVDb21tZW50KGVkaXRvciwgaXNTZWxlY3RlZCwgdmlzaWJpbGl0eSA9IHZvaWQgMCkge1xuICAgIHRoaXMuI2NvbW1lbnRNYW5hZ2VyPy50b2dnbGVDb21tZW50UG9wdXAoZWRpdG9yLCBpc1NlbGVjdGVkLCB2aXNpYmlsaXR5KTtcbiAgfVxuICBtYWtlQ29tbWVudENvbG9yKGNvbG9yLCBvcGFjaXR5KSB7XG4gICAgcmV0dXJuIGNvbG9yICYmIHRoaXMuI2NvbW1lbnRNYW5hZ2VyPy5tYWtlQ29tbWVudENvbG9yKGNvbG9yLCBvcGFjaXR5KSB8fCBudWxsO1xuICB9XG4gIGdldENvbW1lbnREaWFsb2dFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLiNjb21tZW50TWFuYWdlcj8uZGlhbG9nRWxlbWVudCB8fCBudWxsO1xuICB9XG4gIGFzeW5jIHdhaXRGb3JFZGl0b3JzUmVuZGVyZWQocGFnZU51bWJlcikge1xuICAgIGlmICh0aGlzLiNhbGxMYXllcnMuaGFzKHBhZ2VOdW1iZXIgLSAxKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICByZXNvbHZlLFxuICAgICAgcHJvbWlzZVxuICAgIH0gPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICBjb25zdCBvbkVkaXRvcnNSZW5kZXJlZCA9IChldnQpID0+IHtcbiAgICAgIGlmIChldnQucGFnZU51bWJlciA9PT0gcGFnZU51bWJlcikge1xuICAgICAgICB0aGlzLl9ldmVudEJ1cy5fb2ZmKFwiZWRpdG9yc3JlbmRlcmVkXCIsIG9uRWRpdG9yc1JlbmRlcmVkKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fZXZlbnRCdXMub24oXCJlZGl0b3JzcmVuZGVyZWRcIiwgb25FZGl0b3JzUmVuZGVyZWQpO1xuICAgIGF3YWl0IHByb21pc2U7XG4gIH1cbiAgZ2V0U2lnbmF0dXJlKGVkaXRvcikge1xuICAgIHRoaXMuI3NpZ25hdHVyZU1hbmFnZXI/LmdldFNpZ25hdHVyZSh7XG4gICAgICB1aU1hbmFnZXI6IHRoaXMsXG4gICAgICBlZGl0b3JcbiAgICB9KTtcbiAgfVxuICBnZXQgc2lnbmF0dXJlTWFuYWdlcigpIHtcbiAgICByZXR1cm4gdGhpcy4jc2lnbmF0dXJlTWFuYWdlcjtcbiAgfVxuICBzd2l0Y2hUb01vZGUobW9kZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl9ldmVudEJ1cy5vbihcImFubm90YXRpb25lZGl0b3Jtb2RlY2hhbmdlZFwiLCBjYWxsYmFjaywge1xuICAgICAgb25jZTogdHJ1ZSxcbiAgICAgIHNpZ25hbDogdGhpcy5fc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy5fZXZlbnRCdXMuZGlzcGF0Y2goXCJzaG93YW5ub3RhdGlvbmVkaXRvcnVpXCIsIHtcbiAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgIG1vZGVcbiAgICB9KTtcbiAgfVxuICBzZXRQcmVmZXJlbmNlKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5fZXZlbnRCdXMuZGlzcGF0Y2goXCJzZXRwcmVmZXJlbmNlXCIsIHtcbiAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgIG5hbWUsXG4gICAgICB2YWx1ZVxuICAgIH0pO1xuICB9XG4gIG9uU2V0UHJlZmVyZW5jZSh7XG4gICAgbmFtZSxcbiAgICB2YWx1ZVxuICB9KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlIFwiZW5hYmxlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZVwiOlxuICAgICAgICB0aGlzLiNlbmFibGVOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBvblBhZ2VDaGFuZ2luZyh7XG4gICAgcGFnZU51bWJlclxuICB9KSB7XG4gICAgdGhpcy4jY3VycmVudFBhZ2VJbmRleCA9IHBhZ2VOdW1iZXIgLSAxO1xuICB9XG4gIGZvY3VzTWFpbkNvbnRhaW5lcigpIHtcbiAgICB0aGlzLiNjb250YWluZXIuZm9jdXMoKTtcbiAgfVxuICBmaW5kUGFyZW50KHgsIHkpIHtcbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB4OiBsYXllclgsXG4gICAgICAgIHk6IGxheWVyWSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSA9IGxheWVyLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGlmICh4ID49IGxheWVyWCAmJiB4IDw9IGxheWVyWCArIHdpZHRoICYmIHkgPj0gbGF5ZXJZICYmIHkgPD0gbGF5ZXJZICsgaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBsYXllcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZGlzYWJsZVVzZXJTZWxlY3QodmFsdWUgPSBmYWxzZSkge1xuICAgIHRoaXMuI3ZpZXdlci5jbGFzc0xpc3QudG9nZ2xlKFwibm9Vc2VyU2VsZWN0XCIsIHZhbHVlKTtcbiAgfVxuICBhZGRTaG91bGRSZXNjYWxlKGVkaXRvcikge1xuICAgIHRoaXMuI2VkaXRvcnNUb1Jlc2NhbGUuYWRkKGVkaXRvcik7XG4gIH1cbiAgcmVtb3ZlU2hvdWxkUmVzY2FsZShlZGl0b3IpIHtcbiAgICB0aGlzLiNlZGl0b3JzVG9SZXNjYWxlLmRlbGV0ZShlZGl0b3IpO1xuICB9XG4gIG9uU2NhbGVDaGFuZ2luZyh7XG4gICAgc2NhbGVcbiAgfSkge1xuICAgIHRoaXMuY29tbWl0T3JSZW1vdmUoKTtcbiAgICB0aGlzLnZpZXdQYXJhbWV0ZXJzLnJlYWxTY2FsZSA9IHNjYWxlICogUGl4ZWxzUGVySW5jaC5QREZfVE9fQ1NTX1VOSVRTO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnNUb1Jlc2NhbGUpIHtcbiAgICAgIGVkaXRvci5vblNjYWxlQ2hhbmdpbmcoKTtcbiAgICB9XG4gICAgdGhpcy4jY3VycmVudERyYXdpbmdTZXNzaW9uPy5vblNjYWxlQ2hhbmdpbmcoKTtcbiAgfVxuICBvblJvdGF0aW9uQ2hhbmdpbmcoe1xuICAgIHBhZ2VzUm90YXRpb25cbiAgfSkge1xuICAgIHRoaXMuY29tbWl0T3JSZW1vdmUoKTtcbiAgICB0aGlzLnZpZXdQYXJhbWV0ZXJzLnJvdGF0aW9uID0gcGFnZXNSb3RhdGlvbjtcbiAgfVxuICAjZ2V0QW5jaG9yRWxlbWVudEZvclNlbGVjdGlvbih7XG4gICAgYW5jaG9yTm9kZVxuICB9KSB7XG4gICAgcmV0dXJuIGFuY2hvck5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFID8gYW5jaG9yTm9kZS5wYXJlbnRFbGVtZW50IDogYW5jaG9yTm9kZTtcbiAgfVxuICAjZ2V0TGF5ZXJGb3JUZXh0TGF5ZXIodGV4dExheWVyKSB7XG4gICAgY29uc3Qge1xuICAgICAgY3VycmVudExheWVyXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGN1cnJlbnRMYXllci5oYXNUZXh0TGF5ZXIodGV4dExheWVyKSkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRMYXllcjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChsYXllci5oYXNUZXh0TGF5ZXIodGV4dExheWVyKSkge1xuICAgICAgICByZXR1cm4gbGF5ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGhpZ2hsaWdodFNlbGVjdGlvbihtZXRob2RPZkNyZWF0aW9uID0gXCJcIiwgY29tbWVudCA9IGZhbHNlKSB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGFuY2hvck5vZGUsXG4gICAgICBhbmNob3JPZmZzZXQsXG4gICAgICBmb2N1c05vZGUsXG4gICAgICBmb2N1c09mZnNldFxuICAgIH0gPSBzZWxlY3Rpb247XG4gICAgY29uc3QgdGV4dCA9IHNlbGVjdGlvbi50b1N0cmluZygpO1xuICAgIGNvbnN0IGFuY2hvckVsZW1lbnQgPSB0aGlzLiNnZXRBbmNob3JFbGVtZW50Rm9yU2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgY29uc3QgdGV4dExheWVyID0gYW5jaG9yRWxlbWVudC5jbG9zZXN0KFwiLnRleHRMYXllclwiKTtcbiAgICBjb25zdCBib3hlcyA9IHRoaXMuZ2V0U2VsZWN0aW9uQm94ZXModGV4dExheWVyKTtcbiAgICBpZiAoIWJveGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNlbGVjdGlvbi5lbXB0eSgpO1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy4jZ2V0TGF5ZXJGb3JUZXh0TGF5ZXIodGV4dExheWVyKTtcbiAgICBjb25zdCBpc05vbmVNb2RlID0gdGhpcy4jbW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORTtcbiAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGVkaXRvciA9IGxheWVyPy5jcmVhdGVBbmRBZGROZXdFZGl0b3Ioe1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9LCBmYWxzZSwge1xuICAgICAgICBtZXRob2RPZkNyZWF0aW9uLFxuICAgICAgICBib3hlcyxcbiAgICAgICAgYW5jaG9yTm9kZSxcbiAgICAgICAgYW5jaG9yT2Zmc2V0LFxuICAgICAgICBmb2N1c05vZGUsXG4gICAgICAgIGZvY3VzT2Zmc2V0LFxuICAgICAgICB0ZXh0XG4gICAgICB9KTtcbiAgICAgIGlmIChpc05vbmVNb2RlKSB7XG4gICAgICAgIHRoaXMuc2hvd0FsbEVkaXRvcnMoXCJoaWdobGlnaHRcIiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoY29tbWVudCkge1xuICAgICAgICBlZGl0b3I/LmVkaXRDb21tZW50KCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNOb25lTW9kZSkge1xuICAgICAgdGhpcy5zd2l0Y2hUb01vZGUoQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hULCBjYWxsYmFjayk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrKCk7XG4gIH1cbiAgY29tbWVudFNlbGVjdGlvbihtZXRob2RPZkNyZWF0aW9uID0gXCJcIikge1xuICAgIHRoaXMuaGlnaGxpZ2h0U2VsZWN0aW9uKG1ldGhvZE9mQ3JlYXRpb24sIHRydWUpO1xuICB9XG4gICNkaXNwbGF5RmxvYXRpbmdUb29sYmFyKCkge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xuICAgIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5pc0NvbGxhcHNlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhbmNob3JFbGVtZW50ID0gdGhpcy4jZ2V0QW5jaG9yRWxlbWVudEZvclNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIGNvbnN0IHRleHRMYXllciA9IGFuY2hvckVsZW1lbnQuY2xvc2VzdChcIi50ZXh0TGF5ZXJcIik7XG4gICAgY29uc3QgYm94ZXMgPSB0aGlzLmdldFNlbGVjdGlvbkJveGVzKHRleHRMYXllcik7XG4gICAgaWYgKCFib3hlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNmbG9hdGluZ1Rvb2xiYXIgfHw9IG5ldyBGbG9hdGluZ1Rvb2xiYXIodGhpcyk7XG4gICAgdGhpcy4jZmxvYXRpbmdUb29sYmFyLnNob3codGV4dExheWVyLCBib3hlcywgdGhpcy5kaXJlY3Rpb24gPT09IFwibHRyXCIpO1xuICB9XG4gIGdldEFuZFJlbW92ZURhdGFGcm9tQW5ub3RhdGlvblN0b3JhZ2UoYW5ub3RhdGlvbklkKSB7XG4gICAgaWYgKCF0aGlzLiNhbm5vdGF0aW9uU3RvcmFnZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IGAke0Fubm90YXRpb25FZGl0b3JQcmVmaXh9JHthbm5vdGF0aW9uSWR9YDtcbiAgICBjb25zdCBzdG9yZWRWYWx1ZSA9IHRoaXMuI2Fubm90YXRpb25TdG9yYWdlLmdldFJhd1ZhbHVlKGtleSk7XG4gICAgaWYgKHN0b3JlZFZhbHVlKSB7XG4gICAgICB0aGlzLiNhbm5vdGF0aW9uU3RvcmFnZS5yZW1vdmUoa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHN0b3JlZFZhbHVlO1xuICB9XG4gIGFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoZWRpdG9yKSB7XG4gICAgaWYgKCFlZGl0b3IuaXNFbXB0eSgpICYmIHRoaXMuI2Fubm90YXRpb25TdG9yYWdlICYmICF0aGlzLiNhbm5vdGF0aW9uU3RvcmFnZS5oYXMoZWRpdG9yLmlkKSkge1xuICAgICAgdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUoZWRpdG9yLmlkLCBlZGl0b3IpO1xuICAgIH1cbiAgfVxuICBhMTF5QWxlcnQobWVzc2FnZUlkLCBhcmdzID0gbnVsbCkge1xuICAgIGNvbnN0IHZpZXdlckFsZXJ0ID0gdGhpcy4jdmlld2VyQWxlcnQ7XG4gICAgaWYgKCF2aWV3ZXJBbGVydCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2aWV3ZXJBbGVydC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgbWVzc2FnZUlkKTtcbiAgICBpZiAoYXJncykge1xuICAgICAgdmlld2VyQWxlcnQuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWFyZ3NcIiwgSlNPTi5zdHJpbmdpZnkoYXJncykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2aWV3ZXJBbGVydC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLWwxMG4tYXJnc1wiKTtcbiAgICB9XG4gIH1cbiAgI3NlbGVjdGlvbkNoYW5nZSgpIHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb24uaXNDb2xsYXBzZWQpIHtcbiAgICAgIGlmICh0aGlzLiNzZWxlY3RlZFRleHROb2RlKSB7XG4gICAgICAgIHRoaXMuI2Zsb2F0aW5nVG9vbGJhcj8uaGlkZSgpO1xuICAgICAgICB0aGlzLiNzZWxlY3RlZFRleHROb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgICAgIGhhc1NlbGVjdGVkVGV4dDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGFuY2hvck5vZGVcbiAgICB9ID0gc2VsZWN0aW9uO1xuICAgIGlmIChhbmNob3JOb2RlID09PSB0aGlzLiNzZWxlY3RlZFRleHROb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFuY2hvckVsZW1lbnQgPSB0aGlzLiNnZXRBbmNob3JFbGVtZW50Rm9yU2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgY29uc3QgdGV4dExheWVyID0gYW5jaG9yRWxlbWVudC5jbG9zZXN0KFwiLnRleHRMYXllclwiKTtcbiAgICBpZiAoIXRleHRMYXllcikge1xuICAgICAgaWYgKHRoaXMuI3NlbGVjdGVkVGV4dE5vZGUpIHtcbiAgICAgICAgdGhpcy4jZmxvYXRpbmdUb29sYmFyPy5oaWRlKCk7XG4gICAgICAgIHRoaXMuI3NlbGVjdGVkVGV4dE5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICAgICAgaGFzU2VsZWN0ZWRUZXh0OiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jZmxvYXRpbmdUb29sYmFyPy5oaWRlKCk7XG4gICAgdGhpcy4jc2VsZWN0ZWRUZXh0Tm9kZSA9IGFuY2hvck5vZGU7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRUZXh0OiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKHRoaXMuI21vZGUgIT09IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVCAmJiB0aGlzLiNtb2RlICE9PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiNtb2RlID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQpIHtcbiAgICAgIHRoaXMuc2hvd0FsbEVkaXRvcnMoXCJoaWdobGlnaHRcIiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIHRoaXMuI2hpZ2hsaWdodFdoZW5TaGlmdFVwID0gdGhpcy5pc1NoaWZ0S2V5RG93bjtcbiAgICBpZiAoIXRoaXMuaXNTaGlmdEtleURvd24pIHtcbiAgICAgIGNvbnN0IGFjdGl2ZUxheWVyID0gdGhpcy4jbW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hUID8gdGhpcy4jZ2V0TGF5ZXJGb3JUZXh0TGF5ZXIodGV4dExheWVyKSA6IG51bGw7XG4gICAgICBhY3RpdmVMYXllcj8udG9nZ2xlRHJhd2luZygpO1xuICAgICAgaWYgKHRoaXMuI2lzUG9pbnRlckRvd24pIHtcbiAgICAgICAgY29uc3QgYWMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuY29tYmluZWRTaWduYWwoYWMpO1xuICAgICAgICBjb25zdCBwb2ludGVydXAgPSAoZSkgPT4ge1xuICAgICAgICAgIGlmIChlLnR5cGUgPT09IFwicG9pbnRlcnVwXCIgJiYgZS5idXR0b24gIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWMuYWJvcnQoKTtcbiAgICAgICAgICBhY3RpdmVMYXllcj8udG9nZ2xlRHJhd2luZyh0cnVlKTtcbiAgICAgICAgICBpZiAoZS50eXBlID09PSBcInBvaW50ZXJ1cFwiKSB7XG4gICAgICAgICAgICB0aGlzLiNvblNlbGVjdEVuZChcIm1haW5fdG9vbGJhclwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHBvaW50ZXJ1cCwge1xuICAgICAgICAgIHNpZ25hbFxuICAgICAgICB9KTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHBvaW50ZXJ1cCwge1xuICAgICAgICAgIHNpZ25hbFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2ZUxheWVyPy50b2dnbGVEcmF3aW5nKHRydWUpO1xuICAgICAgICB0aGlzLiNvblNlbGVjdEVuZChcIm1haW5fdG9vbGJhclwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgI29uU2VsZWN0RW5kKG1ldGhvZE9mQ3JlYXRpb24gPSBcIlwiKSB7XG4gICAgaWYgKHRoaXMuI21vZGUgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVCkge1xuICAgICAgdGhpcy5oaWdobGlnaHRTZWxlY3Rpb24obWV0aG9kT2ZDcmVhdGlvbik7XG4gICAgfSBlbHNlIGlmICh0aGlzLiNlbmFibGVIaWdobGlnaHRGbG9hdGluZ0J1dHRvbikge1xuICAgICAgdGhpcy4jZGlzcGxheUZsb2F0aW5nVG9vbGJhcigpO1xuICAgIH1cbiAgfVxuICAjYWRkU2VsZWN0aW9uTGlzdGVuZXIoKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB0aGlzLiNzZWxlY3Rpb25DaGFuZ2UuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsOiB0aGlzLl9zaWduYWxcbiAgICB9KTtcbiAgfVxuICAjYWRkRm9jdXNNYW5hZ2VyKCkge1xuICAgIGlmICh0aGlzLiNmb2N1c01hbmFnZXJBQykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNmb2N1c01hbmFnZXJBQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLmNvbWJpbmVkU2lnbmFsKHRoaXMuI2ZvY3VzTWFuYWdlckFDKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuZm9jdXMuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMuYmx1ci5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgfVxuICAjcmVtb3ZlRm9jdXNNYW5hZ2VyKCkge1xuICAgIHRoaXMuI2ZvY3VzTWFuYWdlckFDPy5hYm9ydCgpO1xuICAgIHRoaXMuI2ZvY3VzTWFuYWdlckFDID0gbnVsbDtcbiAgfVxuICBibHVyKCkge1xuICAgIHRoaXMuaXNTaGlmdEtleURvd24gPSBmYWxzZTtcbiAgICBpZiAodGhpcy4jaGlnaGxpZ2h0V2hlblNoaWZ0VXApIHtcbiAgICAgIHRoaXMuI2hpZ2hsaWdodFdoZW5TaGlmdFVwID0gZmFsc2U7XG4gICAgICB0aGlzLiNvblNlbGVjdEVuZChcIm1haW5fdG9vbGJhclwiKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmhhc1NlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhY3RpdmVFbGVtZW50XG4gICAgfSA9IGRvY3VtZW50O1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgaWYgKGVkaXRvci5kaXYuY29udGFpbnMoYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgdGhpcy4jbGFzdEFjdGl2ZUVsZW1lbnQgPSBbZWRpdG9yLCBhY3RpdmVFbGVtZW50XTtcbiAgICAgICAgZWRpdG9yLl9mb2N1c0V2ZW50c0FsbG93ZWQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvY3VzKCkge1xuICAgIGlmICghdGhpcy4jbGFzdEFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgW2xhc3RFZGl0b3IsIGxhc3RBY3RpdmVFbGVtZW50XSA9IHRoaXMuI2xhc3RBY3RpdmVFbGVtZW50O1xuICAgIHRoaXMuI2xhc3RBY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgICBsYXN0QWN0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCAoKSA9PiB7XG4gICAgICBsYXN0RWRpdG9yLl9mb2N1c0V2ZW50c0FsbG93ZWQgPSB0cnVlO1xuICAgIH0sIHtcbiAgICAgIG9uY2U6IHRydWUsXG4gICAgICBzaWduYWw6IHRoaXMuX3NpZ25hbFxuICAgIH0pO1xuICAgIGxhc3RBY3RpdmVFbGVtZW50LmZvY3VzKCk7XG4gIH1cbiAgI2FkZEtleWJvYXJkTWFuYWdlcigpIHtcbiAgICBpZiAodGhpcy4ja2V5Ym9hcmRNYW5hZ2VyQUMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4ja2V5Ym9hcmRNYW5hZ2VyQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5jb21iaW5lZFNpZ25hbCh0aGlzLiNrZXlib2FyZE1hbmFnZXJBQyk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMua2V5ZG93bi5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIHRoaXMua2V5dXAuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgI3JlbW92ZUtleWJvYXJkTWFuYWdlcigpIHtcbiAgICB0aGlzLiNrZXlib2FyZE1hbmFnZXJBQz8uYWJvcnQoKTtcbiAgICB0aGlzLiNrZXlib2FyZE1hbmFnZXJBQyA9IG51bGw7XG4gIH1cbiAgI2FkZENvcHlQYXN0ZUxpc3RlbmVycygpIHtcbiAgICBpZiAodGhpcy4jY29weVBhc3RlQUMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY29weVBhc3RlQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5jb21iaW5lZFNpZ25hbCh0aGlzLiNjb3B5UGFzdGVBQyk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNvcHlcIiwgdGhpcy5jb3B5LmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjdXRcIiwgdGhpcy5jdXQuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBhc3RlXCIsIHRoaXMucGFzdGUuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgI3JlbW92ZUNvcHlQYXN0ZUxpc3RlbmVycygpIHtcbiAgICB0aGlzLiNjb3B5UGFzdGVBQz8uYWJvcnQoKTtcbiAgICB0aGlzLiNjb3B5UGFzdGVBQyA9IG51bGw7XG4gIH1cbiAgI2FkZERyYWdBbmREcm9wTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3NpZ25hbDtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ292ZXJcIiwgdGhpcy5kcmFnT3Zlci5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiZHJvcFwiLCB0aGlzLmRyb3AuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgYWRkRWRpdExpc3RlbmVycygpIHtcbiAgICB0aGlzLiNhZGRLZXlib2FyZE1hbmFnZXIoKTtcbiAgICB0aGlzLiNhZGRDb3B5UGFzdGVMaXN0ZW5lcnMoKTtcbiAgfVxuICByZW1vdmVFZGl0TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuI3JlbW92ZUtleWJvYXJkTWFuYWdlcigpO1xuICAgIHRoaXMuI3JlbW92ZUNvcHlQYXN0ZUxpc3RlbmVycygpO1xuICB9XG4gIGRyYWdPdmVyKGV2ZW50KSB7XG4gICAgZm9yIChjb25zdCB7XG4gICAgICB0eXBlXG4gICAgfSBvZiBldmVudC5kYXRhVHJhbnNmZXIuaXRlbXMpIHtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yVHlwZSBvZiB0aGlzLiNlZGl0b3JUeXBlcykge1xuICAgICAgICBpZiAoZWRpdG9yVHlwZS5pc0hhbmRsaW5nTWltZUZvclBhc3RpbmcodHlwZSkpIHtcbiAgICAgICAgICBldmVudC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IFwiY29weVwiO1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRyb3AoZXZlbnQpIHtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgZXZlbnQuZGF0YVRyYW5zZmVyLml0ZW1zKSB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgdGhpcy4jZWRpdG9yVHlwZXMpIHtcbiAgICAgICAgaWYgKGVkaXRvclR5cGUuaXNIYW5kbGluZ01pbWVGb3JQYXN0aW5nKGl0ZW0udHlwZSkpIHtcbiAgICAgICAgICBlZGl0b3JUeXBlLnBhc3RlKGl0ZW0sIHRoaXMuY3VycmVudExheWVyKTtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb3B5KGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLiNhY3RpdmVFZGl0b3I/LmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgaWYgKCF0aGlzLmhhc1NlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlZGl0b3JzID0gW107XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICBjb25zdCBzZXJpYWxpemVkID0gZWRpdG9yLnNlcmlhbGl6ZSh0cnVlKTtcbiAgICAgIGlmIChzZXJpYWxpemVkKSB7XG4gICAgICAgIGVkaXRvcnMucHVzaChzZXJpYWxpemVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVkaXRvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50LmNsaXBib2FyZERhdGEuc2V0RGF0YShcImFwcGxpY2F0aW9uL3BkZmpzXCIsIEpTT04uc3RyaW5naWZ5KGVkaXRvcnMpKTtcbiAgfVxuICBjdXQoZXZlbnQpIHtcbiAgICB0aGlzLmNvcHkoZXZlbnQpO1xuICAgIHRoaXMuZGVsZXRlKCk7XG4gIH1cbiAgYXN5bmMgcGFzdGUoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGNsaXBib2FyZERhdGFcbiAgICB9ID0gZXZlbnQ7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGNsaXBib2FyZERhdGEuaXRlbXMpIHtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yVHlwZSBvZiB0aGlzLiNlZGl0b3JUeXBlcykge1xuICAgICAgICBpZiAoZWRpdG9yVHlwZS5pc0hhbmRsaW5nTWltZUZvclBhc3RpbmcoaXRlbS50eXBlKSkge1xuICAgICAgICAgIGVkaXRvclR5cGUucGFzdGUoaXRlbSwgdGhpcy5jdXJyZW50TGF5ZXIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBsZXQgZGF0YSA9IGNsaXBib2FyZERhdGEuZ2V0RGF0YShcImFwcGxpY2F0aW9uL3BkZmpzXCIpO1xuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHdhcm4oYHBhc3RlOiBcIiR7ZXgubWVzc2FnZX1cIi5gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudW5zZWxlY3RBbGwoKTtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuY3VycmVudExheWVyO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBuZXdFZGl0b3JzID0gW107XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGRlc2VyaWFsaXplZEVkaXRvciA9IGF3YWl0IGxheWVyLmRlc2VyaWFsaXplKGVkaXRvcik7XG4gICAgICAgIGlmICghZGVzZXJpYWxpemVkRWRpdG9yKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5ld0VkaXRvcnMucHVzaChkZXNlcmlhbGl6ZWRFZGl0b3IpO1xuICAgICAgfVxuICAgICAgY29uc3QgY21kID0gKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBuZXdFZGl0b3JzKSB7XG4gICAgICAgICAgdGhpcy4jYWRkRWRpdG9yVG9MYXllcihlZGl0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3NlbGVjdEVkaXRvcnMobmV3RWRpdG9ycyk7XG4gICAgICB9O1xuICAgICAgY29uc3QgdW5kbyA9ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgbmV3RWRpdG9ycykge1xuICAgICAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgICBjbWQsXG4gICAgICAgIHVuZG8sXG4gICAgICAgIG11c3RFeGVjOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgd2FybihgcGFzdGU6IFwiJHtleC5tZXNzYWdlfVwiLmApO1xuICAgIH1cbiAgfVxuICBrZXlkb3duKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmlzU2hpZnRLZXlEb3duICYmIGV2ZW50LmtleSA9PT0gXCJTaGlmdFwiKSB7XG4gICAgICB0aGlzLmlzU2hpZnRLZXlEb3duID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI21vZGUgIT09IEFubm90YXRpb25FZGl0b3JUeXBlLk5PTkUgJiYgIXRoaXMuaXNFZGl0b3JIYW5kbGluZ0tleWJvYXJkKSB7XG4gICAgICBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLl9rZXlib2FyZE1hbmFnZXIuZXhlYyh0aGlzLCBldmVudCk7XG4gICAgfVxuICB9XG4gIGtleXVwKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuaXNTaGlmdEtleURvd24gJiYgZXZlbnQua2V5ID09PSBcIlNoaWZ0XCIpIHtcbiAgICAgIHRoaXMuaXNTaGlmdEtleURvd24gPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLiNoaWdobGlnaHRXaGVuU2hpZnRVcCkge1xuICAgICAgICB0aGlzLiNoaWdobGlnaHRXaGVuU2hpZnRVcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNvblNlbGVjdEVuZChcIm1haW5fdG9vbGJhclwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgb25FZGl0aW5nQWN0aW9uKHtcbiAgICBuYW1lXG4gIH0pIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgXCJ1bmRvXCI6XG4gICAgICBjYXNlIFwicmVkb1wiOlxuICAgICAgY2FzZSBcImRlbGV0ZVwiOlxuICAgICAgY2FzZSBcInNlbGVjdEFsbFwiOlxuICAgICAgICB0aGlzW25hbWVdKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImhpZ2hsaWdodFNlbGVjdGlvblwiOlxuICAgICAgICB0aGlzLmhpZ2hsaWdodFNlbGVjdGlvbihcImNvbnRleHRfbWVudVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiY29tbWVudFNlbGVjdGlvblwiOlxuICAgICAgICB0aGlzLmNvbW1lbnRTZWxlY3Rpb24oXCJjb250ZXh0X21lbnVcIik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAjZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoZGV0YWlscykge1xuICAgIGNvbnN0IGhhc0NoYW5nZWQgPSBPYmplY3QuZW50cmllcyhkZXRhaWxzKS5zb21lKChba2V5LCB2YWx1ZV0pID0+IHRoaXMuI3ByZXZpb3VzU3RhdGVzW2tleV0gIT09IHZhbHVlKTtcbiAgICBpZiAoaGFzQ2hhbmdlZCkge1xuICAgICAgdGhpcy5fZXZlbnRCdXMuZGlzcGF0Y2goXCJhbm5vdGF0aW9uZWRpdG9yc3RhdGVzY2hhbmdlZFwiLCB7XG4gICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgZGV0YWlsczogT2JqZWN0LmFzc2lnbih0aGlzLiNwcmV2aW91c1N0YXRlcywgZGV0YWlscylcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMuI21vZGUgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVCAmJiBkZXRhaWxzLmhhc1NlbGVjdGVkRWRpdG9yID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVVJKFtbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX0ZSRUUsIHRydWVdXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gICNkaXNwYXRjaFVwZGF0ZVVJKGRldGFpbHMpIHtcbiAgICB0aGlzLl9ldmVudEJ1cy5kaXNwYXRjaChcImFubm90YXRpb25lZGl0b3JwYXJhbXNjaGFuZ2VkXCIsIHtcbiAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgIGRldGFpbHNcbiAgICB9KTtcbiAgfVxuICBzZXRFZGl0aW5nU3RhdGUoaXNFZGl0aW5nKSB7XG4gICAgaWYgKGlzRWRpdGluZykge1xuICAgICAgdGhpcy4jYWRkRm9jdXNNYW5hZ2VyKCk7XG4gICAgICB0aGlzLiNhZGRDb3B5UGFzdGVMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgICAgaXNFZGl0aW5nOiB0aGlzLiNtb2RlICE9PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FLFxuICAgICAgICBpc0VtcHR5OiB0aGlzLiNpc0VtcHR5KCksXG4gICAgICAgIGhhc1NvbWV0aGluZ1RvVW5kbzogdGhpcy4jY29tbWFuZE1hbmFnZXIuaGFzU29tZXRoaW5nVG9VbmRvKCksXG4gICAgICAgIGhhc1NvbWV0aGluZ1RvUmVkbzogdGhpcy4jY29tbWFuZE1hbmFnZXIuaGFzU29tZXRoaW5nVG9SZWRvKCksXG4gICAgICAgIGhhc1NlbGVjdGVkRWRpdG9yOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI3JlbW92ZUZvY3VzTWFuYWdlcigpO1xuICAgICAgdGhpcy4jcmVtb3ZlQ29weVBhc3RlTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICAgIGlzRWRpdGluZzogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgdGhpcy5kaXNhYmxlVXNlclNlbGVjdChmYWxzZSk7XG4gICAgfVxuICB9XG4gIHJlZ2lzdGVyRWRpdG9yVHlwZXModHlwZXMpIHtcbiAgICBpZiAodGhpcy4jZWRpdG9yVHlwZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jZWRpdG9yVHlwZXMgPSB0eXBlcztcbiAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgdGhpcy4jZWRpdG9yVHlwZXMpIHtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoZWRpdG9yVHlwZS5kZWZhdWx0UHJvcGVydGllc1RvVXBkYXRlKTtcbiAgICB9XG4gIH1cbiAgZ2V0SWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2lkTWFuYWdlci5pZDtcbiAgfVxuICBnZXQgY3VycmVudExheWVyKCkge1xuICAgIHJldHVybiB0aGlzLiNhbGxMYXllcnMuZ2V0KHRoaXMuI2N1cnJlbnRQYWdlSW5kZXgpO1xuICB9XG4gIGdldExheWVyKHBhZ2VJbmRleCkge1xuICAgIHJldHVybiB0aGlzLiNhbGxMYXllcnMuZ2V0KHBhZ2VJbmRleCk7XG4gIH1cbiAgZ2V0IGN1cnJlbnRQYWdlSW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2N1cnJlbnRQYWdlSW5kZXg7XG4gIH1cbiAgYWRkTGF5ZXIobGF5ZXIpIHtcbiAgICB0aGlzLiNhbGxMYXllcnMuc2V0KGxheWVyLnBhZ2VJbmRleCwgbGF5ZXIpO1xuICAgIGlmICh0aGlzLiNpc0VuYWJsZWQpIHtcbiAgICAgIGxheWVyLmVuYWJsZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXllci5kaXNhYmxlKCk7XG4gICAgfVxuICB9XG4gIHJlbW92ZUxheWVyKGxheWVyKSB7XG4gICAgdGhpcy4jYWxsTGF5ZXJzLmRlbGV0ZShsYXllci5wYWdlSW5kZXgpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZU1vZGUobW9kZSwgZWRpdElkID0gbnVsbCwgaXNGcm9tS2V5Ym9hcmQgPSBmYWxzZSwgbXVzdEVudGVySW5FZGl0TW9kZSA9IGZhbHNlLCBlZGl0Q29tbWVudCA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuI21vZGUgPT09IG1vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI3VwZGF0ZU1vZGVDYXBhYmlsaXR5KSB7XG4gICAgICBhd2FpdCB0aGlzLiN1cGRhdGVNb2RlQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgICAgaWYgKCF0aGlzLiN1cGRhdGVNb2RlQ2FwYWJpbGl0eSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI3VwZGF0ZU1vZGVDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy4jY3VycmVudERyYXdpbmdTZXNzaW9uPy5jb21taXRPclJlbW92ZSgpO1xuICAgIGlmICh0aGlzLiNtb2RlID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5QT1BVUCkge1xuICAgICAgdGhpcy4jY29tbWVudE1hbmFnZXI/LmhpZGVTaWRlYmFyKCk7XG4gICAgfVxuICAgIHRoaXMuI2NvbW1lbnRNYW5hZ2VyPy5kZXN0cm95UG9wdXAoKTtcbiAgICB0aGlzLiNtb2RlID0gbW9kZTtcbiAgICBpZiAobW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORSkge1xuICAgICAgdGhpcy5zZXRFZGl0aW5nU3RhdGUoZmFsc2UpO1xuICAgICAgdGhpcy4jZGlzYWJsZUFsbCgpO1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jYWxsRWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgICBlZGl0b3IuaGlkZVN0YW5kYWxvbmVDb21tZW50QnV0dG9uKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9lZGl0b3JVbmRvQmFyPy5oaWRlKCk7XG4gICAgICB0aGlzLnRvZ2dsZUNvbW1lbnQobnVsbCk7XG4gICAgICB0aGlzLiN1cGRhdGVNb2RlQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIGVkaXRvci5hZGRTdGFuZGFsb25lQ29tbWVudEJ1dHRvbigpO1xuICAgIH1cbiAgICBpZiAobW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuU0lHTkFUVVJFKSB7XG4gICAgICBhd2FpdCB0aGlzLiNzaWduYXR1cmVNYW5hZ2VyPy5sb2FkU2lnbmF0dXJlcygpO1xuICAgIH1cbiAgICB0aGlzLnNldEVkaXRpbmdTdGF0ZSh0cnVlKTtcbiAgICBhd2FpdCB0aGlzLiNlbmFibGVBbGwoKTtcbiAgICB0aGlzLnVuc2VsZWN0QWxsKCk7XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgIGxheWVyLnVwZGF0ZU1vZGUobW9kZSk7XG4gICAgfVxuICAgIGlmIChtb2RlID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5QT1BVUCkge1xuICAgICAgdGhpcy4jYWxsRWRpdGFibGVBbm5vdGF0aW9ucyB8fD0gYXdhaXQgdGhpcy4jcGRmRG9jdW1lbnQuZ2V0QW5ub3RhdGlvbnNCeVR5cGUobmV3IFNldCh0aGlzLiNlZGl0b3JUeXBlcy5tYXAoKGVkaXRvckNsYXNzKSA9PiBlZGl0b3JDbGFzcy5fZWRpdG9yVHlwZSkpKTtcbiAgICAgIGNvbnN0IGVsZW1lbnRJZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgY29uc3QgYWxsQ29tbWVudHMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGFubm90YXRpb25FbGVtZW50SWQsXG4gICAgICAgICAgaGFzQ29tbWVudCxcbiAgICAgICAgICBkZWxldGVkXG4gICAgICAgIH0gPSBlZGl0b3I7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICAgICAgZWxlbWVudElkcy5hZGQoYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0NvbW1lbnQgJiYgIWRlbGV0ZWQpIHtcbiAgICAgICAgICBhbGxDb21tZW50cy5wdXNoKGVkaXRvci5nZXREYXRhKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGFubm90YXRpb24gb2YgdGhpcy4jYWxsRWRpdGFibGVBbm5vdGF0aW9ucykge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgcG9wdXBSZWYsXG4gICAgICAgICAgY29udGVudHNPYmpcbiAgICAgICAgfSA9IGFubm90YXRpb247XG4gICAgICAgIGlmIChwb3B1cFJlZiAmJiBjb250ZW50c09iaj8uc3RyICYmICFlbGVtZW50SWRzLmhhcyhpZCkgJiYgIXRoaXMuI2RlbGV0ZWRBbm5vdGF0aW9uc0VsZW1lbnRJZHMuaGFzKGlkKSkge1xuICAgICAgICAgIGFsbENvbW1lbnRzLnB1c2goYW5ub3RhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuI2NvbW1lbnRNYW5hZ2VyPy5zaG93U2lkZWJhcihhbGxDb21tZW50cyk7XG4gICAgfVxuICAgIGlmICghZWRpdElkKSB7XG4gICAgICBpZiAoaXNGcm9tS2V5Ym9hcmQpIHtcbiAgICAgICAgdGhpcy5hZGROZXdFZGl0b3JGcm9tS2V5Ym9hcmQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3VwZGF0ZU1vZGVDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jYWxsRWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGVkaXRvci51aWQgPT09IGVkaXRJZCkge1xuICAgICAgICB0aGlzLnNldFNlbGVjdGVkKGVkaXRvcik7XG4gICAgICAgIGlmIChlZGl0Q29tbWVudCkge1xuICAgICAgICAgIGVkaXRvci5lZGl0Q29tbWVudCgpO1xuICAgICAgICB9IGVsc2UgaWYgKG11c3RFbnRlckluRWRpdE1vZGUpIHtcbiAgICAgICAgICBlZGl0b3IuZW50ZXJJbkVkaXRNb2RlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWRpdG9yLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkaXRvci51bnNlbGVjdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiN1cGRhdGVNb2RlQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gIH1cbiAgYWRkTmV3RWRpdG9yRnJvbUtleWJvYXJkKCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRMYXllci5jYW5DcmVhdGVOZXdFbXB0eUVkaXRvcigpKSB7XG4gICAgICB0aGlzLmN1cnJlbnRMYXllci5hZGROZXdFZGl0b3IoKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlVG9vbGJhcihvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMubW9kZSA9PT0gdGhpcy4jbW9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9ldmVudEJ1cy5kaXNwYXRjaChcInN3aXRjaGFubm90YXRpb25lZGl0b3Jtb2RlXCIsIHtcbiAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVQYXJhbXModHlwZSwgdmFsdWUpIHtcbiAgICBpZiAoIXRoaXMuI2VkaXRvclR5cGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5DUkVBVEU6XG4gICAgICAgIHRoaXMuY3VycmVudExheWVyLmFkZE5ld0VkaXRvcih2YWx1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX1NIT1dfQUxMOlxuICAgICAgICB0aGlzLl9ldmVudEJ1cy5kaXNwYXRjaChcInJlcG9ydHRlbGVtZXRyeVwiLCB7XG4gICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZWRpdGluZ1wiLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICB0eXBlOiBcImhpZ2hsaWdodFwiLFxuICAgICAgICAgICAgICBhY3Rpb246IFwidG9nZ2xlX3Zpc2liaWxpdHlcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgICh0aGlzLiNzaG93QWxsU3RhdGVzIHx8PSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKS5zZXQodHlwZSwgdmFsdWUpO1xuICAgICAgICB0aGlzLnNob3dBbGxFZGl0b3JzKFwiaGlnaGxpZ2h0XCIsIHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0aGlzLmhhc1NlbGVjdGlvbikge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICAgIGVkaXRvci51cGRhdGVQYXJhbXModHlwZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgdGhpcy4jZWRpdG9yVHlwZXMpIHtcbiAgICAgICAgZWRpdG9yVHlwZS51cGRhdGVEZWZhdWx0UGFyYW1zKHR5cGUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2hvd0FsbEVkaXRvcnModHlwZSwgdmlzaWJsZSwgdXBkYXRlQnV0dG9uID0gZmFsc2UpIHtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICBpZiAoZWRpdG9yLmVkaXRvclR5cGUgPT09IHR5cGUpIHtcbiAgICAgICAgZWRpdG9yLnNob3codmlzaWJsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy4jc2hvd0FsbFN0YXRlcz8uZ2V0KEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9TSE9XX0FMTCkgPz8gdHJ1ZTtcbiAgICBpZiAoc3RhdGUgIT09IHZpc2libGUpIHtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoW1tBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfU0hPV19BTEwsIHZpc2libGVdXSk7XG4gICAgfVxuICB9XG4gIGVuYWJsZVdhaXRpbmcobXVzdFdhaXQgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLiNpc1dhaXRpbmcgPT09IG11c3RXYWl0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2lzV2FpdGluZyA9IG11c3RXYWl0O1xuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy4jYWxsTGF5ZXJzLnZhbHVlcygpKSB7XG4gICAgICBpZiAobXVzdFdhaXQpIHtcbiAgICAgICAgbGF5ZXIuZGlzYWJsZUNsaWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXllci5lbmFibGVDbGljaygpO1xuICAgICAgfVxuICAgICAgbGF5ZXIuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJ3YWl0aW5nXCIsIG11c3RXYWl0KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgI2VuYWJsZUFsbCgpIHtcbiAgICBpZiAoIXRoaXMuI2lzRW5hYmxlZCkge1xuICAgICAgdGhpcy4jaXNFbmFibGVkID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgICBwcm9taXNlcy5wdXNoKGxheWVyLmVuYWJsZSgpKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgICAgZWRpdG9yLmVuYWJsZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAjZGlzYWJsZUFsbCgpIHtcbiAgICB0aGlzLnVuc2VsZWN0QWxsKCk7XG4gICAgaWYgKHRoaXMuI2lzRW5hYmxlZCkge1xuICAgICAgdGhpcy4jaXNFbmFibGVkID0gZmFsc2U7XG4gICAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgICBsYXllci5kaXNhYmxlKCk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICAgIGVkaXRvci5kaXNhYmxlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gICpnZXRFZGl0b3JzKHBhZ2VJbmRleCkge1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlZGl0b3IucGFnZUluZGV4ID09PSBwYWdlSW5kZXgpIHtcbiAgICAgICAgeWllbGQgZWRpdG9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXRFZGl0b3IoaWQpIHtcbiAgICByZXR1cm4gdGhpcy4jYWxsRWRpdG9ycy5nZXQoaWQpO1xuICB9XG4gIGFkZEVkaXRvcihlZGl0b3IpIHtcbiAgICB0aGlzLiNhbGxFZGl0b3JzLnNldChlZGl0b3IuaWQsIGVkaXRvcik7XG4gIH1cbiAgcmVtb3ZlRWRpdG9yKGVkaXRvcikge1xuICAgIGlmIChlZGl0b3IuZGl2LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICBpZiAodGhpcy4jZm9jdXNNYWluQ29udGFpbmVyVGltZW91dElkKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNmb2N1c01haW5Db250YWluZXJUaW1lb3V0SWQpO1xuICAgICAgfVxuICAgICAgdGhpcy4jZm9jdXNNYWluQ29udGFpbmVyVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuZm9jdXNNYWluQ29udGFpbmVyKCk7XG4gICAgICAgIHRoaXMuI2ZvY3VzTWFpbkNvbnRhaW5lclRpbWVvdXRJZCA9IG51bGw7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gICAgdGhpcy4jYWxsRWRpdG9ycy5kZWxldGUoZWRpdG9yLmlkKTtcbiAgICBpZiAoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIHRoaXMuI21pc3NpbmdDYW52YXNlcz8uZGVsZXRlKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgICB9XG4gICAgdGhpcy51bnNlbGVjdChlZGl0b3IpO1xuICAgIGlmICghZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQgfHwgIXRoaXMuI2RlbGV0ZWRBbm5vdGF0aW9uc0VsZW1lbnRJZHMuaGFzKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKSkge1xuICAgICAgdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2U/LnJlbW92ZShlZGl0b3IuaWQpO1xuICAgIH1cbiAgfVxuICBhZGREZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoZWRpdG9yKSB7XG4gICAgdGhpcy4jZGVsZXRlZEFubm90YXRpb25zRWxlbWVudElkcy5hZGQoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpO1xuICAgIHRoaXMuYWRkQ2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbihlZGl0b3IpO1xuICAgIGVkaXRvci5kZWxldGVkID0gdHJ1ZTtcbiAgfVxuICBpc0RlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgcmV0dXJuIHRoaXMuI2RlbGV0ZWRBbm5vdGF0aW9uc0VsZW1lbnRJZHMuaGFzKGFubm90YXRpb25FbGVtZW50SWQpO1xuICB9XG4gIHJlbW92ZURlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IpIHtcbiAgICB0aGlzLiNkZWxldGVkQW5ub3RhdGlvbnNFbGVtZW50SWRzLmRlbGV0ZShlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gICAgdGhpcy5yZW1vdmVDaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9uKGVkaXRvcik7XG4gICAgZWRpdG9yLmRlbGV0ZWQgPSBmYWxzZTtcbiAgfVxuICAjYWRkRWRpdG9yVG9MYXllcihlZGl0b3IpIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuI2FsbExheWVycy5nZXQoZWRpdG9yLnBhZ2VJbmRleCk7XG4gICAgaWYgKGxheWVyKSB7XG4gICAgICBsYXllci5hZGRPclJlYnVpbGQoZWRpdG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGRFZGl0b3IoZWRpdG9yKTtcbiAgICAgIHRoaXMuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZShlZGl0b3IpO1xuICAgIH1cbiAgfVxuICBzZXRBY3RpdmVFZGl0b3IoZWRpdG9yKSB7XG4gICAgaWYgKHRoaXMuI2FjdGl2ZUVkaXRvciA9PT0gZWRpdG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2FjdGl2ZUVkaXRvciA9IGVkaXRvcjtcbiAgICBpZiAoZWRpdG9yKSB7XG4gICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVVJKGVkaXRvci5wcm9wZXJ0aWVzVG9VcGRhdGUpO1xuICAgIH1cbiAgfVxuICBnZXQgI2xhc3RTZWxlY3RlZEVkaXRvcigpIHtcbiAgICBsZXQgZWQgPSBudWxsO1xuICAgIGZvciAoZWQgb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgfVxuICAgIHJldHVybiBlZDtcbiAgfVxuICB1cGRhdGVVSShlZGl0b3IpIHtcbiAgICBpZiAodGhpcy4jbGFzdFNlbGVjdGVkRWRpdG9yID09PSBlZGl0b3IpIHtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoZWRpdG9yLnByb3BlcnRpZXNUb1VwZGF0ZSk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVVJRm9yRGVmYXVsdFByb3BlcnRpZXMoZWRpdG9yVHlwZSkge1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoZWRpdG9yVHlwZS5kZWZhdWx0UHJvcGVydGllc1RvVXBkYXRlKTtcbiAgfVxuICB0b2dnbGVTZWxlY3RlZChlZGl0b3IpIHtcbiAgICBpZiAodGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmhhcyhlZGl0b3IpKSB7XG4gICAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuZGVsZXRlKGVkaXRvcik7XG4gICAgICBlZGl0b3IudW5zZWxlY3QoKTtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IHRoaXMuaGFzU2VsZWN0aW9uXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmFkZChlZGl0b3IpO1xuICAgIGVkaXRvci5zZWxlY3QoKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVVJKGVkaXRvci5wcm9wZXJ0aWVzVG9VcGRhdGUpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NlbGVjdGVkRWRpdG9yOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgc2V0U2VsZWN0ZWQoZWRpdG9yKSB7XG4gICAgdGhpcy51cGRhdGVUb29sYmFyKHtcbiAgICAgIG1vZGU6IGVkaXRvci5tb2RlLFxuICAgICAgZWRpdElkOiBlZGl0b3IuaWRcbiAgICB9KTtcbiAgICB0aGlzLiNjdXJyZW50RHJhd2luZ1Nlc3Npb24/LmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgZm9yIChjb25zdCBlZCBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGlmIChlZCAhPT0gZWRpdG9yKSB7XG4gICAgICAgIGVkLnVuc2VsZWN0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5jbGVhcigpO1xuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5hZGQoZWRpdG9yKTtcbiAgICBlZGl0b3Iuc2VsZWN0KCk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVVSShlZGl0b3IucHJvcGVydGllc1RvVXBkYXRlKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTZWxlY3RlZEVkaXRvcjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGlzU2VsZWN0ZWQoZWRpdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5oYXMoZWRpdG9yKTtcbiAgfVxuICBnZXQgZmlyc3RTZWxlY3RlZEVkaXRvcigpIHtcbiAgICByZXR1cm4gdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcbiAgfVxuICB1bnNlbGVjdChlZGl0b3IpIHtcbiAgICBlZGl0b3IudW5zZWxlY3QoKTtcbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuZGVsZXRlKGVkaXRvcik7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IHRoaXMuaGFzU2VsZWN0aW9uXG4gICAgfSk7XG4gIH1cbiAgZ2V0IGhhc1NlbGVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLnNpemUgIT09IDA7XG4gIH1cbiAgZ2V0IGlzRW50ZXJIYW5kbGVkKCkge1xuICAgIHJldHVybiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuc2l6ZSA9PT0gMSAmJiB0aGlzLmZpcnN0U2VsZWN0ZWRFZGl0b3IuaXNFbnRlckhhbmRsZWQ7XG4gIH1cbiAgdW5kbygpIHtcbiAgICB0aGlzLiNjb21tYW5kTWFuYWdlci51bmRvKCk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU29tZXRoaW5nVG9VbmRvOiB0aGlzLiNjb21tYW5kTWFuYWdlci5oYXNTb21ldGhpbmdUb1VuZG8oKSxcbiAgICAgIGhhc1NvbWV0aGluZ1RvUmVkbzogdHJ1ZSxcbiAgICAgIGlzRW1wdHk6IHRoaXMuI2lzRW1wdHkoKVxuICAgIH0pO1xuICAgIHRoaXMuX2VkaXRvclVuZG9CYXI/LmhpZGUoKTtcbiAgfVxuICByZWRvKCkge1xuICAgIHRoaXMuI2NvbW1hbmRNYW5hZ2VyLnJlZG8oKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTb21ldGhpbmdUb1VuZG86IHRydWUsXG4gICAgICBoYXNTb21ldGhpbmdUb1JlZG86IHRoaXMuI2NvbW1hbmRNYW5hZ2VyLmhhc1NvbWV0aGluZ1RvUmVkbygpLFxuICAgICAgaXNFbXB0eTogdGhpcy4jaXNFbXB0eSgpXG4gICAgfSk7XG4gIH1cbiAgYWRkQ29tbWFuZHMocGFyYW1zKSB7XG4gICAgdGhpcy4jY29tbWFuZE1hbmFnZXIuYWRkKHBhcmFtcyk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU29tZXRoaW5nVG9VbmRvOiB0cnVlLFxuICAgICAgaGFzU29tZXRoaW5nVG9SZWRvOiBmYWxzZSxcbiAgICAgIGlzRW1wdHk6IHRoaXMuI2lzRW1wdHkoKVxuICAgIH0pO1xuICB9XG4gIGNsZWFuVW5kb1N0YWNrKHR5cGUpIHtcbiAgICB0aGlzLiNjb21tYW5kTWFuYWdlci5jbGVhblR5cGUodHlwZSk7XG4gIH1cbiAgI2lzRW1wdHkoKSB7XG4gICAgaWYgKHRoaXMuI2FsbEVkaXRvcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLiNhbGxFZGl0b3JzLnNpemUgPT09IDEpIHtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgICAgcmV0dXJuIGVkaXRvci5pc0VtcHR5KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBkZWxldGUoKSB7XG4gICAgdGhpcy5jb21taXRPclJlbW92ZSgpO1xuICAgIGNvbnN0IGRyYXdpbmdFZGl0b3IgPSB0aGlzLmN1cnJlbnRMYXllcj8uZW5kRHJhd2luZ1Nlc3Npb24odHJ1ZSk7XG4gICAgaWYgKCF0aGlzLmhhc1NlbGVjdGlvbiAmJiAhZHJhd2luZ0VkaXRvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlZGl0b3JzID0gZHJhd2luZ0VkaXRvciA/IFtkcmF3aW5nRWRpdG9yXSA6IFsuLi50aGlzLiNzZWxlY3RlZEVkaXRvcnNdO1xuICAgIGNvbnN0IGNtZCA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2VkaXRvclVuZG9CYXI/LnNob3codW5kbywgZWRpdG9ycy5sZW5ndGggPT09IDEgPyBlZGl0b3JzWzBdLmVkaXRvclR5cGUgOiBlZGl0b3JzLmxlbmd0aCk7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHVuZG8gPSAoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICAgIHRoaXMuI2FkZEVkaXRvclRvTGF5ZXIoZWRpdG9yKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kLFxuICAgICAgdW5kbyxcbiAgICAgIG11c3RFeGVjOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgY29tbWl0T3JSZW1vdmUoKSB7XG4gICAgdGhpcy4jYWN0aXZlRWRpdG9yPy5jb21taXRPclJlbW92ZSgpO1xuICB9XG4gIGhhc1NvbWV0aGluZ1RvQ29udHJvbCgpIHtcbiAgICByZXR1cm4gdGhpcy4jYWN0aXZlRWRpdG9yIHx8IHRoaXMuaGFzU2VsZWN0aW9uO1xuICB9XG4gICNzZWxlY3RFZGl0b3JzKGVkaXRvcnMpIHtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGVkaXRvci51bnNlbGVjdCgpO1xuICAgIH1cbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuY2xlYXIoKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICBpZiAoZWRpdG9yLmlzRW1wdHkoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5hZGQoZWRpdG9yKTtcbiAgICAgIGVkaXRvci5zZWxlY3QoKTtcbiAgICB9XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IHRoaXMuaGFzU2VsZWN0aW9uXG4gICAgfSk7XG4gIH1cbiAgc2VsZWN0QWxsKCkge1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgZWRpdG9yLmNvbW1pdCgpO1xuICAgIH1cbiAgICB0aGlzLiNzZWxlY3RFZGl0b3JzKHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpO1xuICB9XG4gIHVuc2VsZWN0QWxsKCkge1xuICAgIGlmICh0aGlzLiNhY3RpdmVFZGl0b3IpIHtcbiAgICAgIHRoaXMuI2FjdGl2ZUVkaXRvci5jb21taXRPclJlbW92ZSgpO1xuICAgICAgaWYgKHRoaXMuI21vZGUgIT09IEFubm90YXRpb25FZGl0b3JUeXBlLk5PTkUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy4jY3VycmVudERyYXdpbmdTZXNzaW9uPy5jb21taXRPclJlbW92ZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICBlZGl0b3IudW5zZWxlY3QoKTtcbiAgICB9XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmNsZWFyKCk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgdHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzKHgsIHksIG5vQ29tbWl0ID0gZmFsc2UpIHtcbiAgICBpZiAoIW5vQ29tbWl0KSB7XG4gICAgICB0aGlzLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jdHJhbnNsYXRpb25bMF0gKz0geDtcbiAgICB0aGlzLiN0cmFuc2xhdGlvblsxXSArPSB5O1xuICAgIGNvbnN0IFt0b3RhbFgsIHRvdGFsWV0gPSB0aGlzLiN0cmFuc2xhdGlvbjtcbiAgICBjb25zdCBlZGl0b3JzID0gWy4uLnRoaXMuI3NlbGVjdGVkRWRpdG9yc107XG4gICAgY29uc3QgVElNRV9UT19XQUlUID0gMWUzO1xuICAgIGlmICh0aGlzLiN0cmFuc2xhdGlvblRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI3RyYW5zbGF0aW9uVGltZW91dElkKTtcbiAgICB9XG4gICAgdGhpcy4jdHJhbnNsYXRpb25UaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuI3RyYW5zbGF0aW9uVGltZW91dElkID0gbnVsbDtcbiAgICAgIHRoaXMuI3RyYW5zbGF0aW9uWzBdID0gdGhpcy4jdHJhbnNsYXRpb25bMV0gPSAwO1xuICAgICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICAgIGNtZDogKCkgPT4ge1xuICAgICAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIGVkaXRvcnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNhbGxFZGl0b3JzLmhhcyhlZGl0b3IuaWQpKSB7XG4gICAgICAgICAgICAgIGVkaXRvci50cmFuc2xhdGVJblBhZ2UodG90YWxYLCB0b3RhbFkpO1xuICAgICAgICAgICAgICBlZGl0b3IudHJhbnNsYXRpb25Eb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1bmRvOiAoKSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgZWRpdG9ycykge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2FsbEVkaXRvcnMuaGFzKGVkaXRvci5pZCkpIHtcbiAgICAgICAgICAgICAgZWRpdG9yLnRyYW5zbGF0ZUluUGFnZSgtdG90YWxYLCAtdG90YWxZKTtcbiAgICAgICAgICAgICAgZWRpdG9yLnRyYW5zbGF0aW9uRG9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbXVzdEV4ZWM6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9LCBUSU1FX1RPX1dBSVQpO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIGVkaXRvcnMpIHtcbiAgICAgIGVkaXRvci50cmFuc2xhdGVJblBhZ2UoeCwgeSk7XG4gICAgICBlZGl0b3IudHJhbnNsYXRpb25Eb25lKCk7XG4gICAgfVxuICB9XG4gIHNldFVwRHJhZ1Nlc3Npb24oKSB7XG4gICAgaWYgKCF0aGlzLmhhc1NlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRpc2FibGVVc2VyU2VsZWN0KHRydWUpO1xuICAgIHRoaXMuI2RyYWdnaW5nRWRpdG9ycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICB0aGlzLiNkcmFnZ2luZ0VkaXRvcnMuc2V0KGVkaXRvciwge1xuICAgICAgICBzYXZlZFg6IGVkaXRvci54LFxuICAgICAgICBzYXZlZFk6IGVkaXRvci55LFxuICAgICAgICBzYXZlZFBhZ2VJbmRleDogZWRpdG9yLnBhZ2VJbmRleCxcbiAgICAgICAgbmV3WDogMCxcbiAgICAgICAgbmV3WTogMCxcbiAgICAgICAgbmV3UGFnZUluZGV4OiAtMVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGVuZERyYWdTZXNzaW9uKCkge1xuICAgIGlmICghdGhpcy4jZHJhZ2dpbmdFZGl0b3JzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuZGlzYWJsZVVzZXJTZWxlY3QoZmFsc2UpO1xuICAgIGNvbnN0IG1hcCA9IHRoaXMuI2RyYWdnaW5nRWRpdG9ycztcbiAgICB0aGlzLiNkcmFnZ2luZ0VkaXRvcnMgPSBudWxsO1xuICAgIGxldCBtdXN0QmVBZGRlZEluVW5kb1N0YWNrID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBbe1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBwYWdlSW5kZXhcbiAgICB9LCB2YWx1ZV0gb2YgbWFwKSB7XG4gICAgICB2YWx1ZS5uZXdYID0geDtcbiAgICAgIHZhbHVlLm5ld1kgPSB5O1xuICAgICAgdmFsdWUubmV3UGFnZUluZGV4ID0gcGFnZUluZGV4O1xuICAgICAgbXVzdEJlQWRkZWRJblVuZG9TdGFjayB8fD0geCAhPT0gdmFsdWUuc2F2ZWRYIHx8IHkgIT09IHZhbHVlLnNhdmVkWSB8fCBwYWdlSW5kZXggIT09IHZhbHVlLnNhdmVkUGFnZUluZGV4O1xuICAgIH1cbiAgICBpZiAoIW11c3RCZUFkZGVkSW5VbmRvU3RhY2spIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbW92ZSA9IChlZGl0b3IsIHgsIHksIHBhZ2VJbmRleCkgPT4ge1xuICAgICAgaWYgKHRoaXMuI2FsbEVkaXRvcnMuaGFzKGVkaXRvci5pZCkpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy4jYWxsTGF5ZXJzLmdldChwYWdlSW5kZXgpO1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgZWRpdG9yLl9zZXRQYXJlbnRBbmRQb3NpdGlvbihwYXJlbnQsIHgsIHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVkaXRvci5wYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgICAgICAgZWRpdG9yLnggPSB4O1xuICAgICAgICAgIGVkaXRvci55ID0geTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBbZWRpdG9yLCB7XG4gICAgICAgICAgbmV3WCxcbiAgICAgICAgICBuZXdZLFxuICAgICAgICAgIG5ld1BhZ2VJbmRleFxuICAgICAgICB9XSBvZiBtYXApIHtcbiAgICAgICAgICBtb3ZlKGVkaXRvciwgbmV3WCwgbmV3WSwgbmV3UGFnZUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVuZG86ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBbZWRpdG9yLCB7XG4gICAgICAgICAgc2F2ZWRYLFxuICAgICAgICAgIHNhdmVkWSxcbiAgICAgICAgICBzYXZlZFBhZ2VJbmRleFxuICAgICAgICB9XSBvZiBtYXApIHtcbiAgICAgICAgICBtb3ZlKGVkaXRvciwgc2F2ZWRYLCBzYXZlZFksIHNhdmVkUGFnZUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG11c3RFeGVjOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZHJhZ1NlbGVjdGVkRWRpdG9ycyh0eCwgdHkpIHtcbiAgICBpZiAoIXRoaXMuI2RyYWdnaW5nRWRpdG9ycykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNkcmFnZ2luZ0VkaXRvcnMua2V5cygpKSB7XG4gICAgICBlZGl0b3IuZHJhZyh0eCwgdHkpO1xuICAgIH1cbiAgfVxuICByZWJ1aWxkKGVkaXRvcikge1xuICAgIGlmIChlZGl0b3IucGFyZW50ID09PSBudWxsKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldExheWVyKGVkaXRvci5wYWdlSW5kZXgpO1xuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBwYXJlbnQuY2hhbmdlUGFyZW50KGVkaXRvcik7XG4gICAgICAgIHBhcmVudC5hZGRPclJlYnVpbGQoZWRpdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWRkRWRpdG9yKGVkaXRvcik7XG4gICAgICAgIHRoaXMuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZShlZGl0b3IpO1xuICAgICAgICBlZGl0b3IucmVidWlsZCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlZGl0b3IucGFyZW50LmFkZE9yUmVidWlsZChlZGl0b3IpO1xuICAgIH1cbiAgfVxuICBnZXQgaXNFZGl0b3JIYW5kbGluZ0tleWJvYXJkKCkge1xuICAgIHJldHVybiB0aGlzLmdldEFjdGl2ZSgpPy5zaG91bGRHZXRLZXlib2FyZEV2ZW50cygpIHx8IHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5zaXplID09PSAxICYmIHRoaXMuZmlyc3RTZWxlY3RlZEVkaXRvci5zaG91bGRHZXRLZXlib2FyZEV2ZW50cygpO1xuICB9XG4gIGlzQWN0aXZlKGVkaXRvcikge1xuICAgIHJldHVybiB0aGlzLiNhY3RpdmVFZGl0b3IgPT09IGVkaXRvcjtcbiAgfVxuICBnZXRBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FjdGl2ZUVkaXRvcjtcbiAgfVxuICBnZXRNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLiNtb2RlO1xuICB9XG4gIGlzRWRpdGluZ01vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI21vZGUgIT09IEFubm90YXRpb25FZGl0b3JUeXBlLk5PTkU7XG4gIH1cbiAgZ2V0IGltYWdlTWFuYWdlcigpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaW1hZ2VNYW5hZ2VyXCIsIG5ldyBJbWFnZU1hbmFnZXIoKSk7XG4gIH1cbiAgZ2V0U2VsZWN0aW9uQm94ZXModGV4dExheWVyKSB7XG4gICAgaWYgKCF0ZXh0TGF5ZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBzZWxlY3Rpb24ucmFuZ2VDb3VudDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGlmICghdGV4dExheWVyLmNvbnRhaW5zKHNlbGVjdGlvbi5nZXRSYW5nZUF0KGkpLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgeDogbGF5ZXJYLFxuICAgICAgeTogbGF5ZXJZLFxuICAgICAgd2lkdGg6IHBhcmVudFdpZHRoLFxuICAgICAgaGVpZ2h0OiBwYXJlbnRIZWlnaHRcbiAgICB9ID0gdGV4dExheWVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCByb3RhdG9yO1xuICAgIHN3aXRjaCAodGV4dExheWVyLmdldEF0dHJpYnV0ZShcImRhdGEtbWFpbi1yb3RhdGlvblwiKSkge1xuICAgICAgY2FzZSBcIjkwXCI6XG4gICAgICAgIHJvdGF0b3IgPSAoeCwgeSwgdywgaCkgPT4gKHtcbiAgICAgICAgICB4OiAoeSAtIGxheWVyWSkgLyBwYXJlbnRIZWlnaHQsXG4gICAgICAgICAgeTogMSAtICh4ICsgdyAtIGxheWVyWCkgLyBwYXJlbnRXaWR0aCxcbiAgICAgICAgICB3aWR0aDogaCAvIHBhcmVudEhlaWdodCxcbiAgICAgICAgICBoZWlnaHQ6IHcgLyBwYXJlbnRXaWR0aFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiMTgwXCI6XG4gICAgICAgIHJvdGF0b3IgPSAoeCwgeSwgdywgaCkgPT4gKHtcbiAgICAgICAgICB4OiAxIC0gKHggKyB3IC0gbGF5ZXJYKSAvIHBhcmVudFdpZHRoLFxuICAgICAgICAgIHk6IDEgLSAoeSArIGggLSBsYXllclkpIC8gcGFyZW50SGVpZ2h0LFxuICAgICAgICAgIHdpZHRoOiB3IC8gcGFyZW50V2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoIC8gcGFyZW50SGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCIyNzBcIjpcbiAgICAgICAgcm90YXRvciA9ICh4LCB5LCB3LCBoKSA9PiAoe1xuICAgICAgICAgIHg6IDEgLSAoeSArIGggLSBsYXllclkpIC8gcGFyZW50SGVpZ2h0LFxuICAgICAgICAgIHk6ICh4IC0gbGF5ZXJYKSAvIHBhcmVudFdpZHRoLFxuICAgICAgICAgIHdpZHRoOiBoIC8gcGFyZW50SGVpZ2h0LFxuICAgICAgICAgIGhlaWdodDogdyAvIHBhcmVudFdpZHRoXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJvdGF0b3IgPSAoeCwgeSwgdywgaCkgPT4gKHtcbiAgICAgICAgICB4OiAoeCAtIGxheWVyWCkgLyBwYXJlbnRXaWR0aCxcbiAgICAgICAgICB5OiAoeSAtIGxheWVyWSkgLyBwYXJlbnRIZWlnaHQsXG4gICAgICAgICAgd2lkdGg6IHcgLyBwYXJlbnRXaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGggLyBwYXJlbnRIZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBib3hlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHNlbGVjdGlvbi5yYW5nZUNvdW50OyBpIDwgaWk7IGkrKykge1xuICAgICAgY29uc3QgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdChpKTtcbiAgICAgIGlmIChyYW5nZS5jb2xsYXBzZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSBvZiByYW5nZS5nZXRDbGllbnRSZWN0cygpKSB7XG4gICAgICAgIGlmICh3aWR0aCA9PT0gMCB8fCBoZWlnaHQgPT09IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBib3hlcy5wdXNoKHJvdGF0b3IoeCwgeSwgd2lkdGgsIGhlaWdodCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYm94ZXMubGVuZ3RoID09PSAwID8gbnVsbCA6IGJveGVzO1xuICB9XG4gIGFkZENoYW5nZWRFeGlzdGluZ0Fubm90YXRpb24oe1xuICAgIGFubm90YXRpb25FbGVtZW50SWQsXG4gICAgaWRcbiAgfSkge1xuICAgICh0aGlzLiNjaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9ucyB8fD0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSkuc2V0KGFubm90YXRpb25FbGVtZW50SWQsIGlkKTtcbiAgfVxuICByZW1vdmVDaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9uKHtcbiAgICBhbm5vdGF0aW9uRWxlbWVudElkXG4gIH0pIHtcbiAgICB0aGlzLiNjaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9ucz8uZGVsZXRlKGFubm90YXRpb25FbGVtZW50SWQpO1xuICB9XG4gIHJlbmRlckFubm90YXRpb25FbGVtZW50KGFubm90YXRpb24pIHtcbiAgICBjb25zdCBlZGl0b3JJZCA9IHRoaXMuI2NoYW5nZWRFeGlzdGluZ0Fubm90YXRpb25zPy5nZXQoYW5ub3RhdGlvbi5kYXRhLmlkKTtcbiAgICBpZiAoIWVkaXRvcklkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuI2Fubm90YXRpb25TdG9yYWdlLmdldFJhd1ZhbHVlKGVkaXRvcklkKTtcbiAgICBpZiAoIWVkaXRvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jbW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORSAmJiAhZWRpdG9yLmhhc0JlZW5Nb2RpZmllZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlZGl0b3IucmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbik7XG4gIH1cbiAgc2V0TWlzc2luZ0NhbnZhcyhhbm5vdGF0aW9uSWQsIGFubm90YXRpb25FbGVtZW50SWQsIGNhbnZhcykge1xuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuI21pc3NpbmdDYW52YXNlcz8uZ2V0KGFubm90YXRpb25JZCk7XG4gICAgaWYgKCFlZGl0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWRpdG9yLnNldENhbnZhcyhhbm5vdGF0aW9uRWxlbWVudElkLCBjYW52YXMpO1xuICAgIHRoaXMuI21pc3NpbmdDYW52YXNlcy5kZWxldGUoYW5ub3RhdGlvbklkKTtcbiAgfVxuICBhZGRNaXNzaW5nQ2FudmFzKGFubm90YXRpb25JZCwgZWRpdG9yKSB7XG4gICAgKHRoaXMuI21pc3NpbmdDYW52YXNlcyB8fD0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSkuc2V0KGFubm90YXRpb25JZCwgZWRpdG9yKTtcbiAgfVxufVxuY2xhc3MgQWx0VGV4dCB7XG4gICNhbHRUZXh0ID0gbnVsbDtcbiAgI2FsdFRleHREZWNvcmF0aXZlID0gZmFsc2U7XG4gICNhbHRUZXh0QnV0dG9uID0gbnVsbDtcbiAgI2FsdFRleHRCdXR0b25MYWJlbCA9IG51bGw7XG4gICNhbHRUZXh0VG9vbHRpcCA9IG51bGw7XG4gICNhbHRUZXh0VG9vbHRpcFRpbWVvdXQgPSBudWxsO1xuICAjYWx0VGV4dFdhc0Zyb21LZXlCb2FyZCA9IGZhbHNlO1xuICAjYmFkZ2UgPSBudWxsO1xuICAjZWRpdG9yID0gbnVsbDtcbiAgI2d1ZXNzZWRUZXh0ID0gbnVsbDtcbiAgI3RleHRXaXRoRGlzY2xhaW1lciA9IG51bGw7XG4gICN1c2VOZXdBbHRUZXh0RmxvdyA9IGZhbHNlO1xuICBzdGF0aWMgI2wxMG5OZXdCdXR0b24gPSBudWxsO1xuICBzdGF0aWMgX2wxMG4gPSBudWxsO1xuICBjb25zdHJ1Y3RvcihlZGl0b3IpIHtcbiAgICB0aGlzLiNlZGl0b3IgPSBlZGl0b3I7XG4gICAgdGhpcy4jdXNlTmV3QWx0VGV4dEZsb3cgPSBlZGl0b3IuX3VpTWFuYWdlci51c2VOZXdBbHRUZXh0RmxvdztcbiAgICBBbHRUZXh0LiNsMTBuTmV3QnV0dG9uIHx8PSBPYmplY3QuZnJlZXplKHtcbiAgICAgIGFkZGVkOiBcInBkZmpzLWVkaXRvci1uZXctYWx0LXRleHQtYWRkZWQtYnV0dG9uXCIsXG4gICAgICBcImFkZGVkLWxhYmVsXCI6IFwicGRmanMtZWRpdG9yLW5ldy1hbHQtdGV4dC1hZGRlZC1idXR0b24tbGFiZWxcIixcbiAgICAgIG1pc3Npbmc6IFwicGRmanMtZWRpdG9yLW5ldy1hbHQtdGV4dC1taXNzaW5nLWJ1dHRvblwiLFxuICAgICAgXCJtaXNzaW5nLWxhYmVsXCI6IFwicGRmanMtZWRpdG9yLW5ldy1hbHQtdGV4dC1taXNzaW5nLWJ1dHRvbi1sYWJlbFwiLFxuICAgICAgcmV2aWV3OiBcInBkZmpzLWVkaXRvci1uZXctYWx0LXRleHQtdG8tcmV2aWV3LWJ1dHRvblwiLFxuICAgICAgXCJyZXZpZXctbGFiZWxcIjogXCJwZGZqcy1lZGl0b3ItbmV3LWFsdC10ZXh0LXRvLXJldmlldy1idXR0b24tbGFiZWxcIlxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBpbml0aWFsaXplKGwxMG4pIHtcbiAgICBBbHRUZXh0Ll9sMTBuID8/PSBsMTBuO1xuICB9XG4gIGFzeW5jIHJlbmRlcigpIHtcbiAgICBjb25zdCBhbHRUZXh0ID0gdGhpcy4jYWx0VGV4dEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgYWx0VGV4dC5jbGFzc05hbWUgPSBcImFsdFRleHRcIjtcbiAgICBhbHRUZXh0LnRhYkluZGV4ID0gXCIwXCI7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLiNhbHRUZXh0QnV0dG9uTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICBhbHRUZXh0LmFwcGVuZChsYWJlbCk7XG4gICAgaWYgKHRoaXMuI3VzZU5ld0FsdFRleHRGbG93KSB7XG4gICAgICBhbHRUZXh0LmNsYXNzTGlzdC5hZGQoXCJuZXdcIik7XG4gICAgICBhbHRUZXh0LnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBBbHRUZXh0LiNsMTBuTmV3QnV0dG9uLm1pc3NpbmcpO1xuICAgICAgbGFiZWwuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIEFsdFRleHQuI2wxMG5OZXdCdXR0b25bXCJtaXNzaW5nLWxhYmVsXCJdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWx0VGV4dC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1lZGl0b3ItYWx0LXRleHQtYnV0dG9uXCIpO1xuICAgICAgbGFiZWwuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtZWRpdG9yLWFsdC10ZXh0LWJ1dHRvbi1sYWJlbFwiKTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jZWRpdG9yLl91aU1hbmFnZXIuX3NpZ25hbDtcbiAgICBhbHRUZXh0LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBub0NvbnRleHRNZW51LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBhbHRUZXh0LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCAoZXZlbnQpID0+IGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBjb25zdCBvbkNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy4jZWRpdG9yLl91aU1hbmFnZXIuZWRpdEFsdFRleHQodGhpcy4jZWRpdG9yKTtcbiAgICAgIGlmICh0aGlzLiN1c2VOZXdBbHRUZXh0Rmxvdykge1xuICAgICAgICB0aGlzLiNlZGl0b3IuX3JlcG9ydFRlbGVtZXRyeSh7XG4gICAgICAgICAgYWN0aW9uOiBcInBkZmpzLmltYWdlLmFsdF90ZXh0LmltYWdlX3N0YXR1c19sYWJlbF9jbGlja2VkXCIsXG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgbGFiZWw6IHRoaXMuI2xhYmVsXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGFsdFRleHQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIG9uQ2xpY2ssIHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBhbHRUZXh0LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gYWx0VGV4dCAmJiBldmVudC5rZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgICB0aGlzLiNhbHRUZXh0V2FzRnJvbUtleUJvYXJkID0gdHJ1ZTtcbiAgICAgICAgb25DbGljayhldmVudCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgYXdhaXQgdGhpcy4jc2V0U3RhdGUoKTtcbiAgICByZXR1cm4gYWx0VGV4dDtcbiAgfVxuICBnZXQgI2xhYmVsKCkge1xuICAgIHJldHVybiB0aGlzLiNhbHRUZXh0ICYmIFwiYWRkZWRcIiB8fCB0aGlzLiNhbHRUZXh0ID09PSBudWxsICYmIHRoaXMuZ3Vlc3NlZFRleHQgJiYgXCJyZXZpZXdcIiB8fCBcIm1pc3NpbmdcIjtcbiAgfVxuICBmaW5pc2goKSB7XG4gICAgaWYgKCF0aGlzLiNhbHRUZXh0QnV0dG9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2FsdFRleHRCdXR0b24uZm9jdXMoe1xuICAgICAgZm9jdXNWaXNpYmxlOiB0aGlzLiNhbHRUZXh0V2FzRnJvbUtleUJvYXJkXG4gICAgfSk7XG4gICAgdGhpcy4jYWx0VGV4dFdhc0Zyb21LZXlCb2FyZCA9IGZhbHNlO1xuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgaWYgKHRoaXMuI3VzZU5ld0FsdFRleHRGbG93KSB7XG4gICAgICByZXR1cm4gdGhpcy4jYWx0VGV4dCA9PT0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuICF0aGlzLiNhbHRUZXh0ICYmICF0aGlzLiNhbHRUZXh0RGVjb3JhdGl2ZTtcbiAgfVxuICBoYXNEYXRhKCkge1xuICAgIGlmICh0aGlzLiN1c2VOZXdBbHRUZXh0Rmxvdykge1xuICAgICAgcmV0dXJuIHRoaXMuI2FsdFRleHQgIT09IG51bGwgfHwgISF0aGlzLiNndWVzc2VkVGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaXNFbXB0eSgpO1xuICB9XG4gIGdldCBndWVzc2VkVGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy4jZ3Vlc3NlZFRleHQ7XG4gIH1cbiAgYXN5bmMgc2V0R3Vlc3NlZFRleHQoZ3Vlc3NlZFRleHQpIHtcbiAgICBpZiAodGhpcy4jYWx0VGV4dCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNndWVzc2VkVGV4dCA9IGd1ZXNzZWRUZXh0O1xuICAgIHRoaXMuI3RleHRXaXRoRGlzY2xhaW1lciA9IGF3YWl0IEFsdFRleHQuX2wxMG4uZ2V0KFwicGRmanMtZWRpdG9yLW5ldy1hbHQtdGV4dC1nZW5lcmF0ZWQtYWx0LXRleHQtd2l0aC1kaXNjbGFpbWVyXCIsIHtcbiAgICAgIGdlbmVyYXRlZEFsdFRleHQ6IGd1ZXNzZWRUZXh0XG4gICAgfSk7XG4gICAgdGhpcy4jc2V0U3RhdGUoKTtcbiAgfVxuICB0b2dnbGVBbHRUZXh0QmFkZ2UodmlzaWJpbGl0eSA9IGZhbHNlKSB7XG4gICAgaWYgKCF0aGlzLiN1c2VOZXdBbHRUZXh0RmxvdyB8fCB0aGlzLiNhbHRUZXh0KSB7XG4gICAgICB0aGlzLiNiYWRnZT8ucmVtb3ZlKCk7XG4gICAgICB0aGlzLiNiYWRnZSA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy4jYmFkZ2UpIHtcbiAgICAgIGNvbnN0IGJhZGdlID0gdGhpcy4jYmFkZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgYmFkZ2UuY2xhc3NOYW1lID0gXCJub0FsdFRleHRCYWRnZVwiO1xuICAgICAgdGhpcy4jZWRpdG9yLmRpdi5hcHBlbmQoYmFkZ2UpO1xuICAgIH1cbiAgICB0aGlzLiNiYWRnZS5jbGFzc0xpc3QudG9nZ2xlKFwiaGlkZGVuXCIsICF2aXNpYmlsaXR5KTtcbiAgfVxuICBzZXJpYWxpemUoaXNGb3JDb3B5aW5nKSB7XG4gICAgbGV0IGFsdFRleHQgPSB0aGlzLiNhbHRUZXh0O1xuICAgIGlmICghaXNGb3JDb3B5aW5nICYmIHRoaXMuI2d1ZXNzZWRUZXh0ID09PSBhbHRUZXh0KSB7XG4gICAgICBhbHRUZXh0ID0gdGhpcy4jdGV4dFdpdGhEaXNjbGFpbWVyO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgYWx0VGV4dCxcbiAgICAgIGRlY29yYXRpdmU6IHRoaXMuI2FsdFRleHREZWNvcmF0aXZlLFxuICAgICAgZ3Vlc3NlZFRleHQ6IHRoaXMuI2d1ZXNzZWRUZXh0LFxuICAgICAgdGV4dFdpdGhEaXNjbGFpbWVyOiB0aGlzLiN0ZXh0V2l0aERpc2NsYWltZXJcbiAgICB9O1xuICB9XG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhbHRUZXh0OiB0aGlzLiNhbHRUZXh0LFxuICAgICAgZGVjb3JhdGl2ZTogdGhpcy4jYWx0VGV4dERlY29yYXRpdmVcbiAgICB9O1xuICB9XG4gIHNldCBkYXRhKHtcbiAgICBhbHRUZXh0LFxuICAgIGRlY29yYXRpdmUsXG4gICAgZ3Vlc3NlZFRleHQsXG4gICAgdGV4dFdpdGhEaXNjbGFpbWVyLFxuICAgIGNhbmNlbCA9IGZhbHNlXG4gIH0pIHtcbiAgICBpZiAoZ3Vlc3NlZFRleHQpIHtcbiAgICAgIHRoaXMuI2d1ZXNzZWRUZXh0ID0gZ3Vlc3NlZFRleHQ7XG4gICAgICB0aGlzLiN0ZXh0V2l0aERpc2NsYWltZXIgPSB0ZXh0V2l0aERpc2NsYWltZXI7XG4gICAgfVxuICAgIGlmICh0aGlzLiNhbHRUZXh0ID09PSBhbHRUZXh0ICYmIHRoaXMuI2FsdFRleHREZWNvcmF0aXZlID09PSBkZWNvcmF0aXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY2FuY2VsKSB7XG4gICAgICB0aGlzLiNhbHRUZXh0ID0gYWx0VGV4dDtcbiAgICAgIHRoaXMuI2FsdFRleHREZWNvcmF0aXZlID0gZGVjb3JhdGl2ZTtcbiAgICB9XG4gICAgdGhpcy4jc2V0U3RhdGUoKTtcbiAgfVxuICB0b2dnbGUoZW5hYmxlZCA9IGZhbHNlKSB7XG4gICAgaWYgKCF0aGlzLiNhbHRUZXh0QnV0dG9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghZW5hYmxlZCAmJiB0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQpO1xuICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy4jYWx0VGV4dEJ1dHRvbi5kaXNhYmxlZCA9ICFlbmFibGVkO1xuICB9XG4gIHNob3duKCkge1xuICAgIHRoaXMuI2VkaXRvci5fcmVwb3J0VGVsZW1ldHJ5KHtcbiAgICAgIGFjdGlvbjogXCJwZGZqcy5pbWFnZS5hbHRfdGV4dC5pbWFnZV9zdGF0dXNfbGFiZWxfZGlzcGxheWVkXCIsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGxhYmVsOiB0aGlzLiNsYWJlbFxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4jYWx0VGV4dEJ1dHRvbj8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jYWx0VGV4dEJ1dHRvbiA9IG51bGw7XG4gICAgdGhpcy4jYWx0VGV4dEJ1dHRvbkxhYmVsID0gbnVsbDtcbiAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcCA9IG51bGw7XG4gICAgdGhpcy4jYmFkZ2U/LnJlbW92ZSgpO1xuICAgIHRoaXMuI2JhZGdlID0gbnVsbDtcbiAgfVxuICBhc3luYyAjc2V0U3RhdGUoKSB7XG4gICAgY29uc3QgYnV0dG9uID0gdGhpcy4jYWx0VGV4dEJ1dHRvbjtcbiAgICBpZiAoIWJ1dHRvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jdXNlTmV3QWx0VGV4dEZsb3cpIHtcbiAgICAgIGJ1dHRvbi5jbGFzc0xpc3QudG9nZ2xlKFwiZG9uZVwiLCAhIXRoaXMuI2FsdFRleHQpO1xuICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBBbHRUZXh0LiNsMTBuTmV3QnV0dG9uW3RoaXMuI2xhYmVsXSk7XG4gICAgICB0aGlzLiNhbHRUZXh0QnV0dG9uTGFiZWw/LnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBBbHRUZXh0LiNsMTBuTmV3QnV0dG9uW2Ake3RoaXMuI2xhYmVsfS1sYWJlbGBdKTtcbiAgICAgIGlmICghdGhpcy4jYWx0VGV4dCkge1xuICAgICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcD8ucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLiNhbHRUZXh0ICYmICF0aGlzLiNhbHRUZXh0RGVjb3JhdGl2ZSkge1xuICAgICAgICBidXR0b24uY2xhc3NMaXN0LnJlbW92ZShcImRvbmVcIik7XG4gICAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwPy5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJkb25lXCIpO1xuICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLWVkaXRvci1hbHQtdGV4dC1lZGl0LWJ1dHRvblwiKTtcbiAgICB9XG4gICAgbGV0IHRvb2x0aXAgPSB0aGlzLiNhbHRUZXh0VG9vbHRpcDtcbiAgICBpZiAoIXRvb2x0aXApIHtcbiAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwID0gdG9vbHRpcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgdG9vbHRpcC5jbGFzc05hbWUgPSBcInRvb2x0aXBcIjtcbiAgICAgIHRvb2x0aXAuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInRvb2x0aXBcIik7XG4gICAgICB0b29sdGlwLmlkID0gYGFsdC10ZXh0LXRvb2x0aXAtJHt0aGlzLiNlZGl0b3IuaWR9YDtcbiAgICAgIGNvbnN0IERFTEFZX1RPX1NIT1dfVE9PTFRJUCA9IDEwMDtcbiAgICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI2VkaXRvci5fdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCk7XG4gICAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCA9IG51bGw7XG4gICAgICB9LCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcC5jbGFzc0xpc3QuYWRkKFwic2hvd1wiKTtcbiAgICAgICAgICB0aGlzLiNlZGl0b3IuX3JlcG9ydFRlbGVtZXRyeSh7XG4gICAgICAgICAgICBhY3Rpb246IFwiYWx0X3RleHRfdG9vbHRpcFwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIERFTEFZX1RPX1NIT1dfVE9PTFRJUCk7XG4gICAgICB9LCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCk7XG4gICAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcD8uY2xhc3NMaXN0LnJlbW92ZShcInNob3dcIik7XG4gICAgICB9LCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLiNhbHRUZXh0RGVjb3JhdGl2ZSkge1xuICAgICAgdG9vbHRpcC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1lZGl0b3ItYWx0LXRleHQtZGVjb3JhdGl2ZS10b29sdGlwXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b29sdGlwLnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiKTtcbiAgICAgIHRvb2x0aXAudGV4dENvbnRlbnQgPSB0aGlzLiNhbHRUZXh0O1xuICAgIH1cbiAgICBpZiAoIXRvb2x0aXAucGFyZW50Tm9kZSkge1xuICAgICAgYnV0dG9uLmFwcGVuZCh0b29sdGlwKTtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuI2VkaXRvci5nZXRFbGVtZW50Rm9yQWx0VGV4dCgpO1xuICAgIGVsZW1lbnQ/LnNldEF0dHJpYnV0ZShcImFyaWEtZGVzY3JpYmVkYnlcIiwgdG9vbHRpcC5pZCk7XG4gIH1cbn1cbmNsYXNzIENvbW1lbnQge1xuICAjY29tbWVudFN0YW5kYWxvbmVCdXR0b24gPSBudWxsO1xuICAjY29tbWVudFRvb2xiYXJCdXR0b24gPSBudWxsO1xuICAjY29tbWVudFdhc0Zyb21LZXlCb2FyZCA9IGZhbHNlO1xuICAjZWRpdG9yID0gbnVsbDtcbiAgI2luaXRpYWxUZXh0ID0gbnVsbDtcbiAgI3JpY2hUZXh0ID0gbnVsbDtcbiAgI3RleHQgPSBudWxsO1xuICAjZGF0ZSA9IG51bGw7XG4gICNkZWxldGVkID0gZmFsc2U7XG4gICNwb3B1cFBvc2l0aW9uID0gbnVsbDtcbiAgY29uc3RydWN0b3IoZWRpdG9yKSB7XG4gICAgdGhpcy4jZWRpdG9yID0gZWRpdG9yO1xuICB9XG4gIHJlbmRlckZvclRvb2xiYXIoKSB7XG4gICAgY29uc3QgYnV0dG9uID0gdGhpcy4jY29tbWVudFRvb2xiYXJCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgIGJ1dHRvbi5jbGFzc05hbWUgPSBcImNvbW1lbnRcIjtcbiAgICByZXR1cm4gdGhpcy4jcmVuZGVyKGJ1dHRvbiwgZmFsc2UpO1xuICB9XG4gIHJlbmRlckZvclN0YW5kYWxvbmUoKSB7XG4gICAgY29uc3QgYnV0dG9uID0gdGhpcy4jY29tbWVudFN0YW5kYWxvbmVCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgIGJ1dHRvbi5jbGFzc05hbWUgPSBcImFubm90YXRpb25Db21tZW50QnV0dG9uXCI7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLiNlZGl0b3IuY29tbWVudEJ1dHRvblBvc2l0aW9uO1xuICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzdHlsZVxuICAgICAgfSA9IGJ1dHRvbjtcbiAgICAgIHN0eWxlLmluc2V0SW5saW5lRW5kID0gYGNhbGMoJHsxMDAgKiAodGhpcy4jZWRpdG9yLl91aU1hbmFnZXIuZGlyZWN0aW9uID09PSBcImx0clwiID8gMSAtIHBvc2l0aW9uWzBdIDogcG9zaXRpb25bMF0pfSUgLSB2YXIoLS1jb21tZW50LWJ1dHRvbi1kaW0pKWA7XG4gICAgICBzdHlsZS50b3AgPSBgY2FsYygkezEwMCAqIHBvc2l0aW9uWzFdfSUgLSB2YXIoLS1jb21tZW50LWJ1dHRvbi1kaW0pKWA7XG4gICAgICBjb25zdCBjb2xvciA9IHRoaXMuI2VkaXRvci5jb21tZW50QnV0dG9uQ29sb3I7XG4gICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3I7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNyZW5kZXIoYnV0dG9uLCB0cnVlKTtcbiAgfVxuICBmb2N1c0J1dHRvbigpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICh0aGlzLiNjb21tZW50U3RhbmRhbG9uZUJ1dHRvbiA/PyB0aGlzLiNjb21tZW50VG9vbGJhckJ1dHRvbik/LmZvY3VzKCk7XG4gICAgfSwgMCk7XG4gIH1cbiAgb25VcGRhdGVkQ29sb3IoKSB7XG4gICAgaWYgKCF0aGlzLiNjb21tZW50U3RhbmRhbG9uZUJ1dHRvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb2xvciA9IHRoaXMuI2VkaXRvci5jb21tZW50QnV0dG9uQ29sb3I7XG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICB0aGlzLiNjb21tZW50U3RhbmRhbG9uZUJ1dHRvbi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjtcbiAgICB9XG4gICAgdGhpcy4jZWRpdG9yLl91aU1hbmFnZXIudXBkYXRlUG9wdXBDb2xvcih0aGlzLiNlZGl0b3IpO1xuICB9XG4gIGdldCBjb21tZW50QnV0dG9uV2lkdGgoKSB7XG4gICAgcmV0dXJuICh0aGlzLiNjb21tZW50U3RhbmRhbG9uZUJ1dHRvbj8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggPz8gMCkgLyB0aGlzLiNlZGl0b3IucGFyZW50LmJvdW5kaW5nQ2xpZW50UmVjdC53aWR0aDtcbiAgfVxuICBnZXQgY29tbWVudFBvcHVwUG9zaXRpb25JbkxheWVyKCkge1xuICAgIGlmICh0aGlzLiNwb3B1cFBvc2l0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy4jcG9wdXBQb3NpdGlvbjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNjb21tZW50U3RhbmRhbG9uZUJ1dHRvbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXMuI2NvbW1lbnRTdGFuZGFsb25lQnV0dG9uLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIHg6IHBhcmVudFgsXG4gICAgICB5OiBwYXJlbnRZLFxuICAgICAgd2lkdGg6IHBhcmVudFdpZHRoLFxuICAgICAgaGVpZ2h0OiBwYXJlbnRIZWlnaHRcbiAgICB9ID0gdGhpcy4jZWRpdG9yLnBhcmVudC5ib3VuZGluZ0NsaWVudFJlY3Q7XG4gICAgcmV0dXJuIFsoeCAtIHBhcmVudFgpIC8gcGFyZW50V2lkdGgsICh5ICsgaGVpZ2h0IC0gcGFyZW50WSkgLyBwYXJlbnRIZWlnaHRdO1xuICB9XG4gIHNldCBjb21tZW50UG9wdXBQb3NpdGlvbkluTGF5ZXIocG9zKSB7XG4gICAgdGhpcy4jcG9wdXBQb3NpdGlvbiA9IHBvcztcbiAgfVxuICBoYXNEZWZhdWx0UG9wdXBQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9wdXBQb3NpdGlvbiA9PT0gbnVsbDtcbiAgfVxuICByZW1vdmVTdGFuZGFsb25lQ29tbWVudEJ1dHRvbigpIHtcbiAgICB0aGlzLiNjb21tZW50U3RhbmRhbG9uZUJ1dHRvbj8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jY29tbWVudFN0YW5kYWxvbmVCdXR0b24gPSBudWxsO1xuICB9XG4gIHJlbW92ZVRvb2xiYXJDb21tZW50QnV0dG9uKCkge1xuICAgIHRoaXMuI2NvbW1lbnRUb29sYmFyQnV0dG9uPy5yZW1vdmUoKTtcbiAgICB0aGlzLiNjb21tZW50VG9vbGJhckJ1dHRvbiA9IG51bGw7XG4gIH1cbiAgc2V0Q29tbWVudEJ1dHRvblN0YXRlcyh7XG4gICAgc2VsZWN0ZWQsXG4gICAgaGFzUG9wdXBcbiAgfSkge1xuICAgIGlmICghdGhpcy4jY29tbWVudFN0YW5kYWxvbmVCdXR0b24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY29tbWVudFN0YW5kYWxvbmVCdXR0b24uY2xhc3NMaXN0LnRvZ2dsZShcInNlbGVjdGVkXCIsIHNlbGVjdGVkKTtcbiAgICB0aGlzLiNjb21tZW50U3RhbmRhbG9uZUJ1dHRvbi5hcmlhRXhwYW5kZWQgPSBoYXNQb3B1cDtcbiAgfVxuICAjcmVuZGVyKGNvbW1lbnQsIGlzU3RhbmRhbG9uZSkge1xuICAgIGlmICghdGhpcy4jZWRpdG9yLl91aU1hbmFnZXIuaGFzQ29tbWVudE1hbmFnZXIoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbW1lbnQudGFiSW5kZXggPSBcIjBcIjtcbiAgICBjb21tZW50LmFyaWFIYXNQb3B1cCA9IFwiZGlhbG9nXCI7XG4gICAgaWYgKGlzU3RhbmRhbG9uZSkge1xuICAgICAgY29tbWVudC5hcmlhQ29udHJvbHMgPSBcImNvbW1lbnRQb3B1cFwiO1xuICAgICAgY29tbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1zaG93LWNvbW1lbnQtYnV0dG9uXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21tZW50LmFyaWFDb250cm9sc0VsZW1lbnRzID0gW3RoaXMuI2VkaXRvci5fdWlNYW5hZ2VyLmdldENvbW1lbnREaWFsb2dFbGVtZW50KCldO1xuICAgICAgY29tbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1lZGl0b3ItZWRpdC1jb21tZW50LWJ1dHRvblwiKTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jZWRpdG9yLl91aU1hbmFnZXIuX3NpZ25hbDtcbiAgICBpZiAoIShzaWduYWwgaW5zdGFuY2VvZiBBYm9ydFNpZ25hbCkgfHwgc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybiBjb21tZW50O1xuICAgIH1cbiAgICBjb21tZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBub0NvbnRleHRNZW51LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBpZiAoaXNTdGFuZGFsb25lKSB7XG4gICAgICBjb21tZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIChlKSA9PiB7XG4gICAgICAgIHRoaXMuI2VkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gZmFsc2U7XG4gICAgICAgIHN0b3BFdmVudChlKTtcbiAgICAgIH0sIHtcbiAgICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGNvbW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIChlKSA9PiB7XG4gICAgICAgIHRoaXMuI2VkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gdHJ1ZTtcbiAgICAgICAgc3RvcEV2ZW50KGUpO1xuICAgICAgfSwge1xuICAgICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb21tZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCAoZXZlbnQpID0+IGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBjb25zdCBvbkNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKGNvbW1lbnQgPT09IHRoaXMuI2NvbW1lbnRUb29sYmFyQnV0dG9uKSB7XG4gICAgICAgIHRoaXMuZWRpdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4jZWRpdG9yLnRvZ2dsZUNvbW1lbnQodHJ1ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb21tZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBvbkNsaWNrLCB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgY29tbWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC50YXJnZXQgPT09IGNvbW1lbnQgJiYgZXZlbnQua2V5ID09PSBcIkVudGVyXCIpIHtcbiAgICAgICAgdGhpcy4jY29tbWVudFdhc0Zyb21LZXlCb2FyZCA9IHRydWU7XG4gICAgICAgIG9uQ2xpY2soZXZlbnQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGNvbW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJlbnRlclwiLCAoKSA9PiB7XG4gICAgICB0aGlzLiNlZGl0b3IudG9nZ2xlQ29tbWVudChmYWxzZSwgdHJ1ZSk7XG4gICAgfSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgY29tbWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmxlYXZlXCIsICgpID0+IHtcbiAgICAgIHRoaXMuI2VkaXRvci50b2dnbGVDb21tZW50KGZhbHNlLCBmYWxzZSk7XG4gICAgfSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbW1lbnQ7XG4gIH1cbiAgZWRpdChvcHRpb25zKSB7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLmNvbW1lbnRQb3B1cFBvc2l0aW9uSW5MYXllcjtcbiAgICBsZXQgcG9zWCwgcG9zWTtcbiAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgIFtwb3NYLCBwb3NZXSA9IHBvc2l0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICBbcG9zWCwgcG9zWV0gPSB0aGlzLiNlZGl0b3IuY29tbWVudEJ1dHRvblBvc2l0aW9uO1xuICAgICAgY29uc3Qge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9ID0gdGhpcy4jZWRpdG9yO1xuICAgICAgcG9zWCA9IHggKyBwb3NYICogd2lkdGg7XG4gICAgICBwb3NZID0geSArIHBvc1kgKiBoZWlnaHQ7XG4gICAgfVxuICAgIGNvbnN0IHBhcmVudERpbWVuc2lvbnMgPSB0aGlzLiNlZGl0b3IucGFyZW50LmJvdW5kaW5nQ2xpZW50UmVjdDtcbiAgICBjb25zdCB7XG4gICAgICB4OiBwYXJlbnRYLFxuICAgICAgeTogcGFyZW50WSxcbiAgICAgIHdpZHRoOiBwYXJlbnRXaWR0aCxcbiAgICAgIGhlaWdodDogcGFyZW50SGVpZ2h0XG4gICAgfSA9IHBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy4jZWRpdG9yLl91aU1hbmFnZXIuZWRpdENvbW1lbnQodGhpcy4jZWRpdG9yLCBwYXJlbnRYICsgcG9zWCAqIHBhcmVudFdpZHRoLCBwYXJlbnRZICsgcG9zWSAqIHBhcmVudEhlaWdodCwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHBhcmVudERpbWVuc2lvbnNcbiAgICB9KTtcbiAgfVxuICBmaW5pc2goKSB7XG4gICAgaWYgKCF0aGlzLiNjb21tZW50VG9vbGJhckJ1dHRvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNjb21tZW50VG9vbGJhckJ1dHRvbi5mb2N1cyh7XG4gICAgICBmb2N1c1Zpc2libGU6IHRoaXMuI2NvbW1lbnRXYXNGcm9tS2V5Qm9hcmRcbiAgICB9KTtcbiAgICB0aGlzLiNjb21tZW50V2FzRnJvbUtleUJvYXJkID0gZmFsc2U7XG4gIH1cbiAgaXNEZWxldGVkKCkge1xuICAgIHJldHVybiB0aGlzLiNkZWxldGVkIHx8IHRoaXMuI3RleHQgPT09IFwiXCI7XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy4jdGV4dCA9PT0gbnVsbDtcbiAgfVxuICBoYXNCZWVuRWRpdGVkKCkge1xuICAgIHJldHVybiB0aGlzLmlzRGVsZXRlZCgpIHx8IHRoaXMuI3RleHQgIT09IHRoaXMuI2luaXRpYWxUZXh0O1xuICB9XG4gIHNlcmlhbGl6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhO1xuICB9XG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0ZXh0OiB0aGlzLiN0ZXh0LFxuICAgICAgcmljaFRleHQ6IHRoaXMuI3JpY2hUZXh0LFxuICAgICAgZGF0ZTogdGhpcy4jZGF0ZSxcbiAgICAgIGRlbGV0ZWQ6IHRoaXMuaXNEZWxldGVkKClcbiAgICB9O1xuICB9XG4gIHNldCBkYXRhKHRleHQpIHtcbiAgICBpZiAodGV4dCAhPT0gdGhpcy4jdGV4dCkge1xuICAgICAgdGhpcy4jcmljaFRleHQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGV4dCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy4jdGV4dCA9IFwiXCI7XG4gICAgICB0aGlzLiNkZWxldGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jdGV4dCA9IHRleHQ7XG4gICAgdGhpcy4jZGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgIHRoaXMuI2RlbGV0ZWQgPSBmYWxzZTtcbiAgfVxuICBzZXRJbml0aWFsVGV4dCh0ZXh0LCByaWNoVGV4dCA9IG51bGwpIHtcbiAgICB0aGlzLiNpbml0aWFsVGV4dCA9IHRleHQ7XG4gICAgdGhpcy5kYXRhID0gdGV4dDtcbiAgICB0aGlzLiNkYXRlID0gbnVsbDtcbiAgICB0aGlzLiNyaWNoVGV4dCA9IHJpY2hUZXh0O1xuICB9XG4gIHNob3duKCkge1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4jY29tbWVudFRvb2xiYXJCdXR0b24/LnJlbW92ZSgpO1xuICAgIHRoaXMuI2NvbW1lbnRUb29sYmFyQnV0dG9uID0gbnVsbDtcbiAgICB0aGlzLiNjb21tZW50U3RhbmRhbG9uZUJ1dHRvbj8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jY29tbWVudFN0YW5kYWxvbmVCdXR0b24gPSBudWxsO1xuICAgIHRoaXMuI3RleHQgPSBcIlwiO1xuICAgIHRoaXMuI3JpY2hUZXh0ID0gbnVsbDtcbiAgICB0aGlzLiNkYXRlID0gbnVsbDtcbiAgICB0aGlzLiNlZGl0b3IgPSBudWxsO1xuICAgIHRoaXMuI2NvbW1lbnRXYXNGcm9tS2V5Qm9hcmQgPSBmYWxzZTtcbiAgICB0aGlzLiNkZWxldGVkID0gZmFsc2U7XG4gIH1cbn1cbmNsYXNzIFRvdWNoTWFuYWdlciB7XG4gICNjb250YWluZXI7XG4gICNpc1BpbmNoaW5nID0gZmFsc2U7XG4gICNpc1BpbmNoaW5nU3RvcHBlZCA9IG51bGw7XG4gICNpc1BpbmNoaW5nRGlzYWJsZWQ7XG4gICNvblBpbmNoU3RhcnQ7XG4gICNvblBpbmNoaW5nO1xuICAjb25QaW5jaEVuZDtcbiAgI3BvaW50ZXJEb3duQUMgPSBudWxsO1xuICAjc2lnbmFsO1xuICAjdG91Y2hJbmZvID0gbnVsbDtcbiAgI3RvdWNoTWFuYWdlckFDO1xuICAjdG91Y2hNb3ZlQUMgPSBudWxsO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY29udGFpbmVyLFxuICAgIGlzUGluY2hpbmdEaXNhYmxlZCA9IG51bGwsXG4gICAgaXNQaW5jaGluZ1N0b3BwZWQgPSBudWxsLFxuICAgIG9uUGluY2hTdGFydCA9IG51bGwsXG4gICAgb25QaW5jaGluZyA9IG51bGwsXG4gICAgb25QaW5jaEVuZCA9IG51bGwsXG4gICAgc2lnbmFsXG4gIH0pIHtcbiAgICB0aGlzLiNjb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy4jaXNQaW5jaGluZ1N0b3BwZWQgPSBpc1BpbmNoaW5nU3RvcHBlZDtcbiAgICB0aGlzLiNpc1BpbmNoaW5nRGlzYWJsZWQgPSBpc1BpbmNoaW5nRGlzYWJsZWQ7XG4gICAgdGhpcy4jb25QaW5jaFN0YXJ0ID0gb25QaW5jaFN0YXJ0O1xuICAgIHRoaXMuI29uUGluY2hpbmcgPSBvblBpbmNoaW5nO1xuICAgIHRoaXMuI29uUGluY2hFbmQgPSBvblBpbmNoRW5kO1xuICAgIHRoaXMuI3RvdWNoTWFuYWdlckFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIHRoaXMuI3NpZ25hbCA9IEFib3J0U2lnbmFsLmFueShbc2lnbmFsLCB0aGlzLiN0b3VjaE1hbmFnZXJBQy5zaWduYWxdKTtcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy4jb25Ub3VjaFN0YXJ0LmJpbmQodGhpcyksIHtcbiAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgc2lnbmFsOiB0aGlzLiNzaWduYWxcbiAgICB9KTtcbiAgfVxuICBnZXQgTUlOX1RPVUNIX0RJU1RBTkNFX1RPX1BJTkNIKCkge1xuICAgIHJldHVybiAzNSAvIE91dHB1dFNjYWxlLnBpeGVsUmF0aW87XG4gIH1cbiAgI29uVG91Y2hTdGFydChldnQpIHtcbiAgICBpZiAodGhpcy4jaXNQaW5jaGluZ0Rpc2FibGVkPy4oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZ0LnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAodGhpcy4jcG9pbnRlckRvd25BQykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwb2ludGVyRG93bkFDID0gdGhpcy4jcG9pbnRlckRvd25BQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIGNvbnN0IHNpZ25hbCA9IEFib3J0U2lnbmFsLmFueShbdGhpcy4jc2lnbmFsLCBwb2ludGVyRG93bkFDLnNpZ25hbF0pO1xuICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy4jY29udGFpbmVyO1xuICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgICAgc2lnbmFsLFxuICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNhbmNlbFBvaW50ZXJEb3duID0gKGUpID0+IHtcbiAgICAgICAgaWYgKGUucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIikge1xuICAgICAgICAgIHRoaXMuI3BvaW50ZXJEb3duQUM/LmFib3J0KCk7XG4gICAgICAgICAgdGhpcy4jcG9pbnRlckRvd25BQyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIChlKSA9PiB7XG4gICAgICAgIGlmIChlLnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIpIHtcbiAgICAgICAgICBzdG9wRXZlbnQoZSk7XG4gICAgICAgICAgY2FuY2VsUG9pbnRlckRvd24oZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIG9wdHMpO1xuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgY2FuY2VsUG9pbnRlckRvd24sIG9wdHMpO1xuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyY2FuY2VsXCIsIGNhbmNlbFBvaW50ZXJEb3duLCBvcHRzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiN0b3VjaE1vdmVBQykge1xuICAgICAgdGhpcy4jdG91Y2hNb3ZlQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICBjb25zdCBzaWduYWwgPSBBYm9ydFNpZ25hbC5hbnkoW3RoaXMuI3NpZ25hbCwgdGhpcy4jdG91Y2hNb3ZlQUMuc2lnbmFsXSk7XG4gICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLiNjb250YWluZXI7XG4gICAgICBjb25zdCBvcHQgPSB7XG4gICAgICAgIHNpZ25hbCxcbiAgICAgICAgY2FwdHVyZTogZmFsc2UsXG4gICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICB9O1xuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy4jb25Ub3VjaE1vdmUuYmluZCh0aGlzKSwgb3B0KTtcbiAgICAgIGNvbnN0IG9uVG91Y2hFbmQgPSB0aGlzLiNvblRvdWNoRW5kLmJpbmQodGhpcyk7XG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIG9uVG91Y2hFbmQsIG9wdCk7XG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoY2FuY2VsXCIsIG9uVG91Y2hFbmQsIG9wdCk7XG4gICAgICBvcHQuY2FwdHVyZSA9IHRydWU7XG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHN0b3BFdmVudCwgb3B0KTtcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgc3RvcEV2ZW50LCBvcHQpO1xuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyY2FuY2VsXCIsIHN0b3BFdmVudCwgb3B0KTtcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHN0b3BFdmVudCwgb3B0KTtcbiAgICAgIHRoaXMuI29uUGluY2hTdGFydD8uKCk7XG4gICAgfVxuICAgIHN0b3BFdmVudChldnQpO1xuICAgIGlmIChldnQudG91Y2hlcy5sZW5ndGggIT09IDIgfHwgdGhpcy4jaXNQaW5jaGluZ1N0b3BwZWQ/LigpKSB7XG4gICAgICB0aGlzLiN0b3VjaEluZm8gPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgW3RvdWNoMCwgdG91Y2gxXSA9IGV2dC50b3VjaGVzO1xuICAgIGlmICh0b3VjaDAuaWRlbnRpZmllciA+IHRvdWNoMS5pZGVudGlmaWVyKSB7XG4gICAgICBbdG91Y2gwLCB0b3VjaDFdID0gW3RvdWNoMSwgdG91Y2gwXTtcbiAgICB9XG4gICAgdGhpcy4jdG91Y2hJbmZvID0ge1xuICAgICAgdG91Y2gwWDogdG91Y2gwLnNjcmVlblgsXG4gICAgICB0b3VjaDBZOiB0b3VjaDAuc2NyZWVuWSxcbiAgICAgIHRvdWNoMVg6IHRvdWNoMS5zY3JlZW5YLFxuICAgICAgdG91Y2gxWTogdG91Y2gxLnNjcmVlbllcbiAgICB9O1xuICB9XG4gICNvblRvdWNoTW92ZShldnQpIHtcbiAgICBpZiAoIXRoaXMuI3RvdWNoSW5mbyB8fCBldnQudG91Y2hlcy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3RvcEV2ZW50KGV2dCk7XG4gICAgbGV0IFt0b3VjaDAsIHRvdWNoMV0gPSBldnQudG91Y2hlcztcbiAgICBpZiAodG91Y2gwLmlkZW50aWZpZXIgPiB0b3VjaDEuaWRlbnRpZmllcikge1xuICAgICAgW3RvdWNoMCwgdG91Y2gxXSA9IFt0b3VjaDEsIHRvdWNoMF07XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHNjcmVlblg6IHNjcmVlbjBYLFxuICAgICAgc2NyZWVuWTogc2NyZWVuMFlcbiAgICB9ID0gdG91Y2gwO1xuICAgIGNvbnN0IHtcbiAgICAgIHNjcmVlblg6IHNjcmVlbjFYLFxuICAgICAgc2NyZWVuWTogc2NyZWVuMVlcbiAgICB9ID0gdG91Y2gxO1xuICAgIGNvbnN0IHRvdWNoSW5mbyA9IHRoaXMuI3RvdWNoSW5mbztcbiAgICBjb25zdCB7XG4gICAgICB0b3VjaDBYOiBwVG91Y2gwWCxcbiAgICAgIHRvdWNoMFk6IHBUb3VjaDBZLFxuICAgICAgdG91Y2gxWDogcFRvdWNoMVgsXG4gICAgICB0b3VjaDFZOiBwVG91Y2gxWVxuICAgIH0gPSB0b3VjaEluZm87XG4gICAgY29uc3QgcHJldkdhcFggPSBwVG91Y2gxWCAtIHBUb3VjaDBYO1xuICAgIGNvbnN0IHByZXZHYXBZID0gcFRvdWNoMVkgLSBwVG91Y2gwWTtcbiAgICBjb25zdCBjdXJyR2FwWCA9IHNjcmVlbjFYIC0gc2NyZWVuMFg7XG4gICAgY29uc3QgY3VyckdhcFkgPSBzY3JlZW4xWSAtIHNjcmVlbjBZO1xuICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5oeXBvdChjdXJyR2FwWCwgY3VyckdhcFkpIHx8IDE7XG4gICAgY29uc3QgcERpc3RhbmNlID0gTWF0aC5oeXBvdChwcmV2R2FwWCwgcHJldkdhcFkpIHx8IDE7XG4gICAgaWYgKCF0aGlzLiNpc1BpbmNoaW5nICYmIE1hdGguYWJzKHBEaXN0YW5jZSAtIGRpc3RhbmNlKSA8PSBUb3VjaE1hbmFnZXIuTUlOX1RPVUNIX0RJU1RBTkNFX1RPX1BJTkNIKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRvdWNoSW5mby50b3VjaDBYID0gc2NyZWVuMFg7XG4gICAgdG91Y2hJbmZvLnRvdWNoMFkgPSBzY3JlZW4wWTtcbiAgICB0b3VjaEluZm8udG91Y2gxWCA9IHNjcmVlbjFYO1xuICAgIHRvdWNoSW5mby50b3VjaDFZID0gc2NyZWVuMVk7XG4gICAgaWYgKCF0aGlzLiNpc1BpbmNoaW5nKSB7XG4gICAgICB0aGlzLiNpc1BpbmNoaW5nID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb3JpZ2luID0gWyhzY3JlZW4wWCArIHNjcmVlbjFYKSAvIDIsIChzY3JlZW4wWSArIHNjcmVlbjFZKSAvIDJdO1xuICAgIHRoaXMuI29uUGluY2hpbmc/LihvcmlnaW4sIHBEaXN0YW5jZSwgZGlzdGFuY2UpO1xuICB9XG4gICNvblRvdWNoRW5kKGV2dCkge1xuICAgIGlmIChldnQudG91Y2hlcy5sZW5ndGggPj0gMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jdG91Y2hNb3ZlQUMpIHtcbiAgICAgIHRoaXMuI3RvdWNoTW92ZUFDLmFib3J0KCk7XG4gICAgICB0aGlzLiN0b3VjaE1vdmVBQyA9IG51bGw7XG4gICAgICB0aGlzLiNvblBpbmNoRW5kPy4oKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiN0b3VjaEluZm8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3RvcEV2ZW50KGV2dCk7XG4gICAgdGhpcy4jdG91Y2hJbmZvID0gbnVsbDtcbiAgICB0aGlzLiNpc1BpbmNoaW5nID0gZmFsc2U7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiN0b3VjaE1hbmFnZXJBQz8uYWJvcnQoKTtcbiAgICB0aGlzLiN0b3VjaE1hbmFnZXJBQyA9IG51bGw7XG4gICAgdGhpcy4jcG9pbnRlckRvd25BQz8uYWJvcnQoKTtcbiAgICB0aGlzLiNwb2ludGVyRG93bkFDID0gbnVsbDtcbiAgfVxufVxuY2xhc3MgQW5ub3RhdGlvbkVkaXRvciB7XG4gICNhY2Nlc3NpYmlsaXR5RGF0YSA9IG51bGw7XG4gICNhbGxSZXNpemVyRGl2cyA9IG51bGw7XG4gICNhbHRUZXh0ID0gbnVsbDtcbiAgI2NvbW1lbnQgPSBudWxsO1xuICAjY29tbWVudFN0YW5kYWxvbmVCdXR0b24gPSBudWxsO1xuICAjZGlzYWJsZWQgPSBmYWxzZTtcbiAgI2RyYWdQb2ludGVySWQgPSBudWxsO1xuICAjZHJhZ1BvaW50ZXJUeXBlID0gXCJcIjtcbiAgI3Jlc2l6ZXJzRGl2ID0gbnVsbDtcbiAgI2xhc3RQb2ludGVyQ29vcmRzID0gbnVsbDtcbiAgI3NhdmVkRGltZW5zaW9ucyA9IG51bGw7XG4gICNmYWtlQW5ub3RhdGlvbiA9IG51bGw7XG4gICNmb2N1c0FDID0gbnVsbDtcbiAgI2ZvY3VzZWRSZXNpemVyTmFtZSA9IFwiXCI7XG4gICNoYXNCZWVuQ2xpY2tlZCA9IGZhbHNlO1xuICAjaW5pdGlhbFJlY3QgPSBudWxsO1xuICAjaXNFZGl0aW5nID0gZmFsc2U7XG4gICNpc0luRWRpdE1vZGUgPSBmYWxzZTtcbiAgI2lzUmVzaXplckVuYWJsZWRGb3JLZXlib2FyZCA9IGZhbHNlO1xuICAjbW92ZUluRE9NVGltZW91dCA9IG51bGw7XG4gICNwcmV2RHJhZ1ggPSAwO1xuICAjcHJldkRyYWdZID0gMDtcbiAgI3RlbGVtZXRyeVRpbWVvdXRzID0gbnVsbDtcbiAgI3RvdWNoTWFuYWdlciA9IG51bGw7XG4gIGlzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgX2lzQ29weSA9IGZhbHNlO1xuICBfZWRpdFRvb2xiYXIgPSBudWxsO1xuICBfaW5pdGlhbE9wdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgX2luaXRpYWxEYXRhID0gbnVsbDtcbiAgX2lzVmlzaWJsZSA9IHRydWU7XG4gIF91aU1hbmFnZXIgPSBudWxsO1xuICBfZm9jdXNFdmVudHNBbGxvd2VkID0gdHJ1ZTtcbiAgc3RhdGljIF9sMTBuID0gbnVsbDtcbiAgc3RhdGljIF9sMTBuUmVzaXplciA9IG51bGw7XG4gICNpc0RyYWdnYWJsZSA9IGZhbHNlO1xuICAjekluZGV4ID0gQW5ub3RhdGlvbkVkaXRvci5fekluZGV4Kys7XG4gIHN0YXRpYyBfYm9yZGVyTGluZVdpZHRoID0gLTE7XG4gIHN0YXRpYyBfY29sb3JNYW5hZ2VyID0gbmV3IENvbG9yTWFuYWdlcigpO1xuICBzdGF0aWMgX3pJbmRleCA9IDE7XG4gIHN0YXRpYyBfdGVsZW1ldHJ5VGltZW91dCA9IDFlMztcbiAgc3RhdGljIGdldCBfcmVzaXplcktleWJvYXJkTWFuYWdlcigpIHtcbiAgICBjb25zdCByZXNpemUgPSBBbm5vdGF0aW9uRWRpdG9yLnByb3RvdHlwZS5fcmVzaXplV2l0aEtleWJvYXJkO1xuICAgIGNvbnN0IHNtYWxsID0gQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlci5UUkFOU0xBVEVfU01BTEw7XG4gICAgY29uc3QgYmlnID0gQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlci5UUkFOU0xBVEVfQklHO1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfcmVzaXplcktleWJvYXJkTWFuYWdlclwiLCBuZXcgS2V5Ym9hcmRNYW5hZ2VyKFtbW1wiQXJyb3dMZWZ0XCIsIFwibWFjK0Fycm93TGVmdFwiXSwgcmVzaXplLCB7XG4gICAgICBhcmdzOiBbLXNtYWxsLCAwXVxuICAgIH1dLCBbW1wiY3RybCtBcnJvd0xlZnRcIiwgXCJtYWMrc2hpZnQrQXJyb3dMZWZ0XCJdLCByZXNpemUsIHtcbiAgICAgIGFyZ3M6IFstYmlnLCAwXVxuICAgIH1dLCBbW1wiQXJyb3dSaWdodFwiLCBcIm1hYytBcnJvd1JpZ2h0XCJdLCByZXNpemUsIHtcbiAgICAgIGFyZ3M6IFtzbWFsbCwgMF1cbiAgICB9XSwgW1tcImN0cmwrQXJyb3dSaWdodFwiLCBcIm1hYytzaGlmdCtBcnJvd1JpZ2h0XCJdLCByZXNpemUsIHtcbiAgICAgIGFyZ3M6IFtiaWcsIDBdXG4gICAgfV0sIFtbXCJBcnJvd1VwXCIsIFwibWFjK0Fycm93VXBcIl0sIHJlc2l6ZSwge1xuICAgICAgYXJnczogWzAsIC1zbWFsbF1cbiAgICB9XSwgW1tcImN0cmwrQXJyb3dVcFwiLCBcIm1hYytzaGlmdCtBcnJvd1VwXCJdLCByZXNpemUsIHtcbiAgICAgIGFyZ3M6IFswLCAtYmlnXVxuICAgIH1dLCBbW1wiQXJyb3dEb3duXCIsIFwibWFjK0Fycm93RG93blwiXSwgcmVzaXplLCB7XG4gICAgICBhcmdzOiBbMCwgc21hbGxdXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93RG93blwiLCBcIm1hYytzaGlmdCtBcnJvd0Rvd25cIl0sIHJlc2l6ZSwge1xuICAgICAgYXJnczogWzAsIGJpZ11cbiAgICB9XSwgW1tcIkVzY2FwZVwiLCBcIm1hYytFc2NhcGVcIl0sIEFubm90YXRpb25FZGl0b3IucHJvdG90eXBlLl9zdG9wUmVzaXppbmdXaXRoS2V5Ym9hcmRdXSkpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmFtZXRlcnMucGFyZW50O1xuICAgIHRoaXMuaWQgPSBwYXJhbWV0ZXJzLmlkO1xuICAgIHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IG51bGw7XG4gICAgdGhpcy5wYWdlSW5kZXggPSBwYXJhbWV0ZXJzLnBhcmVudC5wYWdlSW5kZXg7XG4gICAgdGhpcy5uYW1lID0gcGFyYW1ldGVycy5uYW1lO1xuICAgIHRoaXMuZGl2ID0gbnVsbDtcbiAgICB0aGlzLl91aU1hbmFnZXIgPSBwYXJhbWV0ZXJzLnVpTWFuYWdlcjtcbiAgICB0aGlzLmFubm90YXRpb25FbGVtZW50SWQgPSBudWxsO1xuICAgIHRoaXMuX3dpbGxLZWVwQXNwZWN0UmF0aW8gPSBmYWxzZTtcbiAgICB0aGlzLl9pbml0aWFsT3B0aW9ucy5pc0NlbnRlcmVkID0gcGFyYW1ldGVycy5pc0NlbnRlcmVkO1xuICAgIHRoaXMuX3N0cnVjdFRyZWVQYXJlbnRJZCA9IG51bGw7XG4gICAgdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkID0gcGFyYW1ldGVycy5hbm5vdGF0aW9uRWxlbWVudElkIHx8IG51bGw7XG4gICAgdGhpcy5jcmVhdGlvbkRhdGUgPSBwYXJhbWV0ZXJzLmNyZWF0aW9uRGF0ZSB8fCAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICB0aGlzLm1vZGlmaWNhdGlvbkRhdGUgPSBwYXJhbWV0ZXJzLm1vZGlmaWNhdGlvbkRhdGUgfHwgbnVsbDtcbiAgICBjb25zdCB7XG4gICAgICByb3RhdGlvbixcbiAgICAgIHJhd0RpbXM6IHtcbiAgICAgICAgcGFnZVdpZHRoLFxuICAgICAgICBwYWdlSGVpZ2h0LFxuICAgICAgICBwYWdlWCxcbiAgICAgICAgcGFnZVlcbiAgICAgIH1cbiAgICB9ID0gdGhpcy5wYXJlbnQudmlld3BvcnQ7XG4gICAgdGhpcy5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHRoaXMucGFnZVJvdGF0aW9uID0gKDM2MCArIHJvdGF0aW9uIC0gdGhpcy5fdWlNYW5hZ2VyLnZpZXdQYXJhbWV0ZXJzLnJvdGF0aW9uKSAlIDM2MDtcbiAgICB0aGlzLnBhZ2VEaW1lbnNpb25zID0gW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF07XG4gICAgdGhpcy5wYWdlVHJhbnNsYXRpb24gPSBbcGFnZVgsIHBhZ2VZXTtcbiAgICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy54ID0gcGFyYW1ldGVycy54IC8gd2lkdGg7XG4gICAgdGhpcy55ID0gcGFyYW1ldGVycy55IC8gaGVpZ2h0O1xuICAgIHRoaXMuaXNBdHRhY2hlZFRvRE9NID0gZmFsc2U7XG4gICAgdGhpcy5kZWxldGVkID0gZmFsc2U7XG4gIH1cbiAgZ2V0IGVkaXRvclR5cGUoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvci5fdHlwZTtcbiAgfVxuICBnZXQgbW9kZSgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yLl9lZGl0b3JUeXBlO1xuICB9XG4gIHN0YXRpYyBnZXQgaXNEcmF3ZXIoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YXRpYyBnZXQgX2RlZmF1bHRMaW5lQ29sb3IoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9kZWZhdWx0TGluZUNvbG9yXCIsIHRoaXMuX2NvbG9yTWFuYWdlci5nZXRIZXhDb2RlKFwiQ2FudmFzVGV4dFwiKSk7XG4gIH1cbiAgc3RhdGljIGRlbGV0ZUFubm90YXRpb25FbGVtZW50KGVkaXRvcikge1xuICAgIGNvbnN0IGZha2VFZGl0b3IgPSBuZXcgRmFrZUVkaXRvcih7XG4gICAgICBpZDogZWRpdG9yLnBhcmVudC5nZXROZXh0SWQoKSxcbiAgICAgIHBhcmVudDogZWRpdG9yLnBhcmVudCxcbiAgICAgIHVpTWFuYWdlcjogZWRpdG9yLl91aU1hbmFnZXJcbiAgICB9KTtcbiAgICBmYWtlRWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQgPSBlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZDtcbiAgICBmYWtlRWRpdG9yLmRlbGV0ZWQgPSB0cnVlO1xuICAgIGZha2VFZGl0b3IuX3VpTWFuYWdlci5hZGRUb0Fubm90YXRpb25TdG9yYWdlKGZha2VFZGl0b3IpO1xuICB9XG4gIHN0YXRpYyBpbml0aWFsaXplKGwxMG4sIF91aU1hbmFnZXIpIHtcbiAgICBBbm5vdGF0aW9uRWRpdG9yLl9sMTBuID8/PSBsMTBuO1xuICAgIEFubm90YXRpb25FZGl0b3IuX2wxMG5SZXNpemVyIHx8PSBPYmplY3QuZnJlZXplKHtcbiAgICAgIHRvcExlZnQ6IFwicGRmanMtZWRpdG9yLXJlc2l6ZXItdG9wLWxlZnRcIixcbiAgICAgIHRvcE1pZGRsZTogXCJwZGZqcy1lZGl0b3ItcmVzaXplci10b3AtbWlkZGxlXCIsXG4gICAgICB0b3BSaWdodDogXCJwZGZqcy1lZGl0b3ItcmVzaXplci10b3AtcmlnaHRcIixcbiAgICAgIG1pZGRsZVJpZ2h0OiBcInBkZmpzLWVkaXRvci1yZXNpemVyLW1pZGRsZS1yaWdodFwiLFxuICAgICAgYm90dG9tUmlnaHQ6IFwicGRmanMtZWRpdG9yLXJlc2l6ZXItYm90dG9tLXJpZ2h0XCIsXG4gICAgICBib3R0b21NaWRkbGU6IFwicGRmanMtZWRpdG9yLXJlc2l6ZXItYm90dG9tLW1pZGRsZVwiLFxuICAgICAgYm90dG9tTGVmdDogXCJwZGZqcy1lZGl0b3ItcmVzaXplci1ib3R0b20tbGVmdFwiLFxuICAgICAgbWlkZGxlTGVmdDogXCJwZGZqcy1lZGl0b3ItcmVzaXplci1taWRkbGUtbGVmdFwiXG4gICAgfSk7XG4gICAgaWYgKEFubm90YXRpb25FZGl0b3IuX2JvcmRlckxpbmVXaWR0aCAhPT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG4gICAgQW5ub3RhdGlvbkVkaXRvci5fYm9yZGVyTGluZVdpZHRoID0gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiLS1vdXRsaW5lLXdpZHRoXCIpKSB8fCAwO1xuICB9XG4gIHN0YXRpYyB1cGRhdGVEZWZhdWx0UGFyYW1zKF90eXBlLCBfdmFsdWUpIHtcbiAgfVxuICBzdGF0aWMgZ2V0IGRlZmF1bHRQcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHN0YXRpYyBpc0hhbmRsaW5nTWltZUZvclBhc3RpbmcobWltZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgcGFzdGUoaXRlbSwgcGFyZW50KSB7XG4gICAgdW5yZWFjaGFibGUoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgZ2V0IHByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgZ2V0IF9pc0RyYWdnYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jaXNEcmFnZ2FibGU7XG4gIH1cbiAgc2V0IF9pc0RyYWdnYWJsZSh2YWx1ZSkge1xuICAgIHRoaXMuI2lzRHJhZ2dhYmxlID0gdmFsdWU7XG4gICAgdGhpcy5kaXY/LmNsYXNzTGlzdC50b2dnbGUoXCJkcmFnZ2FibGVcIiwgdmFsdWUpO1xuICB9XG4gIGdldCB1aWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCB8fCB0aGlzLmlkO1xuICB9XG4gIGdldCBpc0VudGVySGFuZGxlZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjZW50ZXIoKSB7XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgIHN3aXRjaCAodGhpcy5wYXJlbnRSb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgdGhpcy54IC09IHRoaXMuaGVpZ2h0ICogcGFnZUhlaWdodCAvIChwYWdlV2lkdGggKiAyKTtcbiAgICAgICAgdGhpcy55ICs9IHRoaXMud2lkdGggKiBwYWdlV2lkdGggLyAocGFnZUhlaWdodCAqIDIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICB0aGlzLnggKz0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIHRoaXMueSArPSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHRoaXMueCArPSB0aGlzLmhlaWdodCAqIHBhZ2VIZWlnaHQgLyAocGFnZVdpZHRoICogMik7XG4gICAgICAgIHRoaXMueSAtPSB0aGlzLndpZHRoICogcGFnZVdpZHRoIC8gKHBhZ2VIZWlnaHQgKiAyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLnggLT0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIHRoaXMueSAtPSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gIH1cbiAgYWRkQ29tbWFuZHMocGFyYW1zKSB7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLmFkZENvbW1hbmRzKHBhcmFtcyk7XG4gIH1cbiAgZ2V0IGN1cnJlbnRMYXllcigpIHtcbiAgICByZXR1cm4gdGhpcy5fdWlNYW5hZ2VyLmN1cnJlbnRMYXllcjtcbiAgfVxuICBzZXRJbkJhY2tncm91bmQoKSB7XG4gICAgdGhpcy5kaXYuc3R5bGUuekluZGV4ID0gMDtcbiAgfVxuICBzZXRJbkZvcmVncm91bmQoKSB7XG4gICAgdGhpcy5kaXYuc3R5bGUuekluZGV4ID0gdGhpcy4jekluZGV4O1xuICB9XG4gIHNldFBhcmVudChwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICB0aGlzLnBhZ2VJbmRleCA9IHBhcmVudC5wYWdlSW5kZXg7XG4gICAgICB0aGlzLnBhZ2VEaW1lbnNpb25zID0gcGFyZW50LnBhZ2VEaW1lbnNpb25zO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNzdG9wUmVzaXppbmcoKTtcbiAgICAgIHRoaXMuI2Zha2VBbm5vdGF0aW9uPy5yZW1vdmUoKTtcbiAgICAgIHRoaXMuI2Zha2VBbm5vdGF0aW9uID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIH1cbiAgZm9jdXNpbihldmVudCkge1xuICAgIGlmICghdGhpcy5fZm9jdXNFdmVudHNBbGxvd2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy4jaGFzQmVlbkNsaWNrZWQpIHtcbiAgICAgIHRoaXMucGFyZW50LnNldFNlbGVjdGVkKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNoYXNCZWVuQ2xpY2tlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb2N1c291dChldmVudCkge1xuICAgIGlmICghdGhpcy5fZm9jdXNFdmVudHNBbGxvd2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICBpZiAodGFyZ2V0Py5jbG9zZXN0KGAjJHt0aGlzLmlkfWApKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKCF0aGlzLnBhcmVudD8uaXNNdWx0aXBsZVNlbGVjdGlvbikge1xuICAgICAgdGhpcy5jb21taXRPclJlbW92ZSgpO1xuICAgIH1cbiAgfVxuICBjb21taXRPclJlbW92ZSgpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29tbWl0KCk7XG4gICAgfVxuICB9XG4gIGNvbW1pdCgpIHtcbiAgICBpZiAoIXRoaXMuaXNJbkVkaXRNb2RlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5hZGRUb0Fubm90YXRpb25TdG9yYWdlKCk7XG4gIH1cbiAgYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZSgpIHtcbiAgICB0aGlzLl91aU1hbmFnZXIuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZSh0aGlzKTtcbiAgfVxuICBzZXRBdCh4LCB5LCB0eCwgdHkpIHtcbiAgICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgW3R4LCB0eV0gPSB0aGlzLnNjcmVlblRvUGFnZVRyYW5zbGF0aW9uKHR4LCB0eSk7XG4gICAgdGhpcy54ID0gKHggKyB0eCkgLyB3aWR0aDtcbiAgICB0aGlzLnkgPSAoeSArIHR5KSAvIGhlaWdodDtcbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gIH1cbiAgX21vdmVBZnRlclBhc3RlKGJhc2VYLCBiYXNlWSkge1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICB0aGlzLnNldEF0KGJhc2VYICogcGFyZW50V2lkdGgsIGJhc2VZICogcGFyZW50SGVpZ2h0LCB0aGlzLndpZHRoICogcGFyZW50V2lkdGgsIHRoaXMuaGVpZ2h0ICogcGFyZW50SGVpZ2h0KTtcbiAgICB0aGlzLl9vblRyYW5zbGF0ZWQoKTtcbiAgfVxuICAjdHJhbnNsYXRlKFt3aWR0aCwgaGVpZ2h0XSwgeCwgeSkge1xuICAgIFt4LCB5XSA9IHRoaXMuc2NyZWVuVG9QYWdlVHJhbnNsYXRpb24oeCwgeSk7XG4gICAgdGhpcy54ICs9IHggLyB3aWR0aDtcbiAgICB0aGlzLnkgKz0geSAvIGhlaWdodDtcbiAgICB0aGlzLl9vblRyYW5zbGF0aW5nKHRoaXMueCwgdGhpcy55KTtcbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gIH1cbiAgdHJhbnNsYXRlKHgsIHkpIHtcbiAgICB0aGlzLiN0cmFuc2xhdGUodGhpcy5wYXJlbnREaW1lbnNpb25zLCB4LCB5KTtcbiAgfVxuICB0cmFuc2xhdGVJblBhZ2UoeCwgeSkge1xuICAgIHRoaXMuI2luaXRpYWxSZWN0IHx8PSBbdGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XTtcbiAgICB0aGlzLiN0cmFuc2xhdGUodGhpcy5wYWdlRGltZW5zaW9ucywgeCwgeSk7XG4gICAgdGhpcy5kaXYuc2Nyb2xsSW50b1ZpZXcoe1xuICAgICAgYmxvY2s6IFwibmVhcmVzdFwiXG4gICAgfSk7XG4gIH1cbiAgdHJhbnNsYXRpb25Eb25lKCkge1xuICAgIHRoaXMuX29uVHJhbnNsYXRlZCh0aGlzLngsIHRoaXMueSk7XG4gIH1cbiAgZHJhZyh0eCwgdHkpIHtcbiAgICB0aGlzLiNpbml0aWFsUmVjdCB8fD0gW3RoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodF07XG4gICAgY29uc3Qge1xuICAgICAgZGl2LFxuICAgICAgcGFyZW50RGltZW5zaW9uczogW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdXG4gICAgfSA9IHRoaXM7XG4gICAgdGhpcy54ICs9IHR4IC8gcGFyZW50V2lkdGg7XG4gICAgdGhpcy55ICs9IHR5IC8gcGFyZW50SGVpZ2h0O1xuICAgIGlmICh0aGlzLnBhcmVudCAmJiAodGhpcy54IDwgMCB8fCB0aGlzLnggPiAxIHx8IHRoaXMueSA8IDAgfHwgdGhpcy55ID4gMSkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeDogeDIsXG4gICAgICAgIHk6IHkyXG4gICAgICB9ID0gdGhpcy5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBpZiAodGhpcy5wYXJlbnQuZmluZE5ld1BhcmVudCh0aGlzLCB4MiwgeTIpKSB7XG4gICAgICAgIHRoaXMueCAtPSBNYXRoLmZsb29yKHRoaXMueCk7XG4gICAgICAgIHRoaXMueSAtPSBNYXRoLmZsb29yKHRoaXMueSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IFtieCwgYnldID0gdGhpcy5nZXRCYXNlVHJhbnNsYXRpb24oKTtcbiAgICB4ICs9IGJ4O1xuICAgIHkgKz0gYnk7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gZGl2O1xuICAgIHN0eWxlLmxlZnQgPSBgJHsoMTAwICogeCkudG9GaXhlZCgyKX0lYDtcbiAgICBzdHlsZS50b3AgPSBgJHsoMTAwICogeSkudG9GaXhlZCgyKX0lYDtcbiAgICB0aGlzLl9vblRyYW5zbGF0aW5nKHgsIHkpO1xuICAgIGRpdi5zY3JvbGxJbnRvVmlldyh7XG4gICAgICBibG9jazogXCJuZWFyZXN0XCJcbiAgICB9KTtcbiAgfVxuICBfb25UcmFuc2xhdGluZyh4LCB5KSB7XG4gIH1cbiAgX29uVHJhbnNsYXRlZCh4LCB5KSB7XG4gIH1cbiAgZ2V0IF9oYXNCZWVuTW92ZWQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy4jaW5pdGlhbFJlY3QgJiYgKHRoaXMuI2luaXRpYWxSZWN0WzBdICE9PSB0aGlzLnggfHwgdGhpcy4jaW5pdGlhbFJlY3RbMV0gIT09IHRoaXMueSk7XG4gIH1cbiAgZ2V0IF9oYXNCZWVuUmVzaXplZCgpIHtcbiAgICByZXR1cm4gISF0aGlzLiNpbml0aWFsUmVjdCAmJiAodGhpcy4jaW5pdGlhbFJlY3RbMl0gIT09IHRoaXMud2lkdGggfHwgdGhpcy4jaW5pdGlhbFJlY3RbM10gIT09IHRoaXMuaGVpZ2h0KTtcbiAgfVxuICBnZXRCYXNlVHJhbnNsYXRpb24oKSB7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIGNvbnN0IHtcbiAgICAgIF9ib3JkZXJMaW5lV2lkdGhcbiAgICB9ID0gQW5ub3RhdGlvbkVkaXRvcjtcbiAgICBjb25zdCB4ID0gX2JvcmRlckxpbmVXaWR0aCAvIHBhcmVudFdpZHRoO1xuICAgIGNvbnN0IHkgPSBfYm9yZGVyTGluZVdpZHRoIC8gcGFyZW50SGVpZ2h0O1xuICAgIHN3aXRjaCAodGhpcy5yb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFsteCwgeV07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gW3gsIC15XTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBbLXgsIC15XTtcbiAgICB9XG4gIH1cbiAgZ2V0IF9tdXN0Rml4UG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZml4QW5kU2V0UG9zaXRpb24ocm90YXRpb24gPSB0aGlzLnJvdGF0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGl2OiB7XG4gICAgICAgIHN0eWxlXG4gICAgICB9LFxuICAgICAgcGFnZURpbWVuc2lvbnM6IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcztcbiAgICB3aWR0aCAqPSBwYWdlV2lkdGg7XG4gICAgaGVpZ2h0ICo9IHBhZ2VIZWlnaHQ7XG4gICAgeCAqPSBwYWdlV2lkdGg7XG4gICAgeSAqPSBwYWdlSGVpZ2h0O1xuICAgIGlmICh0aGlzLl9tdXN0Rml4UG9zaXRpb24pIHtcbiAgICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHggPSBNYXRoQ2xhbXAoeCwgMCwgcGFnZVdpZHRoIC0gd2lkdGgpO1xuICAgICAgICAgIHkgPSBNYXRoQ2xhbXAoeSwgMCwgcGFnZUhlaWdodCAtIGhlaWdodCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgOTA6XG4gICAgICAgICAgeCA9IE1hdGhDbGFtcCh4LCAwLCBwYWdlV2lkdGggLSBoZWlnaHQpO1xuICAgICAgICAgIHkgPSBNYXRoQ2xhbXAoeSwgd2lkdGgsIHBhZ2VIZWlnaHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE4MDpcbiAgICAgICAgICB4ID0gTWF0aENsYW1wKHgsIHdpZHRoLCBwYWdlV2lkdGgpO1xuICAgICAgICAgIHkgPSBNYXRoQ2xhbXAoeSwgaGVpZ2h0LCBwYWdlSGVpZ2h0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNzA6XG4gICAgICAgICAgeCA9IE1hdGhDbGFtcCh4LCBoZWlnaHQsIHBhZ2VXaWR0aCk7XG4gICAgICAgICAgeSA9IE1hdGhDbGFtcCh5LCAwLCBwYWdlSGVpZ2h0IC0gd2lkdGgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnggPSB4IC89IHBhZ2VXaWR0aDtcbiAgICB0aGlzLnkgPSB5IC89IHBhZ2VIZWlnaHQ7XG4gICAgY29uc3QgW2J4LCBieV0gPSB0aGlzLmdldEJhc2VUcmFuc2xhdGlvbigpO1xuICAgIHggKz0gYng7XG4gICAgeSArPSBieTtcbiAgICBzdHlsZS5sZWZ0ID0gYCR7KDEwMCAqIHgpLnRvRml4ZWQoMil9JWA7XG4gICAgc3R5bGUudG9wID0gYCR7KDEwMCAqIHkpLnRvRml4ZWQoMil9JWA7XG4gICAgdGhpcy5tb3ZlSW5ET00oKTtcbiAgfVxuICBzdGF0aWMgI3JvdGF0ZVBvaW50KHgsIHksIGFuZ2xlKSB7XG4gICAgc3dpdGNoIChhbmdsZSkge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFt5LCAteF07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFsteCwgLXldO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbLXksIHhdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9XG4gIH1cbiAgc2NyZWVuVG9QYWdlVHJhbnNsYXRpb24oeCwgeSkge1xuICAgIHJldHVybiBBbm5vdGF0aW9uRWRpdG9yLiNyb3RhdGVQb2ludCh4LCB5LCB0aGlzLnBhcmVudFJvdGF0aW9uKTtcbiAgfVxuICBwYWdlVHJhbnNsYXRpb25Ub1NjcmVlbih4LCB5KSB7XG4gICAgcmV0dXJuIEFubm90YXRpb25FZGl0b3IuI3JvdGF0ZVBvaW50KHgsIHksIDM2MCAtIHRoaXMucGFyZW50Um90YXRpb24pO1xuICB9XG4gICNnZXRSb3RhdGlvbk1hdHJpeChyb3RhdGlvbikge1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgOTA6IHtcbiAgICAgICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgICAgICByZXR1cm4gWzAsIC1wYWdlV2lkdGggLyBwYWdlSGVpZ2h0LCBwYWdlSGVpZ2h0IC8gcGFnZVdpZHRoLCAwXTtcbiAgICAgIH1cbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gWy0xLCAwLCAwLCAtMV07XG4gICAgICBjYXNlIDI3MDoge1xuICAgICAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgICAgIHJldHVybiBbMCwgcGFnZVdpZHRoIC8gcGFnZUhlaWdodCwgLXBhZ2VIZWlnaHQgLyBwYWdlV2lkdGgsIDBdO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFsxLCAwLCAwLCAxXTtcbiAgICB9XG4gIH1cbiAgZ2V0IHBhcmVudFNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLl91aU1hbmFnZXIudmlld1BhcmFtZXRlcnMucmVhbFNjYWxlO1xuICB9XG4gIGdldCBwYXJlbnRSb3RhdGlvbigpIHtcbiAgICByZXR1cm4gKHRoaXMuX3VpTWFuYWdlci52aWV3UGFyYW1ldGVycy5yb3RhdGlvbiArIHRoaXMucGFnZVJvdGF0aW9uKSAlIDM2MDtcbiAgfVxuICBnZXQgcGFyZW50RGltZW5zaW9ucygpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYXJlbnRTY2FsZSxcbiAgICAgIHBhZ2VEaW1lbnNpb25zOiBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XVxuICAgIH0gPSB0aGlzO1xuICAgIHJldHVybiBbcGFnZVdpZHRoICogcGFyZW50U2NhbGUsIHBhZ2VIZWlnaHQgKiBwYXJlbnRTY2FsZV07XG4gIH1cbiAgc2V0RGltcygpIHtcbiAgICBjb25zdCB7XG4gICAgICBkaXY6IHtcbiAgICAgICAgc3R5bGVcbiAgICAgIH0sXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzO1xuICAgIHN0eWxlLndpZHRoID0gYCR7KDEwMCAqIHdpZHRoKS50b0ZpeGVkKDIpfSVgO1xuICAgIHN0eWxlLmhlaWdodCA9IGAkeygxMDAgKiBoZWlnaHQpLnRvRml4ZWQoMil9JWA7XG4gIH1cbiAgZ2V0SW5pdGlhbFRyYW5zbGF0aW9uKCkge1xuICAgIHJldHVybiBbMCwgMF07XG4gIH1cbiAgI2NyZWF0ZVJlc2l6ZXJzKCkge1xuICAgIGlmICh0aGlzLiNyZXNpemVyc0Rpdikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNyZXNpemVyc0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy4jcmVzaXplcnNEaXYuY2xhc3NMaXN0LmFkZChcInJlc2l6ZXJzXCIpO1xuICAgIGNvbnN0IGNsYXNzZXMgPSB0aGlzLl93aWxsS2VlcEFzcGVjdFJhdGlvID8gW1widG9wTGVmdFwiLCBcInRvcFJpZ2h0XCIsIFwiYm90dG9tUmlnaHRcIiwgXCJib3R0b21MZWZ0XCJdIDogW1widG9wTGVmdFwiLCBcInRvcE1pZGRsZVwiLCBcInRvcFJpZ2h0XCIsIFwibWlkZGxlUmlnaHRcIiwgXCJib3R0b21SaWdodFwiLCBcImJvdHRvbU1pZGRsZVwiLCBcImJvdHRvbUxlZnRcIiwgXCJtaWRkbGVMZWZ0XCJdO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3VpTWFuYWdlci5fc2lnbmFsO1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBjbGFzc2VzKSB7XG4gICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy4jcmVzaXplcnNEaXYuYXBwZW5kKGRpdik7XG4gICAgICBkaXYuY2xhc3NMaXN0LmFkZChcInJlc2l6ZXJcIiwgbmFtZSk7XG4gICAgICBkaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1yZXNpemVyLW5hbWVcIiwgbmFtZSk7XG4gICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHRoaXMuI3Jlc2l6ZXJQb2ludGVyZG93bi5iaW5kKHRoaXMsIG5hbWUpLCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG5vQ29udGV4dE1lbnUsIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGRpdi50YWJJbmRleCA9IC0xO1xuICAgIH1cbiAgICB0aGlzLmRpdi5wcmVwZW5kKHRoaXMuI3Jlc2l6ZXJzRGl2KTtcbiAgfVxuICAjcmVzaXplclBvaW50ZXJkb3duKG5hbWUsIGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCB7XG4gICAgICBpc01hY1xuICAgIH0gPSB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgZXZlbnQuY3RybEtleSAmJiBpc01hYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNhbHRUZXh0Py50b2dnbGUoZmFsc2UpO1xuICAgIGNvbnN0IHNhdmVkRHJhZ2dhYmxlID0gdGhpcy5faXNEcmFnZ2FibGU7XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSBmYWxzZTtcbiAgICB0aGlzLiNsYXN0UG9pbnRlckNvb3JkcyA9IFtldmVudC5zY3JlZW5YLCBldmVudC5zY3JlZW5ZXTtcbiAgICBjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLl91aU1hbmFnZXIuY29tYmluZWRTaWduYWwoYWMpO1xuICAgIHRoaXMucGFyZW50LnRvZ2dsZVBvaW50ZXJFdmVudHMoZmFsc2UpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgdGhpcy4jcmVzaXplclBvaW50ZXJtb3ZlLmJpbmQodGhpcywgbmFtZSksIHtcbiAgICAgIHBhc3NpdmU6IHRydWUsXG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgc3RvcEV2ZW50LCB7XG4gICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy4jc2F2ZWREaW1lbnNpb25zID0ge1xuICAgICAgc2F2ZWRYOiB0aGlzLngsXG4gICAgICBzYXZlZFk6IHRoaXMueSxcbiAgICAgIHNhdmVkV2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBzYXZlZEhlaWdodDogdGhpcy5oZWlnaHRcbiAgICB9O1xuICAgIGNvbnN0IHNhdmVkUGFyZW50Q3Vyc29yID0gdGhpcy5wYXJlbnQuZGl2LnN0eWxlLmN1cnNvcjtcbiAgICBjb25zdCBzYXZlZEN1cnNvciA9IHRoaXMuZGl2LnN0eWxlLmN1cnNvcjtcbiAgICB0aGlzLmRpdi5zdHlsZS5jdXJzb3IgPSB0aGlzLnBhcmVudC5kaXYuc3R5bGUuY3Vyc29yID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZXZlbnQudGFyZ2V0KS5jdXJzb3I7XG4gICAgY29uc3QgcG9pbnRlclVwQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICBhYy5hYm9ydCgpO1xuICAgICAgdGhpcy5wYXJlbnQudG9nZ2xlUG9pbnRlckV2ZW50cyh0cnVlKTtcbiAgICAgIHRoaXMuI2FsdFRleHQ/LnRvZ2dsZSh0cnVlKTtcbiAgICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gc2F2ZWREcmFnZ2FibGU7XG4gICAgICB0aGlzLnBhcmVudC5kaXYuc3R5bGUuY3Vyc29yID0gc2F2ZWRQYXJlbnRDdXJzb3I7XG4gICAgICB0aGlzLmRpdi5zdHlsZS5jdXJzb3IgPSBzYXZlZEN1cnNvcjtcbiAgICAgIHRoaXMuI2FkZFJlc2l6ZVRvVW5kb1N0YWNrKCk7XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBwb2ludGVyVXBDYWxsYmFjaywge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHBvaW50ZXJVcENhbGxiYWNrLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgfVxuICAjcmVzaXplKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMuc2V0RGltcygpO1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICB0aGlzLl9vblJlc2l6ZWQoKTtcbiAgfVxuICBfb25SZXNpemVkKCkge1xuICB9XG4gICNhZGRSZXNpemVUb1VuZG9TdGFjaygpIHtcbiAgICBpZiAoIXRoaXMuI3NhdmVkRGltZW5zaW9ucykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzYXZlZFgsXG4gICAgICBzYXZlZFksXG4gICAgICBzYXZlZFdpZHRoLFxuICAgICAgc2F2ZWRIZWlnaHRcbiAgICB9ID0gdGhpcy4jc2F2ZWREaW1lbnNpb25zO1xuICAgIHRoaXMuI3NhdmVkRGltZW5zaW9ucyA9IG51bGw7XG4gICAgY29uc3QgbmV3WCA9IHRoaXMueDtcbiAgICBjb25zdCBuZXdZID0gdGhpcy55O1xuICAgIGNvbnN0IG5ld1dpZHRoID0gdGhpcy53aWR0aDtcbiAgICBjb25zdCBuZXdIZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICBpZiAobmV3WCA9PT0gc2F2ZWRYICYmIG5ld1kgPT09IHNhdmVkWSAmJiBuZXdXaWR0aCA9PT0gc2F2ZWRXaWR0aCAmJiBuZXdIZWlnaHQgPT09IHNhdmVkSGVpZ2h0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiB0aGlzLiNyZXNpemUuYmluZCh0aGlzLCBuZXdYLCBuZXdZLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KSxcbiAgICAgIHVuZG86IHRoaXMuI3Jlc2l6ZS5iaW5kKHRoaXMsIHNhdmVkWCwgc2F2ZWRZLCBzYXZlZFdpZHRoLCBzYXZlZEhlaWdodCksXG4gICAgICBtdXN0RXhlYzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBfcm91bmQoeCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHggKiAxZTQpIC8gMWU0O1xuICB9XG4gICNyZXNpemVyUG9pbnRlcm1vdmUobmFtZSwgZXZlbnQpIHtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgY29uc3Qgc2F2ZWRYID0gdGhpcy54O1xuICAgIGNvbnN0IHNhdmVkWSA9IHRoaXMueTtcbiAgICBjb25zdCBzYXZlZFdpZHRoID0gdGhpcy53aWR0aDtcbiAgICBjb25zdCBzYXZlZEhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgIGNvbnN0IG1pbldpZHRoID0gQW5ub3RhdGlvbkVkaXRvci5NSU5fU0laRSAvIHBhcmVudFdpZHRoO1xuICAgIGNvbnN0IG1pbkhlaWdodCA9IEFubm90YXRpb25FZGl0b3IuTUlOX1NJWkUgLyBwYXJlbnRIZWlnaHQ7XG4gICAgY29uc3Qgcm90YXRpb25NYXRyaXggPSB0aGlzLiNnZXRSb3RhdGlvbk1hdHJpeCh0aGlzLnJvdGF0aW9uKTtcbiAgICBjb25zdCB0cmFuc2YgPSAoeCwgeSkgPT4gW3JvdGF0aW9uTWF0cml4WzBdICogeCArIHJvdGF0aW9uTWF0cml4WzJdICogeSwgcm90YXRpb25NYXRyaXhbMV0gKiB4ICsgcm90YXRpb25NYXRyaXhbM10gKiB5XTtcbiAgICBjb25zdCBpbnZSb3RhdGlvbk1hdHJpeCA9IHRoaXMuI2dldFJvdGF0aW9uTWF0cml4KDM2MCAtIHRoaXMucm90YXRpb24pO1xuICAgIGNvbnN0IGludlRyYW5zZiA9ICh4LCB5KSA9PiBbaW52Um90YXRpb25NYXRyaXhbMF0gKiB4ICsgaW52Um90YXRpb25NYXRyaXhbMl0gKiB5LCBpbnZSb3RhdGlvbk1hdHJpeFsxXSAqIHggKyBpbnZSb3RhdGlvbk1hdHJpeFszXSAqIHldO1xuICAgIGxldCBnZXRQb2ludDtcbiAgICBsZXQgZ2V0T3Bwb3NpdGU7XG4gICAgbGV0IGlzRGlhZ29uYWwgPSBmYWxzZTtcbiAgICBsZXQgaXNIb3Jpem9udGFsID0gZmFsc2U7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlIFwidG9wTGVmdFwiOlxuICAgICAgICBpc0RpYWdvbmFsID0gdHJ1ZTtcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gWzAsIDBdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbdywgaF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInRvcE1pZGRsZVwiOlxuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbdyAvIDIsIDBdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbdyAvIDIsIGhdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ0b3BSaWdodFwiOlxuICAgICAgICBpc0RpYWdvbmFsID0gdHJ1ZTtcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gW3csIDBdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbMCwgaF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1pZGRsZVJpZ2h0XCI6XG4gICAgICAgIGlzSG9yaXpvbnRhbCA9IHRydWU7XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFt3LCBoIC8gMl07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFswLCBoIC8gMl07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJvdHRvbVJpZ2h0XCI6XG4gICAgICAgIGlzRGlhZ29uYWwgPSB0cnVlO1xuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbdywgaF07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFswLCAwXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYm90dG9tTWlkZGxlXCI6XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFt3IC8gMiwgaF07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFt3IC8gMiwgMF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJvdHRvbUxlZnRcIjpcbiAgICAgICAgaXNEaWFnb25hbCA9IHRydWU7XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFswLCBoXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gW3csIDBdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtaWRkbGVMZWZ0XCI6XG4gICAgICAgIGlzSG9yaXpvbnRhbCA9IHRydWU7XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFswLCBoIC8gMl07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFt3LCBoIC8gMl07XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBwb2ludCA9IGdldFBvaW50KHNhdmVkV2lkdGgsIHNhdmVkSGVpZ2h0KTtcbiAgICBjb25zdCBvcHBvc2l0ZVBvaW50ID0gZ2V0T3Bwb3NpdGUoc2F2ZWRXaWR0aCwgc2F2ZWRIZWlnaHQpO1xuICAgIGxldCB0cmFuc2ZPcHBvc2l0ZVBvaW50ID0gdHJhbnNmKC4uLm9wcG9zaXRlUG9pbnQpO1xuICAgIGNvbnN0IG9wcG9zaXRlWCA9IEFubm90YXRpb25FZGl0b3IuX3JvdW5kKHNhdmVkWCArIHRyYW5zZk9wcG9zaXRlUG9pbnRbMF0pO1xuICAgIGNvbnN0IG9wcG9zaXRlWSA9IEFubm90YXRpb25FZGl0b3IuX3JvdW5kKHNhdmVkWSArIHRyYW5zZk9wcG9zaXRlUG9pbnRbMV0pO1xuICAgIGxldCByYXRpb1ggPSAxO1xuICAgIGxldCByYXRpb1kgPSAxO1xuICAgIGxldCBkZWx0YVgsIGRlbHRhWTtcbiAgICBpZiAoIWV2ZW50LmZyb21LZXlib2FyZCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzY3JlZW5YLFxuICAgICAgICBzY3JlZW5ZXG4gICAgICB9ID0gZXZlbnQ7XG4gICAgICBjb25zdCBbbGFzdFNjcmVlblgsIGxhc3RTY3JlZW5ZXSA9IHRoaXMuI2xhc3RQb2ludGVyQ29vcmRzO1xuICAgICAgW2RlbHRhWCwgZGVsdGFZXSA9IHRoaXMuc2NyZWVuVG9QYWdlVHJhbnNsYXRpb24oc2NyZWVuWCAtIGxhc3RTY3JlZW5YLCBzY3JlZW5ZIC0gbGFzdFNjcmVlblkpO1xuICAgICAgdGhpcy4jbGFzdFBvaW50ZXJDb29yZHNbMF0gPSBzY3JlZW5YO1xuICAgICAgdGhpcy4jbGFzdFBvaW50ZXJDb29yZHNbMV0gPSBzY3JlZW5ZO1xuICAgIH0gZWxzZSB7XG4gICAgICAoe1xuICAgICAgICBkZWx0YVgsXG4gICAgICAgIGRlbHRhWVxuICAgICAgfSA9IGV2ZW50KTtcbiAgICB9XG4gICAgW2RlbHRhWCwgZGVsdGFZXSA9IGludlRyYW5zZihkZWx0YVggLyBwYXJlbnRXaWR0aCwgZGVsdGFZIC8gcGFyZW50SGVpZ2h0KTtcbiAgICBpZiAoaXNEaWFnb25hbCkge1xuICAgICAgY29uc3Qgb2xkRGlhZyA9IE1hdGguaHlwb3Qoc2F2ZWRXaWR0aCwgc2F2ZWRIZWlnaHQpO1xuICAgICAgcmF0aW9YID0gcmF0aW9ZID0gTWF0aC5tYXgoTWF0aC5taW4oTWF0aC5oeXBvdChvcHBvc2l0ZVBvaW50WzBdIC0gcG9pbnRbMF0gLSBkZWx0YVgsIG9wcG9zaXRlUG9pbnRbMV0gLSBwb2ludFsxXSAtIGRlbHRhWSkgLyBvbGREaWFnLCAxIC8gc2F2ZWRXaWR0aCwgMSAvIHNhdmVkSGVpZ2h0KSwgbWluV2lkdGggLyBzYXZlZFdpZHRoLCBtaW5IZWlnaHQgLyBzYXZlZEhlaWdodCk7XG4gICAgfSBlbHNlIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgIHJhdGlvWCA9IE1hdGhDbGFtcChNYXRoLmFicyhvcHBvc2l0ZVBvaW50WzBdIC0gcG9pbnRbMF0gLSBkZWx0YVgpLCBtaW5XaWR0aCwgMSkgLyBzYXZlZFdpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICByYXRpb1kgPSBNYXRoQ2xhbXAoTWF0aC5hYnMob3Bwb3NpdGVQb2ludFsxXSAtIHBvaW50WzFdIC0gZGVsdGFZKSwgbWluSGVpZ2h0LCAxKSAvIHNhdmVkSGVpZ2h0O1xuICAgIH1cbiAgICBjb25zdCBuZXdXaWR0aCA9IEFubm90YXRpb25FZGl0b3IuX3JvdW5kKHNhdmVkV2lkdGggKiByYXRpb1gpO1xuICAgIGNvbnN0IG5ld0hlaWdodCA9IEFubm90YXRpb25FZGl0b3IuX3JvdW5kKHNhdmVkSGVpZ2h0ICogcmF0aW9ZKTtcbiAgICB0cmFuc2ZPcHBvc2l0ZVBvaW50ID0gdHJhbnNmKC4uLmdldE9wcG9zaXRlKG5ld1dpZHRoLCBuZXdIZWlnaHQpKTtcbiAgICBjb25zdCBuZXdYID0gb3Bwb3NpdGVYIC0gdHJhbnNmT3Bwb3NpdGVQb2ludFswXTtcbiAgICBjb25zdCBuZXdZID0gb3Bwb3NpdGVZIC0gdHJhbnNmT3Bwb3NpdGVQb2ludFsxXTtcbiAgICB0aGlzLiNpbml0aWFsUmVjdCB8fD0gW3RoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodF07XG4gICAgdGhpcy53aWR0aCA9IG5ld1dpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgIHRoaXMueCA9IG5ld1g7XG4gICAgdGhpcy55ID0gbmV3WTtcbiAgICB0aGlzLnNldERpbXMoKTtcbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gICAgdGhpcy5fb25SZXNpemluZygpO1xuICB9XG4gIF9vblJlc2l6aW5nKCkge1xuICB9XG4gIGFsdFRleHRGaW5pc2goKSB7XG4gICAgdGhpcy4jYWx0VGV4dD8uZmluaXNoKCk7XG4gIH1cbiAgZ2V0IHRvb2xiYXJCdXR0b25zKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGFzeW5jIGFkZEVkaXRUb29sYmFyKCkge1xuICAgIGlmICh0aGlzLl9lZGl0VG9vbGJhciB8fCB0aGlzLiNpc0luRWRpdE1vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lZGl0VG9vbGJhcjtcbiAgICB9XG4gICAgdGhpcy5fZWRpdFRvb2xiYXIgPSBuZXcgRWRpdG9yVG9vbGJhcih0aGlzKTtcbiAgICB0aGlzLmRpdi5hcHBlbmQodGhpcy5fZWRpdFRvb2xiYXIucmVuZGVyKCkpO1xuICAgIGNvbnN0IHtcbiAgICAgIHRvb2xiYXJCdXR0b25zXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKHRvb2xiYXJCdXR0b25zKSB7XG4gICAgICBmb3IgKGNvbnN0IFtuYW1lLCB0b29sXSBvZiB0b29sYmFyQnV0dG9ucykge1xuICAgICAgICBhd2FpdCB0aGlzLl9lZGl0VG9vbGJhci5hZGRCdXR0b24obmFtZSwgdG9vbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5oYXNDb21tZW50KSB7XG4gICAgICB0aGlzLl9lZGl0VG9vbGJhci5hZGRCdXR0b24oXCJjb21tZW50XCIsIHRoaXMuYWRkQ29tbWVudEJ1dHRvbigpKTtcbiAgICB9XG4gICAgdGhpcy5fZWRpdFRvb2xiYXIuYWRkQnV0dG9uKFwiZGVsZXRlXCIpO1xuICAgIHJldHVybiB0aGlzLl9lZGl0VG9vbGJhcjtcbiAgfVxuICBhZGRDb21tZW50QnV0dG9uSW5Ub29sYmFyKCkge1xuICAgIHRoaXMuX2VkaXRUb29sYmFyPy5hZGRCdXR0b25CZWZvcmUoXCJjb21tZW50XCIsIHRoaXMuYWRkQ29tbWVudEJ1dHRvbigpLCBcIi5kZWxldGVCdXR0b25cIik7XG4gIH1cbiAgcmVtb3ZlQ29tbWVudEJ1dHRvbkZyb21Ub29sYmFyKCkge1xuICAgIHRoaXMuX2VkaXRUb29sYmFyPy5yZW1vdmVCdXR0b24oXCJjb21tZW50XCIpO1xuICB9XG4gIHJlbW92ZUVkaXRUb29sYmFyKCkge1xuICAgIHRoaXMuX2VkaXRUb29sYmFyPy5yZW1vdmUoKTtcbiAgICB0aGlzLl9lZGl0VG9vbGJhciA9IG51bGw7XG4gICAgdGhpcy4jYWx0VGV4dD8uZGVzdHJveSgpO1xuICB9XG4gIGFkZENvbnRhaW5lcihjb250YWluZXIpIHtcbiAgICBjb25zdCBlZGl0VG9vbGJhckRpdiA9IHRoaXMuX2VkaXRUb29sYmFyPy5kaXY7XG4gICAgaWYgKGVkaXRUb29sYmFyRGl2KSB7XG4gICAgICBlZGl0VG9vbGJhckRpdi5iZWZvcmUoY29udGFpbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXYuYXBwZW5kKGNvbnRhaW5lcik7XG4gICAgfVxuICB9XG4gIGdldENsaWVudERpbWVuc2lvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB9XG4gIGNyZWF0ZUFsdFRleHQoKSB7XG4gICAgaWYgKCF0aGlzLiNhbHRUZXh0KSB7XG4gICAgICBBbHRUZXh0LmluaXRpYWxpemUoQW5ub3RhdGlvbkVkaXRvci5fbDEwbik7XG4gICAgICB0aGlzLiNhbHRUZXh0ID0gbmV3IEFsdFRleHQodGhpcyk7XG4gICAgICBpZiAodGhpcy4jYWNjZXNzaWJpbGl0eURhdGEpIHtcbiAgICAgICAgdGhpcy4jYWx0VGV4dC5kYXRhID0gdGhpcy4jYWNjZXNzaWJpbGl0eURhdGE7XG4gICAgICAgIHRoaXMuI2FjY2Vzc2liaWxpdHlEYXRhID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI2FsdFRleHQ7XG4gIH1cbiAgZ2V0IGFsdFRleHREYXRhKCkge1xuICAgIHJldHVybiB0aGlzLiNhbHRUZXh0Py5kYXRhO1xuICB9XG4gIHNldCBhbHRUZXh0RGF0YShkYXRhKSB7XG4gICAgaWYgKCF0aGlzLiNhbHRUZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2FsdFRleHQuZGF0YSA9IGRhdGE7XG4gIH1cbiAgZ2V0IGd1ZXNzZWRBbHRUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLiNhbHRUZXh0Py5ndWVzc2VkVGV4dDtcbiAgfVxuICBhc3luYyBzZXRHdWVzc2VkQWx0VGV4dCh0ZXh0KSB7XG4gICAgYXdhaXQgdGhpcy4jYWx0VGV4dD8uc2V0R3Vlc3NlZFRleHQodGV4dCk7XG4gIH1cbiAgc2VyaWFsaXplQWx0VGV4dChpc0ZvckNvcHlpbmcpIHtcbiAgICByZXR1cm4gdGhpcy4jYWx0VGV4dD8uc2VyaWFsaXplKGlzRm9yQ29weWluZyk7XG4gIH1cbiAgaGFzQWx0VGV4dCgpIHtcbiAgICByZXR1cm4gISF0aGlzLiNhbHRUZXh0ICYmICF0aGlzLiNhbHRUZXh0LmlzRW1wdHkoKTtcbiAgfVxuICBoYXNBbHRUZXh0RGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy4jYWx0VGV4dD8uaGFzRGF0YSgpID8/IGZhbHNlO1xuICB9XG4gIGZvY3VzQ29tbWVudEJ1dHRvbigpIHtcbiAgICB0aGlzLiNjb21tZW50Py5mb2N1c0J1dHRvbigpO1xuICB9XG4gIGFkZENvbW1lbnRCdXR0b24oKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NvbW1lbnQgfHw9IG5ldyBDb21tZW50KHRoaXMpO1xuICB9XG4gIGFkZFN0YW5kYWxvbmVDb21tZW50QnV0dG9uKCkge1xuICAgIGlmICh0aGlzLiNjb21tZW50U3RhbmRhbG9uZUJ1dHRvbikge1xuICAgICAgaWYgKHRoaXMuX3VpTWFuYWdlci5pc0VkaXRpbmdNb2RlKCkpIHtcbiAgICAgICAgdGhpcy4jY29tbWVudFN0YW5kYWxvbmVCdXR0b24uY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmhhc0NvbW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY29tbWVudFN0YW5kYWxvbmVCdXR0b24gPSB0aGlzLiNjb21tZW50LnJlbmRlckZvclN0YW5kYWxvbmUoKTtcbiAgICB0aGlzLmRpdi5hcHBlbmQodGhpcy4jY29tbWVudFN0YW5kYWxvbmVCdXR0b24pO1xuICB9XG4gIHJlbW92ZVN0YW5kYWxvbmVDb21tZW50QnV0dG9uKCkge1xuICAgIHRoaXMuI2NvbW1lbnQucmVtb3ZlU3RhbmRhbG9uZUNvbW1lbnRCdXR0b24oKTtcbiAgICB0aGlzLiNjb21tZW50U3RhbmRhbG9uZUJ1dHRvbiA9IG51bGw7XG4gIH1cbiAgaGlkZVN0YW5kYWxvbmVDb21tZW50QnV0dG9uKCkge1xuICAgIHRoaXMuI2NvbW1lbnRTdGFuZGFsb25lQnV0dG9uPy5jbGFzc0xpc3QuYWRkKFwiaGlkZGVuXCIpO1xuICB9XG4gIGdldCBjb21tZW50KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgcmljaFRleHQsXG4gICAgICAgIHRleHQsXG4gICAgICAgIGRhdGUsXG4gICAgICAgIGRlbGV0ZWRcbiAgICAgIH1cbiAgICB9ID0gdGhpcy4jY29tbWVudDtcbiAgICByZXR1cm4ge1xuICAgICAgdGV4dCxcbiAgICAgIHJpY2hUZXh0LFxuICAgICAgZGF0ZSxcbiAgICAgIGRlbGV0ZWQsXG4gICAgICBjb2xvcjogdGhpcy5nZXROb25IQ01Db2xvcigpLFxuICAgICAgb3BhY2l0eTogdGhpcy5vcGFjaXR5ID8/IDFcbiAgICB9O1xuICB9XG4gIHNldCBjb21tZW50KHRleHQpIHtcbiAgICB0aGlzLiNjb21tZW50IHx8PSBuZXcgQ29tbWVudCh0aGlzKTtcbiAgICB0aGlzLiNjb21tZW50LmRhdGEgPSB0ZXh0O1xuICAgIGlmICh0aGlzLmhhc0NvbW1lbnQpIHtcbiAgICAgIHRoaXMucmVtb3ZlQ29tbWVudEJ1dHRvbkZyb21Ub29sYmFyKCk7XG4gICAgICB0aGlzLmFkZFN0YW5kYWxvbmVDb21tZW50QnV0dG9uKCk7XG4gICAgICB0aGlzLl91aU1hbmFnZXIudXBkYXRlQ29tbWVudCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGRDb21tZW50QnV0dG9uSW5Ub29sYmFyKCk7XG4gICAgICB0aGlzLnJlbW92ZVN0YW5kYWxvbmVDb21tZW50QnV0dG9uKCk7XG4gICAgICB0aGlzLl91aU1hbmFnZXIucmVtb3ZlQ29tbWVudCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgc2V0Q29tbWVudERhdGEoe1xuICAgIGNvbW1lbnQsXG4gICAgcG9wdXBSZWYsXG4gICAgcmljaFRleHRcbiAgfSkge1xuICAgIGlmICghcG9wdXBSZWYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY29tbWVudCB8fD0gbmV3IENvbW1lbnQodGhpcyk7XG4gICAgdGhpcy4jY29tbWVudC5zZXRJbml0aWFsVGV4dChjb21tZW50LCByaWNoVGV4dCk7XG4gICAgaWYgKCF0aGlzLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RvcmVkRGF0YSA9IHRoaXMuX3VpTWFuYWdlci5nZXRBbmRSZW1vdmVEYXRhRnJvbUFubm90YXRpb25TdG9yYWdlKHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gICAgaWYgKHN0b3JlZERhdGEpIHtcbiAgICAgIHRoaXMudXBkYXRlRnJvbUFubm90YXRpb25MYXllcihzdG9yZWREYXRhKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGhhc0VkaXRlZENvbW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NvbW1lbnQ/Lmhhc0JlZW5FZGl0ZWQoKTtcbiAgfVxuICBnZXQgaGFzRGVsZXRlZENvbW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NvbW1lbnQ/LmlzRGVsZXRlZCgpO1xuICB9XG4gIGdldCBoYXNDb21tZW50KCkge1xuICAgIHJldHVybiAhIXRoaXMuI2NvbW1lbnQgJiYgIXRoaXMuI2NvbW1lbnQuaXNFbXB0eSgpICYmICF0aGlzLiNjb21tZW50LmlzRGVsZXRlZCgpO1xuICB9XG4gIGFzeW5jIGVkaXRDb21tZW50KG9wdGlvbnMpIHtcbiAgICB0aGlzLiNjb21tZW50IHx8PSBuZXcgQ29tbWVudCh0aGlzKTtcbiAgICB0aGlzLiNjb21tZW50LmVkaXQob3B0aW9ucyk7XG4gIH1cbiAgdG9nZ2xlQ29tbWVudChpc1NlbGVjdGVkLCB2aXNpYmlsaXR5ID0gdm9pZCAwKSB7XG4gICAgaWYgKHRoaXMuaGFzQ29tbWVudCkge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLnRvZ2dsZUNvbW1lbnQodGhpcywgaXNTZWxlY3RlZCwgdmlzaWJpbGl0eSk7XG4gICAgfVxuICB9XG4gIHNldFNlbGVjdGVkQ29tbWVudEJ1dHRvbihzZWxlY3RlZCkge1xuICAgIHRoaXMuI2NvbW1lbnQuc2V0U2VsZWN0ZWRCdXR0b24oc2VsZWN0ZWQpO1xuICB9XG4gIGFkZENvbW1lbnQoc2VyaWFsaXplZCkge1xuICAgIGlmICh0aGlzLmhhc0VkaXRlZENvbW1lbnQpIHtcbiAgICAgIGNvbnN0IERFRkFVTFRfUE9QVVBfV0lEVEggPSAxODA7XG4gICAgICBjb25zdCBERUZBVUxUX1BPUFVQX0hFSUdIVCA9IDEwMDtcbiAgICAgIGNvbnN0IFssICwgLCB0clldID0gc2VyaWFsaXplZC5yZWN0O1xuICAgICAgY29uc3QgW3BhZ2VXaWR0aF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgICAgY29uc3QgW3BhZ2VYXSA9IHRoaXMucGFnZVRyYW5zbGF0aW9uO1xuICAgICAgY29uc3QgYmxYID0gcGFnZVggKyBwYWdlV2lkdGggKyAxO1xuICAgICAgY29uc3QgYmxZID0gdHJZIC0gREVGQVVMVF9QT1BVUF9IRUlHSFQ7XG4gICAgICBjb25zdCB0clggPSBibFggKyBERUZBVUxUX1BPUFVQX1dJRFRIO1xuICAgICAgc2VyaWFsaXplZC5wb3B1cCA9IHtcbiAgICAgICAgY29udGVudHM6IHRoaXMuY29tbWVudC50ZXh0LFxuICAgICAgICBkZWxldGVkOiB0aGlzLmNvbW1lbnQuZGVsZXRlZCxcbiAgICAgICAgcmVjdDogW2JsWCwgYmxZLCB0clgsIHRyWV1cbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHVwZGF0ZUZyb21Bbm5vdGF0aW9uTGF5ZXIoe1xuICAgIHBvcHVwOiB7XG4gICAgICBjb250ZW50cyxcbiAgICAgIGRlbGV0ZWRcbiAgICB9XG4gIH0pIHtcbiAgICB0aGlzLiNjb21tZW50LmRhdGEgPSBkZWxldGVkID8gbnVsbCA6IGNvbnRlbnRzO1xuICB9XG4gIGdldCBwYXJlbnRCb3VuZGluZ0NsaWVudFJlY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50LmJvdW5kaW5nQ2xpZW50UmVjdDtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgZGl2ID0gdGhpcy5kaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVkaXRvci1yb3RhdGlvblwiLCAoMzYwIC0gdGhpcy5yb3RhdGlvbikgJSAzNjApO1xuICAgIGRpdi5jbGFzc05hbWUgPSB0aGlzLm5hbWU7XG4gICAgZGl2LnNldEF0dHJpYnV0ZShcImlkXCIsIHRoaXMuaWQpO1xuICAgIGRpdi50YWJJbmRleCA9IHRoaXMuI2Rpc2FibGVkID8gLTEgOiAwO1xuICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiYXBwbGljYXRpb25cIik7XG4gICAgaWYgKHRoaXMuZGVmYXVsdEwxMG5JZCkge1xuICAgICAgZGl2LnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCB0aGlzLmRlZmF1bHRMMTBuSWQpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSkge1xuICAgICAgZGl2LmNsYXNzTGlzdC5hZGQoXCJoaWRkZW5cIik7XG4gICAgfVxuICAgIHRoaXMuc2V0SW5Gb3JlZ3JvdW5kKCk7XG4gICAgdGhpcy4jYWRkRm9jdXNMaXN0ZW5lcnMoKTtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgaWYgKHRoaXMucGFyZW50Um90YXRpb24gJSAxODAgIT09IDApIHtcbiAgICAgIGRpdi5zdHlsZS5tYXhXaWR0aCA9IGAkeygxMDAgKiBwYXJlbnRIZWlnaHQgLyBwYXJlbnRXaWR0aCkudG9GaXhlZCgyKX0lYDtcbiAgICAgIGRpdi5zdHlsZS5tYXhIZWlnaHQgPSBgJHsoMTAwICogcGFyZW50V2lkdGggLyBwYXJlbnRIZWlnaHQpLnRvRml4ZWQoMil9JWA7XG4gICAgfVxuICAgIGNvbnN0IFt0eCwgdHldID0gdGhpcy5nZXRJbml0aWFsVHJhbnNsYXRpb24oKTtcbiAgICB0aGlzLnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgIGJpbmRFdmVudHModGhpcywgZGl2LCBbXCJrZXlkb3duXCIsIFwicG9pbnRlcmRvd25cIiwgXCJkYmxjbGlja1wiXSk7XG4gICAgaWYgKHRoaXMuaXNSZXNpemFibGUgJiYgdGhpcy5fdWlNYW5hZ2VyLl9zdXBwb3J0c1BpbmNoVG9ab29tKSB7XG4gICAgICB0aGlzLiN0b3VjaE1hbmFnZXIgfHw9IG5ldyBUb3VjaE1hbmFnZXIoe1xuICAgICAgICBjb250YWluZXI6IGRpdixcbiAgICAgICAgaXNQaW5jaGluZ0Rpc2FibGVkOiAoKSA9PiAhdGhpcy5pc1NlbGVjdGVkLFxuICAgICAgICBvblBpbmNoU3RhcnQ6IHRoaXMuI3RvdWNoUGluY2hTdGFydENhbGxiYWNrLmJpbmQodGhpcyksXG4gICAgICAgIG9uUGluY2hpbmc6IHRoaXMuI3RvdWNoUGluY2hDYWxsYmFjay5iaW5kKHRoaXMpLFxuICAgICAgICBvblBpbmNoRW5kOiB0aGlzLiN0b3VjaFBpbmNoRW5kQ2FsbGJhY2suYmluZCh0aGlzKSxcbiAgICAgICAgc2lnbmFsOiB0aGlzLl91aU1hbmFnZXIuX3NpZ25hbFxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuYWRkU3RhbmRhbG9uZUNvbW1lbnRCdXR0b24oKTtcbiAgICB0aGlzLl91aU1hbmFnZXIuX2VkaXRvclVuZG9CYXI/LmhpZGUoKTtcbiAgICByZXR1cm4gZGl2O1xuICB9XG4gICN0b3VjaFBpbmNoU3RhcnRDYWxsYmFjaygpIHtcbiAgICB0aGlzLiNzYXZlZERpbWVuc2lvbnMgPSB7XG4gICAgICBzYXZlZFg6IHRoaXMueCxcbiAgICAgIHNhdmVkWTogdGhpcy55LFxuICAgICAgc2F2ZWRXaWR0aDogdGhpcy53aWR0aCxcbiAgICAgIHNhdmVkSGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgIH07XG4gICAgdGhpcy4jYWx0VGV4dD8udG9nZ2xlKGZhbHNlKTtcbiAgICB0aGlzLnBhcmVudC50b2dnbGVQb2ludGVyRXZlbnRzKGZhbHNlKTtcbiAgfVxuICAjdG91Y2hQaW5jaENhbGxiYWNrKF9vcmlnaW4sIHByZXZEaXN0YW5jZSwgZGlzdGFuY2UpIHtcbiAgICBjb25zdCBzbG93RG93bkZhY3RvciA9IDAuNztcbiAgICBsZXQgZmFjdG9yID0gc2xvd0Rvd25GYWN0b3IgKiAoZGlzdGFuY2UgLyBwcmV2RGlzdGFuY2UpICsgMSAtIHNsb3dEb3duRmFjdG9yO1xuICAgIGlmIChmYWN0b3IgPT09IDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgcm90YXRpb25NYXRyaXggPSB0aGlzLiNnZXRSb3RhdGlvbk1hdHJpeCh0aGlzLnJvdGF0aW9uKTtcbiAgICBjb25zdCB0cmFuc2YgPSAoeCwgeSkgPT4gW3JvdGF0aW9uTWF0cml4WzBdICogeCArIHJvdGF0aW9uTWF0cml4WzJdICogeSwgcm90YXRpb25NYXRyaXhbMV0gKiB4ICsgcm90YXRpb25NYXRyaXhbM10gKiB5XTtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgY29uc3Qgc2F2ZWRYID0gdGhpcy54O1xuICAgIGNvbnN0IHNhdmVkWSA9IHRoaXMueTtcbiAgICBjb25zdCBzYXZlZFdpZHRoID0gdGhpcy53aWR0aDtcbiAgICBjb25zdCBzYXZlZEhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgIGNvbnN0IG1pbldpZHRoID0gQW5ub3RhdGlvbkVkaXRvci5NSU5fU0laRSAvIHBhcmVudFdpZHRoO1xuICAgIGNvbnN0IG1pbkhlaWdodCA9IEFubm90YXRpb25FZGl0b3IuTUlOX1NJWkUgLyBwYXJlbnRIZWlnaHQ7XG4gICAgZmFjdG9yID0gTWF0aC5tYXgoTWF0aC5taW4oZmFjdG9yLCAxIC8gc2F2ZWRXaWR0aCwgMSAvIHNhdmVkSGVpZ2h0KSwgbWluV2lkdGggLyBzYXZlZFdpZHRoLCBtaW5IZWlnaHQgLyBzYXZlZEhlaWdodCk7XG4gICAgY29uc3QgbmV3V2lkdGggPSBBbm5vdGF0aW9uRWRpdG9yLl9yb3VuZChzYXZlZFdpZHRoICogZmFjdG9yKTtcbiAgICBjb25zdCBuZXdIZWlnaHQgPSBBbm5vdGF0aW9uRWRpdG9yLl9yb3VuZChzYXZlZEhlaWdodCAqIGZhY3Rvcik7XG4gICAgaWYgKG5ld1dpZHRoID09PSBzYXZlZFdpZHRoICYmIG5ld0hlaWdodCA9PT0gc2F2ZWRIZWlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jaW5pdGlhbFJlY3QgfHw9IFtzYXZlZFgsIHNhdmVkWSwgc2F2ZWRXaWR0aCwgc2F2ZWRIZWlnaHRdO1xuICAgIGNvbnN0IHRyYW5zZkNlbnRlclBvaW50ID0gdHJhbnNmKHNhdmVkV2lkdGggLyAyLCBzYXZlZEhlaWdodCAvIDIpO1xuICAgIGNvbnN0IGNlbnRlclggPSBBbm5vdGF0aW9uRWRpdG9yLl9yb3VuZChzYXZlZFggKyB0cmFuc2ZDZW50ZXJQb2ludFswXSk7XG4gICAgY29uc3QgY2VudGVyWSA9IEFubm90YXRpb25FZGl0b3IuX3JvdW5kKHNhdmVkWSArIHRyYW5zZkNlbnRlclBvaW50WzFdKTtcbiAgICBjb25zdCBuZXdUcmFuc2ZDZW50ZXJQb2ludCA9IHRyYW5zZihuZXdXaWR0aCAvIDIsIG5ld0hlaWdodCAvIDIpO1xuICAgIHRoaXMueCA9IGNlbnRlclggLSBuZXdUcmFuc2ZDZW50ZXJQb2ludFswXTtcbiAgICB0aGlzLnkgPSBjZW50ZXJZIC0gbmV3VHJhbnNmQ2VudGVyUG9pbnRbMV07XG4gICAgdGhpcy53aWR0aCA9IG5ld1dpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgIHRoaXMuc2V0RGltcygpO1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICB0aGlzLl9vblJlc2l6aW5nKCk7XG4gIH1cbiAgI3RvdWNoUGluY2hFbmRDYWxsYmFjaygpIHtcbiAgICB0aGlzLiNhbHRUZXh0Py50b2dnbGUodHJ1ZSk7XG4gICAgdGhpcy5wYXJlbnQudG9nZ2xlUG9pbnRlckV2ZW50cyh0cnVlKTtcbiAgICB0aGlzLiNhZGRSZXNpemVUb1VuZG9TdGFjaygpO1xuICB9XG4gIHBvaW50ZXJkb3duKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8IGV2ZW50LmN0cmxLZXkgJiYgaXNNYWMpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2hhc0JlZW5DbGlja2VkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5faXNEcmFnZ2FibGUpIHtcbiAgICAgIHRoaXMuI3NldFVwRHJhZ1Nlc3Npb24oZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNzZWxlY3RPblBvaW50ZXJFdmVudChldmVudCk7XG4gIH1cbiAgI3NlbGVjdE9uUG9pbnRlckV2ZW50KGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBpZiAoZXZlbnQuY3RybEtleSAmJiAhaXNNYWMgfHwgZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQubWV0YUtleSAmJiBpc01hYykge1xuICAgICAgdGhpcy5wYXJlbnQudG9nZ2xlU2VsZWN0ZWQodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFyZW50LnNldFNlbGVjdGVkKHRoaXMpO1xuICAgIH1cbiAgfVxuICAjc2V0VXBEcmFnU2Vzc2lvbihldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzU2VsZWN0ZWRcbiAgICB9ID0gdGhpcztcbiAgICB0aGlzLl91aU1hbmFnZXIuc2V0VXBEcmFnU2Vzc2lvbigpO1xuICAgIGxldCBoYXNEcmFnZ2luZ1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICBjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLl91aU1hbmFnZXIuY29tYmluZWRTaWduYWwoYWMpO1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICBzaWduYWxcbiAgICB9O1xuICAgIGNvbnN0IGNhbmNlbERyYWcgPSAoZSkgPT4ge1xuICAgICAgYWMuYWJvcnQoKTtcbiAgICAgIHRoaXMuI2RyYWdQb2ludGVySWQgPSBudWxsO1xuICAgICAgdGhpcy4jaGFzQmVlbkNsaWNrZWQgPSBmYWxzZTtcbiAgICAgIGlmICghdGhpcy5fdWlNYW5hZ2VyLmVuZERyYWdTZXNzaW9uKCkpIHtcbiAgICAgICAgdGhpcy4jc2VsZWN0T25Qb2ludGVyRXZlbnQoZSk7XG4gICAgICB9XG4gICAgICBpZiAoaGFzRHJhZ2dpbmdTdGFydGVkKSB7XG4gICAgICAgIHRoaXMuX29uU3RvcERyYWdnaW5nKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgdGhpcy4jcHJldkRyYWdYID0gZXZlbnQuY2xpZW50WDtcbiAgICAgIHRoaXMuI3ByZXZEcmFnWSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICB0aGlzLiNkcmFnUG9pbnRlcklkID0gZXZlbnQucG9pbnRlcklkO1xuICAgICAgdGhpcy4jZHJhZ1BvaW50ZXJUeXBlID0gZXZlbnQucG9pbnRlclR5cGU7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIChlKSA9PiB7XG4gICAgICAgIGlmICghaGFzRHJhZ2dpbmdTdGFydGVkKSB7XG4gICAgICAgICAgaGFzRHJhZ2dpbmdTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLl91aU1hbmFnZXIudG9nZ2xlQ29tbWVudCh0aGlzLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgdGhpcy5fb25TdGFydERyYWdnaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGNsaWVudFg6IHgsXG4gICAgICAgICAgY2xpZW50WTogeSxcbiAgICAgICAgICBwb2ludGVySWRcbiAgICAgICAgfSA9IGU7XG4gICAgICAgIGlmIChwb2ludGVySWQgIT09IHRoaXMuI2RyYWdQb2ludGVySWQpIHtcbiAgICAgICAgICBzdG9wRXZlbnQoZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFt0eCwgdHldID0gdGhpcy5zY3JlZW5Ub1BhZ2VUcmFuc2xhdGlvbih4IC0gdGhpcy4jcHJldkRyYWdYLCB5IC0gdGhpcy4jcHJldkRyYWdZKTtcbiAgICAgICAgdGhpcy4jcHJldkRyYWdYID0geDtcbiAgICAgICAgdGhpcy4jcHJldkRyYWdZID0geTtcbiAgICAgICAgdGhpcy5fdWlNYW5hZ2VyLmRyYWdTZWxlY3RlZEVkaXRvcnModHgsIHR5KTtcbiAgICAgIH0sIG9wdHMpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgc3RvcEV2ZW50LCBvcHRzKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgKGUpID0+IHtcbiAgICAgICAgaWYgKGUucG9pbnRlclR5cGUgPT09IHRoaXMuI2RyYWdQb2ludGVyVHlwZSkge1xuICAgICAgICAgIGlmICh0aGlzLiN0b3VjaE1hbmFnZXIgfHwgZS5pc1ByaW1hcnkpIHtcbiAgICAgICAgICAgIGNhbmNlbERyYWcoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0b3BFdmVudChlKTtcbiAgICAgIH0sIG9wdHMpO1xuICAgIH1cbiAgICBjb25zdCBwb2ludGVyVXBDYWxsYmFjayA9IChlKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuI2RyYWdQb2ludGVySWQgfHwgdGhpcy4jZHJhZ1BvaW50ZXJJZCA9PT0gZS5wb2ludGVySWQpIHtcbiAgICAgICAgY2FuY2VsRHJhZyhlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3RvcEV2ZW50KGUpO1xuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgcG9pbnRlclVwQ2FsbGJhY2ssIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBwb2ludGVyVXBDYWxsYmFjaywge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgX29uU3RhcnREcmFnZ2luZygpIHtcbiAgfVxuICBfb25TdG9wRHJhZ2dpbmcoKSB7XG4gIH1cbiAgbW92ZUluRE9NKCkge1xuICAgIGlmICh0aGlzLiNtb3ZlSW5ET01UaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jbW92ZUluRE9NVGltZW91dCk7XG4gICAgfVxuICAgIHRoaXMuI21vdmVJbkRPTVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuI21vdmVJbkRPTVRpbWVvdXQgPSBudWxsO1xuICAgICAgdGhpcy5wYXJlbnQ/Lm1vdmVFZGl0b3JJbkRPTSh0aGlzKTtcbiAgICB9LCAwKTtcbiAgfVxuICBfc2V0UGFyZW50QW5kUG9zaXRpb24ocGFyZW50LCB4LCB5KSB7XG4gICAgcGFyZW50LmNoYW5nZVBhcmVudCh0aGlzKTtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICAgIHRoaXMuX29uVHJhbnNsYXRlZCgpO1xuICB9XG4gIGdldFJlY3QodHgsIHR5LCByb3RhdGlvbiA9IHRoaXMucm90YXRpb24pIHtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMucGFyZW50U2NhbGU7XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgIGNvbnN0IFtwYWdlWCwgcGFnZVldID0gdGhpcy5wYWdlVHJhbnNsYXRpb247XG4gICAgY29uc3Qgc2hpZnRYID0gdHggLyBzY2FsZTtcbiAgICBjb25zdCBzaGlmdFkgPSB0eSAvIHNjYWxlO1xuICAgIGNvbnN0IHggPSB0aGlzLnggKiBwYWdlV2lkdGg7XG4gICAgY29uc3QgeSA9IHRoaXMueSAqIHBhZ2VIZWlnaHQ7XG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLndpZHRoICogcGFnZVdpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuaGVpZ2h0ICogcGFnZUhlaWdodDtcbiAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBbeCArIHNoaWZ0WCArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSAtIHNoaWZ0WSAtIGhlaWdodCArIHBhZ2VZLCB4ICsgc2hpZnRYICsgd2lkdGggKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgLSBzaGlmdFkgKyBwYWdlWV07XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gW3ggKyBzaGlmdFkgKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgKyBzaGlmdFggKyBwYWdlWSwgeCArIHNoaWZ0WSArIGhlaWdodCArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSArIHNoaWZ0WCArIHdpZHRoICsgcGFnZVldO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbeCAtIHNoaWZ0WCAtIHdpZHRoICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5ICsgc2hpZnRZICsgcGFnZVksIHggLSBzaGlmdFggKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgKyBzaGlmdFkgKyBoZWlnaHQgKyBwYWdlWV07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcmV0dXJuIFt4IC0gc2hpZnRZIC0gaGVpZ2h0ICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5IC0gc2hpZnRYIC0gd2lkdGggKyBwYWdlWSwgeCAtIHNoaWZ0WSArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSAtIHNoaWZ0WCArIHBhZ2VZXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcm90YXRpb25cIik7XG4gICAgfVxuICB9XG4gIGdldFJlY3RJbkN1cnJlbnRDb29yZHMocmVjdCwgcGFnZUhlaWdodCkge1xuICAgIGNvbnN0IFt4MSwgeTEsIHgyLCB5Ml0gPSByZWN0O1xuICAgIGNvbnN0IHdpZHRoID0geDIgLSB4MTtcbiAgICBjb25zdCBoZWlnaHQgPSB5MiAtIHkxO1xuICAgIHN3aXRjaCAodGhpcy5yb3RhdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gW3gxLCBwYWdlSGVpZ2h0IC0geTIsIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFt4MSwgcGFnZUhlaWdodCAtIHkxLCBoZWlnaHQsIHdpZHRoXTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gW3gyLCBwYWdlSGVpZ2h0IC0geTEsIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbeDIsIHBhZ2VIZWlnaHQgLSB5MiwgaGVpZ2h0LCB3aWR0aF07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJvdGF0aW9uXCIpO1xuICAgIH1cbiAgfVxuICBnZXRQREZSZWN0KCkge1xuICAgIHJldHVybiB0aGlzLmdldFJlY3QoMCwgMCk7XG4gIH1cbiAgZ2V0Tm9uSENNQ29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sb3IgJiYgQW5ub3RhdGlvbkVkaXRvci5fY29sb3JNYW5hZ2VyLmNvbnZlcnQodGhpcy5fdWlNYW5hZ2VyLmdldE5vbkhDTUNvbG9yKHRoaXMuY29sb3IpKTtcbiAgfVxuICBvblVwZGF0ZWRDb2xvcigpIHtcbiAgICB0aGlzLiNjb21tZW50Py5vblVwZGF0ZWRDb2xvcigpO1xuICB9XG4gIGdldERhdGEoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWVudDoge1xuICAgICAgICB0ZXh0OiBzdHIsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBkYXRlLFxuICAgICAgICBvcGFjaXR5LFxuICAgICAgICBkZWxldGVkLFxuICAgICAgICByaWNoVGV4dFxuICAgICAgfSxcbiAgICAgIHVpZDogaWQsXG4gICAgICBwYWdlSW5kZXgsXG4gICAgICBjcmVhdGlvbkRhdGUsXG4gICAgICBtb2RpZmljYXRpb25EYXRlXG4gICAgfSA9IHRoaXM7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkLFxuICAgICAgcGFnZUluZGV4LFxuICAgICAgcmVjdDogdGhpcy5nZXRQREZSZWN0KCksXG4gICAgICByaWNoVGV4dCxcbiAgICAgIGNvbnRlbnRzT2JqOiB7XG4gICAgICAgIHN0clxuICAgICAgfSxcbiAgICAgIGNyZWF0aW9uRGF0ZSxcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGU6IGRhdGUgfHwgbW9kaWZpY2F0aW9uRGF0ZSxcbiAgICAgIHBvcHVwUmVmOiAhZGVsZXRlZCxcbiAgICAgIGNvbG9yLFxuICAgICAgb3BhY2l0eVxuICAgIH07XG4gIH1cbiAgb25jZUFkZGVkKGZvY3VzKSB7XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZW5hYmxlRWRpdE1vZGUoKSB7XG4gICAgaWYgKHRoaXMuaXNJbkVkaXRNb2RlKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQuc2V0RWRpdGluZ1N0YXRlKGZhbHNlKTtcbiAgICB0aGlzLiNpc0luRWRpdE1vZGUgPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGRpc2FibGVFZGl0TW9kZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNJbkVkaXRNb2RlKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQuc2V0RWRpdGluZ1N0YXRlKHRydWUpO1xuICAgIHRoaXMuI2lzSW5FZGl0TW9kZSA9IGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlzSW5FZGl0TW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jaXNJbkVkaXRNb2RlO1xuICB9XG4gIHNob3VsZEdldEtleWJvYXJkRXZlbnRzKCkge1xuICAgIHJldHVybiB0aGlzLiNpc1Jlc2l6ZXJFbmFibGVkRm9yS2V5Ym9hcmQ7XG4gIH1cbiAgbmVlZHNUb0JlUmVidWlsdCgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXYgJiYgIXRoaXMuaXNBdHRhY2hlZFRvRE9NO1xuICB9XG4gIGdldCBpc09uU2NyZWVuKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHRvcCxcbiAgICAgIGxlZnQsXG4gICAgICBib3R0b20sXG4gICAgICByaWdodFxuICAgIH0gPSB0aGlzLmdldENsaWVudERpbWVuc2lvbnMoKTtcbiAgICBjb25zdCB7XG4gICAgICBpbm5lckhlaWdodCxcbiAgICAgIGlubmVyV2lkdGhcbiAgICB9ID0gd2luZG93O1xuICAgIHJldHVybiBsZWZ0IDwgaW5uZXJXaWR0aCAmJiByaWdodCA+IDAgJiYgdG9wIDwgaW5uZXJIZWlnaHQgJiYgYm90dG9tID4gMDtcbiAgfVxuICAjYWRkRm9jdXNMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKHRoaXMuI2ZvY3VzQUMgfHwgIXRoaXMuZGl2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2ZvY3VzQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5fdWlNYW5hZ2VyLmNvbWJpbmVkU2lnbmFsKHRoaXMuI2ZvY3VzQUMpO1xuICAgIHRoaXMuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIHRoaXMuZm9jdXNpbi5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgdGhpcy5mb2N1c291dC5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgfVxuICByZWJ1aWxkKCkge1xuICAgIHRoaXMuI2FkZEZvY3VzTGlzdGVuZXJzKCk7XG4gIH1cbiAgcm90YXRlKF9hbmdsZSkge1xuICB9XG4gIHJlc2l6ZSgpIHtcbiAgfVxuICBzZXJpYWxpemVEZWxldGVkKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkLFxuICAgICAgZGVsZXRlZDogdHJ1ZSxcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5wYWdlSW5kZXgsXG4gICAgICBwb3B1cFJlZjogdGhpcy5faW5pdGlhbERhdGE/LnBvcHVwUmVmIHx8IFwiXCJcbiAgICB9O1xuICB9XG4gIHNlcmlhbGl6ZShpc0ZvckNvcHlpbmcgPSBmYWxzZSwgY29udGV4dCA9IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYW5ub3RhdGlvblR5cGU6IHRoaXMubW9kZSxcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5wYWdlSW5kZXgsXG4gICAgICByZWN0OiB0aGlzLmdldFBERlJlY3QoKSxcbiAgICAgIHJvdGF0aW9uOiB0aGlzLnJvdGF0aW9uLFxuICAgICAgc3RydWN0VHJlZVBhcmVudElkOiB0aGlzLl9zdHJ1Y3RUcmVlUGFyZW50SWQsXG4gICAgICBwb3B1cFJlZjogdGhpcy5faW5pdGlhbERhdGE/LnBvcHVwUmVmIHx8IFwiXCJcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBhc3luYyBkZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcikge1xuICAgIGNvbnN0IGVkaXRvciA9IG5ldyB0aGlzLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcih7XG4gICAgICBwYXJlbnQsXG4gICAgICBpZDogcGFyZW50LmdldE5leHRJZCgpLFxuICAgICAgdWlNYW5hZ2VyLFxuICAgICAgYW5ub3RhdGlvbkVsZW1lbnRJZDogZGF0YS5hbm5vdGF0aW9uRWxlbWVudElkLFxuICAgICAgY3JlYXRpb25EYXRlOiBkYXRhLmNyZWF0aW9uRGF0ZSxcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGU6IGRhdGEubW9kaWZpY2F0aW9uRGF0ZVxuICAgIH0pO1xuICAgIGVkaXRvci5yb3RhdGlvbiA9IGRhdGEucm90YXRpb247XG4gICAgZWRpdG9yLiNhY2Nlc3NpYmlsaXR5RGF0YSA9IGRhdGEuYWNjZXNzaWJpbGl0eURhdGE7XG4gICAgZWRpdG9yLl9pc0NvcHkgPSBkYXRhLmlzQ29weSB8fCBmYWxzZTtcbiAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IGVkaXRvci5wYWdlRGltZW5zaW9ucztcbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSBlZGl0b3IuZ2V0UmVjdEluQ3VycmVudENvb3JkcyhkYXRhLnJlY3QsIHBhZ2VIZWlnaHQpO1xuICAgIGVkaXRvci54ID0geCAvIHBhZ2VXaWR0aDtcbiAgICBlZGl0b3IueSA9IHkgLyBwYWdlSGVpZ2h0O1xuICAgIGVkaXRvci53aWR0aCA9IHdpZHRoIC8gcGFnZVdpZHRoO1xuICAgIGVkaXRvci5oZWlnaHQgPSBoZWlnaHQgLyBwYWdlSGVpZ2h0O1xuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgZ2V0IGhhc0JlZW5Nb2RpZmllZCgpIHtcbiAgICByZXR1cm4gISF0aGlzLmFubm90YXRpb25FbGVtZW50SWQgJiYgKHRoaXMuZGVsZXRlZCB8fCB0aGlzLnNlcmlhbGl6ZSgpICE9PSBudWxsKTtcbiAgfVxuICByZW1vdmUoKSB7XG4gICAgdGhpcy4jZm9jdXNBQz8uYWJvcnQoKTtcbiAgICB0aGlzLiNmb2N1c0FDID0gbnVsbDtcbiAgICBpZiAoIXRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICB0aGlzLmNvbW1pdCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50LnJlbW92ZSh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLnJlbW92ZUVkaXRvcih0aGlzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI21vdmVJbkRPTVRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNtb3ZlSW5ET01UaW1lb3V0KTtcbiAgICAgIHRoaXMuI21vdmVJbkRPTVRpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLiNzdG9wUmVzaXppbmcoKTtcbiAgICB0aGlzLnJlbW92ZUVkaXRUb29sYmFyKCk7XG4gICAgaWYgKHRoaXMuI3RlbGVtZXRyeVRpbWVvdXRzKSB7XG4gICAgICBmb3IgKGNvbnN0IHRpbWVvdXQgb2YgdGhpcy4jdGVsZW1ldHJ5VGltZW91dHMudmFsdWVzKCkpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgfVxuICAgICAgdGhpcy4jdGVsZW1ldHJ5VGltZW91dHMgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgdGhpcy4jdG91Y2hNYW5hZ2VyPy5kZXN0cm95KCk7XG4gICAgdGhpcy4jdG91Y2hNYW5hZ2VyID0gbnVsbDtcbiAgfVxuICBnZXQgaXNSZXNpemFibGUoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIG1ha2VSZXNpemFibGUoKSB7XG4gICAgaWYgKHRoaXMuaXNSZXNpemFibGUpIHtcbiAgICAgIHRoaXMuI2NyZWF0ZVJlc2l6ZXJzKCk7XG4gICAgICB0aGlzLiNyZXNpemVyc0Rpdi5jbGFzc0xpc3QucmVtb3ZlKFwiaGlkZGVuXCIpO1xuICAgIH1cbiAgfVxuICBnZXQgdG9vbGJhclBvc2l0aW9uKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdldCBjb21tZW50QnV0dG9uUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VpTWFuYWdlci5kaXJlY3Rpb24gPT09IFwibHRyXCIgPyBbMSwgMF0gOiBbMCwgMF07XG4gIH1cbiAgZ2V0IGNvbW1lbnRCdXR0b25Qb3NpdGlvbkluUGFnZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21tZW50QnV0dG9uUG9zaXRpb246IFtwb3NYLCBwb3NZXVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IFtibFgsIGJsWSwgdHJYLCB0clldID0gdGhpcy5nZXRQREZSZWN0KCk7XG4gICAgcmV0dXJuIFtBbm5vdGF0aW9uRWRpdG9yLl9yb3VuZChibFggKyAodHJYIC0gYmxYKSAqIHBvc1gpLCBBbm5vdGF0aW9uRWRpdG9yLl9yb3VuZChibFkgKyAodHJZIC0gYmxZKSAqICgxIC0gcG9zWSkpXTtcbiAgfVxuICBnZXQgY29tbWVudEJ1dHRvbkNvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLl91aU1hbmFnZXIubWFrZUNvbW1lbnRDb2xvcih0aGlzLmdldE5vbkhDTUNvbG9yKCksIHRoaXMub3BhY2l0eSk7XG4gIH1cbiAgZ2V0IGNvbW1lbnRQb3B1cFBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLiNjb21tZW50LmNvbW1lbnRQb3B1cFBvc2l0aW9uSW5MYXllcjtcbiAgfVxuICBzZXQgY29tbWVudFBvcHVwUG9zaXRpb24ocG9zKSB7XG4gICAgdGhpcy4jY29tbWVudC5jb21tZW50UG9wdXBQb3NpdGlvbkluTGF5ZXIgPSBwb3M7XG4gIH1cbiAgaGFzRGVmYXVsdFBvcHVwUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NvbW1lbnQuaGFzRGVmYXVsdFBvcHVwUG9zaXRpb24oKTtcbiAgfVxuICBnZXQgY29tbWVudEJ1dHRvbldpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLiNjb21tZW50LmNvbW1lbnRCdXR0b25XaWR0aDtcbiAgfVxuICBnZXQgZWxlbWVudEJlZm9yZVBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLmRpdjtcbiAgfVxuICBzZXRDb21tZW50QnV0dG9uU3RhdGVzKG9wdGlvbnMpIHtcbiAgICB0aGlzLiNjb21tZW50LnNldENvbW1lbnRCdXR0b25TdGF0ZXMob3B0aW9ucyk7XG4gIH1cbiAga2V5ZG93bihldmVudCkge1xuICAgIGlmICghdGhpcy5pc1Jlc2l6YWJsZSB8fCBldmVudC50YXJnZXQgIT09IHRoaXMuZGl2IHx8IGV2ZW50LmtleSAhPT0gXCJFbnRlclwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3VpTWFuYWdlci5zZXRTZWxlY3RlZCh0aGlzKTtcbiAgICB0aGlzLiNzYXZlZERpbWVuc2lvbnMgPSB7XG4gICAgICBzYXZlZFg6IHRoaXMueCxcbiAgICAgIHNhdmVkWTogdGhpcy55LFxuICAgICAgc2F2ZWRXaWR0aDogdGhpcy53aWR0aCxcbiAgICAgIHNhdmVkSGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgIH07XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLiNyZXNpemVyc0Rpdi5jaGlsZHJlbjtcbiAgICBpZiAoIXRoaXMuI2FsbFJlc2l6ZXJEaXZzKSB7XG4gICAgICB0aGlzLiNhbGxSZXNpemVyRGl2cyA9IEFycmF5LmZyb20oY2hpbGRyZW4pO1xuICAgICAgY29uc3QgYm91bmRSZXNpemVyS2V5ZG93biA9IHRoaXMuI3Jlc2l6ZXJLZXlkb3duLmJpbmQodGhpcyk7XG4gICAgICBjb25zdCBib3VuZFJlc2l6ZXJCbHVyID0gdGhpcy4jcmVzaXplckJsdXIuYmluZCh0aGlzKTtcbiAgICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3VpTWFuYWdlci5fc2lnbmFsO1xuICAgICAgZm9yIChjb25zdCBkaXYgb2YgdGhpcy4jYWxsUmVzaXplckRpdnMpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGRpdi5nZXRBdHRyaWJ1dGUoXCJkYXRhLXJlc2l6ZXItbmFtZVwiKTtcbiAgICAgICAgZGl2LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJzcGluYnV0dG9uXCIpO1xuICAgICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgYm91bmRSZXNpemVyS2V5ZG93biwge1xuICAgICAgICAgIHNpZ25hbFxuICAgICAgICB9KTtcbiAgICAgICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGJvdW5kUmVzaXplckJsdXIsIHtcbiAgICAgICAgICBzaWduYWxcbiAgICAgICAgfSk7XG4gICAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy4jcmVzaXplckZvY3VzLmJpbmQodGhpcywgbmFtZSksIHtcbiAgICAgICAgICBzaWduYWxcbiAgICAgICAgfSk7XG4gICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgQW5ub3RhdGlvbkVkaXRvci5fbDEwblJlc2l6ZXJbbmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmaXJzdCA9IHRoaXMuI2FsbFJlc2l6ZXJEaXZzWzBdO1xuICAgIGxldCBmaXJzdFBvc2l0aW9uID0gMDtcbiAgICBmb3IgKGNvbnN0IGRpdiBvZiBjaGlsZHJlbikge1xuICAgICAgaWYgKGRpdiA9PT0gZmlyc3QpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBmaXJzdFBvc2l0aW9uKys7XG4gICAgfVxuICAgIGNvbnN0IG5leHRGaXJzdFBvc2l0aW9uID0gKDM2MCAtIHRoaXMucm90YXRpb24gKyB0aGlzLnBhcmVudFJvdGF0aW9uKSAlIDM2MCAvIDkwICogKHRoaXMuI2FsbFJlc2l6ZXJEaXZzLmxlbmd0aCAvIDQpO1xuICAgIGlmIChuZXh0Rmlyc3RQb3NpdGlvbiAhPT0gZmlyc3RQb3NpdGlvbikge1xuICAgICAgaWYgKG5leHRGaXJzdFBvc2l0aW9uIDwgZmlyc3RQb3NpdGlvbikge1xuICAgICAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgZmlyc3RQb3NpdGlvbiAtIG5leHRGaXJzdFBvc2l0aW9uOyBpMisrKSB7XG4gICAgICAgICAgdGhpcy4jcmVzaXplcnNEaXYuYXBwZW5kKHRoaXMuI3Jlc2l6ZXJzRGl2LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5leHRGaXJzdFBvc2l0aW9uID4gZmlyc3RQb3NpdGlvbikge1xuICAgICAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgbmV4dEZpcnN0UG9zaXRpb24gLSBmaXJzdFBvc2l0aW9uOyBpMisrKSB7XG4gICAgICAgICAgdGhpcy4jcmVzaXplcnNEaXYuZmlyc3RDaGlsZC5iZWZvcmUodGhpcy4jcmVzaXplcnNEaXYubGFzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgICBjb25zdCBkaXYgPSB0aGlzLiNhbGxSZXNpemVyRGl2c1tpKytdO1xuICAgICAgICBjb25zdCBuYW1lID0gZGl2LmdldEF0dHJpYnV0ZShcImRhdGEtcmVzaXplci1uYW1lXCIpO1xuICAgICAgICBjaGlsZC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgQW5ub3RhdGlvbkVkaXRvci5fbDEwblJlc2l6ZXJbbmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNzZXRSZXNpemVyVGFiSW5kZXgoMCk7XG4gICAgdGhpcy4jaXNSZXNpemVyRW5hYmxlZEZvcktleWJvYXJkID0gdHJ1ZTtcbiAgICB0aGlzLiNyZXNpemVyc0Rpdi5maXJzdENoaWxkLmZvY3VzKHtcbiAgICAgIGZvY3VzVmlzaWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gIH1cbiAgI3Jlc2l6ZXJLZXlkb3duKGV2ZW50KSB7XG4gICAgQW5ub3RhdGlvbkVkaXRvci5fcmVzaXplcktleWJvYXJkTWFuYWdlci5leGVjKHRoaXMsIGV2ZW50KTtcbiAgfVxuICAjcmVzaXplckJsdXIoZXZlbnQpIHtcbiAgICBpZiAodGhpcy4jaXNSZXNpemVyRW5hYmxlZEZvcktleWJvYXJkICYmIGV2ZW50LnJlbGF0ZWRUYXJnZXQ/LnBhcmVudE5vZGUgIT09IHRoaXMuI3Jlc2l6ZXJzRGl2KSB7XG4gICAgICB0aGlzLiNzdG9wUmVzaXppbmcoKTtcbiAgICB9XG4gIH1cbiAgI3Jlc2l6ZXJGb2N1cyhuYW1lKSB7XG4gICAgdGhpcy4jZm9jdXNlZFJlc2l6ZXJOYW1lID0gdGhpcy4jaXNSZXNpemVyRW5hYmxlZEZvcktleWJvYXJkID8gbmFtZSA6IFwiXCI7XG4gIH1cbiAgI3NldFJlc2l6ZXJUYWJJbmRleCh2YWx1ZSkge1xuICAgIGlmICghdGhpcy4jYWxsUmVzaXplckRpdnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBkaXYgb2YgdGhpcy4jYWxsUmVzaXplckRpdnMpIHtcbiAgICAgIGRpdi50YWJJbmRleCA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICBfcmVzaXplV2l0aEtleWJvYXJkKHgsIHkpIHtcbiAgICBpZiAoIXRoaXMuI2lzUmVzaXplckVuYWJsZWRGb3JLZXlib2FyZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNyZXNpemVyUG9pbnRlcm1vdmUodGhpcy4jZm9jdXNlZFJlc2l6ZXJOYW1lLCB7XG4gICAgICBkZWx0YVg6IHgsXG4gICAgICBkZWx0YVk6IHksXG4gICAgICBmcm9tS2V5Ym9hcmQ6IHRydWVcbiAgICB9KTtcbiAgfVxuICAjc3RvcFJlc2l6aW5nKCkge1xuICAgIHRoaXMuI2lzUmVzaXplckVuYWJsZWRGb3JLZXlib2FyZCA9IGZhbHNlO1xuICAgIHRoaXMuI3NldFJlc2l6ZXJUYWJJbmRleCgtMSk7XG4gICAgdGhpcy4jYWRkUmVzaXplVG9VbmRvU3RhY2soKTtcbiAgfVxuICBfc3RvcFJlc2l6aW5nV2l0aEtleWJvYXJkKCkge1xuICAgIHRoaXMuI3N0b3BSZXNpemluZygpO1xuICAgIHRoaXMuZGl2LmZvY3VzKCk7XG4gIH1cbiAgc2VsZWN0KCkge1xuICAgIGlmICh0aGlzLmlzU2VsZWN0ZWQgJiYgdGhpcy5fZWRpdFRvb2xiYXIpIHtcbiAgICAgIHRoaXMuX2VkaXRUb29sYmFyLnNob3coKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICB0aGlzLm1ha2VSZXNpemFibGUoKTtcbiAgICB0aGlzLmRpdj8uY2xhc3NMaXN0LmFkZChcInNlbGVjdGVkRWRpdG9yXCIpO1xuICAgIGlmICghdGhpcy5fZWRpdFRvb2xiYXIpIHtcbiAgICAgIHRoaXMuYWRkRWRpdFRvb2xiYXIoKS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuZGl2Py5jbGFzc0xpc3QuY29udGFpbnMoXCJzZWxlY3RlZEVkaXRvclwiKSkge1xuICAgICAgICAgIHRoaXMuX2VkaXRUb29sYmFyPy5zaG93KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9lZGl0VG9vbGJhcj8uc2hvdygpO1xuICAgIHRoaXMuI2FsdFRleHQ/LnRvZ2dsZUFsdFRleHRCYWRnZShmYWxzZSk7XG4gIH1cbiAgZm9jdXMoKSB7XG4gICAgaWYgKHRoaXMuZGl2ICYmICF0aGlzLmRpdi5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmRpdj8uZm9jdXMoe1xuICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgICB9KSwgMCk7XG4gICAgfVxuICB9XG4gIHVuc2VsZWN0KCkge1xuICAgIGlmICghdGhpcy5pc1NlbGVjdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuI3Jlc2l6ZXJzRGl2Py5jbGFzc0xpc3QuYWRkKFwiaGlkZGVuXCIpO1xuICAgIHRoaXMuZGl2Py5jbGFzc0xpc3QucmVtb3ZlKFwic2VsZWN0ZWRFZGl0b3JcIik7XG4gICAgaWYgKHRoaXMuZGl2Py5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmN1cnJlbnRMYXllci5kaXYuZm9jdXMoe1xuICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fZWRpdFRvb2xiYXI/LmhpZGUoKTtcbiAgICB0aGlzLiNhbHRUZXh0Py50b2dnbGVBbHRUZXh0QmFkZ2UodHJ1ZSk7XG4gICAgaWYgKHRoaXMuaGFzQ29tbWVudCkge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLnRvZ2dsZUNvbW1lbnQodGhpcywgZmFsc2UsIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlUGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gIH1cbiAgZGlzYWJsZUVkaXRpbmcoKSB7XG4gIH1cbiAgZW5hYmxlRWRpdGluZygpIHtcbiAgfVxuICBnZXQgY2FuQ2hhbmdlQ29udGVudCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZW50ZXJJbkVkaXRNb2RlKCkge1xuICAgIGlmICghdGhpcy5jYW5DaGFuZ2VDb250ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICB0aGlzLmRpdi5mb2N1cygpO1xuICB9XG4gIGRibGNsaWNrKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnRhcmdldC5ub2RlTmFtZSA9PT0gXCJCVVRUT05cIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVudGVySW5FZGl0TW9kZSgpO1xuICAgIHRoaXMucGFyZW50LnVwZGF0ZVRvb2xiYXIoe1xuICAgICAgbW9kZTogdGhpcy5jb25zdHJ1Y3Rvci5fZWRpdG9yVHlwZSxcbiAgICAgIGVkaXRJZDogdGhpcy5pZFxuICAgIH0pO1xuICB9XG4gIGdldEVsZW1lbnRGb3JBbHRUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmRpdjtcbiAgfVxuICBnZXQgY29udGVudERpdigpIHtcbiAgICByZXR1cm4gdGhpcy5kaXY7XG4gIH1cbiAgZ2V0IGlzRWRpdGluZygpIHtcbiAgICByZXR1cm4gdGhpcy4jaXNFZGl0aW5nO1xuICB9XG4gIHNldCBpc0VkaXRpbmcodmFsdWUpIHtcbiAgICB0aGlzLiNpc0VkaXRpbmcgPSB2YWx1ZTtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5wYXJlbnQuc2V0U2VsZWN0ZWQodGhpcyk7XG4gICAgICB0aGlzLnBhcmVudC5zZXRBY3RpdmVFZGl0b3IodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFyZW50LnNldEFjdGl2ZUVkaXRvcihudWxsKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldCBNSU5fU0laRSgpIHtcbiAgICByZXR1cm4gMTY7XG4gIH1cbiAgc3RhdGljIGNhbkNyZWF0ZU5ld0VtcHR5RWRpdG9yKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldCB0ZWxlbWV0cnlJbml0aWFsRGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWN0aW9uOiBcImFkZGVkXCJcbiAgICB9O1xuICB9XG4gIGdldCB0ZWxlbWV0cnlGaW5hbERhdGEoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgX3JlcG9ydFRlbGVtZXRyeShkYXRhLCBtdXN0V2FpdCA9IGZhbHNlKSB7XG4gICAgaWYgKG11c3RXYWl0KSB7XG4gICAgICB0aGlzLiN0ZWxlbWV0cnlUaW1lb3V0cyB8fD0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWN0aW9uXG4gICAgICB9ID0gZGF0YTtcbiAgICAgIGxldCB0aW1lb3V0ID0gdGhpcy4jdGVsZW1ldHJ5VGltZW91dHMuZ2V0KGFjdGlvbik7XG4gICAgICBpZiAodGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB9XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuX3JlcG9ydFRlbGVtZXRyeShkYXRhKTtcbiAgICAgICAgdGhpcy4jdGVsZW1ldHJ5VGltZW91dHMuZGVsZXRlKGFjdGlvbik7XG4gICAgICAgIGlmICh0aGlzLiN0ZWxlbWV0cnlUaW1lb3V0cy5zaXplID09PSAwKSB7XG4gICAgICAgICAgdGhpcy4jdGVsZW1ldHJ5VGltZW91dHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9LCBBbm5vdGF0aW9uRWRpdG9yLl90ZWxlbWV0cnlUaW1lb3V0KTtcbiAgICAgIHRoaXMuI3RlbGVtZXRyeVRpbWVvdXRzLnNldChhY3Rpb24sIHRpbWVvdXQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkYXRhLnR5cGUgfHw9IHRoaXMuZWRpdG9yVHlwZTtcbiAgICB0aGlzLl91aU1hbmFnZXIuX2V2ZW50QnVzLmRpc3BhdGNoKFwicmVwb3J0dGVsZW1ldHJ5XCIsIHtcbiAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgdHlwZTogXCJlZGl0aW5nXCIsXG4gICAgICAgIGRhdGFcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzaG93KHZpc2libGUgPSB0aGlzLl9pc1Zpc2libGUpIHtcbiAgICB0aGlzLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiaGlkZGVuXCIsICF2aXNpYmxlKTtcbiAgICB0aGlzLl9pc1Zpc2libGUgPSB2aXNpYmxlO1xuICB9XG4gIGVuYWJsZSgpIHtcbiAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgIHRoaXMuZGl2LnRhYkluZGV4ID0gMDtcbiAgICB9XG4gICAgdGhpcy4jZGlzYWJsZWQgPSBmYWxzZTtcbiAgfVxuICBkaXNhYmxlKCkge1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgdGhpcy5kaXYudGFiSW5kZXggPSAtMTtcbiAgICB9XG4gICAgdGhpcy4jZGlzYWJsZWQgPSB0cnVlO1xuICB9XG4gIHVwZGF0ZUZha2VBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uTGF5ZXIpIHtcbiAgICBpZiAoIXRoaXMuI2Zha2VBbm5vdGF0aW9uICYmICF0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIHRoaXMuI2Zha2VBbm5vdGF0aW9uID0gYW5ub3RhdGlvbkxheWVyLmFkZEZha2VBbm5vdGF0aW9uKHRoaXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5kZWxldGVkKSB7XG4gICAgICB0aGlzLiNmYWtlQW5ub3RhdGlvbi5yZW1vdmUoKTtcbiAgICAgIHRoaXMuI2Zha2VBbm5vdGF0aW9uID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGFzRWRpdGVkQ29tbWVudCB8fCB0aGlzLl9oYXNCZWVuTW92ZWQgfHwgdGhpcy5faGFzQmVlblJlc2l6ZWQpIHtcbiAgICAgIHRoaXMuI2Zha2VBbm5vdGF0aW9uLnVwZGF0ZUVkaXRlZCh7XG4gICAgICAgIHJlY3Q6IHRoaXMuZ2V0UERGUmVjdCgpLFxuICAgICAgICBwb3B1cDogdGhpcy5jb21tZW50XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIGlmICh0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIGFubm90YXRpb24uaGlkZSgpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCBjb250ZW50ID0gYW5ub3RhdGlvbi5jb250YWluZXIucXVlcnlTZWxlY3RvcihcIi5hbm5vdGF0aW9uQ29udGVudFwiKTtcbiAgICBpZiAoIWNvbnRlbnQpIHtcbiAgICAgIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgY29udGVudC5jbGFzc0xpc3QuYWRkKFwiYW5ub3RhdGlvbkNvbnRlbnRcIiwgdGhpcy5lZGl0b3JUeXBlKTtcbiAgICAgIGFubm90YXRpb24uY29udGFpbmVyLnByZXBlbmQoY29udGVudCk7XG4gICAgfSBlbHNlIGlmIChjb250ZW50Lm5vZGVOYW1lID09PSBcIkNBTlZBU1wiKSB7XG4gICAgICBjb25zdCBjYW52YXMgPSBjb250ZW50O1xuICAgICAgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoXCJhbm5vdGF0aW9uQ29udGVudFwiLCB0aGlzLmVkaXRvclR5cGUpO1xuICAgICAgY2FudmFzLmJlZm9yZShjb250ZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cbiAgcmVzZXRBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgZmlyc3RDaGlsZFxuICAgIH0gPSBhbm5vdGF0aW9uLmNvbnRhaW5lcjtcbiAgICBpZiAoZmlyc3RDaGlsZD8ubm9kZU5hbWUgPT09IFwiRElWXCIgJiYgZmlyc3RDaGlsZC5jbGFzc0xpc3QuY29udGFpbnMoXCJhbm5vdGF0aW9uQ29udGVudFwiKSkge1xuICAgICAgZmlyc3RDaGlsZC5yZW1vdmUoKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEZha2VFZGl0b3IgZXh0ZW5kcyBBbm5vdGF0aW9uRWRpdG9yIHtcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIocGFyYW1zKTtcbiAgICB0aGlzLmFubm90YXRpb25FbGVtZW50SWQgPSBwYXJhbXMuYW5ub3RhdGlvbkVsZW1lbnRJZDtcbiAgICB0aGlzLmRlbGV0ZWQgPSB0cnVlO1xuICB9XG4gIHNlcmlhbGl6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVEZWxldGVkKCk7XG4gIH1cbn1cbmNvbnN0IFNFRUQgPSAzMjg1Mzc3NTIwO1xuY29uc3QgTUFTS19ISUdIID0gNDI5NDkwMTc2MDtcbmNvbnN0IE1BU0tfTE9XID0gNjU1MzU7XG5jbGFzcyBNdXJtdXJIYXNoM182NCB7XG4gIGNvbnN0cnVjdG9yKHNlZWQpIHtcbiAgICB0aGlzLmgxID0gc2VlZCA/IHNlZWQgJiA0Mjk0OTY3Mjk1IDogU0VFRDtcbiAgICB0aGlzLmgyID0gc2VlZCA/IHNlZWQgJiA0Mjk0OTY3Mjk1IDogU0VFRDtcbiAgfVxuICB1cGRhdGUoaW5wdXQpIHtcbiAgICBsZXQgZGF0YSwgbGVuZ3RoO1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShpbnB1dC5sZW5ndGggKiAyKTtcbiAgICAgIGxlbmd0aCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBpbnB1dC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBpbnB1dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY29kZSA8PSAyNTUpIHtcbiAgICAgICAgICBkYXRhW2xlbmd0aCsrXSA9IGNvZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YVtsZW5ndGgrK10gPSBjb2RlID4+PiA4O1xuICAgICAgICAgIGRhdGFbbGVuZ3RoKytdID0gY29kZSAmIDI1NTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGlucHV0KSkge1xuICAgICAgZGF0YSA9IGlucHV0LnNsaWNlKCk7XG4gICAgICBsZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSBmb3JtYXQsIG11c3QgYmUgYSBzdHJpbmcgb3IgVHlwZWRBcnJheS5cIik7XG4gICAgfVxuICAgIGNvbnN0IGJsb2NrQ291bnRzID0gbGVuZ3RoID4+IDI7XG4gICAgY29uc3QgdGFpbExlbmd0aCA9IGxlbmd0aCAtIGJsb2NrQ291bnRzICogNDtcbiAgICBjb25zdCBkYXRhVWludDMyID0gbmV3IFVpbnQzMkFycmF5KGRhdGEuYnVmZmVyLCAwLCBibG9ja0NvdW50cyk7XG4gICAgbGV0IGsxID0gMCwgazIgPSAwO1xuICAgIGxldCBoMSA9IHRoaXMuaDEsIGgyID0gdGhpcy5oMjtcbiAgICBjb25zdCBDMSA9IDM0MzI5MTgzNTMsIEMyID0gNDYxODQ1OTA3O1xuICAgIGNvbnN0IEMxX0xPVyA9IEMxICYgTUFTS19MT1csIEMyX0xPVyA9IEMyICYgTUFTS19MT1c7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja0NvdW50czsgaSsrKSB7XG4gICAgICBpZiAoaSAmIDEpIHtcbiAgICAgICAgazEgPSBkYXRhVWludDMyW2ldO1xuICAgICAgICBrMSA9IGsxICogQzEgJiBNQVNLX0hJR0ggfCBrMSAqIEMxX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBrMSA9IGsxIDw8IDE1IHwgazEgPj4+IDE3O1xuICAgICAgICBrMSA9IGsxICogQzIgJiBNQVNLX0hJR0ggfCBrMSAqIEMyX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBoMSBePSBrMTtcbiAgICAgICAgaDEgPSBoMSA8PCAxMyB8IGgxID4+PiAxOTtcbiAgICAgICAgaDEgPSBoMSAqIDUgKyAzODY0MjkyMTk2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgazIgPSBkYXRhVWludDMyW2ldO1xuICAgICAgICBrMiA9IGsyICogQzEgJiBNQVNLX0hJR0ggfCBrMiAqIEMxX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBrMiA9IGsyIDw8IDE1IHwgazIgPj4+IDE3O1xuICAgICAgICBrMiA9IGsyICogQzIgJiBNQVNLX0hJR0ggfCBrMiAqIEMyX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBoMiBePSBrMjtcbiAgICAgICAgaDIgPSBoMiA8PCAxMyB8IGgyID4+PiAxOTtcbiAgICAgICAgaDIgPSBoMiAqIDUgKyAzODY0MjkyMTk2O1xuICAgICAgfVxuICAgIH1cbiAgICBrMSA9IDA7XG4gICAgc3dpdGNoICh0YWlsTGVuZ3RoKSB7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGsxIF49IGRhdGFbYmxvY2tDb3VudHMgKiA0ICsgMl0gPDwgMTY7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGsxIF49IGRhdGFbYmxvY2tDb3VudHMgKiA0ICsgMV0gPDwgODtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgazEgXj0gZGF0YVtibG9ja0NvdW50cyAqIDRdO1xuICAgICAgICBrMSA9IGsxICogQzEgJiBNQVNLX0hJR0ggfCBrMSAqIEMxX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBrMSA9IGsxIDw8IDE1IHwgazEgPj4+IDE3O1xuICAgICAgICBrMSA9IGsxICogQzIgJiBNQVNLX0hJR0ggfCBrMSAqIEMyX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBpZiAoYmxvY2tDb3VudHMgJiAxKSB7XG4gICAgICAgICAgaDEgXj0gazE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaDIgXj0gazE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5oMSA9IGgxO1xuICAgIHRoaXMuaDIgPSBoMjtcbiAgfVxuICBoZXhkaWdlc3QoKSB7XG4gICAgbGV0IGgxID0gdGhpcy5oMSwgaDIgPSB0aGlzLmgyO1xuICAgIGgxIF49IGgyID4+PiAxO1xuICAgIGgxID0gaDEgKiAzOTgxODA2Nzk3ICYgTUFTS19ISUdIIHwgaDEgKiAzNjA0NSAmIE1BU0tfTE9XO1xuICAgIGgyID0gaDIgKiA0MjgzNTQzNTExICYgTUFTS19ISUdIIHwgKChoMiA8PCAxNiB8IGgxID4+PiAxNikgKiAyOTUwMTYzNzk3ICYgTUFTS19ISUdIKSA+Pj4gMTY7XG4gICAgaDEgXj0gaDIgPj4+IDE7XG4gICAgaDEgPSBoMSAqIDQ0NDk4NDQwMyAmIE1BU0tfSElHSCB8IGgxICogNjA0OTkgJiBNQVNLX0xPVztcbiAgICBoMiA9IGgyICogMzMwMTg4MjM2NiAmIE1BU0tfSElHSCB8ICgoaDIgPDwgMTYgfCBoMSA+Pj4gMTYpICogMzEyMDQzNzg5MyAmIE1BU0tfSElHSCkgPj4+IDE2O1xuICAgIGgxIF49IGgyID4+PiAxO1xuICAgIHJldHVybiAoaDEgPj4+IDApLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg4LCBcIjBcIikgKyAoaDIgPj4+IDApLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg4LCBcIjBcIik7XG4gIH1cbn1cbmNvbnN0IFNlcmlhbGl6YWJsZUVtcHR5ID0gT2JqZWN0LmZyZWV6ZSh7XG4gIG1hcDogbnVsbCxcbiAgaGFzaDogXCJcIixcbiAgdHJhbnNmZXI6IHZvaWQgMFxufSk7XG5jbGFzcyBBbm5vdGF0aW9uU3RvcmFnZSB7XG4gICNtb2RpZmllZCA9IGZhbHNlO1xuICAjbW9kaWZpZWRJZHMgPSBudWxsO1xuICAjZWRpdG9yc01hcCA9IG51bGw7XG4gICNzdG9yYWdlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5vblNldE1vZGlmaWVkID0gbnVsbDtcbiAgICB0aGlzLm9uUmVzZXRNb2RpZmllZCA9IG51bGw7XG4gICAgdGhpcy5vbkFubm90YXRpb25FZGl0b3IgPSBudWxsO1xuICB9XG4gIGdldFZhbHVlKGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLiNzdG9yYWdlLmdldChrZXkpO1xuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihkZWZhdWx0VmFsdWUsIHZhbHVlKTtcbiAgfVxuICBnZXRSYXdWYWx1ZShrZXkpIHtcbiAgICByZXR1cm4gdGhpcy4jc3RvcmFnZS5nZXQoa2V5KTtcbiAgfVxuICByZW1vdmUoa2V5KSB7XG4gICAgY29uc3Qgc3RvcmVkVmFsdWUgPSB0aGlzLiNzdG9yYWdlLmdldChrZXkpO1xuICAgIGlmIChzdG9yZWRWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzdG9yZWRWYWx1ZSBpbnN0YW5jZW9mIEFubm90YXRpb25FZGl0b3IpIHtcbiAgICAgIHRoaXMuI2VkaXRvcnNNYXAuZGVsZXRlKHN0b3JlZFZhbHVlLmFubm90YXRpb25FbGVtZW50SWQpO1xuICAgIH1cbiAgICB0aGlzLiNzdG9yYWdlLmRlbGV0ZShrZXkpO1xuICAgIGlmICh0aGlzLiNzdG9yYWdlLnNpemUgPT09IDApIHtcbiAgICAgIHRoaXMucmVzZXRNb2RpZmllZCgpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXMub25Bbm5vdGF0aW9uRWRpdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGhpcy4jc3RvcmFnZS52YWx1ZXMoKSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBbm5vdGF0aW9uRWRpdG9yKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLm9uQW5ub3RhdGlvbkVkaXRvcihudWxsKTtcbiAgICB9XG4gIH1cbiAgc2V0VmFsdWUoa2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IG9iaiA9IHRoaXMuI3N0b3JhZ2UuZ2V0KGtleSk7XG4gICAgbGV0IG1vZGlmaWVkID0gZmFsc2U7XG4gICAgaWYgKG9iaiAhPT0gdm9pZCAwKSB7XG4gICAgICBmb3IgKGNvbnN0IFtlbnRyeSwgdmFsXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKG9ialtlbnRyeV0gIT09IHZhbCkge1xuICAgICAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICBvYmpbZW50cnldID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuI3N0b3JhZ2Uuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAobW9kaWZpZWQpIHtcbiAgICAgIHRoaXMuI3NldE1vZGlmaWVkKCk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFubm90YXRpb25FZGl0b3IpIHtcbiAgICAgICh0aGlzLiNlZGl0b3JzTWFwIHx8PSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKS5zZXQodmFsdWUuYW5ub3RhdGlvbkVsZW1lbnRJZCwgdmFsdWUpO1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9uQW5ub3RhdGlvbkVkaXRvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMub25Bbm5vdGF0aW9uRWRpdG9yKHZhbHVlLmNvbnN0cnVjdG9yLl90eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaGFzKGtleSkge1xuICAgIHJldHVybiB0aGlzLiNzdG9yYWdlLmhhcyhrZXkpO1xuICB9XG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLiNzdG9yYWdlLnNpemU7XG4gIH1cbiAgI3NldE1vZGlmaWVkKCkge1xuICAgIGlmICghdGhpcy4jbW9kaWZpZWQpIHtcbiAgICAgIHRoaXMuI21vZGlmaWVkID0gdHJ1ZTtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vblNldE1vZGlmaWVkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5vblNldE1vZGlmaWVkKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlc2V0TW9kaWZpZWQoKSB7XG4gICAgaWYgKHRoaXMuI21vZGlmaWVkKSB7XG4gICAgICB0aGlzLiNtb2RpZmllZCA9IGZhbHNlO1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9uUmVzZXRNb2RpZmllZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMub25SZXNldE1vZGlmaWVkKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBwcmludCgpIHtcbiAgICByZXR1cm4gbmV3IFByaW50QW5ub3RhdGlvblN0b3JhZ2UodGhpcyk7XG4gIH1cbiAgZ2V0IHNlcmlhbGl6YWJsZSgpIHtcbiAgICBpZiAodGhpcy4jc3RvcmFnZS5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gU2VyaWFsaXphYmxlRW1wdHk7XG4gICAgfVxuICAgIGNvbnN0IG1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIGhhc2ggPSBuZXcgTXVybXVySGFzaDNfNjQoKSwgdHJhbnNmZXIgPSBbXTtcbiAgICBjb25zdCBjb250ZXh0ID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IGhhc0JpdG1hcCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiB0aGlzLiNzdG9yYWdlKSB7XG4gICAgICBjb25zdCBzZXJpYWxpemVkID0gdmFsIGluc3RhbmNlb2YgQW5ub3RhdGlvbkVkaXRvciA/IHZhbC5zZXJpYWxpemUoZmFsc2UsIGNvbnRleHQpIDogdmFsO1xuICAgICAgaWYgKHNlcmlhbGl6ZWQpIHtcbiAgICAgICAgbWFwLnNldChrZXksIHNlcmlhbGl6ZWQpO1xuICAgICAgICBoYXNoLnVwZGF0ZShgJHtrZXl9OiR7SlNPTi5zdHJpbmdpZnkoc2VyaWFsaXplZCl9YCk7XG4gICAgICAgIGhhc0JpdG1hcCB8fD0gISFzZXJpYWxpemVkLmJpdG1hcDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhhc0JpdG1hcCkge1xuICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBtYXAudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKHZhbHVlLmJpdG1hcCkge1xuICAgICAgICAgIHRyYW5zZmVyLnB1c2godmFsdWUuYml0bWFwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFwLnNpemUgPiAwID8ge1xuICAgICAgbWFwLFxuICAgICAgaGFzaDogaGFzaC5oZXhkaWdlc3QoKSxcbiAgICAgIHRyYW5zZmVyXG4gICAgfSA6IFNlcmlhbGl6YWJsZUVtcHR5O1xuICB9XG4gIGdldCBlZGl0b3JTdGF0cygpIHtcbiAgICBsZXQgc3RhdHMgPSBudWxsO1xuICAgIGNvbnN0IHR5cGVUb0VkaXRvciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgbGV0IG51bWJlck9mRWRpdGVkQ29tbWVudHMgPSAwO1xuICAgIGxldCBudW1iZXJPZkRlbGV0ZWRDb21tZW50cyA9IDA7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB0aGlzLiNzdG9yYWdlLnZhbHVlcygpKSB7XG4gICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEFubm90YXRpb25FZGl0b3IpKSB7XG4gICAgICAgIGlmICh2YWx1ZS5wb3B1cCkge1xuICAgICAgICAgIGlmICh2YWx1ZS5wb3B1cC5kZWxldGVkKSB7XG4gICAgICAgICAgICBudW1iZXJPZkRlbGV0ZWRDb21tZW50cyArPSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBudW1iZXJPZkVkaXRlZENvbW1lbnRzICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlLmlzQ29tbWVudERlbGV0ZWQpIHtcbiAgICAgICAgbnVtYmVyT2ZEZWxldGVkQ29tbWVudHMgKz0gMTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUuaGFzRWRpdGVkQ29tbWVudCkge1xuICAgICAgICBudW1iZXJPZkVkaXRlZENvbW1lbnRzICs9IDE7XG4gICAgICB9XG4gICAgICBjb25zdCBlZGl0b3JTdGF0cyA9IHZhbHVlLnRlbGVtZXRyeUZpbmFsRGF0YTtcbiAgICAgIGlmICghZWRpdG9yU3RhdHMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIHR5cGVcbiAgICAgIH0gPSBlZGl0b3JTdGF0cztcbiAgICAgIGlmICghdHlwZVRvRWRpdG9yLmhhcyh0eXBlKSkge1xuICAgICAgICB0eXBlVG9FZGl0b3Iuc2V0KHR5cGUsIE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkuY29uc3RydWN0b3IpO1xuICAgICAgfVxuICAgICAgc3RhdHMgfHw9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgY29uc3QgbWFwID0gc3RhdHNbdHlwZV0gfHw9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXMoZWRpdG9yU3RhdHMpKSB7XG4gICAgICAgIGlmIChrZXkgPT09IFwidHlwZVwiKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvdW50ZXJzID0gbWFwLmdldChrZXkpO1xuICAgICAgICBpZiAoIWNvdW50ZXJzKSB7XG4gICAgICAgICAgY291bnRlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICAgIG1hcC5zZXQoa2V5LCBjb3VudGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY291bnQgPSBjb3VudGVycy5nZXQodmFsKSA/PyAwO1xuICAgICAgICBjb3VudGVycy5zZXQodmFsLCBjb3VudCArIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobnVtYmVyT2ZEZWxldGVkQ29tbWVudHMgPiAwIHx8IG51bWJlck9mRWRpdGVkQ29tbWVudHMgPiAwKSB7XG4gICAgICBzdGF0cyB8fD0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBzdGF0cy5jb21tZW50cyA9IHtcbiAgICAgICAgZGVsZXRlZDogbnVtYmVyT2ZEZWxldGVkQ29tbWVudHMsXG4gICAgICAgIGVkaXRlZDogbnVtYmVyT2ZFZGl0ZWRDb21tZW50c1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFzdGF0cykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW3R5cGUsIGVkaXRvcl0gb2YgdHlwZVRvRWRpdG9yKSB7XG4gICAgICBzdGF0c1t0eXBlXSA9IGVkaXRvci5jb21wdXRlVGVsZW1ldHJ5RmluYWxEYXRhKHN0YXRzW3R5cGVdKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRzO1xuICB9XG4gIHJlc2V0TW9kaWZpZWRJZHMoKSB7XG4gICAgdGhpcy4jbW9kaWZpZWRJZHMgPSBudWxsO1xuICB9XG4gIHVwZGF0ZUVkaXRvcihhbm5vdGF0aW9uSWQsIGRhdGEpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI2VkaXRvcnNNYXA/LmdldChhbm5vdGF0aW9uSWQpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdmFsdWUudXBkYXRlRnJvbUFubm90YXRpb25MYXllcihkYXRhKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZ2V0RWRpdG9yKGFubm90YXRpb25JZCkge1xuICAgIHJldHVybiB0aGlzLiNlZGl0b3JzTWFwPy5nZXQoYW5ub3RhdGlvbklkKSB8fCBudWxsO1xuICB9XG4gIGdldCBtb2RpZmllZElkcygpIHtcbiAgICBpZiAodGhpcy4jbW9kaWZpZWRJZHMpIHtcbiAgICAgIHJldHVybiB0aGlzLiNtb2RpZmllZElkcztcbiAgICB9XG4gICAgY29uc3QgaWRzID0gW107XG4gICAgaWYgKHRoaXMuI2VkaXRvcnNNYXApIHtcbiAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGhpcy4jZWRpdG9yc01hcC52YWx1ZXMoKSkge1xuICAgICAgICBpZiAoIXZhbHVlLnNlcmlhbGl6ZSgpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWRzLnB1c2godmFsdWUuYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNtb2RpZmllZElkcyA9IHtcbiAgICAgIGlkczogbmV3IFNldChpZHMpLFxuICAgICAgaGFzaDogaWRzLmpvaW4oXCIsXCIpXG4gICAgfTtcbiAgfVxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gdGhpcy4jc3RvcmFnZS5lbnRyaWVzKCk7XG4gIH1cbn1cbmNsYXNzIFByaW50QW5ub3RhdGlvblN0b3JhZ2UgZXh0ZW5kcyBBbm5vdGF0aW9uU3RvcmFnZSB7XG4gICNzZXJpYWxpemFibGU7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3Qge1xuICAgICAgbWFwLFxuICAgICAgaGFzaCxcbiAgICAgIHRyYW5zZmVyXG4gICAgfSA9IHBhcmVudC5zZXJpYWxpemFibGU7XG4gICAgY29uc3QgY2xvbmUgPSBzdHJ1Y3R1cmVkQ2xvbmUobWFwLCB0cmFuc2ZlciA/IHtcbiAgICAgIHRyYW5zZmVyXG4gICAgfSA6IG51bGwpO1xuICAgIHRoaXMuI3NlcmlhbGl6YWJsZSA9IHtcbiAgICAgIG1hcDogY2xvbmUsXG4gICAgICBoYXNoLFxuICAgICAgdHJhbnNmZXJcbiAgICB9O1xuICB9XG4gIGdldCBwcmludCgpIHtcbiAgICB1bnJlYWNoYWJsZShcIlNob3VsZCBub3QgY2FsbCBQcmludEFubm90YXRpb25TdG9yYWdlLnByaW50XCIpO1xuICB9XG4gIGdldCBzZXJpYWxpemFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NlcmlhbGl6YWJsZTtcbiAgfVxuICBnZXQgbW9kaWZpZWRJZHMoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIm1vZGlmaWVkSWRzXCIsIHtcbiAgICAgIGlkczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgICAgIGhhc2g6IFwiXCJcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgRm9udExvYWRlciB7XG4gICNzeXN0ZW1Gb250cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBvd25lckRvY3VtZW50ID0gZ2xvYmFsVGhpcy5kb2N1bWVudCxcbiAgICBzdHlsZUVsZW1lbnQgPSBudWxsXG4gIH0pIHtcbiAgICB0aGlzLl9kb2N1bWVudCA9IG93bmVyRG9jdW1lbnQ7XG4gICAgdGhpcy5uYXRpdmVGb250RmFjZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuc3R5bGVFbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLmxvYWRpbmdSZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMubG9hZFRlc3RGb250SWQgPSAwO1xuICB9XG4gIGFkZE5hdGl2ZUZvbnRGYWNlKG5hdGl2ZUZvbnRGYWNlKSB7XG4gICAgdGhpcy5uYXRpdmVGb250RmFjZXMuYWRkKG5hdGl2ZUZvbnRGYWNlKTtcbiAgICB0aGlzLl9kb2N1bWVudC5mb250cy5hZGQobmF0aXZlRm9udEZhY2UpO1xuICB9XG4gIHJlbW92ZU5hdGl2ZUZvbnRGYWNlKG5hdGl2ZUZvbnRGYWNlKSB7XG4gICAgdGhpcy5uYXRpdmVGb250RmFjZXMuZGVsZXRlKG5hdGl2ZUZvbnRGYWNlKTtcbiAgICB0aGlzLl9kb2N1bWVudC5mb250cy5kZWxldGUobmF0aXZlRm9udEZhY2UpO1xuICB9XG4gIGluc2VydFJ1bGUocnVsZSkge1xuICAgIGlmICghdGhpcy5zdHlsZUVsZW1lbnQpIHtcbiAgICAgIHRoaXMuc3R5bGVFbGVtZW50ID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgdGhpcy5fZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXS5hcHBlbmQodGhpcy5zdHlsZUVsZW1lbnQpO1xuICAgIH1cbiAgICBjb25zdCBzdHlsZVNoZWV0ID0gdGhpcy5zdHlsZUVsZW1lbnQuc2hlZXQ7XG4gICAgc3R5bGVTaGVldC5pbnNlcnRSdWxlKHJ1bGUsIHN0eWxlU2hlZXQuY3NzUnVsZXMubGVuZ3RoKTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICBmb3IgKGNvbnN0IG5hdGl2ZUZvbnRGYWNlIG9mIHRoaXMubmF0aXZlRm9udEZhY2VzKSB7XG4gICAgICB0aGlzLl9kb2N1bWVudC5mb250cy5kZWxldGUobmF0aXZlRm9udEZhY2UpO1xuICAgIH1cbiAgICB0aGlzLm5hdGl2ZUZvbnRGYWNlcy5jbGVhcigpO1xuICAgIHRoaXMuI3N5c3RlbUZvbnRzLmNsZWFyKCk7XG4gICAgaWYgKHRoaXMuc3R5bGVFbGVtZW50KSB7XG4gICAgICB0aGlzLnN0eWxlRWxlbWVudC5yZW1vdmUoKTtcbiAgICAgIHRoaXMuc3R5bGVFbGVtZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgYXN5bmMgbG9hZFN5c3RlbUZvbnQoe1xuICAgIHN5c3RlbUZvbnRJbmZvOiBpbmZvMixcbiAgICBkaXNhYmxlRm9udEZhY2UsXG4gICAgX2luc3BlY3RGb250XG4gIH0pIHtcbiAgICBpZiAoIWluZm8yIHx8IHRoaXMuI3N5c3RlbUZvbnRzLmhhcyhpbmZvMi5sb2FkZWROYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhc3NlcnQoIWRpc2FibGVGb250RmFjZSwgXCJsb2FkU3lzdGVtRm9udCBzaG91bGRuJ3QgYmUgY2FsbGVkIHdoZW4gYGRpc2FibGVGb250RmFjZWAgaXMgc2V0LlwiKTtcbiAgICBpZiAodGhpcy5pc0ZvbnRMb2FkaW5nQVBJU3VwcG9ydGVkKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxvYWRlZE5hbWUsXG4gICAgICAgIHNyYyxcbiAgICAgICAgc3R5bGVcbiAgICAgIH0gPSBpbmZvMjtcbiAgICAgIGNvbnN0IGZvbnRGYWNlID0gbmV3IEZvbnRGYWNlKGxvYWRlZE5hbWUsIHNyYywgc3R5bGUpO1xuICAgICAgdGhpcy5hZGROYXRpdmVGb250RmFjZShmb250RmFjZSk7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBmb250RmFjZS5sb2FkKCk7XG4gICAgICAgIHRoaXMuI3N5c3RlbUZvbnRzLmFkZChsb2FkZWROYW1lKTtcbiAgICAgICAgX2luc3BlY3RGb250Py4oaW5mbzIpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHdhcm4oYENhbm5vdCBsb2FkIHN5c3RlbSBmb250OiAke2luZm8yLmJhc2VGb250TmFtZX0sIGluc3RhbGxpbmcgaXQgY291bGQgaGVscCB0byBpbXByb3ZlIFBERiByZW5kZXJpbmcuYCk7XG4gICAgICAgIHRoaXMucmVtb3ZlTmF0aXZlRm9udEZhY2UoZm9udEZhY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB1bnJlYWNoYWJsZShcIk5vdCBpbXBsZW1lbnRlZDogbG9hZFN5c3RlbUZvbnQgd2l0aG91dCB0aGUgRm9udCBMb2FkaW5nIEFQSS5cIik7XG4gIH1cbiAgYXN5bmMgYmluZChmb250KSB7XG4gICAgaWYgKGZvbnQuYXR0YWNoZWQgfHwgZm9udC5taXNzaW5nRmlsZSAmJiAhZm9udC5zeXN0ZW1Gb250SW5mbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb250LmF0dGFjaGVkID0gdHJ1ZTtcbiAgICBpZiAoZm9udC5zeXN0ZW1Gb250SW5mbykge1xuICAgICAgYXdhaXQgdGhpcy5sb2FkU3lzdGVtRm9udChmb250KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNGb250TG9hZGluZ0FQSVN1cHBvcnRlZCkge1xuICAgICAgY29uc3QgbmF0aXZlRm9udEZhY2UgPSBmb250LmNyZWF0ZU5hdGl2ZUZvbnRGYWNlKCk7XG4gICAgICBpZiAobmF0aXZlRm9udEZhY2UpIHtcbiAgICAgICAgdGhpcy5hZGROYXRpdmVGb250RmFjZShuYXRpdmVGb250RmFjZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgbmF0aXZlRm9udEZhY2UubG9hZGVkO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIHdhcm4oYEZhaWxlZCB0byBsb2FkIGZvbnQgJyR7bmF0aXZlRm9udEZhY2UuZmFtaWx5fSc6ICcke2V4fScuYCk7XG4gICAgICAgICAgZm9udC5kaXNhYmxlRm9udEZhY2UgPSB0cnVlO1xuICAgICAgICAgIHRocm93IGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJ1bGUgPSBmb250LmNyZWF0ZUZvbnRGYWNlUnVsZSgpO1xuICAgIGlmIChydWxlKSB7XG4gICAgICB0aGlzLmluc2VydFJ1bGUocnVsZSk7XG4gICAgICBpZiAodGhpcy5pc1N5bmNGb250TG9hZGluZ1N1cHBvcnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5fcXVldWVMb2FkaW5nQ2FsbGJhY2socmVzb2x2ZSk7XG4gICAgICAgIHRoaXMuX3ByZXBhcmVGb250TG9hZEV2ZW50KGZvbnQsIHJlcXVlc3QpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldCBpc0ZvbnRMb2FkaW5nQVBJU3VwcG9ydGVkKCkge1xuICAgIGNvbnN0IGhhc0ZvbnRzID0gISF0aGlzLl9kb2N1bWVudD8uZm9udHM7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzRm9udExvYWRpbmdBUElTdXBwb3J0ZWRcIiwgaGFzRm9udHMpO1xuICB9XG4gIGdldCBpc1N5bmNGb250TG9hZGluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNTeW5jRm9udExvYWRpbmdTdXBwb3J0ZWRcIiwgaXNOb2RlSlMgfHwgdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybS5pc0ZpcmVmb3gpO1xuICB9XG4gIF9xdWV1ZUxvYWRpbmdDYWxsYmFjayhjYWxsYmFjaykge1xuICAgIGZ1bmN0aW9uIGNvbXBsZXRlUmVxdWVzdCgpIHtcbiAgICAgIGFzc2VydCghcmVxdWVzdC5kb25lLCBcImNvbXBsZXRlUmVxdWVzdCgpIGNhbm5vdCBiZSBjYWxsZWQgdHdpY2UuXCIpO1xuICAgICAgcmVxdWVzdC5kb25lID0gdHJ1ZTtcbiAgICAgIHdoaWxlIChsb2FkaW5nUmVxdWVzdHMubGVuZ3RoID4gMCAmJiBsb2FkaW5nUmVxdWVzdHNbMF0uZG9uZSkge1xuICAgICAgICBjb25zdCBvdGhlclJlcXVlc3QgPSBsb2FkaW5nUmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgICAgc2V0VGltZW91dChvdGhlclJlcXVlc3QuY2FsbGJhY2ssIDApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBsb2FkaW5nUmVxdWVzdHNcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgZG9uZTogZmFsc2UsXG4gICAgICBjb21wbGV0ZTogY29tcGxldGVSZXF1ZXN0LFxuICAgICAgY2FsbGJhY2tcbiAgICB9O1xuICAgIGxvYWRpbmdSZXF1ZXN0cy5wdXNoKHJlcXVlc3QpO1xuICAgIHJldHVybiByZXF1ZXN0O1xuICB9XG4gIGdldCBfbG9hZFRlc3RGb250KCkge1xuICAgIGNvbnN0IHRlc3RGb250ID0gYXRvYihcIlQxUlVUd0FMQUlBQUF3QXdRMFpHSURIdFpnNEFBQU9ZQUFBQWdVWkdWRTFsa3pad0FBQUVIQUFBQUJ4SFJFVkdBQlFBRlFBQUJEZ0FBQUFlVDFNdk1sWU5Zd2tBQUFFZ0FBQUFZR050WVhBQkRRTFVBQUFDTkFBQUFVSm9aV0ZrL3hWRkRRQUFBTHdBQUFBMmFHaGxZUWRrQStvQUFBRDBBQUFBSkdodGRIZ0Q2QUFBQUFBRVdBQUFBQVp0WVhod0FBSlFBQUFBQVJnQUFBQUdibUZ0WlZqbWRINEFBQUdBQUFBQXNYQnZjM1QvaGdBekFBQURlQUFBQUNBQUFRQUFBQUVBQUxaUkZzUmZEenoxQUFzRDZBQUFBQURPQk9UTEFBQUFBTTRLSER3QUFBQUFBK2dESVFBQUFBZ0FBZ0FBQUFBQUFBQUJBQUFESVFBQUFGb0Q2QUFBQUFBRDZBQUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFRQUFVQUFBQWdBQUFBUUQ2QUgwQUFVQUFBS0tBcndBQUFDTUFvb0N2QUFBQWVBQU1RRUNBQUFDQUFZSkFBQUFBQUFBQUFBQUFRQUFBQUFBQUFBQUFBQUFBRkJtUldRQXdBQXVBQzRESVA4NEFGb0RJUUFBQUFBQUFRQUFBQUFBQUFBQUFDQUFJQUFCQUFBQURnQ3VBQUVBQUFBQUFBQUFBUUFBQUFFQUFBQUFBQUVBQVFBQUFBRUFBQUFBQUFJQUFRQUFBQUVBQUFBQUFBTUFBUUFBQUFFQUFBQUFBQVFBQVFBQUFBRUFBQUFBQUFVQUFRQUFBQUVBQUFBQUFBWUFBUUFBQUFNQUFRUUpBQUFBQWdBQkFBTUFBUVFKQUFFQUFnQUJBQU1BQVFRSkFBSUFBZ0FCQUFNQUFRUUpBQU1BQWdBQkFBTUFBUVFKQUFRQUFnQUJBQU1BQVFRSkFBVUFBZ0FCQUFNQUFRUUpBQVlBQWdBQldBQllBQUFBQUFBQUF3QUFBQU1BQUFBY0FBRUFBQUFBQUR3QUF3QUJBQUFBSEFBRUFDQUFBQUFFQUFRQUFRQUFBQzcvL3dBQUFDNy8vLy9UQUFFQUFBQUFBQUFCQmdBQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFNQUFBQUFBQUQvZ3dBeUFBQUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJBQVFFQUFFQkFRSllBQUVCQVNINER3RDRHd0hFQXZnY0EvZ1hCSXdNQVl1TCtuejV0UVhrRDVqM0NCTG5FUUFDQVFFQklWaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZQUFBQkFRQUFEd0FDQVFFRUUvdDNEb3Y2ZkFINmZBVCtmUHA4K253SERvc01Ddm0xQ3ZtMURBejZmQlFBQUFBQUFBQUJBQUFBQU1tSmJ6RUFBQUFBemdUakZRQUFBQURPQk9RcEFBRUFBQUFBQUFBQURBQVVBQVFBQUFBQkFBQUFBZ0FCQUFBQUFBQUFBQUFENkFBQUFBQUFBQT09XCIpO1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfbG9hZFRlc3RGb250XCIsIHRlc3RGb250KTtcbiAgfVxuICBfcHJlcGFyZUZvbnRMb2FkRXZlbnQoZm9udCwgcmVxdWVzdCkge1xuICAgIGZ1bmN0aW9uIGludDMyKGRhdGEyLCBvZmZzZXQpIHtcbiAgICAgIHJldHVybiBkYXRhMi5jaGFyQ29kZUF0KG9mZnNldCkgPDwgMjQgfCBkYXRhMi5jaGFyQ29kZUF0KG9mZnNldCArIDEpIDw8IDE2IHwgZGF0YTIuY2hhckNvZGVBdChvZmZzZXQgKyAyKSA8PCA4IHwgZGF0YTIuY2hhckNvZGVBdChvZmZzZXQgKyAzKSAmIDI1NTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3BsaWNlU3RyaW5nKHMsIG9mZnNldCwgcmVtb3ZlLCBpbnNlcnQpIHtcbiAgICAgIGNvbnN0IGNodW5rMSA9IHMuc3Vic3RyaW5nKDAsIG9mZnNldCk7XG4gICAgICBjb25zdCBjaHVuazIgPSBzLnN1YnN0cmluZyhvZmZzZXQgKyByZW1vdmUpO1xuICAgICAgcmV0dXJuIGNodW5rMSArIGluc2VydCArIGNodW5rMjtcbiAgICB9XG4gICAgbGV0IGksIGlpO1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudmFzLndpZHRoID0gMTtcbiAgICBjYW52YXMuaGVpZ2h0ID0gMTtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGxldCBjYWxsZWQgPSAwO1xuICAgIGZ1bmN0aW9uIGlzRm9udFJlYWR5KG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoKytjYWxsZWQgPiAzMCkge1xuICAgICAgICB3YXJuKFwiTG9hZCB0ZXN0IGZvbnQgbmV2ZXIgbG9hZGVkLlwiKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3R4LmZvbnQgPSBcIjMwcHggXCIgKyBuYW1lO1xuICAgICAgY3R4LmZpbGxUZXh0KFwiLlwiLCAwLCAyMCk7XG4gICAgICBjb25zdCBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpO1xuICAgICAgaWYgKGltYWdlRGF0YS5kYXRhWzNdID4gMCkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KGlzRm9udFJlYWR5LmJpbmQobnVsbCwgbmFtZSwgY2FsbGJhY2spKTtcbiAgICB9XG4gICAgY29uc3QgbG9hZFRlc3RGb250SWQgPSBgbHQke0RhdGUubm93KCl9JHt0aGlzLmxvYWRUZXN0Rm9udElkKyt9YDtcbiAgICBsZXQgZGF0YSA9IHRoaXMuX2xvYWRUZXN0Rm9udDtcbiAgICBjb25zdCBDT01NRU5UX09GRlNFVCA9IDk3NjtcbiAgICBkYXRhID0gc3BsaWNlU3RyaW5nKGRhdGEsIENPTU1FTlRfT0ZGU0VULCBsb2FkVGVzdEZvbnRJZC5sZW5ndGgsIGxvYWRUZXN0Rm9udElkKTtcbiAgICBjb25zdCBDRkZfQ0hFQ0tTVU1fT0ZGU0VUID0gMTY7XG4gICAgY29uc3QgWFhYWF9WQUxVRSA9IDE0ODIxODQ3OTI7XG4gICAgbGV0IGNoZWNrc3VtID0gaW50MzIoZGF0YSwgQ0ZGX0NIRUNLU1VNX09GRlNFVCk7XG4gICAgZm9yIChpID0gMCwgaWkgPSBsb2FkVGVzdEZvbnRJZC5sZW5ndGggLSAzOyBpIDwgaWk7IGkgKz0gNCkge1xuICAgICAgY2hlY2tzdW0gPSBjaGVja3N1bSAtIFhYWFhfVkFMVUUgKyBpbnQzMihsb2FkVGVzdEZvbnRJZCwgaSkgfCAwO1xuICAgIH1cbiAgICBpZiAoaSA8IGxvYWRUZXN0Rm9udElkLmxlbmd0aCkge1xuICAgICAgY2hlY2tzdW0gPSBjaGVja3N1bSAtIFhYWFhfVkFMVUUgKyBpbnQzMihsb2FkVGVzdEZvbnRJZCArIFwiWFhYXCIsIGkpIHwgMDtcbiAgICB9XG4gICAgZGF0YSA9IHNwbGljZVN0cmluZyhkYXRhLCBDRkZfQ0hFQ0tTVU1fT0ZGU0VULCA0LCBzdHJpbmczMihjaGVja3N1bSkpO1xuICAgIGNvbnN0IHVybCA9IGB1cmwoZGF0YTpmb250L29wZW50eXBlO2Jhc2U2NCwke2J0b2EoZGF0YSl9KTtgO1xuICAgIGNvbnN0IHJ1bGUgPSBgQGZvbnQtZmFjZSB7Zm9udC1mYW1pbHk6XCIke2xvYWRUZXN0Rm9udElkfVwiO3NyYzoke3VybH19YDtcbiAgICB0aGlzLmluc2VydFJ1bGUocnVsZSk7XG4gICAgY29uc3QgZGl2ID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkaXYuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgZGl2LnN0eWxlLndpZHRoID0gZGl2LnN0eWxlLmhlaWdodCA9IFwiMTBweFwiO1xuICAgIGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICBkaXYuc3R5bGUudG9wID0gZGl2LnN0eWxlLmxlZnQgPSBcIjBweFwiO1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBbZm9udC5sb2FkZWROYW1lLCBsb2FkVGVzdEZvbnRJZF0pIHtcbiAgICAgIGNvbnN0IHNwYW4gPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIHNwYW4udGV4dENvbnRlbnQgPSBcIkhpXCI7XG4gICAgICBzcGFuLnN0eWxlLmZvbnRGYW1pbHkgPSBuYW1lO1xuICAgICAgZGl2LmFwcGVuZChzcGFuKTtcbiAgICB9XG4gICAgdGhpcy5fZG9jdW1lbnQuYm9keS5hcHBlbmQoZGl2KTtcbiAgICBpc0ZvbnRSZWFkeShsb2FkVGVzdEZvbnRJZCwgKCkgPT4ge1xuICAgICAgZGl2LnJlbW92ZSgpO1xuICAgICAgcmVxdWVzdC5jb21wbGV0ZSgpO1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBGb250RmFjZU9iamVjdCB7XG4gICNmb250RGF0YTtcbiAgY29uc3RydWN0b3IodHJhbnNsYXRlZERhdGEsIGluc3BlY3RGb250ID0gbnVsbCwgZXh0cmEsIGNoYXJQcm9jT3BlcmF0b3JMaXN0KSB7XG4gICAgdGhpcy5jb21waWxlZEdseXBocyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuI2ZvbnREYXRhID0gdHJhbnNsYXRlZERhdGE7XG4gICAgdGhpcy5faW5zcGVjdEZvbnQgPSBpbnNwZWN0Rm9udDtcbiAgICBpZiAoZXh0cmEpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgZXh0cmEpO1xuICAgIH1cbiAgICBpZiAoY2hhclByb2NPcGVyYXRvckxpc3QpIHtcbiAgICAgIHRoaXMuY2hhclByb2NPcGVyYXRvckxpc3QgPSBjaGFyUHJvY09wZXJhdG9yTGlzdDtcbiAgICB9XG4gIH1cbiAgY3JlYXRlTmF0aXZlRm9udEZhY2UoKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEgfHwgdGhpcy5kaXNhYmxlRm9udEZhY2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgbmF0aXZlRm9udEZhY2U7XG4gICAgaWYgKCF0aGlzLmNzc0ZvbnRJbmZvKSB7XG4gICAgICBuYXRpdmVGb250RmFjZSA9IG5ldyBGb250RmFjZSh0aGlzLmxvYWRlZE5hbWUsIHRoaXMuZGF0YSwge30pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjc3MgPSB7XG4gICAgICAgIHdlaWdodDogdGhpcy5jc3NGb250SW5mby5mb250V2VpZ2h0XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuY3NzRm9udEluZm8uaXRhbGljQW5nbGUpIHtcbiAgICAgICAgY3NzLnN0eWxlID0gYG9ibGlxdWUgJHt0aGlzLmNzc0ZvbnRJbmZvLml0YWxpY0FuZ2xlfWRlZ2A7XG4gICAgICB9XG4gICAgICBuYXRpdmVGb250RmFjZSA9IG5ldyBGb250RmFjZSh0aGlzLmNzc0ZvbnRJbmZvLmZvbnRGYW1pbHksIHRoaXMuZGF0YSwgY3NzKTtcbiAgICB9XG4gICAgdGhpcy5faW5zcGVjdEZvbnQ/Lih0aGlzKTtcbiAgICByZXR1cm4gbmF0aXZlRm9udEZhY2U7XG4gIH1cbiAgY3JlYXRlRm9udEZhY2VSdWxlKCkge1xuICAgIGlmICghdGhpcy5kYXRhIHx8IHRoaXMuZGlzYWJsZUZvbnRGYWNlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gYHVybChkYXRhOiR7dGhpcy5taW1ldHlwZX07YmFzZTY0LCR7dG9CYXNlNjRVdGlsKHRoaXMuZGF0YSl9KTtgO1xuICAgIGxldCBydWxlO1xuICAgIGlmICghdGhpcy5jc3NGb250SW5mbykge1xuICAgICAgcnVsZSA9IGBAZm9udC1mYWNlIHtmb250LWZhbWlseTpcIiR7dGhpcy5sb2FkZWROYW1lfVwiO3NyYzoke3VybH19YDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGNzcyA9IGBmb250LXdlaWdodDogJHt0aGlzLmNzc0ZvbnRJbmZvLmZvbnRXZWlnaHR9O2A7XG4gICAgICBpZiAodGhpcy5jc3NGb250SW5mby5pdGFsaWNBbmdsZSkge1xuICAgICAgICBjc3MgKz0gYGZvbnQtc3R5bGU6IG9ibGlxdWUgJHt0aGlzLmNzc0ZvbnRJbmZvLml0YWxpY0FuZ2xlfWRlZztgO1xuICAgICAgfVxuICAgICAgcnVsZSA9IGBAZm9udC1mYWNlIHtmb250LWZhbWlseTpcIiR7dGhpcy5jc3NGb250SW5mby5mb250RmFtaWx5fVwiOyR7Y3NzfXNyYzoke3VybH19YDtcbiAgICB9XG4gICAgdGhpcy5faW5zcGVjdEZvbnQ/Lih0aGlzLCB1cmwpO1xuICAgIHJldHVybiBydWxlO1xuICB9XG4gIGdldFBhdGhHZW5lcmF0b3Iob2JqcywgY2hhcmFjdGVyKSB7XG4gICAgaWYgKHRoaXMuY29tcGlsZWRHbHlwaHNbY2hhcmFjdGVyXSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21waWxlZEdseXBoc1tjaGFyYWN0ZXJdO1xuICAgIH1cbiAgICBjb25zdCBvYmpJZCA9IHRoaXMubG9hZGVkTmFtZSArIFwiX3BhdGhfXCIgKyBjaGFyYWN0ZXI7XG4gICAgbGV0IGNtZHM7XG4gICAgdHJ5IHtcbiAgICAgIGNtZHMgPSBvYmpzLmdldChvYmpJZCk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHdhcm4oYGdldFBhdGhHZW5lcmF0b3IgLSBpZ25vcmluZyBjaGFyYWN0ZXI6IFwiJHtleH1cIi5gKTtcbiAgICB9XG4gICAgY29uc3QgcGF0aCA9IG5ldyBQYXRoMkQoY21kcyB8fCBcIlwiKTtcbiAgICBpZiAoIXRoaXMuZm9udEV4dHJhUHJvcGVydGllcykge1xuICAgICAgb2Jqcy5kZWxldGUob2JqSWQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb21waWxlZEdseXBoc1tjaGFyYWN0ZXJdID0gcGF0aDtcbiAgfVxuICBnZXQgYmxhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ZvbnREYXRhLmJsYWNrO1xuICB9XG4gIGdldCBib2xkKCkge1xuICAgIHJldHVybiB0aGlzLiNmb250RGF0YS5ib2xkO1xuICB9XG4gIGdldCBkaXNhYmxlRm9udEZhY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ZvbnREYXRhLmRpc2FibGVGb250RmFjZSA/PyBmYWxzZTtcbiAgfVxuICBnZXQgZm9udEV4dHJhUHJvcGVydGllcygpIHtcbiAgICByZXR1cm4gdGhpcy4jZm9udERhdGEuZm9udEV4dHJhUHJvcGVydGllcyA/PyBmYWxzZTtcbiAgfVxuICBnZXQgaXNJbnZhbGlkUERGanNGb250KCkge1xuICAgIHJldHVybiB0aGlzLiNmb250RGF0YS5pc0ludmFsaWRQREZqc0ZvbnQ7XG4gIH1cbiAgZ2V0IGlzVHlwZTNGb250KCkge1xuICAgIHJldHVybiB0aGlzLiNmb250RGF0YS5pc1R5cGUzRm9udDtcbiAgfVxuICBnZXQgaXRhbGljKCkge1xuICAgIHJldHVybiB0aGlzLiNmb250RGF0YS5pdGFsaWM7XG4gIH1cbiAgZ2V0IG1pc3NpbmdGaWxlKCkge1xuICAgIHJldHVybiB0aGlzLiNmb250RGF0YS5taXNzaW5nRmlsZTtcbiAgfVxuICBnZXQgcmVtZWFzdXJlKCkge1xuICAgIHJldHVybiB0aGlzLiNmb250RGF0YS5yZW1lYXN1cmU7XG4gIH1cbiAgZ2V0IHZlcnRpY2FsKCkge1xuICAgIHJldHVybiB0aGlzLiNmb250RGF0YS52ZXJ0aWNhbDtcbiAgfVxuICBnZXQgYXNjZW50KCkge1xuICAgIHJldHVybiB0aGlzLiNmb250RGF0YS5hc2NlbnQ7XG4gIH1cbiAgZ2V0IGRlZmF1bHRXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy4jZm9udERhdGEuZGVmYXVsdFdpZHRoO1xuICB9XG4gIGdldCBkZXNjZW50KCkge1xuICAgIHJldHVybiB0aGlzLiNmb250RGF0YS5kZXNjZW50O1xuICB9XG4gIGdldCBiYm94KCkge1xuICAgIHJldHVybiB0aGlzLiNmb250RGF0YS5iYm94O1xuICB9XG4gIGdldCBmb250TWF0cml4KCkge1xuICAgIHJldHVybiB0aGlzLiNmb250RGF0YS5mb250TWF0cml4O1xuICB9XG4gIGdldCBmYWxsYmFja05hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ZvbnREYXRhLmZhbGxiYWNrTmFtZTtcbiAgfVxuICBnZXQgbG9hZGVkTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jZm9udERhdGEubG9hZGVkTmFtZTtcbiAgfVxuICBnZXQgbWltZXR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ZvbnREYXRhLm1pbWV0eXBlO1xuICB9XG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLiNmb250RGF0YS5uYW1lO1xuICB9XG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLiNmb250RGF0YS5kYXRhO1xuICB9XG4gIGNsZWFyRGF0YSgpIHtcbiAgICB0aGlzLiNmb250RGF0YS5jbGVhckRhdGEoKTtcbiAgfVxuICBnZXQgY3NzRm9udEluZm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ZvbnREYXRhLmNzc0ZvbnRJbmZvO1xuICB9XG4gIGdldCBzeXN0ZW1Gb250SW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy4jZm9udERhdGEuc3lzdGVtRm9udEluZm87XG4gIH1cbiAgZ2V0IGRlZmF1bHRWTWV0cmljcygpIHtcbiAgICByZXR1cm4gdGhpcy4jZm9udERhdGEuZGVmYXVsdFZNZXRyaWNzO1xuICB9XG59XG5mdW5jdGlvbiBnZXRVcmxQcm9wKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgcmV0dXJuIHZhbC5ocmVmO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKGlzTm9kZUpTKSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBVUkwucGFyc2UodmFsLCB3aW5kb3cubG9jYXRpb24pO1xuICAgIGlmICh1cmwpIHtcbiAgICAgIHJldHVybiB1cmwuaHJlZjtcbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBQREYgdXJsIGRhdGE6IGVpdGhlciBzdHJpbmcgb3IgVVJMLW9iamVjdCBpcyBleHBlY3RlZCBpbiB0aGUgdXJsIHByb3BlcnR5LlwiKTtcbn1cbmZ1bmN0aW9uIGdldERhdGFQcm9wKHZhbCkge1xuICBpZiAoaXNOb2RlSlMgJiYgdHlwZW9mIEJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiB2YWwgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSBiaW5hcnkgZGF0YSBhcyBgVWludDhBcnJheWAsIHJhdGhlciB0aGFuIGBCdWZmZXJgLlwiKTtcbiAgfVxuICBpZiAodmFsIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiB2YWwuYnl0ZUxlbmd0aCA9PT0gdmFsLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBzdHJpbmdUb0J5dGVzKHZhbCk7XG4gIH1cbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyh2YWwpIHx8IHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIgJiYgIWlzTmFOKHZhbD8ubGVuZ3RoKSkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheSh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgUERGIGJpbmFyeSBkYXRhOiBlaXRoZXIgVHlwZWRBcnJheSwgc3RyaW5nLCBvciBhcnJheS1saWtlIG9iamVjdCBpcyBleHBlY3RlZCBpbiB0aGUgZGF0YSBwcm9wZXJ0eS5cIik7XG59XG5mdW5jdGlvbiBnZXRGYWN0b3J5VXJsUHJvcCh2YWwpIHtcbiAgaWYgKHR5cGVvZiB2YWwgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAodmFsLmVuZHNXaXRoKFwiL1wiKSkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZhY3RvcnkgdXJsOiBcIiR7dmFsfVwiIG11c3QgaW5jbHVkZSB0cmFpbGluZyBzbGFzaC5gKTtcbn1cbmNvbnN0IGlzUmVmUHJveHkgPSAodikgPT4gdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgTnVtYmVyLmlzSW50ZWdlcih2Py5udW0pICYmIHYubnVtID49IDAgJiYgTnVtYmVyLmlzSW50ZWdlcih2Py5nZW4pICYmIHYuZ2VuID49IDA7XG5jb25zdCBpc05hbWVQcm94eSA9ICh2KSA9PiB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygdj8ubmFtZSA9PT0gXCJzdHJpbmdcIjtcbmNvbnN0IGlzVmFsaWRFeHBsaWNpdERlc3QgPSBfaXNWYWxpZEV4cGxpY2l0RGVzdC5iaW5kKG51bGwsIGlzUmVmUHJveHksIGlzTmFtZVByb3h5KTtcbmNsYXNzIExvb3BiYWNrUG9ydCB7XG4gICNsaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAjZGVmZXJyZWQgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgcG9zdE1lc3NhZ2Uob2JqLCB0cmFuc2Zlcikge1xuICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgZGF0YTogc3RydWN0dXJlZENsb25lKG9iaiwgdHJhbnNmZXIgPyB7XG4gICAgICAgIHRyYW5zZmVyXG4gICAgICB9IDogbnVsbClcbiAgICB9O1xuICAgIHRoaXMuI2RlZmVycmVkLnRoZW4oKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBbbGlzdGVuZXJdIG9mIHRoaXMuI2xpc3RlbmVycykge1xuICAgICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhZGRFdmVudExpc3RlbmVyKG5hbWUsIGxpc3RlbmVyLCBvcHRpb25zID0gbnVsbCkge1xuICAgIGxldCBybUFib3J0ID0gbnVsbDtcbiAgICBpZiAob3B0aW9ucz8uc2lnbmFsIGluc3RhbmNlb2YgQWJvcnRTaWduYWwpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICB3YXJuKFwiTG9vcGJhY2tQb3J0IC0gY2Fubm90IHVzZSBhbiBgYWJvcnRlZGAgc2lnbmFsLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgb25BYm9ydCA9ICgpID0+IHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBsaXN0ZW5lcik7XG4gICAgICBybUFib3J0ID0gKCkgPT4gc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcbiAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25BYm9ydCk7XG4gICAgfVxuICAgIHRoaXMuI2xpc3RlbmVycy5zZXQobGlzdGVuZXIsIHJtQWJvcnQpO1xuICB9XG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgbGlzdGVuZXIpIHtcbiAgICBjb25zdCBybUFib3J0ID0gdGhpcy4jbGlzdGVuZXJzLmdldChsaXN0ZW5lcik7XG4gICAgcm1BYm9ydD8uKCk7XG4gICAgdGhpcy4jbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gIH1cbiAgdGVybWluYXRlKCkge1xuICAgIGZvciAoY29uc3QgWywgcm1BYm9ydF0gb2YgdGhpcy4jbGlzdGVuZXJzKSB7XG4gICAgICBybUFib3J0Py4oKTtcbiAgICB9XG4gICAgdGhpcy4jbGlzdGVuZXJzLmNsZWFyKCk7XG4gIH1cbn1cbmNvbnN0IENhbGxiYWNrS2luZCA9IHtcbiAgREFUQTogMSxcbiAgRVJST1I6IDJcbn07XG5jb25zdCBTdHJlYW1LaW5kID0ge1xuICBDQU5DRUw6IDEsXG4gIENBTkNFTF9DT01QTEVURTogMixcbiAgQ0xPU0U6IDMsXG4gIEVOUVVFVUU6IDQsXG4gIEVSUk9SOiA1LFxuICBQVUxMOiA2LFxuICBQVUxMX0NPTVBMRVRFOiA3LFxuICBTVEFSVF9DT01QTEVURTogOFxufTtcbmZ1bmN0aW9uIG9uRm4oKSB7XG59XG5mdW5jdGlvbiB3cmFwUmVhc29uKGV4KSB7XG4gIGlmIChleCBpbnN0YW5jZW9mIEFib3J0RXhjZXB0aW9uIHx8IGV4IGluc3RhbmNlb2YgSW52YWxpZFBERkV4Y2VwdGlvbiB8fCBleCBpbnN0YW5jZW9mIFBhc3N3b3JkRXhjZXB0aW9uIHx8IGV4IGluc3RhbmNlb2YgUmVzcG9uc2VFeGNlcHRpb24gfHwgZXggaW5zdGFuY2VvZiBVbmtub3duRXJyb3JFeGNlcHRpb24pIHtcbiAgICByZXR1cm4gZXg7XG4gIH1cbiAgaWYgKCEoZXggaW5zdGFuY2VvZiBFcnJvciB8fCB0eXBlb2YgZXggPT09IFwib2JqZWN0XCIgJiYgZXggIT09IG51bGwpKSB7XG4gICAgdW5yZWFjaGFibGUoJ3dyYXBSZWFzb246IEV4cGVjdGVkIFwicmVhc29uXCIgdG8gYmUgYSAocG9zc2libHkgY2xvbmVkKSBFcnJvci4nKTtcbiAgfVxuICBzd2l0Y2ggKGV4Lm5hbWUpIHtcbiAgICBjYXNlIFwiQWJvcnRFeGNlcHRpb25cIjpcbiAgICAgIHJldHVybiBuZXcgQWJvcnRFeGNlcHRpb24oZXgubWVzc2FnZSk7XG4gICAgY2FzZSBcIkludmFsaWRQREZFeGNlcHRpb25cIjpcbiAgICAgIHJldHVybiBuZXcgSW52YWxpZFBERkV4Y2VwdGlvbihleC5tZXNzYWdlKTtcbiAgICBjYXNlIFwiUGFzc3dvcmRFeGNlcHRpb25cIjpcbiAgICAgIHJldHVybiBuZXcgUGFzc3dvcmRFeGNlcHRpb24oZXgubWVzc2FnZSwgZXguY29kZSk7XG4gICAgY2FzZSBcIlJlc3BvbnNlRXhjZXB0aW9uXCI6XG4gICAgICByZXR1cm4gbmV3IFJlc3BvbnNlRXhjZXB0aW9uKGV4Lm1lc3NhZ2UsIGV4LnN0YXR1cywgZXgubWlzc2luZyk7XG4gICAgY2FzZSBcIlVua25vd25FcnJvckV4Y2VwdGlvblwiOlxuICAgICAgcmV0dXJuIG5ldyBVbmtub3duRXJyb3JFeGNlcHRpb24oZXgubWVzc2FnZSwgZXguZGV0YWlscyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBVbmtub3duRXJyb3JFeGNlcHRpb24oZXgubWVzc2FnZSwgZXgudG9TdHJpbmcoKSk7XG59XG5jbGFzcyBNZXNzYWdlSGFuZGxlciB7XG4gICNtZXNzYWdlQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZU5hbWUsIHRhcmdldE5hbWUsIGNvbU9iaikge1xuICAgIHRoaXMuc291cmNlTmFtZSA9IHNvdXJjZU5hbWU7XG4gICAgdGhpcy50YXJnZXROYW1lID0gdGFyZ2V0TmFtZTtcbiAgICB0aGlzLmNvbU9iaiA9IGNvbU9iajtcbiAgICB0aGlzLmNhbGxiYWNrSWQgPSAxO1xuICAgIHRoaXMuc3RyZWFtSWQgPSAxO1xuICAgIHRoaXMuc3RyZWFtU2lua3MgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5jYWxsYmFja0NhcGFiaWxpdGllcyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuYWN0aW9uSGFuZGxlciA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGNvbU9iai5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzLiNvbk1lc3NhZ2UuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsOiB0aGlzLiNtZXNzYWdlQUMuc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgI29uTWVzc2FnZSh7XG4gICAgZGF0YVxuICB9KSB7XG4gICAgaWYgKGRhdGEudGFyZ2V0TmFtZSAhPT0gdGhpcy5zb3VyY2VOYW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkYXRhLnN0cmVhbSkge1xuICAgICAgdGhpcy4jcHJvY2Vzc1N0cmVhbU1lc3NhZ2UoZGF0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkYXRhLmNhbGxiYWNrKSB7XG4gICAgICBjb25zdCBjYWxsYmFja0lkID0gZGF0YS5jYWxsYmFja0lkO1xuICAgICAgY29uc3QgY2FwYWJpbGl0eSA9IHRoaXMuY2FsbGJhY2tDYXBhYmlsaXRpZXNbY2FsbGJhY2tJZF07XG4gICAgICBpZiAoIWNhcGFiaWxpdHkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVzb2x2ZSBjYWxsYmFjayAke2NhbGxiYWNrSWR9YCk7XG4gICAgICB9XG4gICAgICBkZWxldGUgdGhpcy5jYWxsYmFja0NhcGFiaWxpdGllc1tjYWxsYmFja0lkXTtcbiAgICAgIGlmIChkYXRhLmNhbGxiYWNrID09PSBDYWxsYmFja0tpbmQuREFUQSkge1xuICAgICAgICBjYXBhYmlsaXR5LnJlc29sdmUoZGF0YS5kYXRhKTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YS5jYWxsYmFjayA9PT0gQ2FsbGJhY2tLaW5kLkVSUk9SKSB7XG4gICAgICAgIGNhcGFiaWxpdHkucmVqZWN0KHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgY2FsbGJhY2sgY2FzZVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYWN0aW9uID0gdGhpcy5hY3Rpb25IYW5kbGVyW2RhdGEuYWN0aW9uXTtcbiAgICBpZiAoIWFjdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGFjdGlvbiBmcm9tIHdvcmtlcjogJHtkYXRhLmFjdGlvbn1gKTtcbiAgICB9XG4gICAgaWYgKGRhdGEuY2FsbGJhY2tJZCkge1xuICAgICAgY29uc3Qgc291cmNlTmFtZSA9IHRoaXMuc291cmNlTmFtZSwgdGFyZ2V0TmFtZSA9IGRhdGEuc291cmNlTmFtZSwgY29tT2JqID0gdGhpcy5jb21PYmo7XG4gICAgICBQcm9taXNlLnRyeShhY3Rpb24sIGRhdGEuZGF0YSkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgY2FsbGJhY2s6IENhbGxiYWNrS2luZC5EQVRBLFxuICAgICAgICAgIGNhbGxiYWNrSWQ6IGRhdGEuY2FsbGJhY2tJZCxcbiAgICAgICAgICBkYXRhOiByZXN1bHRcbiAgICAgICAgfSk7XG4gICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgY2FsbGJhY2s6IENhbGxiYWNrS2luZC5FUlJPUixcbiAgICAgICAgICBjYWxsYmFja0lkOiBkYXRhLmNhbGxiYWNrSWQsXG4gICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRhdGEuc3RyZWFtSWQpIHtcbiAgICAgIHRoaXMuI2NyZWF0ZVN0cmVhbVNpbmsoZGF0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFjdGlvbihkYXRhLmRhdGEpO1xuICB9XG4gIG9uKGFjdGlvbk5hbWUsIGhhbmRsZXIpIHtcbiAgICBjb25zdCBhaCA9IHRoaXMuYWN0aW9uSGFuZGxlcjtcbiAgICBpZiAoYWhbYWN0aW9uTmFtZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlcmUgaXMgYWxyZWFkeSBhbiBhY3Rpb25OYW1lIGNhbGxlZCBcIiR7YWN0aW9uTmFtZX1cImApO1xuICAgIH1cbiAgICBhaFthY3Rpb25OYW1lXSA9IGhhbmRsZXI7XG4gIH1cbiAgc2VuZChhY3Rpb25OYW1lLCBkYXRhLCB0cmFuc2ZlcnMpIHtcbiAgICB0aGlzLmNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICBzb3VyY2VOYW1lOiB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICB0YXJnZXROYW1lOiB0aGlzLnRhcmdldE5hbWUsXG4gICAgICBhY3Rpb246IGFjdGlvbk5hbWUsXG4gICAgICBkYXRhXG4gICAgfSwgdHJhbnNmZXJzKTtcbiAgfVxuICBzZW5kV2l0aFByb21pc2UoYWN0aW9uTmFtZSwgZGF0YSwgdHJhbnNmZXJzKSB7XG4gICAgY29uc3QgY2FsbGJhY2tJZCA9IHRoaXMuY2FsbGJhY2tJZCsrO1xuICAgIGNvbnN0IGNhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLmNhbGxiYWNrQ2FwYWJpbGl0aWVzW2NhbGxiYWNrSWRdID0gY2FwYWJpbGl0eTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5jb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBzb3VyY2VOYW1lOiB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICAgIHRhcmdldE5hbWU6IHRoaXMudGFyZ2V0TmFtZSxcbiAgICAgICAgYWN0aW9uOiBhY3Rpb25OYW1lLFxuICAgICAgICBjYWxsYmFja0lkLFxuICAgICAgICBkYXRhXG4gICAgICB9LCB0cmFuc2ZlcnMpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBjYXBhYmlsaXR5LnJlamVjdChleCk7XG4gICAgfVxuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgc2VuZFdpdGhTdHJlYW0oYWN0aW9uTmFtZSwgZGF0YSwgcXVldWVpbmdTdHJhdGVneSwgdHJhbnNmZXJzKSB7XG4gICAgY29uc3Qgc3RyZWFtSWQgPSB0aGlzLnN0cmVhbUlkKyssIHNvdXJjZU5hbWUgPSB0aGlzLnNvdXJjZU5hbWUsIHRhcmdldE5hbWUgPSB0aGlzLnRhcmdldE5hbWUsIGNvbU9iaiA9IHRoaXMuY29tT2JqO1xuICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgc3RhcnQ6IChjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXJ0Q2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXSA9IHtcbiAgICAgICAgICBjb250cm9sbGVyLFxuICAgICAgICAgIHN0YXJ0Q2FsbDogc3RhcnRDYXBhYmlsaXR5LFxuICAgICAgICAgIHB1bGxDYWxsOiBudWxsLFxuICAgICAgICAgIGNhbmNlbENhbGw6IG51bGwsXG4gICAgICAgICAgaXNDbG9zZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uTmFtZSxcbiAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIGRlc2lyZWRTaXplOiBjb250cm9sbGVyLmRlc2lyZWRTaXplXG4gICAgICAgIH0sIHRyYW5zZmVycyk7XG4gICAgICAgIHJldHVybiBzdGFydENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICAgIH0sXG4gICAgICBwdWxsOiAoY29udHJvbGxlcikgPT4ge1xuICAgICAgICBjb25zdCBwdWxsQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXS5wdWxsQ2FsbCA9IHB1bGxDYXBhYmlsaXR5O1xuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuUFVMTCxcbiAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICBkZXNpcmVkU2l6ZTogY29udHJvbGxlci5kZXNpcmVkU2l6ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHB1bGxDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICB9LFxuICAgICAgY2FuY2VsOiAocmVhc29uKSA9PiB7XG4gICAgICAgIGFzc2VydChyZWFzb24gaW5zdGFuY2VvZiBFcnJvciwgXCJjYW5jZWwgbXVzdCBoYXZlIGEgdmFsaWQgcmVhc29uXCIpO1xuICAgICAgICBjb25zdCBjYW5jZWxDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLmNhbmNlbENhbGwgPSBjYW5jZWxDYXBhYmlsaXR5O1xuICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXS5pc0Nsb3NlZCA9IHRydWU7XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5DQU5DRUwsXG4gICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjYW5jZWxDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICB9XG4gICAgfSwgcXVldWVpbmdTdHJhdGVneSk7XG4gIH1cbiAgI2NyZWF0ZVN0cmVhbVNpbmsoZGF0YSkge1xuICAgIGNvbnN0IHN0cmVhbUlkID0gZGF0YS5zdHJlYW1JZCwgc291cmNlTmFtZSA9IHRoaXMuc291cmNlTmFtZSwgdGFyZ2V0TmFtZSA9IGRhdGEuc291cmNlTmFtZSwgY29tT2JqID0gdGhpcy5jb21PYmo7XG4gICAgY29uc3Qgc2VsZjIgPSB0aGlzLCBhY3Rpb24gPSB0aGlzLmFjdGlvbkhhbmRsZXJbZGF0YS5hY3Rpb25dO1xuICAgIGNvbnN0IHN0cmVhbVNpbmsgPSB7XG4gICAgICBlbnF1ZXVlKGNodW5rLCBzaXplID0gMSwgdHJhbnNmZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhc3REZXNpcmVkU2l6ZSA9IHRoaXMuZGVzaXJlZFNpemU7XG4gICAgICAgIHRoaXMuZGVzaXJlZFNpemUgLT0gc2l6ZTtcbiAgICAgICAgaWYgKGxhc3REZXNpcmVkU2l6ZSA+IDAgJiYgdGhpcy5kZXNpcmVkU2l6ZSA8PSAwKSB7XG4gICAgICAgICAgdGhpcy5zaW5rQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgICAgICAgIHRoaXMucmVhZHkgPSB0aGlzLnNpbmtDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkVOUVVFVUUsXG4gICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgY2h1bmtcbiAgICAgICAgfSwgdHJhbnNmZXJzKTtcbiAgICAgIH0sXG4gICAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0NhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5DTE9TRSxcbiAgICAgICAgICBzdHJlYW1JZFxuICAgICAgICB9KTtcbiAgICAgICAgZGVsZXRlIHNlbGYyLnN0cmVhbVNpbmtzW3N0cmVhbUlkXTtcbiAgICAgIH0sXG4gICAgICBlcnJvcihyZWFzb24pIHtcbiAgICAgICAgYXNzZXJ0KHJlYXNvbiBpbnN0YW5jZW9mIEVycm9yLCBcImVycm9yIG11c3QgaGF2ZSBhIHZhbGlkIHJlYXNvblwiKTtcbiAgICAgICAgaWYgKHRoaXMuaXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0NhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5FUlJPUixcbiAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICByZWFzb246IHdyYXBSZWFzb24ocmVhc29uKVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBzaW5rQ2FwYWJpbGl0eTogUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCksXG4gICAgICBvblB1bGw6IG51bGwsXG4gICAgICBvbkNhbmNlbDogbnVsbCxcbiAgICAgIGlzQ2FuY2VsbGVkOiBmYWxzZSxcbiAgICAgIGRlc2lyZWRTaXplOiBkYXRhLmRlc2lyZWRTaXplLFxuICAgICAgcmVhZHk6IG51bGxcbiAgICB9O1xuICAgIHN0cmVhbVNpbmsuc2lua0NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIHN0cmVhbVNpbmsucmVhZHkgPSBzdHJlYW1TaW5rLnNpbmtDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgdGhpcy5zdHJlYW1TaW5rc1tzdHJlYW1JZF0gPSBzdHJlYW1TaW5rO1xuICAgIFByb21pc2UudHJ5KGFjdGlvbiwgZGF0YS5kYXRhLCBzdHJlYW1TaW5rKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlNUQVJUX0NPTVBMRVRFLFxuICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgc3VjY2VzczogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuU1RBUlRfQ09NUExFVEUsXG4gICAgICAgIHN0cmVhbUlkLFxuICAgICAgICByZWFzb246IHdyYXBSZWFzb24ocmVhc29uKVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgI3Byb2Nlc3NTdHJlYW1NZXNzYWdlKGRhdGEpIHtcbiAgICBjb25zdCBzdHJlYW1JZCA9IGRhdGEuc3RyZWFtSWQsIHNvdXJjZU5hbWUgPSB0aGlzLnNvdXJjZU5hbWUsIHRhcmdldE5hbWUgPSBkYXRhLnNvdXJjZU5hbWUsIGNvbU9iaiA9IHRoaXMuY29tT2JqO1xuICAgIGNvbnN0IHN0cmVhbUNvbnRyb2xsZXIgPSB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXSwgc3RyZWFtU2luayA9IHRoaXMuc3RyZWFtU2lua3Nbc3RyZWFtSWRdO1xuICAgIHN3aXRjaCAoZGF0YS5zdHJlYW0pIHtcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5TVEFSVF9DT01QTEVURTpcbiAgICAgICAgaWYgKGRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuc3RhcnRDYWxsLnJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLnN0YXJ0Q2FsbC5yZWplY3Qod3JhcFJlYXNvbihkYXRhLnJlYXNvbikpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLlBVTExfQ09NUExFVEU6XG4gICAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLnB1bGxDYWxsLnJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLnB1bGxDYWxsLnJlamVjdCh3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuUFVMTDpcbiAgICAgICAgaWYgKCFzdHJlYW1TaW5rKSB7XG4gICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlBVTExfQ09NUExFVEUsXG4gICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtU2luay5kZXNpcmVkU2l6ZSA8PSAwICYmIGRhdGEuZGVzaXJlZFNpemUgPiAwKSB7XG4gICAgICAgICAgc3RyZWFtU2luay5zaW5rQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtU2luay5kZXNpcmVkU2l6ZSA9IGRhdGEuZGVzaXJlZFNpemU7XG4gICAgICAgIFByb21pc2UudHJ5KHN0cmVhbVNpbmsub25QdWxsIHx8IG9uRm4pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlBVTExfQ09NUExFVEUsXG4gICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlBVTExfQ09NUExFVEUsXG4gICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5FTlFVRVVFOlxuICAgICAgICBhc3NlcnQoc3RyZWFtQ29udHJvbGxlciwgXCJlbnF1ZXVlIHNob3VsZCBoYXZlIHN0cmVhbSBjb250cm9sbGVyXCIpO1xuICAgICAgICBpZiAoc3RyZWFtQ29udHJvbGxlci5pc0Nsb3NlZCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuY29udHJvbGxlci5lbnF1ZXVlKGRhdGEuY2h1bmspO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5DTE9TRTpcbiAgICAgICAgYXNzZXJ0KHN0cmVhbUNvbnRyb2xsZXIsIFwiY2xvc2Ugc2hvdWxkIGhhdmUgc3RyZWFtIGNvbnRyb2xsZXJcIik7XG4gICAgICAgIGlmIChzdHJlYW1Db250cm9sbGVyLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtQ29udHJvbGxlci5pc0Nsb3NlZCA9IHRydWU7XG4gICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICB0aGlzLiNkZWxldGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIsIHN0cmVhbUlkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuRVJST1I6XG4gICAgICAgIGFzc2VydChzdHJlYW1Db250cm9sbGVyLCBcImVycm9yIHNob3VsZCBoYXZlIHN0cmVhbSBjb250cm9sbGVyXCIpO1xuICAgICAgICBzdHJlYW1Db250cm9sbGVyLmNvbnRyb2xsZXIuZXJyb3Iod3JhcFJlYXNvbihkYXRhLnJlYXNvbikpO1xuICAgICAgICB0aGlzLiNkZWxldGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIsIHN0cmVhbUlkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuQ0FOQ0VMX0NPTVBMRVRFOlxuICAgICAgICBpZiAoZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgICAgc3RyZWFtQ29udHJvbGxlci5jYW5jZWxDYWxsLnJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLmNhbmNlbENhbGwucmVqZWN0KHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNkZWxldGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIsIHN0cmVhbUlkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuQ0FOQ0VMOlxuICAgICAgICBpZiAoIXN0cmVhbVNpbmspIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhUmVhc29uID0gd3JhcFJlYXNvbihkYXRhLnJlYXNvbik7XG4gICAgICAgIFByb21pc2UudHJ5KHN0cmVhbVNpbmsub25DYW5jZWwgfHwgb25GbiwgZGF0YVJlYXNvbikudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuQ0FOQ0VMX0NPTVBMRVRFLFxuICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5DQU5DRUxfQ09NUExFVEUsXG4gICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdHJlYW1TaW5rLnNpbmtDYXBhYmlsaXR5LnJlamVjdChkYXRhUmVhc29uKTtcbiAgICAgICAgc3RyZWFtU2luay5pc0NhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnN0cmVhbVNpbmtzW3N0cmVhbUlkXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHN0cmVhbSBjYXNlXCIpO1xuICAgIH1cbiAgfVxuICBhc3luYyAjZGVsZXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyLCBzdHJlYW1JZCkge1xuICAgIGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChbc3RyZWFtQ29udHJvbGxlci5zdGFydENhbGw/LnByb21pc2UsIHN0cmVhbUNvbnRyb2xsZXIucHVsbENhbGw/LnByb21pc2UsIHN0cmVhbUNvbnRyb2xsZXIuY2FuY2VsQ2FsbD8ucHJvbWlzZV0pO1xuICAgIGRlbGV0ZSB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI21lc3NhZ2VBQz8uYWJvcnQoKTtcbiAgICB0aGlzLiNtZXNzYWdlQUMgPSBudWxsO1xuICB9XG59XG5jbGFzcyBCYXNlQ2FudmFzRmFjdG9yeSB7XG4gICNlbmFibGVIV0EgPSBmYWxzZTtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGVuYWJsZUhXQSA9IGZhbHNlXG4gIH0pIHtcbiAgICB0aGlzLiNlbmFibGVIV0EgPSBlbmFibGVIV0E7XG4gIH1cbiAgY3JlYXRlKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjYW52YXMgc2l6ZVwiKTtcbiAgICB9XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5fY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuICAgIHJldHVybiB7XG4gICAgICBjYW52YXMsXG4gICAgICBjb250ZXh0OiBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICAgICAgd2lsbFJlYWRGcmVxdWVudGx5OiAhdGhpcy4jZW5hYmxlSFdBXG4gICAgICB9KVxuICAgIH07XG4gIH1cbiAgcmVzZXQoY2FudmFzQW5kQ29udGV4dCwgd2lkdGgsIGhlaWdodCkge1xuICAgIGlmICghY2FudmFzQW5kQ29udGV4dC5jYW52YXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbnZhcyBpcyBub3Qgc3BlY2lmaWVkXCIpO1xuICAgIH1cbiAgICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjYW52YXMgc2l6ZVwiKTtcbiAgICB9XG4gICAgY2FudmFzQW5kQ29udGV4dC5jYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICBjYW52YXNBbmRDb250ZXh0LmNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cbiAgZGVzdHJveShjYW52YXNBbmRDb250ZXh0KSB7XG4gICAgaWYgKCFjYW52YXNBbmRDb250ZXh0LmNhbnZhcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIGlzIG5vdCBzcGVjaWZpZWRcIik7XG4gICAgfVxuICAgIGNhbnZhc0FuZENvbnRleHQuY2FudmFzLndpZHRoID0gMDtcbiAgICBjYW52YXNBbmRDb250ZXh0LmNhbnZhcy5oZWlnaHQgPSAwO1xuICAgIGNhbnZhc0FuZENvbnRleHQuY2FudmFzID0gbnVsbDtcbiAgICBjYW52YXNBbmRDb250ZXh0LmNvbnRleHQgPSBudWxsO1xuICB9XG4gIF9jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgbWV0aG9kIGBfY3JlYXRlQ2FudmFzYCBjYWxsZWQuXCIpO1xuICB9XG59XG5jbGFzcyBET01DYW52YXNGYWN0b3J5IGV4dGVuZHMgQmFzZUNhbnZhc0ZhY3Rvcnkge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgb3duZXJEb2N1bWVudCA9IGdsb2JhbFRoaXMuZG9jdW1lbnQsXG4gICAgZW5hYmxlSFdBID0gZmFsc2VcbiAgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIGVuYWJsZUhXQVxuICAgIH0pO1xuICAgIHRoaXMuX2RvY3VtZW50ID0gb3duZXJEb2N1bWVudDtcbiAgfVxuICBfY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgcmV0dXJuIGNhbnZhcztcbiAgfVxufVxuY2xhc3MgQmFzZUNNYXBSZWFkZXJGYWN0b3J5IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGJhc2VVcmwgPSBudWxsLFxuICAgIGlzQ29tcHJlc3NlZCA9IHRydWVcbiAgfSkge1xuICAgIHRoaXMuYmFzZVVybCA9IGJhc2VVcmw7XG4gICAgdGhpcy5pc0NvbXByZXNzZWQgPSBpc0NvbXByZXNzZWQ7XG4gIH1cbiAgYXN5bmMgZmV0Y2goe1xuICAgIG5hbWVcbiAgfSkge1xuICAgIGlmICghdGhpcy5iYXNlVXJsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhhdCB0aGUgYGNNYXBVcmxgIGFuZCBgY01hcFBhY2tlZGAgQVBJIHBhcmFtZXRlcnMgYXJlIHByb3ZpZGVkLlwiKTtcbiAgICB9XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDTWFwIG5hbWUgbXVzdCBiZSBzcGVjaWZpZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSB0aGlzLmJhc2VVcmwgKyBuYW1lICsgKHRoaXMuaXNDb21wcmVzc2VkID8gXCIuYmNtYXBcIiA6IFwiXCIpO1xuICAgIHJldHVybiB0aGlzLl9mZXRjaCh1cmwpLnRoZW4oKGNNYXBEYXRhKSA9PiAoe1xuICAgICAgY01hcERhdGEsXG4gICAgICBpc0NvbXByZXNzZWQ6IHRoaXMuaXNDb21wcmVzc2VkXG4gICAgfSkpLmNhdGNoKChyZWFzb24pID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGxvYWQgJHt0aGlzLmlzQ29tcHJlc3NlZCA/IFwiYmluYXJ5IFwiIDogXCJcIn1DTWFwIGF0OiAke3VybH1gKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBfZmV0Y2godXJsKSB7XG4gICAgdW5yZWFjaGFibGUoXCJBYnN0cmFjdCBtZXRob2QgYF9mZXRjaGAgY2FsbGVkLlwiKTtcbiAgfVxufVxuY2xhc3MgRE9NQ01hcFJlYWRlckZhY3RvcnkgZXh0ZW5kcyBCYXNlQ01hcFJlYWRlckZhY3Rvcnkge1xuICBhc3luYyBfZmV0Y2godXJsKSB7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IGZldGNoRGF0YSh1cmwsIHRoaXMuaXNDb21wcmVzc2VkID8gXCJhcnJheWJ1ZmZlclwiIDogXCJ0ZXh0XCIpO1xuICAgIHJldHVybiBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBuZXcgVWludDhBcnJheShkYXRhKSA6IHN0cmluZ1RvQnl0ZXMoZGF0YSk7XG4gIH1cbn1cbl9fd2VicGFja19yZXF1aXJlX18oMjQ4OSk7XG5jbGFzcyBCYXNlRmlsdGVyRmFjdG9yeSB7XG4gIGFkZEZpbHRlcihtYXBzKSB7XG4gICAgcmV0dXJuIFwibm9uZVwiO1xuICB9XG4gIGFkZEhDTUZpbHRlcihmZ0NvbG9yLCBiZ0NvbG9yKSB7XG4gICAgcmV0dXJuIFwibm9uZVwiO1xuICB9XG4gIGFkZEFscGhhRmlsdGVyKG1hcCkge1xuICAgIHJldHVybiBcIm5vbmVcIjtcbiAgfVxuICBhZGRMdW1pbm9zaXR5RmlsdGVyKG1hcCkge1xuICAgIHJldHVybiBcIm5vbmVcIjtcbiAgfVxuICBhZGRIaWdobGlnaHRIQ01GaWx0ZXIoZmlsdGVyTmFtZSwgZmdDb2xvciwgYmdDb2xvciwgbmV3RmdDb2xvciwgbmV3QmdDb2xvcikge1xuICAgIHJldHVybiBcIm5vbmVcIjtcbiAgfVxuICBkZXN0cm95KGtlZXBIQ00gPSBmYWxzZSkge1xuICB9XG59XG5jbGFzcyBET01GaWx0ZXJGYWN0b3J5IGV4dGVuZHMgQmFzZUZpbHRlckZhY3Rvcnkge1xuICAjYmFzZVVybDtcbiAgI19jYWNoZTtcbiAgI19kZWZzO1xuICAjZG9jSWQ7XG4gICNkb2N1bWVudDtcbiAgI19oY21DYWNoZTtcbiAgI2lkID0gMDtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGRvY0lkLFxuICAgIG93bmVyRG9jdW1lbnQgPSBnbG9iYWxUaGlzLmRvY3VtZW50XG4gIH0pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuI2RvY0lkID0gZG9jSWQ7XG4gICAgdGhpcy4jZG9jdW1lbnQgPSBvd25lckRvY3VtZW50O1xuICB9XG4gIGdldCAjY2FjaGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI19jYWNoZSB8fD0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBnZXQgI2hjbUNhY2hlKCkge1xuICAgIHJldHVybiB0aGlzLiNfaGNtQ2FjaGUgfHw9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgZ2V0ICNkZWZzKCkge1xuICAgIGlmICghdGhpcy4jX2RlZnMpIHtcbiAgICAgIGNvbnN0IGRpdiA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHN0eWxlXG4gICAgICB9ID0gZGl2O1xuICAgICAgc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgICBzdHlsZS5jb250YWluID0gXCJzdHJpY3RcIjtcbiAgICAgIHN0eWxlLndpZHRoID0gc3R5bGUuaGVpZ2h0ID0gMDtcbiAgICAgIHN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgc3R5bGUudG9wID0gc3R5bGUubGVmdCA9IDA7XG4gICAgICBzdHlsZS56SW5kZXggPSAtMTtcbiAgICAgIGNvbnN0IHN2ZyA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIFwic3ZnXCIpO1xuICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIDApO1xuICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCAwKTtcbiAgICAgIHRoaXMuI19kZWZzID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgXCJkZWZzXCIpO1xuICAgICAgZGl2LmFwcGVuZChzdmcpO1xuICAgICAgc3ZnLmFwcGVuZCh0aGlzLiNfZGVmcyk7XG4gICAgICB0aGlzLiNkb2N1bWVudC5ib2R5LmFwcGVuZChkaXYpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy4jX2RlZnM7XG4gIH1cbiAgI2NyZWF0ZVRhYmxlcyhtYXBzKSB7XG4gICAgaWYgKG1hcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBtYXBSMiA9IG1hcHNbMF07XG4gICAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgICAgYnVmZmVyW2ldID0gbWFwUjJbaV0gLyAyNTU7XG4gICAgICB9XG4gICAgICBjb25zdCB0YWJsZSA9IGJ1ZmZlci5qb2luKFwiLFwiKTtcbiAgICAgIHJldHVybiBbdGFibGUsIHRhYmxlLCB0YWJsZV07XG4gICAgfVxuICAgIGNvbnN0IFttYXBSLCBtYXBHLCBtYXBCXSA9IG1hcHM7XG4gICAgY29uc3QgYnVmZmVyUiA9IG5ldyBBcnJheSgyNTYpO1xuICAgIGNvbnN0IGJ1ZmZlckcgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICBjb25zdCBidWZmZXJCID0gbmV3IEFycmF5KDI1Nik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgYnVmZmVyUltpXSA9IG1hcFJbaV0gLyAyNTU7XG4gICAgICBidWZmZXJHW2ldID0gbWFwR1tpXSAvIDI1NTtcbiAgICAgIGJ1ZmZlckJbaV0gPSBtYXBCW2ldIC8gMjU1O1xuICAgIH1cbiAgICByZXR1cm4gW2J1ZmZlclIuam9pbihcIixcIiksIGJ1ZmZlckcuam9pbihcIixcIiksIGJ1ZmZlckIuam9pbihcIixcIildO1xuICB9XG4gICNjcmVhdGVVcmwoaWQpIHtcbiAgICBpZiAodGhpcy4jYmFzZVVybCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLiNiYXNlVXJsID0gXCJcIjtcbiAgICAgIGNvbnN0IHVybCA9IHRoaXMuI2RvY3VtZW50LlVSTDtcbiAgICAgIGlmICh1cmwgIT09IHRoaXMuI2RvY3VtZW50LmJhc2VVUkkpIHtcbiAgICAgICAgaWYgKGlzRGF0YVNjaGVtZSh1cmwpKSB7XG4gICAgICAgICAgd2FybignI2NyZWF0ZVVybDogaWdub3JlIFwiZGF0YTpcIi1VUkwgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy4jYmFzZVVybCA9IHVwZGF0ZVVybEhhc2godXJsLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYHVybCgke3RoaXMuI2Jhc2VVcmx9IyR7aWR9KWA7XG4gIH1cbiAgYWRkRmlsdGVyKG1hcHMpIHtcbiAgICBpZiAoIW1hcHMpIHtcbiAgICAgIHJldHVybiBcIm5vbmVcIjtcbiAgICB9XG4gICAgbGV0IHZhbHVlID0gdGhpcy4jY2FjaGUuZ2V0KG1hcHMpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBbdGFibGVSLCB0YWJsZUcsIHRhYmxlQl0gPSB0aGlzLiNjcmVhdGVUYWJsZXMobWFwcyk7XG4gICAgY29uc3Qga2V5ID0gbWFwcy5sZW5ndGggPT09IDEgPyB0YWJsZVIgOiBgJHt0YWJsZVJ9JHt0YWJsZUd9JHt0YWJsZUJ9YDtcbiAgICB2YWx1ZSA9IHRoaXMuI2NhY2hlLmdldChrZXkpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy4jY2FjaGUuc2V0KG1hcHMsIHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgaWQgPSBgZ18ke3RoaXMuI2RvY0lkfV90cmFuc2Zlcl9tYXBfJHt0aGlzLiNpZCsrfWA7XG4gICAgY29uc3QgdXJsID0gdGhpcy4jY3JlYXRlVXJsKGlkKTtcbiAgICB0aGlzLiNjYWNoZS5zZXQobWFwcywgdXJsKTtcbiAgICB0aGlzLiNjYWNoZS5zZXQoa2V5LCB1cmwpO1xuICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuI2NyZWF0ZUZpbHRlcihpZCk7XG4gICAgdGhpcy4jYWRkVHJhbnNmZXJNYXBDb252ZXJzaW9uKHRhYmxlUiwgdGFibGVHLCB0YWJsZUIsIGZpbHRlcik7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICBhZGRIQ01GaWx0ZXIoZmdDb2xvciwgYmdDb2xvcikge1xuICAgIGNvbnN0IGtleSA9IGAke2ZnQ29sb3J9LSR7YmdDb2xvcn1gO1xuICAgIGNvbnN0IGZpbHRlck5hbWUgPSBcImJhc2VcIjtcbiAgICBsZXQgaW5mbzIgPSB0aGlzLiNoY21DYWNoZS5nZXQoZmlsdGVyTmFtZSk7XG4gICAgaWYgKGluZm8yPy5rZXkgPT09IGtleSkge1xuICAgICAgcmV0dXJuIGluZm8yLnVybDtcbiAgICB9XG4gICAgaWYgKGluZm8yKSB7XG4gICAgICBpbmZvMi5maWx0ZXI/LnJlbW92ZSgpO1xuICAgICAgaW5mbzIua2V5ID0ga2V5O1xuICAgICAgaW5mbzIudXJsID0gXCJub25lXCI7XG4gICAgICBpbmZvMi5maWx0ZXIgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmZvMiA9IHtcbiAgICAgICAga2V5LFxuICAgICAgICB1cmw6IFwibm9uZVwiLFxuICAgICAgICBmaWx0ZXI6IG51bGxcbiAgICAgIH07XG4gICAgICB0aGlzLiNoY21DYWNoZS5zZXQoZmlsdGVyTmFtZSwgaW5mbzIpO1xuICAgIH1cbiAgICBpZiAoIWZnQ29sb3IgfHwgIWJnQ29sb3IpIHtcbiAgICAgIHJldHVybiBpbmZvMi51cmw7XG4gICAgfVxuICAgIGNvbnN0IGZnUkdCID0gdGhpcy4jZ2V0UkdCKGZnQ29sb3IpO1xuICAgIGZnQ29sb3IgPSBVdGlsLm1ha2VIZXhDb2xvciguLi5mZ1JHQik7XG4gICAgY29uc3QgYmdSR0IgPSB0aGlzLiNnZXRSR0IoYmdDb2xvcik7XG4gICAgYmdDb2xvciA9IFV0aWwubWFrZUhleENvbG9yKC4uLmJnUkdCKTtcbiAgICB0aGlzLiNkZWZzLnN0eWxlLmNvbG9yID0gXCJcIjtcbiAgICBpZiAoZmdDb2xvciA9PT0gXCIjMDAwMDAwXCIgJiYgYmdDb2xvciA9PT0gXCIjZmZmZmZmXCIgfHwgZmdDb2xvciA9PT0gYmdDb2xvcikge1xuICAgICAgcmV0dXJuIGluZm8yLnVybDtcbiAgICB9XG4gICAgY29uc3QgbWFwID0gbmV3IEFycmF5KDI1Nik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gMjU1OyBpKyspIHtcbiAgICAgIGNvbnN0IHggPSBpIC8gMjU1O1xuICAgICAgbWFwW2ldID0geCA8PSAwLjAzOTI4ID8geCAvIDEyLjkyIDogKCh4ICsgMC4wNTUpIC8gMS4wNTUpICoqIDIuNDtcbiAgICB9XG4gICAgY29uc3QgdGFibGUgPSBtYXAuam9pbihcIixcIik7XG4gICAgY29uc3QgaWQgPSBgZ18ke3RoaXMuI2RvY0lkfV9oY21fZmlsdGVyYDtcbiAgICBjb25zdCBmaWx0ZXIgPSBpbmZvMi5maWx0ZXIgPSB0aGlzLiNjcmVhdGVGaWx0ZXIoaWQpO1xuICAgIHRoaXMuI2FkZFRyYW5zZmVyTWFwQ29udmVyc2lvbih0YWJsZSwgdGFibGUsIHRhYmxlLCBmaWx0ZXIpO1xuICAgIHRoaXMuI2FkZEdyYXlDb252ZXJzaW9uKGZpbHRlcik7XG4gICAgY29uc3QgZ2V0U3RlcHMgPSAoYywgbikgPT4ge1xuICAgICAgY29uc3Qgc3RhcnQgPSBmZ1JHQltjXSAvIDI1NTtcbiAgICAgIGNvbnN0IGVuZCA9IGJnUkdCW2NdIC8gMjU1O1xuICAgICAgY29uc3QgYXJyID0gbmV3IEFycmF5KG4gKyAxKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG47IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBzdGFydCArIGkgLyBuICogKGVuZCAtIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnIuam9pbihcIixcIik7XG4gICAgfTtcbiAgICB0aGlzLiNhZGRUcmFuc2Zlck1hcENvbnZlcnNpb24oZ2V0U3RlcHMoMCwgNSksIGdldFN0ZXBzKDEsIDUpLCBnZXRTdGVwcygyLCA1KSwgZmlsdGVyKTtcbiAgICBpbmZvMi51cmwgPSB0aGlzLiNjcmVhdGVVcmwoaWQpO1xuICAgIHJldHVybiBpbmZvMi51cmw7XG4gIH1cbiAgYWRkQWxwaGFGaWx0ZXIobWFwKSB7XG4gICAgbGV0IHZhbHVlID0gdGhpcy4jY2FjaGUuZ2V0KG1hcCk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IFt0YWJsZUFdID0gdGhpcy4jY3JlYXRlVGFibGVzKFttYXBdKTtcbiAgICBjb25zdCBrZXkgPSBgYWxwaGFfJHt0YWJsZUF9YDtcbiAgICB2YWx1ZSA9IHRoaXMuI2NhY2hlLmdldChrZXkpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy4jY2FjaGUuc2V0KG1hcCwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IGBnXyR7dGhpcy4jZG9jSWR9X2FscGhhX21hcF8ke3RoaXMuI2lkKyt9YDtcbiAgICBjb25zdCB1cmwgPSB0aGlzLiNjcmVhdGVVcmwoaWQpO1xuICAgIHRoaXMuI2NhY2hlLnNldChtYXAsIHVybCk7XG4gICAgdGhpcy4jY2FjaGUuc2V0KGtleSwgdXJsKTtcbiAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLiNjcmVhdGVGaWx0ZXIoaWQpO1xuICAgIHRoaXMuI2FkZFRyYW5zZmVyTWFwQWxwaGFDb252ZXJzaW9uKHRhYmxlQSwgZmlsdGVyKTtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIGFkZEx1bWlub3NpdHlGaWx0ZXIobWFwKSB7XG4gICAgbGV0IHZhbHVlID0gdGhpcy4jY2FjaGUuZ2V0KG1hcCB8fCBcImx1bWlub3NpdHlcIik7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGxldCB0YWJsZUEsIGtleTtcbiAgICBpZiAobWFwKSB7XG4gICAgICBbdGFibGVBXSA9IHRoaXMuI2NyZWF0ZVRhYmxlcyhbbWFwXSk7XG4gICAgICBrZXkgPSBgbHVtaW5vc2l0eV8ke3RhYmxlQX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBcImx1bWlub3NpdHlcIjtcbiAgICB9XG4gICAgdmFsdWUgPSB0aGlzLiNjYWNoZS5nZXQoa2V5KTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuI2NhY2hlLnNldChtYXAsIHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgaWQgPSBgZ18ke3RoaXMuI2RvY0lkfV9sdW1pbm9zaXR5X21hcF8ke3RoaXMuI2lkKyt9YDtcbiAgICBjb25zdCB1cmwgPSB0aGlzLiNjcmVhdGVVcmwoaWQpO1xuICAgIHRoaXMuI2NhY2hlLnNldChtYXAsIHVybCk7XG4gICAgdGhpcy4jY2FjaGUuc2V0KGtleSwgdXJsKTtcbiAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLiNjcmVhdGVGaWx0ZXIoaWQpO1xuICAgIHRoaXMuI2FkZEx1bWlub3NpdHlDb252ZXJzaW9uKGZpbHRlcik7XG4gICAgaWYgKG1hcCkge1xuICAgICAgdGhpcy4jYWRkVHJhbnNmZXJNYXBBbHBoYUNvbnZlcnNpb24odGFibGVBLCBmaWx0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIGFkZEhpZ2hsaWdodEhDTUZpbHRlcihmaWx0ZXJOYW1lLCBmZ0NvbG9yLCBiZ0NvbG9yLCBuZXdGZ0NvbG9yLCBuZXdCZ0NvbG9yKSB7XG4gICAgY29uc3Qga2V5ID0gYCR7ZmdDb2xvcn0tJHtiZ0NvbG9yfS0ke25ld0ZnQ29sb3J9LSR7bmV3QmdDb2xvcn1gO1xuICAgIGxldCBpbmZvMiA9IHRoaXMuI2hjbUNhY2hlLmdldChmaWx0ZXJOYW1lKTtcbiAgICBpZiAoaW5mbzI/LmtleSA9PT0ga2V5KSB7XG4gICAgICByZXR1cm4gaW5mbzIudXJsO1xuICAgIH1cbiAgICBpZiAoaW5mbzIpIHtcbiAgICAgIGluZm8yLmZpbHRlcj8ucmVtb3ZlKCk7XG4gICAgICBpbmZvMi5rZXkgPSBrZXk7XG4gICAgICBpbmZvMi51cmwgPSBcIm5vbmVcIjtcbiAgICAgIGluZm8yLmZpbHRlciA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZm8yID0ge1xuICAgICAgICBrZXksXG4gICAgICAgIHVybDogXCJub25lXCIsXG4gICAgICAgIGZpbHRlcjogbnVsbFxuICAgICAgfTtcbiAgICAgIHRoaXMuI2hjbUNhY2hlLnNldChmaWx0ZXJOYW1lLCBpbmZvMik7XG4gICAgfVxuICAgIGlmICghZmdDb2xvciB8fCAhYmdDb2xvcikge1xuICAgICAgcmV0dXJuIGluZm8yLnVybDtcbiAgICB9XG4gICAgY29uc3QgW2ZnUkdCLCBiZ1JHQl0gPSBbZmdDb2xvciwgYmdDb2xvcl0ubWFwKHRoaXMuI2dldFJHQi5iaW5kKHRoaXMpKTtcbiAgICBsZXQgZmdHcmF5ID0gTWF0aC5yb3VuZCgwLjIxMjYgKiBmZ1JHQlswXSArIDAuNzE1MiAqIGZnUkdCWzFdICsgMC4wNzIyICogZmdSR0JbMl0pO1xuICAgIGxldCBiZ0dyYXkgPSBNYXRoLnJvdW5kKDAuMjEyNiAqIGJnUkdCWzBdICsgMC43MTUyICogYmdSR0JbMV0gKyAwLjA3MjIgKiBiZ1JHQlsyXSk7XG4gICAgbGV0IFtuZXdGZ1JHQiwgbmV3QmdSR0JdID0gW25ld0ZnQ29sb3IsIG5ld0JnQ29sb3JdLm1hcCh0aGlzLiNnZXRSR0IuYmluZCh0aGlzKSk7XG4gICAgaWYgKGJnR3JheSA8IGZnR3JheSkge1xuICAgICAgW2ZnR3JheSwgYmdHcmF5LCBuZXdGZ1JHQiwgbmV3QmdSR0JdID0gW2JnR3JheSwgZmdHcmF5LCBuZXdCZ1JHQiwgbmV3RmdSR0JdO1xuICAgIH1cbiAgICB0aGlzLiNkZWZzLnN0eWxlLmNvbG9yID0gXCJcIjtcbiAgICBjb25zdCBnZXRTdGVwcyA9IChmZywgYmcsIG4pID0+IHtcbiAgICAgIGNvbnN0IGFyciA9IG5ldyBBcnJheSgyNTYpO1xuICAgICAgY29uc3Qgc3RlcCA9IChiZ0dyYXkgLSBmZ0dyYXkpIC8gbjtcbiAgICAgIGNvbnN0IG5ld1N0YXJ0ID0gZmcgLyAyNTU7XG4gICAgICBjb25zdCBuZXdTdGVwID0gKGJnIC0gZmcpIC8gKDI1NSAqIG4pO1xuICAgICAgbGV0IHByZXYgPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGsgPSBNYXRoLnJvdW5kKGZnR3JheSArIGkgKiBzdGVwKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBuZXdTdGFydCArIGkgKiBuZXdTdGVwO1xuICAgICAgICBmb3IgKGxldCBqID0gcHJldjsgaiA8PSBrOyBqKyspIHtcbiAgICAgICAgICBhcnJbal0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2ID0gayArIDE7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gcHJldjsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IGFycltwcmV2IC0gMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyLmpvaW4oXCIsXCIpO1xuICAgIH07XG4gICAgY29uc3QgaWQgPSBgZ18ke3RoaXMuI2RvY0lkfV9oY21fJHtmaWx0ZXJOYW1lfV9maWx0ZXJgO1xuICAgIGNvbnN0IGZpbHRlciA9IGluZm8yLmZpbHRlciA9IHRoaXMuI2NyZWF0ZUZpbHRlcihpZCk7XG4gICAgdGhpcy4jYWRkR3JheUNvbnZlcnNpb24oZmlsdGVyKTtcbiAgICB0aGlzLiNhZGRUcmFuc2Zlck1hcENvbnZlcnNpb24oZ2V0U3RlcHMobmV3RmdSR0JbMF0sIG5ld0JnUkdCWzBdLCA1KSwgZ2V0U3RlcHMobmV3RmdSR0JbMV0sIG5ld0JnUkdCWzFdLCA1KSwgZ2V0U3RlcHMobmV3RmdSR0JbMl0sIG5ld0JnUkdCWzJdLCA1KSwgZmlsdGVyKTtcbiAgICBpbmZvMi51cmwgPSB0aGlzLiNjcmVhdGVVcmwoaWQpO1xuICAgIHJldHVybiBpbmZvMi51cmw7XG4gIH1cbiAgZGVzdHJveShrZWVwSENNID0gZmFsc2UpIHtcbiAgICBpZiAoa2VlcEhDTSAmJiB0aGlzLiNfaGNtQ2FjaGU/LnNpemUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jX2RlZnM/LnBhcmVudE5vZGUucGFyZW50Tm9kZS5yZW1vdmUoKTtcbiAgICB0aGlzLiNfZGVmcyA9IG51bGw7XG4gICAgdGhpcy4jX2NhY2hlPy5jbGVhcigpO1xuICAgIHRoaXMuI19jYWNoZSA9IG51bGw7XG4gICAgdGhpcy4jX2hjbUNhY2hlPy5jbGVhcigpO1xuICAgIHRoaXMuI19oY21DYWNoZSA9IG51bGw7XG4gICAgdGhpcy4jaWQgPSAwO1xuICB9XG4gICNhZGRMdW1pbm9zaXR5Q29udmVyc2lvbihmaWx0ZXIpIHtcbiAgICBjb25zdCBmZUNvbG9yTWF0cml4ID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgXCJmZUNvbG9yTWF0cml4XCIpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcIm1hdHJpeFwiKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZShcInZhbHVlc1wiLCBcIjAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAuMyAwLjU5IDAuMTEgMCAwXCIpO1xuICAgIGZpbHRlci5hcHBlbmQoZmVDb2xvck1hdHJpeCk7XG4gIH1cbiAgI2FkZEdyYXlDb252ZXJzaW9uKGZpbHRlcikge1xuICAgIGNvbnN0IGZlQ29sb3JNYXRyaXggPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBcImZlQ29sb3JNYXRyaXhcIik7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwibWF0cml4XCIpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKFwidmFsdWVzXCIsIFwiMC4yMTI2IDAuNzE1MiAwLjA3MjIgMCAwIDAuMjEyNiAwLjcxNTIgMC4wNzIyIDAgMCAwLjIxMjYgMC43MTUyIDAuMDcyMiAwIDAgMCAwIDAgMSAwXCIpO1xuICAgIGZpbHRlci5hcHBlbmQoZmVDb2xvck1hdHJpeCk7XG4gIH1cbiAgI2NyZWF0ZUZpbHRlcihpZCkge1xuICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIFwiZmlsdGVyXCIpO1xuICAgIGZpbHRlci5zZXRBdHRyaWJ1dGUoXCJjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnNcIiwgXCJzUkdCXCIpO1xuICAgIGZpbHRlci5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBpZCk7XG4gICAgdGhpcy4jZGVmcy5hcHBlbmQoZmlsdGVyKTtcbiAgICByZXR1cm4gZmlsdGVyO1xuICB9XG4gICNhcHBlbmRGZUZ1bmMoZmVDb21wb25lbnRUcmFuc2ZlciwgZnVuYywgdGFibGUpIHtcbiAgICBjb25zdCBmZUZ1bmMgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBmdW5jKTtcbiAgICBmZUZ1bmMuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcImRpc2NyZXRlXCIpO1xuICAgIGZlRnVuYy5zZXRBdHRyaWJ1dGUoXCJ0YWJsZVZhbHVlc1wiLCB0YWJsZSk7XG4gICAgZmVDb21wb25lbnRUcmFuc2Zlci5hcHBlbmQoZmVGdW5jKTtcbiAgfVxuICAjYWRkVHJhbnNmZXJNYXBDb252ZXJzaW9uKHJUYWJsZSwgZ1RhYmxlLCBiVGFibGUsIGZpbHRlcikge1xuICAgIGNvbnN0IGZlQ29tcG9uZW50VHJhbnNmZXIgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBcImZlQ29tcG9uZW50VHJhbnNmZXJcIik7XG4gICAgZmlsdGVyLmFwcGVuZChmZUNvbXBvbmVudFRyYW5zZmVyKTtcbiAgICB0aGlzLiNhcHBlbmRGZUZ1bmMoZmVDb21wb25lbnRUcmFuc2ZlciwgXCJmZUZ1bmNSXCIsIHJUYWJsZSk7XG4gICAgdGhpcy4jYXBwZW5kRmVGdW5jKGZlQ29tcG9uZW50VHJhbnNmZXIsIFwiZmVGdW5jR1wiLCBnVGFibGUpO1xuICAgIHRoaXMuI2FwcGVuZEZlRnVuYyhmZUNvbXBvbmVudFRyYW5zZmVyLCBcImZlRnVuY0JcIiwgYlRhYmxlKTtcbiAgfVxuICAjYWRkVHJhbnNmZXJNYXBBbHBoYUNvbnZlcnNpb24oYVRhYmxlLCBmaWx0ZXIpIHtcbiAgICBjb25zdCBmZUNvbXBvbmVudFRyYW5zZmVyID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgXCJmZUNvbXBvbmVudFRyYW5zZmVyXCIpO1xuICAgIGZpbHRlci5hcHBlbmQoZmVDb21wb25lbnRUcmFuc2Zlcik7XG4gICAgdGhpcy4jYXBwZW5kRmVGdW5jKGZlQ29tcG9uZW50VHJhbnNmZXIsIFwiZmVGdW5jQVwiLCBhVGFibGUpO1xuICB9XG4gICNnZXRSR0IoY29sb3IpIHtcbiAgICB0aGlzLiNkZWZzLnN0eWxlLmNvbG9yID0gY29sb3I7XG4gICAgcmV0dXJuIGdldFJHQihnZXRDb21wdXRlZFN0eWxlKHRoaXMuI2RlZnMpLmdldFByb3BlcnR5VmFsdWUoXCJjb2xvclwiKSk7XG4gIH1cbn1cbmNsYXNzIEJhc2VTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBiYXNlVXJsID0gbnVsbFxuICB9KSB7XG4gICAgdGhpcy5iYXNlVXJsID0gYmFzZVVybDtcbiAgfVxuICBhc3luYyBmZXRjaCh7XG4gICAgZmlsZW5hbWVcbiAgfSkge1xuICAgIGlmICghdGhpcy5iYXNlVXJsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhhdCB0aGUgYHN0YW5kYXJkRm9udERhdGFVcmxgIEFQSSBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoIWZpbGVuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGb250IGZpbGVuYW1lIG11c3QgYmUgc3BlY2lmaWVkLlwiKTtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gYCR7dGhpcy5iYXNlVXJsfSR7ZmlsZW5hbWV9YDtcbiAgICByZXR1cm4gdGhpcy5fZmV0Y2godXJsKS5jYXRjaCgocmVhc29uKSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBsb2FkIGZvbnQgZGF0YSBhdDogJHt1cmx9YCk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgX2ZldGNoKHVybCkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgbWV0aG9kIGBfZmV0Y2hgIGNhbGxlZC5cIik7XG4gIH1cbn1cbmNsYXNzIERPTVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IGV4dGVuZHMgQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IHtcbiAgYXN5bmMgX2ZldGNoKHVybCkge1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBmZXRjaERhdGEodXJsLCBcImFycmF5YnVmZmVyXCIpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfVxufVxuY2xhc3MgQmFzZVdhc21GYWN0b3J5IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGJhc2VVcmwgPSBudWxsXG4gIH0pIHtcbiAgICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsO1xuICB9XG4gIGFzeW5jIGZldGNoKHtcbiAgICBmaWxlbmFtZVxuICB9KSB7XG4gICAgaWYgKCF0aGlzLmJhc2VVcmwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuc3VyZSB0aGF0IHRoZSBgd2FzbVVybGAgQVBJIHBhcmFtZXRlciBpcyBwcm92aWRlZC5cIik7XG4gICAgfVxuICAgIGlmICghZmlsZW5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIldhc20gZmlsZW5hbWUgbXVzdCBiZSBzcGVjaWZpZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmJhc2VVcmx9JHtmaWxlbmFtZX1gO1xuICAgIHJldHVybiB0aGlzLl9mZXRjaCh1cmwpLmNhdGNoKChyZWFzb24pID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGxvYWQgd2FzbSBkYXRhIGF0OiAke3VybH1gKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBfZmV0Y2godXJsKSB7XG4gICAgdW5yZWFjaGFibGUoXCJBYnN0cmFjdCBtZXRob2QgYF9mZXRjaGAgY2FsbGVkLlwiKTtcbiAgfVxufVxuY2xhc3MgRE9NV2FzbUZhY3RvcnkgZXh0ZW5kcyBCYXNlV2FzbUZhY3Rvcnkge1xuICBhc3luYyBfZmV0Y2godXJsKSB7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IGZldGNoRGF0YSh1cmwsIFwiYXJyYXlidWZmZXJcIik7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB9XG59XG5pZiAoaXNOb2RlSlMpIHtcbiAgbGV0IGNhbnZhcztcbiAgdHJ5IHtcbiAgICBjb25zdCByZXF1aXJlJDEgPSBwcm9jZXNzLmdldEJ1aWx0aW5Nb2R1bGUoXCJtb2R1bGVcIikuY3JlYXRlUmVxdWlyZSh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIgPyByZXF1aXJlKFwidXJsXCIpLnBhdGhUb0ZpbGVVUkwoX19maWxlbmFtZSkuaHJlZiA6IF9kb2N1bWVudEN1cnJlbnRTY3JpcHQgJiYgX2RvY3VtZW50Q3VycmVudFNjcmlwdC50YWdOYW1lLnRvVXBwZXJDYXNlKCkgPT09IFwiU0NSSVBUXCIgJiYgX2RvY3VtZW50Q3VycmVudFNjcmlwdC5zcmMgfHwgbmV3IFVSTChcImluZGV4LmNqc1wiLCBkb2N1bWVudC5iYXNlVVJJKS5ocmVmKTtcbiAgICB0cnkge1xuICAgICAgY2FudmFzID0gcmVxdWlyZSQxKFwiQG5hcGktcnMvY2FudmFzXCIpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICB3YXJuKGBDYW5ub3QgbG9hZCBcIkBuYXBpLXJzL2NhbnZhc1wiIHBhY2thZ2U6IFwiJHtleH1cIi5gKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgd2FybihgQ2Fubm90IGFjY2VzcyB0aGUgXFxgcmVxdWlyZVxcYCBmdW5jdGlvbjogXCIke2V4fVwiLmApO1xuICB9XG4gIGlmICghZ2xvYmFsVGhpcy5ET01NYXRyaXgpIHtcbiAgICBpZiAoY2FudmFzPy5ET01NYXRyaXgpIHtcbiAgICAgIGdsb2JhbFRoaXMuRE9NTWF0cml4ID0gY2FudmFzLkRPTU1hdHJpeDtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybihcIkNhbm5vdCBwb2x5ZmlsbCBgRE9NTWF0cml4YCwgcmVuZGVyaW5nIG1heSBiZSBicm9rZW4uXCIpO1xuICAgIH1cbiAgfVxuICBpZiAoIWdsb2JhbFRoaXMuSW1hZ2VEYXRhKSB7XG4gICAgaWYgKGNhbnZhcz8uSW1hZ2VEYXRhKSB7XG4gICAgICBnbG9iYWxUaGlzLkltYWdlRGF0YSA9IGNhbnZhcy5JbWFnZURhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4oXCJDYW5ub3QgcG9seWZpbGwgYEltYWdlRGF0YWAsIHJlbmRlcmluZyBtYXkgYmUgYnJva2VuLlwiKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFnbG9iYWxUaGlzLlBhdGgyRCkge1xuICAgIGlmIChjYW52YXM/LlBhdGgyRCkge1xuICAgICAgZ2xvYmFsVGhpcy5QYXRoMkQgPSBjYW52YXMuUGF0aDJEO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKFwiQ2Fubm90IHBvbHlmaWxsIGBQYXRoMkRgLCByZW5kZXJpbmcgbWF5IGJlIGJyb2tlbi5cIik7XG4gICAgfVxuICB9XG4gIGlmICghZ2xvYmFsVGhpcy5uYXZpZ2F0b3I/Lmxhbmd1YWdlKSB7XG4gICAgZ2xvYmFsVGhpcy5uYXZpZ2F0b3IgPSB7XG4gICAgICBsYW5ndWFnZTogXCJlbi1VU1wiLFxuICAgICAgcGxhdGZvcm06IFwiXCIsXG4gICAgICB1c2VyQWdlbnQ6IFwiXCJcbiAgICB9O1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBub2RlX3V0aWxzX2ZldGNoRGF0YSh1cmwpIHtcbiAgY29uc3QgZnMgPSBwcm9jZXNzLmdldEJ1aWx0aW5Nb2R1bGUoXCJmc1wiKTtcbiAgY29uc3QgZGF0YSA9IGF3YWl0IGZzLnByb21pc2VzLnJlYWRGaWxlKHVybCk7XG4gIHJldHVybiBuZXcgVWludDhBcnJheShkYXRhKTtcbn1cbmNsYXNzIE5vZGVGaWx0ZXJGYWN0b3J5IGV4dGVuZHMgQmFzZUZpbHRlckZhY3Rvcnkge1xufVxuY2xhc3MgTm9kZUNhbnZhc0ZhY3RvcnkgZXh0ZW5kcyBCYXNlQ2FudmFzRmFjdG9yeSB7XG4gIF9jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHJlcXVpcmUkMSA9IHByb2Nlc3MuZ2V0QnVpbHRpbk1vZHVsZShcIm1vZHVsZVwiKS5jcmVhdGVSZXF1aXJlKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIiA/IHJlcXVpcmUoXCJ1cmxcIikucGF0aFRvRmlsZVVSTChfX2ZpbGVuYW1lKS5ocmVmIDogX2RvY3VtZW50Q3VycmVudFNjcmlwdCAmJiBfZG9jdW1lbnRDdXJyZW50U2NyaXB0LnRhZ05hbWUudG9VcHBlckNhc2UoKSA9PT0gXCJTQ1JJUFRcIiAmJiBfZG9jdW1lbnRDdXJyZW50U2NyaXB0LnNyYyB8fCBuZXcgVVJMKFwiaW5kZXguY2pzXCIsIGRvY3VtZW50LmJhc2VVUkkpLmhyZWYpO1xuICAgIGNvbnN0IGNhbnZhcyA9IHJlcXVpcmUkMShcIkBuYXBpLXJzL2NhbnZhc1wiKTtcbiAgICByZXR1cm4gY2FudmFzLmNyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgfVxufVxuY2xhc3MgTm9kZUNNYXBSZWFkZXJGYWN0b3J5IGV4dGVuZHMgQmFzZUNNYXBSZWFkZXJGYWN0b3J5IHtcbiAgYXN5bmMgX2ZldGNoKHVybCkge1xuICAgIHJldHVybiBub2RlX3V0aWxzX2ZldGNoRGF0YSh1cmwpO1xuICB9XG59XG5jbGFzcyBOb2RlU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgZXh0ZW5kcyBCYXNlU3RhbmRhcmRGb250RGF0YUZhY3Rvcnkge1xuICBhc3luYyBfZmV0Y2godXJsKSB7XG4gICAgcmV0dXJuIG5vZGVfdXRpbHNfZmV0Y2hEYXRhKHVybCk7XG4gIH1cbn1cbmNsYXNzIE5vZGVXYXNtRmFjdG9yeSBleHRlbmRzIEJhc2VXYXNtRmFjdG9yeSB7XG4gIGFzeW5jIF9mZXRjaCh1cmwpIHtcbiAgICByZXR1cm4gbm9kZV91dGlsc19mZXRjaERhdGEodXJsKTtcbiAgfVxufVxuX193ZWJwYWNrX3JlcXVpcmVfXyg3NTg4KTtcbmNvbnN0IEZPUkNFRF9ERVBFTkRFTkNZX0xBQkVMID0gXCJfX2ZvcmNlZERlcGVuZGVuY3lcIjtcbmNvbnN0IHtcbiAgZmxvb3IsXG4gIGNlaWxcbn0gPSBNYXRoO1xuZnVuY3Rpb24gZXhwYW5kQkJveChhcnJheSwgaW5kZXgsIG1pblgsIG1pblksIG1heFgsIG1heFkpIHtcbiAgYXJyYXlbaW5kZXggKiA0ICsgMF0gPSBNYXRoLm1pbihhcnJheVtpbmRleCAqIDQgKyAwXSwgbWluWCk7XG4gIGFycmF5W2luZGV4ICogNCArIDFdID0gTWF0aC5taW4oYXJyYXlbaW5kZXggKiA0ICsgMV0sIG1pblkpO1xuICBhcnJheVtpbmRleCAqIDQgKyAyXSA9IE1hdGgubWF4KGFycmF5W2luZGV4ICogNCArIDJdLCBtYXhYKTtcbiAgYXJyYXlbaW5kZXggKiA0ICsgM10gPSBNYXRoLm1heChhcnJheVtpbmRleCAqIDQgKyAzXSwgbWF4WSk7XG59XG5jb25zdCBFTVBUWV9CQk9YID0gbmV3IFVpbnQzMkFycmF5KG5ldyBVaW50OEFycmF5KFsyNTUsIDI1NSwgMCwgMF0pLmJ1ZmZlcilbMF07XG5jbGFzcyBCQm94UmVhZGVyIHtcbiAgI2Jib3hlcztcbiAgI2Nvb3JkcztcbiAgY29uc3RydWN0b3IoYmJveGVzLCBjb29yZHMpIHtcbiAgICB0aGlzLiNiYm94ZXMgPSBiYm94ZXM7XG4gICAgdGhpcy4jY29vcmRzID0gY29vcmRzO1xuICB9XG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Jib3hlcy5sZW5ndGg7XG4gIH1cbiAgaXNFbXB0eShpKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Jib3hlc1tpXSA9PT0gRU1QVFlfQkJPWDtcbiAgfVxuICBtaW5YKGkpIHtcbiAgICByZXR1cm4gdGhpcy4jY29vcmRzW2kgKiA0ICsgMF0gLyAyNTY7XG4gIH1cbiAgbWluWShpKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Nvb3Jkc1tpICogNCArIDFdIC8gMjU2O1xuICB9XG4gIG1heFgoaSkge1xuICAgIHJldHVybiAodGhpcy4jY29vcmRzW2kgKiA0ICsgMl0gKyAxKSAvIDI1NjtcbiAgfVxuICBtYXhZKGkpIHtcbiAgICByZXR1cm4gKHRoaXMuI2Nvb3Jkc1tpICogNCArIDNdICsgMSkgLyAyNTY7XG4gIH1cbn1cbmNvbnN0IGVuc3VyZURlYnVnTWV0YWRhdGEgPSAobWFwLCBrZXkpID0+IHtcbiAgaWYgKCFtYXApIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGxldCB2YWx1ZSA9IG1hcC5nZXQoa2V5KTtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHZhbHVlID0ge1xuICAgICAgZGVwZW5kZW5jaWVzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgICAgaXNSZW5kZXJpbmdPcGVyYXRpb246IGZhbHNlXG4gICAgfTtcbiAgICBtYXAuc2V0KGtleSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG5jbGFzcyBDYW52YXNEZXBlbmRlbmN5VHJhY2tlciB7XG4gICNzaW1wbGUgPSB7XG4gICAgX19wcm90b19fOiBudWxsXG4gIH07XG4gICNpbmNyZW1lbnRhbCA9IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgdHJhbnNmb3JtOiBbXSxcbiAgICBtb3ZlVGV4dDogW10sXG4gICAgc2FtZUxpbmVUZXh0OiBbXSxcbiAgICBbRk9SQ0VEX0RFUEVOREVOQ1lfTEFCRUxdOiBbXVxuICB9O1xuICAjbmFtZWREZXBlbmRlbmNpZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAjc2F2ZXNTdGFjayA9IFtdO1xuICAjbWFya2VkQ29udGVudFN0YWNrID0gW107XG4gICNiYXNlVHJhbnNmb3JtU3RhY2sgPSBbWzEsIDAsIDAsIDEsIDAsIDBdXTtcbiAgI2NsaXBCb3ggPSBbLUluZmluaXR5LCAtSW5maW5pdHksIEluZmluaXR5LCBJbmZpbml0eV07XG4gICNwZW5kaW5nQkJveCA9IG5ldyBGbG9hdDY0QXJyYXkoW0luZmluaXR5LCBJbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHldKTtcbiAgI3BlbmRpbmdCQm94SWR4ID0gLTE7XG4gICNwZW5kaW5nRGVwZW5kZW5jaWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgI29wZXJhdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAjZm9udEJCb3hUcnVzdHdvcnRoeSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICNjYW52YXNXaWR0aDtcbiAgI2NhbnZhc0hlaWdodDtcbiAgI2Jib3hlc0Nvb3JkcztcbiAgI2Jib3hlcztcbiAgI2RlYnVnTWV0YWRhdGE7XG4gIGNvbnN0cnVjdG9yKGNhbnZhcywgb3BlcmF0aW9uc0NvdW50LCByZWNvcmREZWJ1Z01ldGFkYXRhID0gZmFsc2UpIHtcbiAgICB0aGlzLiNjYW52YXNXaWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICB0aGlzLiNjYW52YXNIZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuICAgIHRoaXMuI2luaXRpYWxpemVCQm94ZXMob3BlcmF0aW9uc0NvdW50KTtcbiAgICBpZiAocmVjb3JkRGVidWdNZXRhZGF0YSkge1xuICAgICAgdGhpcy4jZGVidWdNZXRhZGF0YSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgfVxuICB9XG4gIGdyb3dPcGVyYXRpb25zQ291bnQob3BlcmF0aW9uc0NvdW50KSB7XG4gICAgaWYgKG9wZXJhdGlvbnNDb3VudCA+PSB0aGlzLiNiYm94ZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLiNpbml0aWFsaXplQkJveGVzKG9wZXJhdGlvbnNDb3VudCwgdGhpcy4jYmJveGVzKTtcbiAgICB9XG4gIH1cbiAgI2luaXRpYWxpemVCQm94ZXMob3BlcmF0aW9uc0NvdW50LCBvbGRCQm94ZXMpIHtcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIob3BlcmF0aW9uc0NvdW50ICogNCk7XG4gICAgdGhpcy4jYmJveGVzQ29vcmRzID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGJ1ZmZlcik7XG4gICAgdGhpcy4jYmJveGVzID0gbmV3IFVpbnQzMkFycmF5KGJ1ZmZlcik7XG4gICAgaWYgKG9sZEJCb3hlcyAmJiBvbGRCQm94ZXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy4jYmJveGVzLnNldChvbGRCQm94ZXMpO1xuICAgICAgdGhpcy4jYmJveGVzLmZpbGwoRU1QVFlfQkJPWCwgb2xkQkJveGVzLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2Jib3hlcy5maWxsKEVNUFRZX0JCT1gpO1xuICAgIH1cbiAgfVxuICBzYXZlKG9wSWR4KSB7XG4gICAgdGhpcy4jc2ltcGxlID0ge1xuICAgICAgX19wcm90b19fOiB0aGlzLiNzaW1wbGVcbiAgICB9O1xuICAgIHRoaXMuI2luY3JlbWVudGFsID0ge1xuICAgICAgX19wcm90b19fOiB0aGlzLiNpbmNyZW1lbnRhbCxcbiAgICAgIHRyYW5zZm9ybToge1xuICAgICAgICBfX3Byb3RvX186IHRoaXMuI2luY3JlbWVudGFsLnRyYW5zZm9ybVxuICAgICAgfSxcbiAgICAgIG1vdmVUZXh0OiB7XG4gICAgICAgIF9fcHJvdG9fXzogdGhpcy4jaW5jcmVtZW50YWwubW92ZVRleHRcbiAgICAgIH0sXG4gICAgICBzYW1lTGluZVRleHQ6IHtcbiAgICAgICAgX19wcm90b19fOiB0aGlzLiNpbmNyZW1lbnRhbC5zYW1lTGluZVRleHRcbiAgICAgIH0sXG4gICAgICBbRk9SQ0VEX0RFUEVOREVOQ1lfTEFCRUxdOiB7XG4gICAgICAgIF9fcHJvdG9fXzogdGhpcy4jaW5jcmVtZW50YWxbRk9SQ0VEX0RFUEVOREVOQ1lfTEFCRUxdXG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLiNjbGlwQm94ID0ge1xuICAgICAgX19wcm90b19fOiB0aGlzLiNjbGlwQm94XG4gICAgfTtcbiAgICB0aGlzLiNzYXZlc1N0YWNrLnB1c2gob3BJZHgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlc3RvcmUob3BJZHgpIHtcbiAgICBjb25zdCBwcmV2aW91cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzLiNzaW1wbGUpO1xuICAgIGlmIChwcmV2aW91cyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRoaXMuI3NpbXBsZSA9IHByZXZpb3VzO1xuICAgIHRoaXMuI2luY3JlbWVudGFsID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMuI2luY3JlbWVudGFsKTtcbiAgICB0aGlzLiNjbGlwQm94ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMuI2NsaXBCb3gpO1xuICAgIGNvbnN0IGxhc3RTYXZlID0gdGhpcy4jc2F2ZXNTdGFjay5wb3AoKTtcbiAgICBpZiAobGFzdFNhdmUgIT09IHZvaWQgMCkge1xuICAgICAgZW5zdXJlRGVidWdNZXRhZGF0YSh0aGlzLiNkZWJ1Z01ldGFkYXRhLCBvcElkeCk/LmRlcGVuZGVuY2llcy5hZGQobGFzdFNhdmUpO1xuICAgICAgdGhpcy4jYmJveGVzW29wSWR4XSA9IHRoaXMuI2Jib3hlc1tsYXN0U2F2ZV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZE9wZW5NYXJrZXIoaWR4KSB7XG4gICAgdGhpcy4jc2F2ZXNTdGFjay5wdXNoKGlkeCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZ2V0T3Blbk1hcmtlcigpIHtcbiAgICBpZiAodGhpcy4jc2F2ZXNTdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy4jc2F2ZXNTdGFjay5hdCgtMSk7XG4gIH1cbiAgcmVjb3JkQ2xvc2VNYXJrZXIob3BJZHgpIHtcbiAgICBjb25zdCBsYXN0U2F2ZSA9IHRoaXMuI3NhdmVzU3RhY2sucG9wKCk7XG4gICAgaWYgKGxhc3RTYXZlICE9PSB2b2lkIDApIHtcbiAgICAgIGVuc3VyZURlYnVnTWV0YWRhdGEodGhpcy4jZGVidWdNZXRhZGF0YSwgb3BJZHgpPy5kZXBlbmRlbmNpZXMuYWRkKGxhc3RTYXZlKTtcbiAgICAgIHRoaXMuI2Jib3hlc1tvcElkeF0gPSB0aGlzLiNiYm94ZXNbbGFzdFNhdmVdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBiZWdpbk1hcmtlZENvbnRlbnQob3BJZHgpIHtcbiAgICB0aGlzLiNtYXJrZWRDb250ZW50U3RhY2sucHVzaChvcElkeCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZW5kTWFya2VkQ29udGVudChvcElkeCkge1xuICAgIGNvbnN0IGxhc3RTYXZlID0gdGhpcy4jbWFya2VkQ29udGVudFN0YWNrLnBvcCgpO1xuICAgIGlmIChsYXN0U2F2ZSAhPT0gdm9pZCAwKSB7XG4gICAgICBlbnN1cmVEZWJ1Z01ldGFkYXRhKHRoaXMuI2RlYnVnTWV0YWRhdGEsIG9wSWR4KT8uZGVwZW5kZW5jaWVzLmFkZChsYXN0U2F2ZSk7XG4gICAgICB0aGlzLiNiYm94ZXNbb3BJZHhdID0gdGhpcy4jYmJveGVzW2xhc3RTYXZlXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcHVzaEJhc2VUcmFuc2Zvcm0oY3R4KSB7XG4gICAgdGhpcy4jYmFzZVRyYW5zZm9ybVN0YWNrLnB1c2goVXRpbC5tdWx0aXBseUJ5RE9NTWF0cml4KHRoaXMuI2Jhc2VUcmFuc2Zvcm1TdGFjay5hdCgtMSksIGN0eC5nZXRUcmFuc2Zvcm0oKSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHBvcEJhc2VUcmFuc2Zvcm0oKSB7XG4gICAgaWYgKHRoaXMuI2Jhc2VUcmFuc2Zvcm1TdGFjay5sZW5ndGggPiAxKSB7XG4gICAgICB0aGlzLiNiYXNlVHJhbnNmb3JtU3RhY2sucG9wKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZFNpbXBsZURhdGEobmFtZSwgaWR4KSB7XG4gICAgdGhpcy4jc2ltcGxlW25hbWVdID0gaWR4O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZEluY3JlbWVudGFsRGF0YShuYW1lLCBpZHgpIHtcbiAgICB0aGlzLiNpbmNyZW1lbnRhbFtuYW1lXS5wdXNoKGlkeCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVzZXRJbmNyZW1lbnRhbERhdGEobmFtZSwgaWR4KSB7XG4gICAgdGhpcy4jaW5jcmVtZW50YWxbbmFtZV0ubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmROYW1lZERhdGEobmFtZSwgaWR4KSB7XG4gICAgdGhpcy4jbmFtZWREZXBlbmRlbmNpZXMuc2V0KG5hbWUsIGlkeCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkU2ltcGxlRGF0YUZyb21OYW1lZChuYW1lLCBkZXBOYW1lLCBmYWxsYmFja0lkeCkge1xuICAgIHRoaXMuI3NpbXBsZVtuYW1lXSA9IHRoaXMuI25hbWVkRGVwZW5kZW5jaWVzLmdldChkZXBOYW1lKSA/PyBmYWxsYmFja0lkeDtcbiAgfVxuICByZWNvcmRGdXR1cmVGb3JjZWREZXBlbmRlbmN5KG5hbWUsIGlkeCkge1xuICAgIHRoaXMucmVjb3JkSW5jcmVtZW50YWxEYXRhKEZPUkNFRF9ERVBFTkRFTkNZX0xBQkVMLCBpZHgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGluaGVyaXRTaW1wbGVEYXRhQXNGdXR1cmVGb3JjZWREZXBlbmRlbmNpZXMobmFtZXMpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgbmFtZXMpIHtcbiAgICAgIGlmIChuYW1lIGluIHRoaXMuI3NpbXBsZSkge1xuICAgICAgICB0aGlzLnJlY29yZEZ1dHVyZUZvcmNlZERlcGVuZGVuY3kobmFtZSwgdGhpcy4jc2ltcGxlW25hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaW5oZXJpdFBlbmRpbmdEZXBlbmRlbmNpZXNBc0Z1dHVyZUZvcmNlZERlcGVuZGVuY2llcygpIHtcbiAgICBmb3IgKGNvbnN0IGRlcCBvZiB0aGlzLiNwZW5kaW5nRGVwZW5kZW5jaWVzKSB7XG4gICAgICB0aGlzLnJlY29yZEZ1dHVyZUZvcmNlZERlcGVuZGVuY3koRk9SQ0VEX0RFUEVOREVOQ1lfTEFCRUwsIGRlcCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlc2V0QkJveChpZHgpIHtcbiAgICBpZiAodGhpcy4jcGVuZGluZ0JCb3hJZHggIT09IGlkeCkge1xuICAgICAgdGhpcy4jcGVuZGluZ0JCb3hJZHggPSBpZHg7XG4gICAgICB0aGlzLiNwZW5kaW5nQkJveFswXSA9IEluZmluaXR5O1xuICAgICAgdGhpcy4jcGVuZGluZ0JCb3hbMV0gPSBJbmZpbml0eTtcbiAgICAgIHRoaXMuI3BlbmRpbmdCQm94WzJdID0gLUluZmluaXR5O1xuICAgICAgdGhpcy4jcGVuZGluZ0JCb3hbM10gPSAtSW5maW5pdHk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZENsaXBCb3goaWR4LCBjdHgsIG1pblgsIG1heFgsIG1pblksIG1heFkpIHtcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSBVdGlsLm11bHRpcGx5QnlET01NYXRyaXgodGhpcy4jYmFzZVRyYW5zZm9ybVN0YWNrLmF0KC0xKSwgY3R4LmdldFRyYW5zZm9ybSgpKTtcbiAgICBjb25zdCBjbGlwQm94ID0gW0luZmluaXR5LCBJbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHldO1xuICAgIFV0aWwuYXhpYWxBbGlnbmVkQm91bmRpbmdCb3goW21pblgsIG1pblksIG1heFgsIG1heFldLCB0cmFuc2Zvcm0sIGNsaXBCb3gpO1xuICAgIGNvbnN0IGludGVyc2VjdGlvbiA9IFV0aWwuaW50ZXJzZWN0KHRoaXMuI2NsaXBCb3gsIGNsaXBCb3gpO1xuICAgIGlmIChpbnRlcnNlY3Rpb24pIHtcbiAgICAgIHRoaXMuI2NsaXBCb3hbMF0gPSBpbnRlcnNlY3Rpb25bMF07XG4gICAgICB0aGlzLiNjbGlwQm94WzFdID0gaW50ZXJzZWN0aW9uWzFdO1xuICAgICAgdGhpcy4jY2xpcEJveFsyXSA9IGludGVyc2VjdGlvblsyXTtcbiAgICAgIHRoaXMuI2NsaXBCb3hbM10gPSBpbnRlcnNlY3Rpb25bM107XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2NsaXBCb3hbMF0gPSB0aGlzLiNjbGlwQm94WzFdID0gSW5maW5pdHk7XG4gICAgICB0aGlzLiNjbGlwQm94WzJdID0gdGhpcy4jY2xpcEJveFszXSA9IC1JbmZpbml0eTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkQkJveChpZHgsIGN0eCwgbWluWCwgbWF4WCwgbWluWSwgbWF4WSkge1xuICAgIGNvbnN0IGNsaXBCb3ggPSB0aGlzLiNjbGlwQm94O1xuICAgIGlmIChjbGlwQm94WzBdID09PSBJbmZpbml0eSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zZm9ybSA9IFV0aWwubXVsdGlwbHlCeURPTU1hdHJpeCh0aGlzLiNiYXNlVHJhbnNmb3JtU3RhY2suYXQoLTEpLCBjdHguZ2V0VHJhbnNmb3JtKCkpO1xuICAgIGlmIChjbGlwQm94WzBdID09PSAtSW5maW5pdHkpIHtcbiAgICAgIFV0aWwuYXhpYWxBbGlnbmVkQm91bmRpbmdCb3goW21pblgsIG1pblksIG1heFgsIG1heFldLCB0cmFuc2Zvcm0sIHRoaXMuI3BlbmRpbmdCQm94KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25zdCBiYm94ID0gW0luZmluaXR5LCBJbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHldO1xuICAgIFV0aWwuYXhpYWxBbGlnbmVkQm91bmRpbmdCb3goW21pblgsIG1pblksIG1heFgsIG1heFldLCB0cmFuc2Zvcm0sIGJib3gpO1xuICAgIHRoaXMuI3BlbmRpbmdCQm94WzBdID0gTWF0aC5taW4odGhpcy4jcGVuZGluZ0JCb3hbMF0sIE1hdGgubWF4KGJib3hbMF0sIGNsaXBCb3hbMF0pKTtcbiAgICB0aGlzLiNwZW5kaW5nQkJveFsxXSA9IE1hdGgubWluKHRoaXMuI3BlbmRpbmdCQm94WzFdLCBNYXRoLm1heChiYm94WzFdLCBjbGlwQm94WzFdKSk7XG4gICAgdGhpcy4jcGVuZGluZ0JCb3hbMl0gPSBNYXRoLm1heCh0aGlzLiNwZW5kaW5nQkJveFsyXSwgTWF0aC5taW4oYmJveFsyXSwgY2xpcEJveFsyXSkpO1xuICAgIHRoaXMuI3BlbmRpbmdCQm94WzNdID0gTWF0aC5tYXgodGhpcy4jcGVuZGluZ0JCb3hbM10sIE1hdGgubWluKGJib3hbM10sIGNsaXBCb3hbM10pKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmRDaGFyYWN0ZXJCQm94KGlkeCwgY3R4LCBmb250LCBzY2FsZSA9IDEsIHggPSAwLCB5ID0gMCwgZ2V0TWVhc3VyZSkge1xuICAgIGNvbnN0IGZvbnRCQm94ID0gZm9udC5iYm94O1xuICAgIGxldCBpc0JCb3hUcnVzdHdvcnRoeTtcbiAgICBsZXQgY29tcHV0ZWRCQm94O1xuICAgIGlmIChmb250QkJveCkge1xuICAgICAgaXNCQm94VHJ1c3R3b3J0aHkgPSBmb250QkJveFsyXSAhPT0gZm9udEJCb3hbMF0gJiYgZm9udEJCb3hbM10gIT09IGZvbnRCQm94WzFdICYmIHRoaXMuI2ZvbnRCQm94VHJ1c3R3b3J0aHkuZ2V0KGZvbnQpO1xuICAgICAgaWYgKGlzQkJveFRydXN0d29ydGh5ICE9PSBmYWxzZSkge1xuICAgICAgICBjb21wdXRlZEJCb3ggPSBbMCwgMCwgMCwgMF07XG4gICAgICAgIFV0aWwuYXhpYWxBbGlnbmVkQm91bmRpbmdCb3goZm9udEJCb3gsIGZvbnQuZm9udE1hdHJpeCwgY29tcHV0ZWRCQm94KTtcbiAgICAgICAgaWYgKHNjYWxlICE9PSAxIHx8IHggIT09IDAgfHwgeSAhPT0gMCkge1xuICAgICAgICAgIFV0aWwuc2NhbGVNaW5NYXgoW3NjYWxlLCAwLCAwLCAtc2NhbGUsIHgsIHldLCBjb21wdXRlZEJCb3gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0JCb3hUcnVzdHdvcnRoeSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJlY29yZEJCb3goaWR4LCBjdHgsIGNvbXB1dGVkQkJveFswXSwgY29tcHV0ZWRCQm94WzJdLCBjb21wdXRlZEJCb3hbMV0sIGNvbXB1dGVkQkJveFszXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFnZXRNZWFzdXJlKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWNvcmRGdWxsUGFnZUJCb3goaWR4KTtcbiAgICB9XG4gICAgY29uc3QgbWVhc3VyZSA9IGdldE1lYXN1cmUoKTtcbiAgICBpZiAoZm9udEJCb3ggJiYgY29tcHV0ZWRCQm94ICYmIGlzQkJveFRydXN0d29ydGh5ID09PSB2b2lkIDApIHtcbiAgICAgIGlzQkJveFRydXN0d29ydGh5ID0gY29tcHV0ZWRCQm94WzBdIDw9IHggLSBtZWFzdXJlLmFjdHVhbEJvdW5kaW5nQm94TGVmdCAmJiBjb21wdXRlZEJCb3hbMl0gPj0geCArIG1lYXN1cmUuYWN0dWFsQm91bmRpbmdCb3hSaWdodCAmJiBjb21wdXRlZEJCb3hbMV0gPD0geSAtIG1lYXN1cmUuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQgJiYgY29tcHV0ZWRCQm94WzNdID49IHkgKyBtZWFzdXJlLmFjdHVhbEJvdW5kaW5nQm94RGVzY2VudDtcbiAgICAgIHRoaXMuI2ZvbnRCQm94VHJ1c3R3b3J0aHkuc2V0KGZvbnQsIGlzQkJveFRydXN0d29ydGh5KTtcbiAgICAgIGlmIChpc0JCb3hUcnVzdHdvcnRoeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWNvcmRCQm94KGlkeCwgY3R4LCBjb21wdXRlZEJCb3hbMF0sIGNvbXB1dGVkQkJveFsyXSwgY29tcHV0ZWRCQm94WzFdLCBjb21wdXRlZEJCb3hbM10pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZWNvcmRCQm94KGlkeCwgY3R4LCB4IC0gbWVhc3VyZS5hY3R1YWxCb3VuZGluZ0JveExlZnQsIHggKyBtZWFzdXJlLmFjdHVhbEJvdW5kaW5nQm94UmlnaHQsIHkgLSBtZWFzdXJlLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50LCB5ICsgbWVhc3VyZS5hY3R1YWxCb3VuZGluZ0JveERlc2NlbnQpO1xuICB9XG4gIHJlY29yZEZ1bGxQYWdlQkJveChpZHgpIHtcbiAgICB0aGlzLiNwZW5kaW5nQkJveFswXSA9IE1hdGgubWF4KDAsIHRoaXMuI2NsaXBCb3hbMF0pO1xuICAgIHRoaXMuI3BlbmRpbmdCQm94WzFdID0gTWF0aC5tYXgoMCwgdGhpcy4jY2xpcEJveFsxXSk7XG4gICAgdGhpcy4jcGVuZGluZ0JCb3hbMl0gPSBNYXRoLm1pbih0aGlzLiNjYW52YXNXaWR0aCwgdGhpcy4jY2xpcEJveFsyXSk7XG4gICAgdGhpcy4jcGVuZGluZ0JCb3hbM10gPSBNYXRoLm1pbih0aGlzLiNjYW52YXNIZWlnaHQsIHRoaXMuI2NsaXBCb3hbM10pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdldFNpbXBsZUluZGV4KGRlcGVuZGVuY3lOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NpbXBsZVtkZXBlbmRlbmN5TmFtZV07XG4gIH1cbiAgcmVjb3JkRGVwZW5kZW5jaWVzKGlkeCwgZGVwZW5kZW5jeU5hbWVzKSB7XG4gICAgY29uc3QgcGVuZGluZ0RlcGVuZGVuY2llcyA9IHRoaXMuI3BlbmRpbmdEZXBlbmRlbmNpZXM7XG4gICAgY29uc3Qgc2ltcGxlID0gdGhpcy4jc2ltcGxlO1xuICAgIGNvbnN0IGluY3JlbWVudGFsID0gdGhpcy4jaW5jcmVtZW50YWw7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIGRlcGVuZGVuY3lOYW1lcykge1xuICAgICAgaWYgKG5hbWUgaW4gdGhpcy4jc2ltcGxlKSB7XG4gICAgICAgIHBlbmRpbmdEZXBlbmRlbmNpZXMuYWRkKHNpbXBsZVtuYW1lXSk7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgaW4gaW5jcmVtZW50YWwpIHtcbiAgICAgICAgaW5jcmVtZW50YWxbbmFtZV0uZm9yRWFjaChwZW5kaW5nRGVwZW5kZW5jaWVzLmFkZCwgcGVuZGluZ0RlcGVuZGVuY2llcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZE5hbWVkRGVwZW5kZW5jeShpZHgsIG5hbWUpIHtcbiAgICBpZiAodGhpcy4jbmFtZWREZXBlbmRlbmNpZXMuaGFzKG5hbWUpKSB7XG4gICAgICB0aGlzLiNwZW5kaW5nRGVwZW5kZW5jaWVzLmFkZCh0aGlzLiNuYW1lZERlcGVuZGVuY2llcy5nZXQobmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmRPcGVyYXRpb24oaWR4LCBwcmVzZXJ2ZSA9IGZhbHNlKSB7XG4gICAgdGhpcy5yZWNvcmREZXBlbmRlbmNpZXMoaWR4LCBbRk9SQ0VEX0RFUEVOREVOQ1lfTEFCRUxdKTtcbiAgICBpZiAodGhpcy4jZGVidWdNZXRhZGF0YSkge1xuICAgICAgY29uc3QgbWV0YWRhdGEgPSBlbnN1cmVEZWJ1Z01ldGFkYXRhKHRoaXMuI2RlYnVnTWV0YWRhdGEsIGlkeCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRlcGVuZGVuY2llc1xuICAgICAgfSA9IG1ldGFkYXRhO1xuICAgICAgdGhpcy4jcGVuZGluZ0RlcGVuZGVuY2llcy5mb3JFYWNoKGRlcGVuZGVuY2llcy5hZGQsIGRlcGVuZGVuY2llcyk7XG4gICAgICB0aGlzLiNzYXZlc1N0YWNrLmZvckVhY2goZGVwZW5kZW5jaWVzLmFkZCwgZGVwZW5kZW5jaWVzKTtcbiAgICAgIHRoaXMuI21hcmtlZENvbnRlbnRTdGFjay5mb3JFYWNoKGRlcGVuZGVuY2llcy5hZGQsIGRlcGVuZGVuY2llcyk7XG4gICAgICBkZXBlbmRlbmNpZXMuZGVsZXRlKGlkeCk7XG4gICAgICBtZXRhZGF0YS5pc1JlbmRlcmluZ09wZXJhdGlvbiA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLiNwZW5kaW5nQkJveElkeCA9PT0gaWR4KSB7XG4gICAgICBjb25zdCBtaW5YID0gZmxvb3IodGhpcy4jcGVuZGluZ0JCb3hbMF0gKiAyNTYgLyB0aGlzLiNjYW52YXNXaWR0aCk7XG4gICAgICBjb25zdCBtaW5ZID0gZmxvb3IodGhpcy4jcGVuZGluZ0JCb3hbMV0gKiAyNTYgLyB0aGlzLiNjYW52YXNIZWlnaHQpO1xuICAgICAgY29uc3QgbWF4WCA9IGNlaWwodGhpcy4jcGVuZGluZ0JCb3hbMl0gKiAyNTYgLyB0aGlzLiNjYW52YXNXaWR0aCk7XG4gICAgICBjb25zdCBtYXhZID0gY2VpbCh0aGlzLiNwZW5kaW5nQkJveFszXSAqIDI1NiAvIHRoaXMuI2NhbnZhc0hlaWdodCk7XG4gICAgICBleHBhbmRCQm94KHRoaXMuI2Jib3hlc0Nvb3JkcywgaWR4LCBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZKTtcbiAgICAgIGZvciAoY29uc3QgZGVwSWR4IG9mIHRoaXMuI3BlbmRpbmdEZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgaWYgKGRlcElkeCAhPT0gaWR4KSB7XG4gICAgICAgICAgZXhwYW5kQkJveCh0aGlzLiNiYm94ZXNDb29yZHMsIGRlcElkeCwgbWluWCwgbWluWSwgbWF4WCwgbWF4WSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qgc2F2ZUlkeCBvZiB0aGlzLiNzYXZlc1N0YWNrKSB7XG4gICAgICAgIGlmIChzYXZlSWR4ICE9PSBpZHgpIHtcbiAgICAgICAgICBleHBhbmRCQm94KHRoaXMuI2Jib3hlc0Nvb3Jkcywgc2F2ZUlkeCwgbWluWCwgbWluWSwgbWF4WCwgbWF4WSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qgc2F2ZUlkeCBvZiB0aGlzLiNtYXJrZWRDb250ZW50U3RhY2spIHtcbiAgICAgICAgaWYgKHNhdmVJZHggIT09IGlkeCkge1xuICAgICAgICAgIGV4cGFuZEJCb3godGhpcy4jYmJveGVzQ29vcmRzLCBzYXZlSWR4LCBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICB0aGlzLiNwZW5kaW5nRGVwZW5kZW5jaWVzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuI3BlbmRpbmdCQm94SWR4ID0gLTE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZFNob3dUZXh0T3BlcmF0aW9uKGlkeCwgcHJlc2VydmUgPSBmYWxzZSkge1xuICAgIGNvbnN0IGRlcHMgPSBBcnJheS5mcm9tKHRoaXMuI3BlbmRpbmdEZXBlbmRlbmNpZXMpO1xuICAgIHRoaXMucmVjb3JkT3BlcmF0aW9uKGlkeCwgcHJlc2VydmUpO1xuICAgIHRoaXMucmVjb3JkSW5jcmVtZW50YWxEYXRhKFwic2FtZUxpbmVUZXh0XCIsIGlkeCk7XG4gICAgZm9yIChjb25zdCBkZXAgb2YgZGVwcykge1xuICAgICAgdGhpcy5yZWNvcmRJbmNyZW1lbnRhbERhdGEoXCJzYW1lTGluZVRleHRcIiwgZGVwKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYmJveFRvQ2xpcEJveERyb3BPcGVyYXRpb24oaWR4LCBwcmVzZXJ2ZSA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuI3BlbmRpbmdCQm94SWR4ID09PSBpZHgpIHtcbiAgICAgIHRoaXMuI3BlbmRpbmdCQm94SWR4ID0gLTE7XG4gICAgICB0aGlzLiNjbGlwQm94WzBdID0gTWF0aC5tYXgodGhpcy4jY2xpcEJveFswXSwgdGhpcy4jcGVuZGluZ0JCb3hbMF0pO1xuICAgICAgdGhpcy4jY2xpcEJveFsxXSA9IE1hdGgubWF4KHRoaXMuI2NsaXBCb3hbMV0sIHRoaXMuI3BlbmRpbmdCQm94WzFdKTtcbiAgICAgIHRoaXMuI2NsaXBCb3hbMl0gPSBNYXRoLm1pbih0aGlzLiNjbGlwQm94WzJdLCB0aGlzLiNwZW5kaW5nQkJveFsyXSk7XG4gICAgICB0aGlzLiNjbGlwQm94WzNdID0gTWF0aC5taW4odGhpcy4jY2xpcEJveFszXSwgdGhpcy4jcGVuZGluZ0JCb3hbM10pO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICB0aGlzLiNwZW5kaW5nRGVwZW5kZW5jaWVzLmNsZWFyKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIF90YWtlUGVuZGluZ0RlcGVuZGVuY2llcygpIHtcbiAgICBjb25zdCBwZW5kaW5nRGVwZW5kZW5jaWVzID0gdGhpcy4jcGVuZGluZ0RlcGVuZGVuY2llcztcbiAgICB0aGlzLiNwZW5kaW5nRGVwZW5kZW5jaWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICByZXR1cm4gcGVuZGluZ0RlcGVuZGVuY2llcztcbiAgfVxuICBfZXh0cmFjdE9wZXJhdGlvbihpZHgpIHtcbiAgICBjb25zdCBvcGVyYXRpb24gPSB0aGlzLiNvcGVyYXRpb25zLmdldChpZHgpO1xuICAgIHRoaXMuI29wZXJhdGlvbnMuZGVsZXRlKGlkeCk7XG4gICAgcmV0dXJuIG9wZXJhdGlvbjtcbiAgfVxuICBfcHVzaFBlbmRpbmdEZXBlbmRlbmNpZXMoZGVwZW5kZW5jaWVzKSB7XG4gICAgZm9yIChjb25zdCBkZXAgb2YgZGVwZW5kZW5jaWVzKSB7XG4gICAgICB0aGlzLiNwZW5kaW5nRGVwZW5kZW5jaWVzLmFkZChkZXApO1xuICAgIH1cbiAgfVxuICB0YWtlKCkge1xuICAgIHRoaXMuI2ZvbnRCQm94VHJ1c3R3b3J0aHkuY2xlYXIoKTtcbiAgICByZXR1cm4gbmV3IEJCb3hSZWFkZXIodGhpcy4jYmJveGVzLCB0aGlzLiNiYm94ZXNDb29yZHMpO1xuICB9XG4gIHRha2VEZWJ1Z01ldGFkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLiNkZWJ1Z01ldGFkYXRhO1xuICB9XG59XG5jbGFzcyBDYW52YXNOZXN0ZWREZXBlbmRlbmN5VHJhY2tlciB7XG4gICNkZXBlbmRlbmN5VHJhY2tlcjtcbiAgI29wSWR4O1xuICAjaWdub3JlQkJveGVzO1xuICAjbmVzdGluZ0xldmVsID0gMDtcbiAgI3NhdmVzTGV2ZWwgPSAwO1xuICBjb25zdHJ1Y3RvcihkZXBlbmRlbmN5VHJhY2tlciwgb3BJZHgsIGlnbm9yZUJCb3hlcykge1xuICAgIGlmIChkZXBlbmRlbmN5VHJhY2tlciBpbnN0YW5jZW9mIENhbnZhc05lc3RlZERlcGVuZGVuY3lUcmFja2VyICYmIGRlcGVuZGVuY3lUcmFja2VyLiNpZ25vcmVCQm94ZXMgPT09ICEhaWdub3JlQkJveGVzKSB7XG4gICAgICByZXR1cm4gZGVwZW5kZW5jeVRyYWNrZXI7XG4gICAgfVxuICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyID0gZGVwZW5kZW5jeVRyYWNrZXI7XG4gICAgdGhpcy4jb3BJZHggPSBvcElkeDtcbiAgICB0aGlzLiNpZ25vcmVCQm94ZXMgPSAhIWlnbm9yZUJCb3hlcztcbiAgfVxuICBncm93T3BlcmF0aW9uc0NvdW50KCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVhY2hhYmxlXCIpO1xuICB9XG4gIHNhdmUob3BJZHgpIHtcbiAgICB0aGlzLiNzYXZlc0xldmVsKys7XG4gICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIuc2F2ZSh0aGlzLiNvcElkeCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVzdG9yZShvcElkeCkge1xuICAgIGlmICh0aGlzLiNzYXZlc0xldmVsID4gMCkge1xuICAgICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIucmVzdG9yZSh0aGlzLiNvcElkeCk7XG4gICAgICB0aGlzLiNzYXZlc0xldmVsLS07XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZE9wZW5NYXJrZXIoaWR4KSB7XG4gICAgdGhpcy4jbmVzdGluZ0xldmVsKys7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZ2V0T3Blbk1hcmtlcigpIHtcbiAgICByZXR1cm4gdGhpcy4jbmVzdGluZ0xldmVsID4gMCA/IHRoaXMuI29wSWR4IDogdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIuZ2V0T3Blbk1hcmtlcigpO1xuICB9XG4gIHJlY29yZENsb3NlTWFya2VyKGlkeCkge1xuICAgIHRoaXMuI25lc3RpbmdMZXZlbC0tO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGJlZ2luTWFya2VkQ29udGVudChvcElkeCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGVuZE1hcmtlZENvbnRlbnQob3BJZHgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBwdXNoQmFzZVRyYW5zZm9ybShjdHgpIHtcbiAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5wdXNoQmFzZVRyYW5zZm9ybShjdHgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHBvcEJhc2VUcmFuc2Zvcm0oKSB7XG4gICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIucG9wQmFzZVRyYW5zZm9ybSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZFNpbXBsZURhdGEobmFtZSwgaWR4KSB7XG4gICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIucmVjb3JkU2ltcGxlRGF0YShuYW1lLCB0aGlzLiNvcElkeCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkSW5jcmVtZW50YWxEYXRhKG5hbWUsIGlkeCkge1xuICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLnJlY29yZEluY3JlbWVudGFsRGF0YShuYW1lLCB0aGlzLiNvcElkeCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVzZXRJbmNyZW1lbnRhbERhdGEobmFtZSwgaWR4KSB7XG4gICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIucmVzZXRJbmNyZW1lbnRhbERhdGEobmFtZSwgdGhpcy4jb3BJZHgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZE5hbWVkRGF0YShuYW1lLCBpZHgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmRTaW1wbGVEYXRhRnJvbU5hbWVkKG5hbWUsIGRlcE5hbWUsIGZhbGxiYWNrSWR4KSB7XG4gICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIucmVjb3JkU2ltcGxlRGF0YUZyb21OYW1lZChuYW1lLCBkZXBOYW1lLCB0aGlzLiNvcElkeCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkRnV0dXJlRm9yY2VkRGVwZW5kZW5jeShuYW1lLCBpZHgpIHtcbiAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5yZWNvcmRGdXR1cmVGb3JjZWREZXBlbmRlbmN5KG5hbWUsIHRoaXMuI29wSWR4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpbmhlcml0U2ltcGxlRGF0YUFzRnV0dXJlRm9yY2VkRGVwZW5kZW5jaWVzKG5hbWVzKSB7XG4gICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIuaW5oZXJpdFNpbXBsZURhdGFBc0Z1dHVyZUZvcmNlZERlcGVuZGVuY2llcyhuYW1lcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaW5oZXJpdFBlbmRpbmdEZXBlbmRlbmNpZXNBc0Z1dHVyZUZvcmNlZERlcGVuZGVuY2llcygpIHtcbiAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5pbmhlcml0UGVuZGluZ0RlcGVuZGVuY2llc0FzRnV0dXJlRm9yY2VkRGVwZW5kZW5jaWVzKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVzZXRCQm94KGlkeCkge1xuICAgIGlmICghdGhpcy4jaWdub3JlQkJveGVzKSB7XG4gICAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5yZXNldEJCb3godGhpcy4jb3BJZHgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmRDbGlwQm94KGlkeCwgY3R4LCBtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZKSB7XG4gICAgaWYgKCF0aGlzLiNpZ25vcmVCQm94ZXMpIHtcbiAgICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLnJlY29yZENsaXBCb3godGhpcy4jb3BJZHgsIGN0eCwgbWluWCwgbWF4WCwgbWluWSwgbWF4WSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZEJCb3goaWR4LCBjdHgsIG1pblgsIG1heFgsIG1pblksIG1heFkpIHtcbiAgICBpZiAoIXRoaXMuI2lnbm9yZUJCb3hlcykge1xuICAgICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIucmVjb3JkQkJveCh0aGlzLiNvcElkeCwgY3R4LCBtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkQ2hhcmFjdGVyQkJveChpZHgsIGN0eCwgZm9udCwgc2NhbGUsIHgsIHksIGdldE1lYXN1cmUpIHtcbiAgICBpZiAoIXRoaXMuI2lnbm9yZUJCb3hlcykge1xuICAgICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIucmVjb3JkQ2hhcmFjdGVyQkJveCh0aGlzLiNvcElkeCwgY3R4LCBmb250LCBzY2FsZSwgeCwgeSwgZ2V0TWVhc3VyZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZEZ1bGxQYWdlQkJveChpZHgpIHtcbiAgICBpZiAoIXRoaXMuI2lnbm9yZUJCb3hlcykge1xuICAgICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIucmVjb3JkRnVsbFBhZ2VCQm94KHRoaXMuI29wSWR4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZ2V0U2ltcGxlSW5kZXgoZGVwZW5kZW5jeU5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIuZ2V0U2ltcGxlSW5kZXgoZGVwZW5kZW5jeU5hbWUpO1xuICB9XG4gIHJlY29yZERlcGVuZGVuY2llcyhpZHgsIGRlcGVuZGVuY3lOYW1lcykge1xuICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLnJlY29yZERlcGVuZGVuY2llcyh0aGlzLiNvcElkeCwgZGVwZW5kZW5jeU5hbWVzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmROYW1lZERlcGVuZGVuY3koaWR4LCBuYW1lKSB7XG4gICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIucmVjb3JkTmFtZWREZXBlbmRlbmN5KHRoaXMuI29wSWR4LCBuYW1lKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmRPcGVyYXRpb24oaWR4KSB7XG4gICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIucmVjb3JkT3BlcmF0aW9uKHRoaXMuI29wSWR4LCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmRTaG93VGV4dE9wZXJhdGlvbihpZHgpIHtcbiAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5yZWNvcmRTaG93VGV4dE9wZXJhdGlvbih0aGlzLiNvcElkeCwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYmJveFRvQ2xpcEJveERyb3BPcGVyYXRpb24oaWR4KSB7XG4gICAgaWYgKCF0aGlzLiNpZ25vcmVCQm94ZXMpIHtcbiAgICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLmJib3hUb0NsaXBCb3hEcm9wT3BlcmF0aW9uKHRoaXMuI29wSWR4LCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdGFrZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlYWNoYWJsZVwiKTtcbiAgfVxuICB0YWtlRGVidWdNZXRhZGF0YSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlYWNoYWJsZVwiKTtcbiAgfVxufVxuY29uc3QgRGVwZW5kZW5jaWVzID0ge1xuICBzdHJva2U6IFtcInBhdGhcIiwgXCJ0cmFuc2Zvcm1cIiwgXCJmaWx0ZXJcIiwgXCJzdHJva2VDb2xvclwiLCBcInN0cm9rZUFscGhhXCIsIFwibGluZVdpZHRoXCIsIFwibGluZUNhcFwiLCBcImxpbmVKb2luXCIsIFwibWl0ZXJMaW1pdFwiLCBcImRhc2hcIl0sXG4gIGZpbGw6IFtcInBhdGhcIiwgXCJ0cmFuc2Zvcm1cIiwgXCJmaWx0ZXJcIiwgXCJmaWxsQ29sb3JcIiwgXCJmaWxsQWxwaGFcIiwgXCJnbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cIiwgXCJTTWFza1wiXSxcbiAgaW1hZ2VYT2JqZWN0OiBbXCJ0cmFuc2Zvcm1cIiwgXCJTTWFza1wiLCBcImZpbHRlclwiLCBcImZpbGxBbHBoYVwiLCBcInN0cm9rZUFscGhhXCIsIFwiZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXCJdLFxuICByYXdGaWxsUGF0aDogW1wiZmlsdGVyXCIsIFwiZmlsbENvbG9yXCIsIFwiZmlsbEFscGhhXCJdLFxuICBzaG93VGV4dDogW1widHJhbnNmb3JtXCIsIFwibGVhZGluZ1wiLCBcImNoYXJTcGFjaW5nXCIsIFwid29yZFNwYWNpbmdcIiwgXCJoU2NhbGVcIiwgXCJ0ZXh0UmlzZVwiLCBcIm1vdmVUZXh0XCIsIFwidGV4dE1hdHJpeFwiLCBcImZvbnRcIiwgXCJmb250T2JqXCIsIFwiZmlsdGVyXCIsIFwiZmlsbENvbG9yXCIsIFwidGV4dFJlbmRlcmluZ01vZGVcIiwgXCJTTWFza1wiLCBcImZpbGxBbHBoYVwiLCBcInN0cm9rZUFscGhhXCIsIFwiZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXCIsIFwic2FtZUxpbmVUZXh0XCJdLFxuICB0cmFuc2Zvcm06IFtcInRyYW5zZm9ybVwiXSxcbiAgdHJhbnNmb3JtQW5kRmlsbDogW1widHJhbnNmb3JtXCIsIFwiZmlsbENvbG9yXCJdXG59O1xuY29uc3QgUGF0aFR5cGUgPSB7XG4gIEZJTEw6IFwiRmlsbFwiLFxuICBTVFJPS0U6IFwiU3Ryb2tlXCIsXG4gIFNIQURJTkc6IFwiU2hhZGluZ1wiXG59O1xuZnVuY3Rpb24gYXBwbHlCb3VuZGluZ0JveChjdHgsIGJib3gpIHtcbiAgaWYgKCFiYm94KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHdpZHRoID0gYmJveFsyXSAtIGJib3hbMF07XG4gIGNvbnN0IGhlaWdodCA9IGJib3hbM10gLSBiYm94WzFdO1xuICBjb25zdCByZWdpb24gPSBuZXcgUGF0aDJEKCk7XG4gIHJlZ2lvbi5yZWN0KGJib3hbMF0sIGJib3hbMV0sIHdpZHRoLCBoZWlnaHQpO1xuICBjdHguY2xpcChyZWdpb24pO1xufVxuY2xhc3MgQmFzZVNoYWRpbmdQYXR0ZXJuIHtcbiAgaXNNb2RpZnlpbmdDdXJyZW50VHJhbnNmb3JtKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBnZXRQYXR0ZXJuKCkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgbWV0aG9kIGBnZXRQYXR0ZXJuYCBjYWxsZWQuXCIpO1xuICB9XG59XG5jbGFzcyBSYWRpYWxBeGlhbFNoYWRpbmdQYXR0ZXJuIGV4dGVuZHMgQmFzZVNoYWRpbmdQYXR0ZXJuIHtcbiAgY29uc3RydWN0b3IoSVIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3R5cGUgPSBJUlsxXTtcbiAgICB0aGlzLl9iYm94ID0gSVJbMl07XG4gICAgdGhpcy5fY29sb3JTdG9wcyA9IElSWzNdO1xuICAgIHRoaXMuX3AwID0gSVJbNF07XG4gICAgdGhpcy5fcDEgPSBJUls1XTtcbiAgICB0aGlzLl9yMCA9IElSWzZdO1xuICAgIHRoaXMuX3IxID0gSVJbN107XG4gICAgdGhpcy5tYXRyaXggPSBudWxsO1xuICB9XG4gIF9jcmVhdGVHcmFkaWVudChjdHgpIHtcbiAgICBsZXQgZ3JhZDtcbiAgICBpZiAodGhpcy5fdHlwZSA9PT0gXCJheGlhbFwiKSB7XG4gICAgICBncmFkID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHRoaXMuX3AwWzBdLCB0aGlzLl9wMFsxXSwgdGhpcy5fcDFbMF0sIHRoaXMuX3AxWzFdKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3R5cGUgPT09IFwicmFkaWFsXCIpIHtcbiAgICAgIGdyYWQgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQodGhpcy5fcDBbMF0sIHRoaXMuX3AwWzFdLCB0aGlzLl9yMCwgdGhpcy5fcDFbMF0sIHRoaXMuX3AxWzFdLCB0aGlzLl9yMSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgY29sb3JTdG9wIG9mIHRoaXMuX2NvbG9yU3RvcHMpIHtcbiAgICAgIGdyYWQuYWRkQ29sb3JTdG9wKGNvbG9yU3RvcFswXSwgY29sb3JTdG9wWzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIGdyYWQ7XG4gIH1cbiAgZ2V0UGF0dGVybihjdHgsIG93bmVyLCBpbnZlcnNlLCBwYXRoVHlwZSkge1xuICAgIGxldCBwYXR0ZXJuO1xuICAgIGlmIChwYXRoVHlwZSA9PT0gUGF0aFR5cGUuU1RST0tFIHx8IHBhdGhUeXBlID09PSBQYXRoVHlwZS5GSUxMKSB7XG4gICAgICBjb25zdCBvd25lckJCb3ggPSBvd25lci5jdXJyZW50LmdldENsaXBwZWRQYXRoQm91bmRpbmdCb3gocGF0aFR5cGUsIGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KSkgfHwgWzAsIDAsIDAsIDBdO1xuICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLmNlaWwob3duZXJCQm94WzJdIC0gb3duZXJCQm94WzBdKSB8fCAxO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5jZWlsKG93bmVyQkJveFszXSAtIG93bmVyQkJveFsxXSkgfHwgMTtcbiAgICAgIGNvbnN0IHRtcENhbnZhcyA9IG93bmVyLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcInBhdHRlcm5cIiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjb25zdCB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICAgIHRtcEN0eC5jbGVhclJlY3QoMCwgMCwgdG1wQ3R4LmNhbnZhcy53aWR0aCwgdG1wQ3R4LmNhbnZhcy5oZWlnaHQpO1xuICAgICAgdG1wQ3R4LmJlZ2luUGF0aCgpO1xuICAgICAgdG1wQ3R4LnJlY3QoMCwgMCwgdG1wQ3R4LmNhbnZhcy53aWR0aCwgdG1wQ3R4LmNhbnZhcy5oZWlnaHQpO1xuICAgICAgdG1wQ3R4LnRyYW5zbGF0ZSgtb3duZXJCQm94WzBdLCAtb3duZXJCQm94WzFdKTtcbiAgICAgIGludmVyc2UgPSBVdGlsLnRyYW5zZm9ybShpbnZlcnNlLCBbMSwgMCwgMCwgMSwgb3duZXJCQm94WzBdLCBvd25lckJCb3hbMV1dKTtcbiAgICAgIHRtcEN0eC50cmFuc2Zvcm0oLi4ub3duZXIuYmFzZVRyYW5zZm9ybSk7XG4gICAgICBpZiAodGhpcy5tYXRyaXgpIHtcbiAgICAgICAgdG1wQ3R4LnRyYW5zZm9ybSguLi50aGlzLm1hdHJpeCk7XG4gICAgICB9XG4gICAgICBhcHBseUJvdW5kaW5nQm94KHRtcEN0eCwgdGhpcy5fYmJveCk7XG4gICAgICB0bXBDdHguZmlsbFN0eWxlID0gdGhpcy5fY3JlYXRlR3JhZGllbnQodG1wQ3R4KTtcbiAgICAgIHRtcEN0eC5maWxsKCk7XG4gICAgICBwYXR0ZXJuID0gY3R4LmNyZWF0ZVBhdHRlcm4odG1wQ2FudmFzLmNhbnZhcywgXCJuby1yZXBlYXRcIik7XG4gICAgICBjb25zdCBkb21NYXRyaXggPSBuZXcgRE9NTWF0cml4KGludmVyc2UpO1xuICAgICAgcGF0dGVybi5zZXRUcmFuc2Zvcm0oZG9tTWF0cml4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBwbHlCb3VuZGluZ0JveChjdHgsIHRoaXMuX2Jib3gpO1xuICAgICAgcGF0dGVybiA9IHRoaXMuX2NyZWF0ZUdyYWRpZW50KGN0eCk7XG4gICAgfVxuICAgIHJldHVybiBwYXR0ZXJuO1xuICB9XG59XG5mdW5jdGlvbiBkcmF3VHJpYW5nbGUoZGF0YSwgY29udGV4dCwgcDEsIHAyLCBwMywgYzEsIGMyLCBjMykge1xuICBjb25zdCBjb29yZHMgPSBjb250ZXh0LmNvb3JkcywgY29sb3JzID0gY29udGV4dC5jb2xvcnM7XG4gIGNvbnN0IGJ5dGVzID0gZGF0YS5kYXRhLCByb3dTaXplID0gZGF0YS53aWR0aCAqIDQ7XG4gIGxldCB0bXA7XG4gIGlmIChjb29yZHNbcDEgKyAxXSA+IGNvb3Jkc1twMiArIDFdKSB7XG4gICAgdG1wID0gcDE7XG4gICAgcDEgPSBwMjtcbiAgICBwMiA9IHRtcDtcbiAgICB0bXAgPSBjMTtcbiAgICBjMSA9IGMyO1xuICAgIGMyID0gdG1wO1xuICB9XG4gIGlmIChjb29yZHNbcDIgKyAxXSA+IGNvb3Jkc1twMyArIDFdKSB7XG4gICAgdG1wID0gcDI7XG4gICAgcDIgPSBwMztcbiAgICBwMyA9IHRtcDtcbiAgICB0bXAgPSBjMjtcbiAgICBjMiA9IGMzO1xuICAgIGMzID0gdG1wO1xuICB9XG4gIGlmIChjb29yZHNbcDEgKyAxXSA+IGNvb3Jkc1twMiArIDFdKSB7XG4gICAgdG1wID0gcDE7XG4gICAgcDEgPSBwMjtcbiAgICBwMiA9IHRtcDtcbiAgICB0bXAgPSBjMTtcbiAgICBjMSA9IGMyO1xuICAgIGMyID0gdG1wO1xuICB9XG4gIGNvbnN0IHgxID0gKGNvb3Jkc1twMV0gKyBjb250ZXh0Lm9mZnNldFgpICogY29udGV4dC5zY2FsZVg7XG4gIGNvbnN0IHkxID0gKGNvb3Jkc1twMSArIDFdICsgY29udGV4dC5vZmZzZXRZKSAqIGNvbnRleHQuc2NhbGVZO1xuICBjb25zdCB4MiA9IChjb29yZHNbcDJdICsgY29udGV4dC5vZmZzZXRYKSAqIGNvbnRleHQuc2NhbGVYO1xuICBjb25zdCB5MiA9IChjb29yZHNbcDIgKyAxXSArIGNvbnRleHQub2Zmc2V0WSkgKiBjb250ZXh0LnNjYWxlWTtcbiAgY29uc3QgeDMgPSAoY29vcmRzW3AzXSArIGNvbnRleHQub2Zmc2V0WCkgKiBjb250ZXh0LnNjYWxlWDtcbiAgY29uc3QgeTMgPSAoY29vcmRzW3AzICsgMV0gKyBjb250ZXh0Lm9mZnNldFkpICogY29udGV4dC5zY2FsZVk7XG4gIGlmICh5MSA+PSB5Mykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjMXIgPSBjb2xvcnNbYzFdLCBjMWcgPSBjb2xvcnNbYzEgKyAxXSwgYzFiID0gY29sb3JzW2MxICsgMl07XG4gIGNvbnN0IGMyciA9IGNvbG9yc1tjMl0sIGMyZyA9IGNvbG9yc1tjMiArIDFdLCBjMmIgPSBjb2xvcnNbYzIgKyAyXTtcbiAgY29uc3QgYzNyID0gY29sb3JzW2MzXSwgYzNnID0gY29sb3JzW2MzICsgMV0sIGMzYiA9IGNvbG9yc1tjMyArIDJdO1xuICBjb25zdCBtaW5ZID0gTWF0aC5yb3VuZCh5MSksIG1heFkgPSBNYXRoLnJvdW5kKHkzKTtcbiAgbGV0IHhhLCBjYXIsIGNhZywgY2FiO1xuICBsZXQgeGIsIGNiciwgY2JnLCBjYmI7XG4gIGZvciAobGV0IHkgPSBtaW5ZOyB5IDw9IG1heFk7IHkrKykge1xuICAgIGlmICh5IDwgeTIpIHtcbiAgICAgIGNvbnN0IGsyID0geSA8IHkxID8gMCA6ICh5MSAtIHkpIC8gKHkxIC0geTIpO1xuICAgICAgeGEgPSB4MSAtICh4MSAtIHgyKSAqIGsyO1xuICAgICAgY2FyID0gYzFyIC0gKGMxciAtIGMycikgKiBrMjtcbiAgICAgIGNhZyA9IGMxZyAtIChjMWcgLSBjMmcpICogazI7XG4gICAgICBjYWIgPSBjMWIgLSAoYzFiIC0gYzJiKSAqIGsyO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgazI7XG4gICAgICBpZiAoeSA+IHkzKSB7XG4gICAgICAgIGsyID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoeTIgPT09IHkzKSB7XG4gICAgICAgIGsyID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGsyID0gKHkyIC0geSkgLyAoeTIgLSB5Myk7XG4gICAgICB9XG4gICAgICB4YSA9IHgyIC0gKHgyIC0geDMpICogazI7XG4gICAgICBjYXIgPSBjMnIgLSAoYzJyIC0gYzNyKSAqIGsyO1xuICAgICAgY2FnID0gYzJnIC0gKGMyZyAtIGMzZykgKiBrMjtcbiAgICAgIGNhYiA9IGMyYiAtIChjMmIgLSBjM2IpICogazI7XG4gICAgfVxuICAgIGxldCBrO1xuICAgIGlmICh5IDwgeTEpIHtcbiAgICAgIGsgPSAwO1xuICAgIH0gZWxzZSBpZiAoeSA+IHkzKSB7XG4gICAgICBrID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgayA9ICh5MSAtIHkpIC8gKHkxIC0geTMpO1xuICAgIH1cbiAgICB4YiA9IHgxIC0gKHgxIC0geDMpICogaztcbiAgICBjYnIgPSBjMXIgLSAoYzFyIC0gYzNyKSAqIGs7XG4gICAgY2JnID0gYzFnIC0gKGMxZyAtIGMzZykgKiBrO1xuICAgIGNiYiA9IGMxYiAtIChjMWIgLSBjM2IpICogaztcbiAgICBjb25zdCB4MV8gPSBNYXRoLnJvdW5kKE1hdGgubWluKHhhLCB4YikpO1xuICAgIGNvbnN0IHgyXyA9IE1hdGgucm91bmQoTWF0aC5tYXgoeGEsIHhiKSk7XG4gICAgbGV0IGogPSByb3dTaXplICogeSArIHgxXyAqIDQ7XG4gICAgZm9yIChsZXQgeCA9IHgxXzsgeCA8PSB4Ml87IHgrKykge1xuICAgICAgayA9ICh4YSAtIHgpIC8gKHhhIC0geGIpO1xuICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgIGsgPSAwO1xuICAgICAgfSBlbHNlIGlmIChrID4gMSkge1xuICAgICAgICBrID0gMTtcbiAgICAgIH1cbiAgICAgIGJ5dGVzW2orK10gPSBjYXIgLSAoY2FyIC0gY2JyKSAqIGsgfCAwO1xuICAgICAgYnl0ZXNbaisrXSA9IGNhZyAtIChjYWcgLSBjYmcpICogayB8IDA7XG4gICAgICBieXRlc1tqKytdID0gY2FiIC0gKGNhYiAtIGNiYikgKiBrIHwgMDtcbiAgICAgIGJ5dGVzW2orK10gPSAyNTU7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkcmF3RmlndXJlKGRhdGEsIGZpZ3VyZSwgY29udGV4dCkge1xuICBjb25zdCBwcyA9IGZpZ3VyZS5jb29yZHM7XG4gIGNvbnN0IGNzID0gZmlndXJlLmNvbG9ycztcbiAgbGV0IGksIGlpO1xuICBzd2l0Y2ggKGZpZ3VyZS50eXBlKSB7XG4gICAgY2FzZSBcImxhdHRpY2VcIjpcbiAgICAgIGNvbnN0IHZlcnRpY2VzUGVyUm93ID0gZmlndXJlLnZlcnRpY2VzUGVyUm93O1xuICAgICAgY29uc3Qgcm93cyA9IE1hdGguZmxvb3IocHMubGVuZ3RoIC8gdmVydGljZXNQZXJSb3cpIC0gMTtcbiAgICAgIGNvbnN0IGNvbHMgPSB2ZXJ0aWNlc1BlclJvdyAtIDE7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICAgIGxldCBxID0gaSAqIHZlcnRpY2VzUGVyUm93O1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbHM7IGorKywgcSsrKSB7XG4gICAgICAgICAgZHJhd1RyaWFuZ2xlKGRhdGEsIGNvbnRleHQsIHBzW3FdLCBwc1txICsgMV0sIHBzW3EgKyB2ZXJ0aWNlc1BlclJvd10sIGNzW3FdLCBjc1txICsgMV0sIGNzW3EgKyB2ZXJ0aWNlc1BlclJvd10pO1xuICAgICAgICAgIGRyYXdUcmlhbmdsZShkYXRhLCBjb250ZXh0LCBwc1txICsgdmVydGljZXNQZXJSb3cgKyAxXSwgcHNbcSArIDFdLCBwc1txICsgdmVydGljZXNQZXJSb3ddLCBjc1txICsgdmVydGljZXNQZXJSb3cgKyAxXSwgY3NbcSArIDFdLCBjc1txICsgdmVydGljZXNQZXJSb3ddKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInRyaWFuZ2xlc1wiOlxuICAgICAgZm9yIChpID0gMCwgaWkgPSBwcy5sZW5ndGg7IGkgPCBpaTsgaSArPSAzKSB7XG4gICAgICAgIGRyYXdUcmlhbmdsZShkYXRhLCBjb250ZXh0LCBwc1tpXSwgcHNbaSArIDFdLCBwc1tpICsgMl0sIGNzW2ldLCBjc1tpICsgMV0sIGNzW2kgKyAyXSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBmaWd1cmVcIik7XG4gIH1cbn1cbmNsYXNzIE1lc2hTaGFkaW5nUGF0dGVybiBleHRlbmRzIEJhc2VTaGFkaW5nUGF0dGVybiB7XG4gIGNvbnN0cnVjdG9yKElSKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9jb29yZHMgPSBJUlsyXTtcbiAgICB0aGlzLl9jb2xvcnMgPSBJUlszXTtcbiAgICB0aGlzLl9maWd1cmVzID0gSVJbNF07XG4gICAgdGhpcy5fYm91bmRzID0gSVJbNV07XG4gICAgdGhpcy5fYmJveCA9IElSWzZdO1xuICAgIHRoaXMuX2JhY2tncm91bmQgPSBJUls3XTtcbiAgICB0aGlzLm1hdHJpeCA9IG51bGw7XG4gIH1cbiAgX2NyZWF0ZU1lc2hDYW52YXMoY29tYmluZWRTY2FsZSwgYmFja2dyb3VuZENvbG9yLCBjYWNoZWRDYW52YXNlcykge1xuICAgIGNvbnN0IEVYUEVDVEVEX1NDQUxFID0gMS4xO1xuICAgIGNvbnN0IE1BWF9QQVRURVJOX1NJWkUgPSAzZTM7XG4gICAgY29uc3QgQk9SREVSX1NJWkUgPSAyO1xuICAgIGNvbnN0IG9mZnNldFggPSBNYXRoLmZsb29yKHRoaXMuX2JvdW5kc1swXSk7XG4gICAgY29uc3Qgb2Zmc2V0WSA9IE1hdGguZmxvb3IodGhpcy5fYm91bmRzWzFdKTtcbiAgICBjb25zdCBib3VuZHNXaWR0aCA9IE1hdGguY2VpbCh0aGlzLl9ib3VuZHNbMl0pIC0gb2Zmc2V0WDtcbiAgICBjb25zdCBib3VuZHNIZWlnaHQgPSBNYXRoLmNlaWwodGhpcy5fYm91bmRzWzNdKSAtIG9mZnNldFk7XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLm1pbihNYXRoLmNlaWwoTWF0aC5hYnMoYm91bmRzV2lkdGggKiBjb21iaW5lZFNjYWxlWzBdICogRVhQRUNURURfU0NBTEUpKSwgTUFYX1BBVFRFUk5fU0laRSk7XG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5taW4oTWF0aC5jZWlsKE1hdGguYWJzKGJvdW5kc0hlaWdodCAqIGNvbWJpbmVkU2NhbGVbMV0gKiBFWFBFQ1RFRF9TQ0FMRSkpLCBNQVhfUEFUVEVSTl9TSVpFKTtcbiAgICBjb25zdCBzY2FsZVggPSBib3VuZHNXaWR0aCAvIHdpZHRoO1xuICAgIGNvbnN0IHNjYWxlWSA9IGJvdW5kc0hlaWdodCAvIGhlaWdodDtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgY29vcmRzOiB0aGlzLl9jb29yZHMsXG4gICAgICBjb2xvcnM6IHRoaXMuX2NvbG9ycyxcbiAgICAgIG9mZnNldFg6IC1vZmZzZXRYLFxuICAgICAgb2Zmc2V0WTogLW9mZnNldFksXG4gICAgICBzY2FsZVg6IDEgLyBzY2FsZVgsXG4gICAgICBzY2FsZVk6IDEgLyBzY2FsZVlcbiAgICB9O1xuICAgIGNvbnN0IHBhZGRlZFdpZHRoID0gd2lkdGggKyBCT1JERVJfU0laRSAqIDI7XG4gICAgY29uc3QgcGFkZGVkSGVpZ2h0ID0gaGVpZ2h0ICsgQk9SREVSX1NJWkUgKiAyO1xuICAgIGNvbnN0IHRtcENhbnZhcyA9IGNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcIm1lc2hcIiwgcGFkZGVkV2lkdGgsIHBhZGRlZEhlaWdodCk7XG4gICAgY29uc3QgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgY29uc3QgZGF0YSA9IHRtcEN0eC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIGhlaWdodCk7XG4gICAgaWYgKGJhY2tncm91bmRDb2xvcikge1xuICAgICAgY29uc3QgYnl0ZXMgPSBkYXRhLmRhdGE7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBieXRlcy5sZW5ndGg7IGkgPCBpaTsgaSArPSA0KSB7XG4gICAgICAgIGJ5dGVzW2ldID0gYmFja2dyb3VuZENvbG9yWzBdO1xuICAgICAgICBieXRlc1tpICsgMV0gPSBiYWNrZ3JvdW5kQ29sb3JbMV07XG4gICAgICAgIGJ5dGVzW2kgKyAyXSA9IGJhY2tncm91bmRDb2xvclsyXTtcbiAgICAgICAgYnl0ZXNbaSArIDNdID0gMjU1O1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGZpZ3VyZSBvZiB0aGlzLl9maWd1cmVzKSB7XG4gICAgICBkcmF3RmlndXJlKGRhdGEsIGZpZ3VyZSwgY29udGV4dCk7XG4gICAgfVxuICAgIHRtcEN0eC5wdXRJbWFnZURhdGEoZGF0YSwgQk9SREVSX1NJWkUsIEJPUkRFUl9TSVpFKTtcbiAgICBjb25zdCBjYW52YXMgPSB0bXBDYW52YXMuY2FudmFzO1xuICAgIHJldHVybiB7XG4gICAgICBjYW52YXMsXG4gICAgICBvZmZzZXRYOiBvZmZzZXRYIC0gQk9SREVSX1NJWkUgKiBzY2FsZVgsXG4gICAgICBvZmZzZXRZOiBvZmZzZXRZIC0gQk9SREVSX1NJWkUgKiBzY2FsZVksXG4gICAgICBzY2FsZVgsXG4gICAgICBzY2FsZVlcbiAgICB9O1xuICB9XG4gIGlzTW9kaWZ5aW5nQ3VycmVudFRyYW5zZm9ybSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBnZXRQYXR0ZXJuKGN0eCwgb3duZXIsIGludmVyc2UsIHBhdGhUeXBlKSB7XG4gICAgYXBwbHlCb3VuZGluZ0JveChjdHgsIHRoaXMuX2Jib3gpO1xuICAgIGNvbnN0IHNjYWxlID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcbiAgICBpZiAocGF0aFR5cGUgPT09IFBhdGhUeXBlLlNIQURJTkcpIHtcbiAgICAgIFV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUoZ2V0Q3VycmVudFRyYW5zZm9ybShjdHgpLCBzY2FsZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1hdHJpeCkge1xuICAgICAgVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZSh0aGlzLm1hdHJpeCwgc2NhbGUpO1xuICAgICAgY29uc3QgW21hdHJpeFNjYWxlWCwgbWF0cml4U2NhbGVZXSA9IHNjYWxlO1xuICAgICAgVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZShvd25lci5iYXNlVHJhbnNmb3JtLCBzY2FsZSk7XG4gICAgICBzY2FsZVswXSAqPSBtYXRyaXhTY2FsZVg7XG4gICAgICBzY2FsZVsxXSAqPSBtYXRyaXhTY2FsZVk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUob3duZXIuYmFzZVRyYW5zZm9ybSwgc2NhbGUpO1xuICAgIH1cbiAgICBjb25zdCB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzID0gdGhpcy5fY3JlYXRlTWVzaENhbnZhcyhzY2FsZSwgcGF0aFR5cGUgPT09IFBhdGhUeXBlLlNIQURJTkcgPyBudWxsIDogdGhpcy5fYmFja2dyb3VuZCwgb3duZXIuY2FjaGVkQ2FudmFzZXMpO1xuICAgIGlmIChwYXRoVHlwZSAhPT0gUGF0aFR5cGUuU0hBRElORykge1xuICAgICAgY3R4LnNldFRyYW5zZm9ybSguLi5vd25lci5iYXNlVHJhbnNmb3JtKTtcbiAgICAgIGlmICh0aGlzLm1hdHJpeCkge1xuICAgICAgICBjdHgudHJhbnNmb3JtKC4uLnRoaXMubWF0cml4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY3R4LnRyYW5zbGF0ZSh0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLm9mZnNldFgsIHRlbXBvcmFyeVBhdHRlcm5DYW52YXMub2Zmc2V0WSk7XG4gICAgY3R4LnNjYWxlKHRlbXBvcmFyeVBhdHRlcm5DYW52YXMuc2NhbGVYLCB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLnNjYWxlWSk7XG4gICAgcmV0dXJuIGN0eC5jcmVhdGVQYXR0ZXJuKHRlbXBvcmFyeVBhdHRlcm5DYW52YXMuY2FudmFzLCBcIm5vLXJlcGVhdFwiKTtcbiAgfVxufVxuY2xhc3MgRHVtbXlTaGFkaW5nUGF0dGVybiBleHRlbmRzIEJhc2VTaGFkaW5nUGF0dGVybiB7XG4gIGdldFBhdHRlcm4oKSB7XG4gICAgcmV0dXJuIFwiaG90cGlua1wiO1xuICB9XG59XG5mdW5jdGlvbiBnZXRTaGFkaW5nUGF0dGVybihJUikge1xuICBzd2l0Y2ggKElSWzBdKSB7XG4gICAgY2FzZSBcIlJhZGlhbEF4aWFsXCI6XG4gICAgICByZXR1cm4gbmV3IFJhZGlhbEF4aWFsU2hhZGluZ1BhdHRlcm4oSVIpO1xuICAgIGNhc2UgXCJNZXNoXCI6XG4gICAgICByZXR1cm4gbmV3IE1lc2hTaGFkaW5nUGF0dGVybihJUik7XG4gICAgY2FzZSBcIkR1bW15XCI6XG4gICAgICByZXR1cm4gbmV3IER1bW15U2hhZGluZ1BhdHRlcm4oKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gSVIgdHlwZTogJHtJUlswXX1gKTtcbn1cbmNvbnN0IFBhaW50VHlwZSA9IHtcbiAgQ09MT1JFRDogMSxcbiAgVU5DT0xPUkVEOiAyXG59O1xuY2xhc3MgVGlsaW5nUGF0dGVybiB7XG4gIHN0YXRpYyBNQVhfUEFUVEVSTl9TSVpFID0gM2UzO1xuICBjb25zdHJ1Y3RvcihJUiwgY3R4LCBjYW52YXNHcmFwaGljc0ZhY3RvcnksIGJhc2VUcmFuc2Zvcm0pIHtcbiAgICB0aGlzLmNvbG9yID0gSVJbMV07XG4gICAgdGhpcy5vcGVyYXRvckxpc3QgPSBJUlsyXTtcbiAgICB0aGlzLm1hdHJpeCA9IElSWzNdO1xuICAgIHRoaXMuYmJveCA9IElSWzRdO1xuICAgIHRoaXMueHN0ZXAgPSBJUls1XTtcbiAgICB0aGlzLnlzdGVwID0gSVJbNl07XG4gICAgdGhpcy5wYWludFR5cGUgPSBJUls3XTtcbiAgICB0aGlzLnRpbGluZ1R5cGUgPSBJUls4XTtcbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLmNhbnZhc0dyYXBoaWNzRmFjdG9yeSA9IGNhbnZhc0dyYXBoaWNzRmFjdG9yeTtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSBiYXNlVHJhbnNmb3JtO1xuICB9XG4gIGNyZWF0ZVBhdHRlcm5DYW52YXMob3duZXIsIG9wSWR4KSB7XG4gICAgY29uc3Qge1xuICAgICAgYmJveCxcbiAgICAgIG9wZXJhdG9yTGlzdCxcbiAgICAgIHBhaW50VHlwZSxcbiAgICAgIHRpbGluZ1R5cGUsXG4gICAgICBjb2xvcixcbiAgICAgIGNhbnZhc0dyYXBoaWNzRmFjdG9yeVxuICAgIH0gPSB0aGlzO1xuICAgIGxldCB7XG4gICAgICB4c3RlcCxcbiAgICAgIHlzdGVwXG4gICAgfSA9IHRoaXM7XG4gICAgeHN0ZXAgPSBNYXRoLmFicyh4c3RlcCk7XG4gICAgeXN0ZXAgPSBNYXRoLmFicyh5c3RlcCk7XG4gICAgaW5mbyhcIlRpbGluZ1R5cGU6IFwiICsgdGlsaW5nVHlwZSk7XG4gICAgY29uc3QgeDAgPSBiYm94WzBdLCB5MCA9IGJib3hbMV0sIHgxID0gYmJveFsyXSwgeTEgPSBiYm94WzNdO1xuICAgIGNvbnN0IHdpZHRoID0geDEgLSB4MDtcbiAgICBjb25zdCBoZWlnaHQgPSB5MSAtIHkwO1xuICAgIGNvbnN0IHNjYWxlID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcbiAgICBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRoaXMubWF0cml4LCBzY2FsZSk7XG4gICAgY29uc3QgW21hdHJpeFNjYWxlWCwgbWF0cml4U2NhbGVZXSA9IHNjYWxlO1xuICAgIFV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUodGhpcy5iYXNlVHJhbnNmb3JtLCBzY2FsZSk7XG4gICAgY29uc3QgY29tYmluZWRTY2FsZVggPSBtYXRyaXhTY2FsZVggKiBzY2FsZVswXTtcbiAgICBjb25zdCBjb21iaW5lZFNjYWxlWSA9IG1hdHJpeFNjYWxlWSAqIHNjYWxlWzFdO1xuICAgIGxldCBjYW52YXNXaWR0aCA9IHdpZHRoLCBjYW52YXNIZWlnaHQgPSBoZWlnaHQsIHJlZHJhd0hvcml6b250YWxseSA9IGZhbHNlLCByZWRyYXdWZXJ0aWNhbGx5ID0gZmFsc2U7XG4gICAgY29uc3QgeFNjYWxlZFN0ZXAgPSBNYXRoLmNlaWwoeHN0ZXAgKiBjb21iaW5lZFNjYWxlWCk7XG4gICAgY29uc3QgeVNjYWxlZFN0ZXAgPSBNYXRoLmNlaWwoeXN0ZXAgKiBjb21iaW5lZFNjYWxlWSk7XG4gICAgY29uc3QgeFNjYWxlZFdpZHRoID0gTWF0aC5jZWlsKHdpZHRoICogY29tYmluZWRTY2FsZVgpO1xuICAgIGNvbnN0IHlTY2FsZWRIZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0ICogY29tYmluZWRTY2FsZVkpO1xuICAgIGlmICh4U2NhbGVkU3RlcCA+PSB4U2NhbGVkV2lkdGgpIHtcbiAgICAgIGNhbnZhc1dpZHRoID0geHN0ZXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZHJhd0hvcml6b250YWxseSA9IHRydWU7XG4gICAgfVxuICAgIGlmICh5U2NhbGVkU3RlcCA+PSB5U2NhbGVkSGVpZ2h0KSB7XG4gICAgICBjYW52YXNIZWlnaHQgPSB5c3RlcDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVkcmF3VmVydGljYWxseSA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGRpbXggPSB0aGlzLmdldFNpemVBbmRTY2FsZShjYW52YXNXaWR0aCwgdGhpcy5jdHguY2FudmFzLndpZHRoLCBjb21iaW5lZFNjYWxlWCk7XG4gICAgY29uc3QgZGlteSA9IHRoaXMuZ2V0U2l6ZUFuZFNjYWxlKGNhbnZhc0hlaWdodCwgdGhpcy5jdHguY2FudmFzLmhlaWdodCwgY29tYmluZWRTY2FsZVkpO1xuICAgIGNvbnN0IHRtcENhbnZhcyA9IG93bmVyLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcInBhdHRlcm5cIiwgZGlteC5zaXplLCBkaW15LnNpemUpO1xuICAgIGNvbnN0IHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgIGNvbnN0IGdyYXBoaWNzID0gY2FudmFzR3JhcGhpY3NGYWN0b3J5LmNyZWF0ZUNhbnZhc0dyYXBoaWNzKHRtcEN0eCwgb3BJZHgpO1xuICAgIGdyYXBoaWNzLmdyb3VwTGV2ZWwgPSBvd25lci5ncm91cExldmVsO1xuICAgIHRoaXMuc2V0RmlsbEFuZFN0cm9rZVN0eWxlVG9Db250ZXh0KGdyYXBoaWNzLCBwYWludFR5cGUsIGNvbG9yKTtcbiAgICB0bXBDdHgudHJhbnNsYXRlKC1kaW14LnNjYWxlICogeDAsIC1kaW15LnNjYWxlICogeTApO1xuICAgIGdyYXBoaWNzLnRyYW5zZm9ybSgwLCBkaW14LnNjYWxlLCAwLCAwLCBkaW15LnNjYWxlLCAwLCAwKTtcbiAgICB0bXBDdHguc2F2ZSgpO1xuICAgIGdyYXBoaWNzLmRlcGVuZGVuY3lUcmFja2VyPy5zYXZlKCk7XG4gICAgdGhpcy5jbGlwQmJveChncmFwaGljcywgeDAsIHkwLCB4MSwgeTEpO1xuICAgIGdyYXBoaWNzLmJhc2VUcmFuc2Zvcm0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKGdyYXBoaWNzLmN0eCk7XG4gICAgZ3JhcGhpY3MuZXhlY3V0ZU9wZXJhdG9yTGlzdChvcGVyYXRvckxpc3QpO1xuICAgIGdyYXBoaWNzLmVuZERyYXdpbmcoKTtcbiAgICBncmFwaGljcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVzdG9yZSgpO1xuICAgIHRtcEN0eC5yZXN0b3JlKCk7XG4gICAgaWYgKHJlZHJhd0hvcml6b250YWxseSB8fCByZWRyYXdWZXJ0aWNhbGx5KSB7XG4gICAgICBjb25zdCBpbWFnZSA9IHRtcENhbnZhcy5jYW52YXM7XG4gICAgICBpZiAocmVkcmF3SG9yaXpvbnRhbGx5KSB7XG4gICAgICAgIGNhbnZhc1dpZHRoID0geHN0ZXA7XG4gICAgICB9XG4gICAgICBpZiAocmVkcmF3VmVydGljYWxseSkge1xuICAgICAgICBjYW52YXNIZWlnaHQgPSB5c3RlcDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRpbXgyID0gdGhpcy5nZXRTaXplQW5kU2NhbGUoY2FudmFzV2lkdGgsIHRoaXMuY3R4LmNhbnZhcy53aWR0aCwgY29tYmluZWRTY2FsZVgpO1xuICAgICAgY29uc3QgZGlteTIgPSB0aGlzLmdldFNpemVBbmRTY2FsZShjYW52YXNIZWlnaHQsIHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQsIGNvbWJpbmVkU2NhbGVZKTtcbiAgICAgIGNvbnN0IHhTaXplID0gZGlteDIuc2l6ZTtcbiAgICAgIGNvbnN0IHlTaXplID0gZGlteTIuc2l6ZTtcbiAgICAgIGNvbnN0IHRtcENhbnZhczIgPSBvd25lci5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJwYXR0ZXJuLXdvcmthcm91bmRcIiwgeFNpemUsIHlTaXplKTtcbiAgICAgIGNvbnN0IHRtcEN0eDIgPSB0bXBDYW52YXMyLmNvbnRleHQ7XG4gICAgICBjb25zdCBpaSA9IHJlZHJhd0hvcml6b250YWxseSA/IE1hdGguZmxvb3Iod2lkdGggLyB4c3RlcCkgOiAwO1xuICAgICAgY29uc3QgamogPSByZWRyYXdWZXJ0aWNhbGx5ID8gTWF0aC5mbG9vcihoZWlnaHQgLyB5c3RlcCkgOiAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gaWk7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8PSBqajsgaisrKSB7XG4gICAgICAgICAgdG1wQ3R4Mi5kcmF3SW1hZ2UoaW1hZ2UsIHhTaXplICogaSwgeVNpemUgKiBqLCB4U2l6ZSwgeVNpemUsIDAsIDAsIHhTaXplLCB5U2l6ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNhbnZhczogdG1wQ2FudmFzMi5jYW52YXMsXG4gICAgICAgIHNjYWxlWDogZGlteDIuc2NhbGUsXG4gICAgICAgIHNjYWxlWTogZGlteTIuc2NhbGUsXG4gICAgICAgIG9mZnNldFg6IHgwLFxuICAgICAgICBvZmZzZXRZOiB5MFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbnZhczogdG1wQ2FudmFzLmNhbnZhcyxcbiAgICAgIHNjYWxlWDogZGlteC5zY2FsZSxcbiAgICAgIHNjYWxlWTogZGlteS5zY2FsZSxcbiAgICAgIG9mZnNldFg6IHgwLFxuICAgICAgb2Zmc2V0WTogeTBcbiAgICB9O1xuICB9XG4gIGdldFNpemVBbmRTY2FsZShzdGVwLCByZWFsT3V0cHV0U2l6ZSwgc2NhbGUpIHtcbiAgICBjb25zdCBtYXhTaXplID0gTWF0aC5tYXgoVGlsaW5nUGF0dGVybi5NQVhfUEFUVEVSTl9TSVpFLCByZWFsT3V0cHV0U2l6ZSk7XG4gICAgbGV0IHNpemUgPSBNYXRoLmNlaWwoc3RlcCAqIHNjYWxlKTtcbiAgICBpZiAoc2l6ZSA+PSBtYXhTaXplKSB7XG4gICAgICBzaXplID0gbWF4U2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGUgPSBzaXplIC8gc3RlcDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjYWxlLFxuICAgICAgc2l6ZVxuICAgIH07XG4gIH1cbiAgY2xpcEJib3goZ3JhcGhpY3MsIHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgY29uc3QgYmJveFdpZHRoID0geDEgLSB4MDtcbiAgICBjb25zdCBiYm94SGVpZ2h0ID0geTEgLSB5MDtcbiAgICBncmFwaGljcy5jdHgucmVjdCh4MCwgeTAsIGJib3hXaWR0aCwgYmJveEhlaWdodCk7XG4gICAgVXRpbC5heGlhbEFsaWduZWRCb3VuZGluZ0JveChbeDAsIHkwLCB4MSwgeTFdLCBnZXRDdXJyZW50VHJhbnNmb3JtKGdyYXBoaWNzLmN0eCksIGdyYXBoaWNzLmN1cnJlbnQubWluTWF4KTtcbiAgICBncmFwaGljcy5jbGlwKCk7XG4gICAgZ3JhcGhpY3MuZW5kUGF0aCgpO1xuICB9XG4gIHNldEZpbGxBbmRTdHJva2VTdHlsZVRvQ29udGV4dChncmFwaGljcywgcGFpbnRUeXBlLCBjb2xvcikge1xuICAgIGNvbnN0IGNvbnRleHQgPSBncmFwaGljcy5jdHgsIGN1cnJlbnQgPSBncmFwaGljcy5jdXJyZW50O1xuICAgIHN3aXRjaCAocGFpbnRUeXBlKSB7XG4gICAgICBjYXNlIFBhaW50VHlwZS5DT0xPUkVEOlxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZmlsbFN0eWxlLFxuICAgICAgICAgIHN0cm9rZVN0eWxlXG4gICAgICAgIH0gPSB0aGlzLmN0eDtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBjdXJyZW50LmZpbGxDb2xvciA9IGZpbGxTdHlsZTtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGN1cnJlbnQuc3Ryb2tlQ29sb3IgPSBzdHJva2VTdHlsZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBhaW50VHlwZS5VTkNPTE9SRUQ6XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgICBjdXJyZW50LmZpbGxDb2xvciA9IGN1cnJlbnQuc3Ryb2tlQ29sb3IgPSBjb2xvcjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXJyb3IoYFVuc3VwcG9ydGVkIHBhaW50IHR5cGU6ICR7cGFpbnRUeXBlfWApO1xuICAgIH1cbiAgfVxuICBpc01vZGlmeWluZ0N1cnJlbnRUcmFuc2Zvcm0oKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGdldFBhdHRlcm4oY3R4LCBvd25lciwgaW52ZXJzZSwgcGF0aFR5cGUsIG9wSWR4KSB7XG4gICAgbGV0IG1hdHJpeCA9IGludmVyc2U7XG4gICAgaWYgKHBhdGhUeXBlICE9PSBQYXRoVHlwZS5TSEFESU5HKSB7XG4gICAgICBtYXRyaXggPSBVdGlsLnRyYW5zZm9ybShtYXRyaXgsIG93bmVyLmJhc2VUcmFuc2Zvcm0pO1xuICAgICAgaWYgKHRoaXMubWF0cml4KSB7XG4gICAgICAgIG1hdHJpeCA9IFV0aWwudHJhbnNmb3JtKG1hdHJpeCwgdGhpcy5tYXRyaXgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzID0gdGhpcy5jcmVhdGVQYXR0ZXJuQ2FudmFzKG93bmVyLCBvcElkeCk7XG4gICAgbGV0IGRvbU1hdHJpeCA9IG5ldyBET01NYXRyaXgobWF0cml4KTtcbiAgICBkb21NYXRyaXggPSBkb21NYXRyaXgudHJhbnNsYXRlKHRlbXBvcmFyeVBhdHRlcm5DYW52YXMub2Zmc2V0WCwgdGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5vZmZzZXRZKTtcbiAgICBkb21NYXRyaXggPSBkb21NYXRyaXguc2NhbGUoMSAvIHRlbXBvcmFyeVBhdHRlcm5DYW52YXMuc2NhbGVYLCAxIC8gdGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5zY2FsZVkpO1xuICAgIGNvbnN0IHBhdHRlcm4gPSBjdHguY3JlYXRlUGF0dGVybih0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLmNhbnZhcywgXCJyZXBlYXRcIik7XG4gICAgcGF0dGVybi5zZXRUcmFuc2Zvcm0oZG9tTWF0cml4KTtcbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfVxufVxuZnVuY3Rpb24gY29udmVydEJsYWNrQW5kV2hpdGVUb1JHQkEoe1xuICBzcmMsXG4gIHNyY1BvcyA9IDAsXG4gIGRlc3QsXG4gIHdpZHRoLFxuICBoZWlnaHQsXG4gIG5vbkJsYWNrQ29sb3IgPSA0Mjk0OTY3Mjk1LFxuICBpbnZlcnNlRGVjb2RlID0gZmFsc2Vcbn0pIHtcbiAgY29uc3QgYmxhY2sgPSB1dGlsX0ZlYXR1cmVUZXN0LmlzTGl0dGxlRW5kaWFuID8gNDI3ODE5MDA4MCA6IDI1NTtcbiAgY29uc3QgW3plcm9NYXBwaW5nLCBvbmVNYXBwaW5nXSA9IGludmVyc2VEZWNvZGUgPyBbbm9uQmxhY2tDb2xvciwgYmxhY2tdIDogW2JsYWNrLCBub25CbGFja0NvbG9yXTtcbiAgY29uc3Qgd2lkdGhJblNvdXJjZSA9IHdpZHRoID4+IDM7XG4gIGNvbnN0IHdpZHRoUmVtYWluZGVyID0gd2lkdGggJiA3O1xuICBjb25zdCBzcmNMZW5ndGggPSBzcmMubGVuZ3RoO1xuICBkZXN0ID0gbmV3IFVpbnQzMkFycmF5KGRlc3QuYnVmZmVyKTtcbiAgbGV0IGRlc3RQb3MgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGhlaWdodDsgaSsrKSB7XG4gICAgZm9yIChjb25zdCBtYXggPSBzcmNQb3MgKyB3aWR0aEluU291cmNlOyBzcmNQb3MgPCBtYXg7IHNyY1BvcysrKSB7XG4gICAgICBjb25zdCBlbGVtMiA9IHNyY1BvcyA8IHNyY0xlbmd0aCA/IHNyY1tzcmNQb3NdIDogMjU1O1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbTIgJiAxMjggPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtMiAmIDY0ID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbTIgJiAzMiA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0yICYgMTYgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtMiAmIDggPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtMiAmIDQgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtMiAmIDIgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtMiAmIDEgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgfVxuICAgIGlmICh3aWR0aFJlbWFpbmRlciA9PT0gMCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGVsZW0gPSBzcmNQb3MgPCBzcmNMZW5ndGggPyBzcmNbc3JjUG9zKytdIDogMjU1O1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgd2lkdGhSZW1haW5kZXI7IGorKykge1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDEgPDwgNyAtIGogPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgc3JjUG9zLFxuICAgIGRlc3RQb3NcbiAgfTtcbn1cbmNvbnN0IE1JTl9GT05UX1NJWkUgPSAxNjtcbmNvbnN0IE1BWF9GT05UX1NJWkUgPSAxMDA7XG5jb25zdCBFWEVDVVRJT05fVElNRSA9IDE1O1xuY29uc3QgRVhFQ1VUSU9OX1NURVBTID0gMTA7XG5jb25zdCBGVUxMX0NIVU5LX0hFSUdIVCA9IDE2O1xuY29uc3QgU0NBTEVfTUFUUklYID0gbmV3IERPTU1hdHJpeCgpO1xuY29uc3QgWFkgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xuY29uc3QgTUlOX01BWF9JTklUID0gbmV3IEZsb2F0MzJBcnJheShbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV0pO1xuZnVuY3Rpb24gbWlycm9yQ29udGV4dE9wZXJhdGlvbnMoY3R4LCBkZXN0Q3R4KSB7XG4gIGlmIChjdHguX3JlbW92ZU1pcnJvcmluZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRleHQgaXMgYWxyZWFkeSBmb3J3YXJkaW5nIG9wZXJhdGlvbnMuXCIpO1xuICB9XG4gIGN0eC5fX29yaWdpbmFsU2F2ZSA9IGN0eC5zYXZlO1xuICBjdHguX19vcmlnaW5hbFJlc3RvcmUgPSBjdHgucmVzdG9yZTtcbiAgY3R4Ll9fb3JpZ2luYWxSb3RhdGUgPSBjdHgucm90YXRlO1xuICBjdHguX19vcmlnaW5hbFNjYWxlID0gY3R4LnNjYWxlO1xuICBjdHguX19vcmlnaW5hbFRyYW5zbGF0ZSA9IGN0eC50cmFuc2xhdGU7XG4gIGN0eC5fX29yaWdpbmFsVHJhbnNmb3JtID0gY3R4LnRyYW5zZm9ybTtcbiAgY3R4Ll9fb3JpZ2luYWxTZXRUcmFuc2Zvcm0gPSBjdHguc2V0VHJhbnNmb3JtO1xuICBjdHguX19vcmlnaW5hbFJlc2V0VHJhbnNmb3JtID0gY3R4LnJlc2V0VHJhbnNmb3JtO1xuICBjdHguX19vcmlnaW5hbENsaXAgPSBjdHguY2xpcDtcbiAgY3R4Ll9fb3JpZ2luYWxNb3ZlVG8gPSBjdHgubW92ZVRvO1xuICBjdHguX19vcmlnaW5hbExpbmVUbyA9IGN0eC5saW5lVG87XG4gIGN0eC5fX29yaWdpbmFsQmV6aWVyQ3VydmVUbyA9IGN0eC5iZXppZXJDdXJ2ZVRvO1xuICBjdHguX19vcmlnaW5hbFJlY3QgPSBjdHgucmVjdDtcbiAgY3R4Ll9fb3JpZ2luYWxDbG9zZVBhdGggPSBjdHguY2xvc2VQYXRoO1xuICBjdHguX19vcmlnaW5hbEJlZ2luUGF0aCA9IGN0eC5iZWdpblBhdGg7XG4gIGN0eC5fcmVtb3ZlTWlycm9yaW5nID0gKCkgPT4ge1xuICAgIGN0eC5zYXZlID0gY3R4Ll9fb3JpZ2luYWxTYXZlO1xuICAgIGN0eC5yZXN0b3JlID0gY3R4Ll9fb3JpZ2luYWxSZXN0b3JlO1xuICAgIGN0eC5yb3RhdGUgPSBjdHguX19vcmlnaW5hbFJvdGF0ZTtcbiAgICBjdHguc2NhbGUgPSBjdHguX19vcmlnaW5hbFNjYWxlO1xuICAgIGN0eC50cmFuc2xhdGUgPSBjdHguX19vcmlnaW5hbFRyYW5zbGF0ZTtcbiAgICBjdHgudHJhbnNmb3JtID0gY3R4Ll9fb3JpZ2luYWxUcmFuc2Zvcm07XG4gICAgY3R4LnNldFRyYW5zZm9ybSA9IGN0eC5fX29yaWdpbmFsU2V0VHJhbnNmb3JtO1xuICAgIGN0eC5yZXNldFRyYW5zZm9ybSA9IGN0eC5fX29yaWdpbmFsUmVzZXRUcmFuc2Zvcm07XG4gICAgY3R4LmNsaXAgPSBjdHguX19vcmlnaW5hbENsaXA7XG4gICAgY3R4Lm1vdmVUbyA9IGN0eC5fX29yaWdpbmFsTW92ZVRvO1xuICAgIGN0eC5saW5lVG8gPSBjdHguX19vcmlnaW5hbExpbmVUbztcbiAgICBjdHguYmV6aWVyQ3VydmVUbyA9IGN0eC5fX29yaWdpbmFsQmV6aWVyQ3VydmVUbztcbiAgICBjdHgucmVjdCA9IGN0eC5fX29yaWdpbmFsUmVjdDtcbiAgICBjdHguY2xvc2VQYXRoID0gY3R4Ll9fb3JpZ2luYWxDbG9zZVBhdGg7XG4gICAgY3R4LmJlZ2luUGF0aCA9IGN0eC5fX29yaWdpbmFsQmVnaW5QYXRoO1xuICAgIGRlbGV0ZSBjdHguX3JlbW92ZU1pcnJvcmluZztcbiAgfTtcbiAgY3R4LnNhdmUgPSBmdW5jdGlvbigpIHtcbiAgICBkZXN0Q3R4LnNhdmUoKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxTYXZlKCk7XG4gIH07XG4gIGN0eC5yZXN0b3JlID0gZnVuY3Rpb24oKSB7XG4gICAgZGVzdEN0eC5yZXN0b3JlKCk7XG4gICAgdGhpcy5fX29yaWdpbmFsUmVzdG9yZSgpO1xuICB9O1xuICBjdHgudHJhbnNsYXRlID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIGRlc3RDdHgudHJhbnNsYXRlKHgsIHkpO1xuICAgIHRoaXMuX19vcmlnaW5hbFRyYW5zbGF0ZSh4LCB5KTtcbiAgfTtcbiAgY3R4LnNjYWxlID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIGRlc3RDdHguc2NhbGUoeCwgeSk7XG4gICAgdGhpcy5fX29yaWdpbmFsU2NhbGUoeCwgeSk7XG4gIH07XG4gIGN0eC50cmFuc2Zvcm0gPSBmdW5jdGlvbihhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgZGVzdEN0eC50cmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZik7XG4gICAgdGhpcy5fX29yaWdpbmFsVHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpO1xuICB9O1xuICBjdHguc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24oYSwgYiwgYywgZCwgZSwgZikge1xuICAgIGRlc3RDdHguc2V0VHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpO1xuICAgIHRoaXMuX19vcmlnaW5hbFNldFRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKTtcbiAgfTtcbiAgY3R4LnJlc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24oKSB7XG4gICAgZGVzdEN0eC5yZXNldFRyYW5zZm9ybSgpO1xuICAgIHRoaXMuX19vcmlnaW5hbFJlc2V0VHJhbnNmb3JtKCk7XG4gIH07XG4gIGN0eC5yb3RhdGUgPSBmdW5jdGlvbihhbmdsZSkge1xuICAgIGRlc3RDdHgucm90YXRlKGFuZ2xlKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxSb3RhdGUoYW5nbGUpO1xuICB9O1xuICBjdHguY2xpcCA9IGZ1bmN0aW9uKHJ1bGUpIHtcbiAgICBkZXN0Q3R4LmNsaXAocnVsZSk7XG4gICAgdGhpcy5fX29yaWdpbmFsQ2xpcChydWxlKTtcbiAgfTtcbiAgY3R4Lm1vdmVUbyA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICBkZXN0Q3R4Lm1vdmVUbyh4LCB5KTtcbiAgICB0aGlzLl9fb3JpZ2luYWxNb3ZlVG8oeCwgeSk7XG4gIH07XG4gIGN0eC5saW5lVG8gPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgZGVzdEN0eC5saW5lVG8oeCwgeSk7XG4gICAgdGhpcy5fX29yaWdpbmFsTGluZVRvKHgsIHkpO1xuICB9O1xuICBjdHguYmV6aWVyQ3VydmVUbyA9IGZ1bmN0aW9uKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpIHtcbiAgICBkZXN0Q3R4LmJlemllckN1cnZlVG8oY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeSk7XG4gICAgdGhpcy5fX29yaWdpbmFsQmV6aWVyQ3VydmVUbyhjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KTtcbiAgfTtcbiAgY3R4LnJlY3QgPSBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgZGVzdEN0eC5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuX19vcmlnaW5hbFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gIH07XG4gIGN0eC5jbG9zZVBhdGggPSBmdW5jdGlvbigpIHtcbiAgICBkZXN0Q3R4LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX19vcmlnaW5hbENsb3NlUGF0aCgpO1xuICB9O1xuICBjdHguYmVnaW5QYXRoID0gZnVuY3Rpb24oKSB7XG4gICAgZGVzdEN0eC5iZWdpblBhdGgoKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxCZWdpblBhdGgoKTtcbiAgfTtcbn1cbmNsYXNzIENhY2hlZENhbnZhc2VzIHtcbiAgY29uc3RydWN0b3IoY2FudmFzRmFjdG9yeSkge1xuICAgIHRoaXMuY2FudmFzRmFjdG9yeSA9IGNhbnZhc0ZhY3Rvcnk7XG4gICAgdGhpcy5jYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIGdldENhbnZhcyhpZCwgd2lkdGgsIGhlaWdodCkge1xuICAgIGxldCBjYW52YXNFbnRyeTtcbiAgICBpZiAodGhpcy5jYWNoZVtpZF0gIT09IHZvaWQgMCkge1xuICAgICAgY2FudmFzRW50cnkgPSB0aGlzLmNhY2hlW2lkXTtcbiAgICAgIHRoaXMuY2FudmFzRmFjdG9yeS5yZXNldChjYW52YXNFbnRyeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbnZhc0VudHJ5ID0gdGhpcy5jYW52YXNGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMuY2FjaGVbaWRdID0gY2FudmFzRW50cnk7XG4gICAgfVxuICAgIHJldHVybiBjYW52YXNFbnRyeTtcbiAgfVxuICBkZWxldGUoaWQpIHtcbiAgICBkZWxldGUgdGhpcy5jYWNoZVtpZF07XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgZm9yIChjb25zdCBpZCBpbiB0aGlzLmNhY2hlKSB7XG4gICAgICBjb25zdCBjYW52YXNFbnRyeSA9IHRoaXMuY2FjaGVbaWRdO1xuICAgICAgdGhpcy5jYW52YXNGYWN0b3J5LmRlc3Ryb3koY2FudmFzRW50cnkpO1xuICAgICAgZGVsZXRlIHRoaXMuY2FjaGVbaWRdO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZHJhd0ltYWdlQXRJbnRlZ2VyQ29vcmRzKGN0eCwgc3JjSW1nLCBzcmNYLCBzcmNZLCBzcmNXLCBzcmNILCBkZXN0WCwgZGVzdFksIGRlc3RXLCBkZXN0SCkge1xuICBjb25zdCBbYSwgYiwgYywgZCwgdHgsIHR5XSA9IGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KTtcbiAgaWYgKGIgPT09IDAgJiYgYyA9PT0gMCkge1xuICAgIGNvbnN0IHRsWCA9IGRlc3RYICogYSArIHR4O1xuICAgIGNvbnN0IHJUbFggPSBNYXRoLnJvdW5kKHRsWCk7XG4gICAgY29uc3QgdGxZID0gZGVzdFkgKiBkICsgdHk7XG4gICAgY29uc3QgclRsWSA9IE1hdGgucm91bmQodGxZKTtcbiAgICBjb25zdCBiclggPSAoZGVzdFggKyBkZXN0VykgKiBhICsgdHg7XG4gICAgY29uc3QgcldpZHRoID0gTWF0aC5hYnMoTWF0aC5yb3VuZChiclgpIC0gclRsWCkgfHwgMTtcbiAgICBjb25zdCBiclkgPSAoZGVzdFkgKyBkZXN0SCkgKiBkICsgdHk7XG4gICAgY29uc3QgckhlaWdodCA9IE1hdGguYWJzKE1hdGgucm91bmQoYnJZKSAtIHJUbFkpIHx8IDE7XG4gICAgY3R4LnNldFRyYW5zZm9ybShNYXRoLnNpZ24oYSksIDAsIDAsIE1hdGguc2lnbihkKSwgclRsWCwgclRsWSk7XG4gICAgY3R4LmRyYXdJbWFnZShzcmNJbWcsIHNyY1gsIHNyY1ksIHNyY1csIHNyY0gsIDAsIDAsIHJXaWR0aCwgckhlaWdodCk7XG4gICAgY3R4LnNldFRyYW5zZm9ybShhLCBiLCBjLCBkLCB0eCwgdHkpO1xuICAgIHJldHVybiBbcldpZHRoLCBySGVpZ2h0XTtcbiAgfVxuICBpZiAoYSA9PT0gMCAmJiBkID09PSAwKSB7XG4gICAgY29uc3QgdGxYID0gZGVzdFkgKiBjICsgdHg7XG4gICAgY29uc3QgclRsWCA9IE1hdGgucm91bmQodGxYKTtcbiAgICBjb25zdCB0bFkgPSBkZXN0WCAqIGIgKyB0eTtcbiAgICBjb25zdCByVGxZID0gTWF0aC5yb3VuZCh0bFkpO1xuICAgIGNvbnN0IGJyWCA9IChkZXN0WSArIGRlc3RIKSAqIGMgKyB0eDtcbiAgICBjb25zdCByV2lkdGggPSBNYXRoLmFicyhNYXRoLnJvdW5kKGJyWCkgLSByVGxYKSB8fCAxO1xuICAgIGNvbnN0IGJyWSA9IChkZXN0WCArIGRlc3RXKSAqIGIgKyB0eTtcbiAgICBjb25zdCBySGVpZ2h0ID0gTWF0aC5hYnMoTWF0aC5yb3VuZChiclkpIC0gclRsWSkgfHwgMTtcbiAgICBjdHguc2V0VHJhbnNmb3JtKDAsIE1hdGguc2lnbihiKSwgTWF0aC5zaWduKGMpLCAwLCByVGxYLCByVGxZKTtcbiAgICBjdHguZHJhd0ltYWdlKHNyY0ltZywgc3JjWCwgc3JjWSwgc3JjVywgc3JjSCwgMCwgMCwgckhlaWdodCwgcldpZHRoKTtcbiAgICBjdHguc2V0VHJhbnNmb3JtKGEsIGIsIGMsIGQsIHR4LCB0eSk7XG4gICAgcmV0dXJuIFtySGVpZ2h0LCByV2lkdGhdO1xuICB9XG4gIGN0eC5kcmF3SW1hZ2Uoc3JjSW1nLCBzcmNYLCBzcmNZLCBzcmNXLCBzcmNILCBkZXN0WCwgZGVzdFksIGRlc3RXLCBkZXN0SCk7XG4gIGNvbnN0IHNjYWxlWCA9IE1hdGguaHlwb3QoYSwgYik7XG4gIGNvbnN0IHNjYWxlWSA9IE1hdGguaHlwb3QoYywgZCk7XG4gIHJldHVybiBbc2NhbGVYICogZGVzdFcsIHNjYWxlWSAqIGRlc3RIXTtcbn1cbmNsYXNzIENhbnZhc0V4dHJhU3RhdGUge1xuICBhbHBoYUlzU2hhcGUgPSBmYWxzZTtcbiAgZm9udFNpemUgPSAwO1xuICBmb250U2l6ZVNjYWxlID0gMTtcbiAgdGV4dE1hdHJpeCA9IG51bGw7XG4gIHRleHRNYXRyaXhTY2FsZSA9IDE7XG4gIGZvbnRNYXRyaXggPSBGT05UX0lERU5USVRZX01BVFJJWDtcbiAgbGVhZGluZyA9IDA7XG4gIHggPSAwO1xuICB5ID0gMDtcbiAgbGluZVggPSAwO1xuICBsaW5lWSA9IDA7XG4gIGNoYXJTcGFjaW5nID0gMDtcbiAgd29yZFNwYWNpbmcgPSAwO1xuICB0ZXh0SFNjYWxlID0gMTtcbiAgdGV4dFJlbmRlcmluZ01vZGUgPSBUZXh0UmVuZGVyaW5nTW9kZS5GSUxMO1xuICB0ZXh0UmlzZSA9IDA7XG4gIGZpbGxDb2xvciA9IFwiIzAwMDAwMFwiO1xuICBzdHJva2VDb2xvciA9IFwiIzAwMDAwMFwiO1xuICBwYXR0ZXJuRmlsbCA9IGZhbHNlO1xuICBwYXR0ZXJuU3Ryb2tlID0gZmFsc2U7XG4gIGZpbGxBbHBoYSA9IDE7XG4gIHN0cm9rZUFscGhhID0gMTtcbiAgbGluZVdpZHRoID0gMTtcbiAgYWN0aXZlU01hc2sgPSBudWxsO1xuICB0cmFuc2Zlck1hcHMgPSBcIm5vbmVcIjtcbiAgY29uc3RydWN0b3Iod2lkdGgsIGhlaWdodCwgcHJlSW5pdCkge1xuICAgIHByZUluaXQ/Lih0aGlzKTtcbiAgICB0aGlzLmNsaXBCb3ggPSBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCB3aWR0aCwgaGVpZ2h0XSk7XG4gICAgdGhpcy5taW5NYXggPSBNSU5fTUFYX0lOSVQuc2xpY2UoKTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZSA9IE9iamVjdC5jcmVhdGUodGhpcyk7XG4gICAgY2xvbmUuY2xpcEJveCA9IHRoaXMuY2xpcEJveC5zbGljZSgpO1xuICAgIGNsb25lLm1pbk1heCA9IHRoaXMubWluTWF4LnNsaWNlKCk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG4gIGdldFBhdGhCb3VuZGluZ0JveChwYXRoVHlwZSA9IFBhdGhUeXBlLkZJTEwsIHRyYW5zZm9ybSA9IG51bGwpIHtcbiAgICBjb25zdCBib3ggPSB0aGlzLm1pbk1heC5zbGljZSgpO1xuICAgIGlmIChwYXRoVHlwZSA9PT0gUGF0aFR5cGUuU1RST0tFKSB7XG4gICAgICBpZiAoIXRyYW5zZm9ybSkge1xuICAgICAgICB1bnJlYWNoYWJsZShcIlN0cm9rZSBib3VuZGluZyBib3ggbXVzdCBpbmNsdWRlIHRyYW5zZm9ybS5cIik7XG4gICAgICB9XG4gICAgICBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRyYW5zZm9ybSwgWFkpO1xuICAgICAgY29uc3QgeFN0cm9rZVBhZCA9IFhZWzBdICogdGhpcy5saW5lV2lkdGggLyAyO1xuICAgICAgY29uc3QgeVN0cm9rZVBhZCA9IFhZWzFdICogdGhpcy5saW5lV2lkdGggLyAyO1xuICAgICAgYm94WzBdIC09IHhTdHJva2VQYWQ7XG4gICAgICBib3hbMV0gLT0geVN0cm9rZVBhZDtcbiAgICAgIGJveFsyXSArPSB4U3Ryb2tlUGFkO1xuICAgICAgYm94WzNdICs9IHlTdHJva2VQYWQ7XG4gICAgfVxuICAgIHJldHVybiBib3g7XG4gIH1cbiAgdXBkYXRlQ2xpcEZyb21QYXRoKCkge1xuICAgIGNvbnN0IGludGVyc2VjdCA9IFV0aWwuaW50ZXJzZWN0KHRoaXMuY2xpcEJveCwgdGhpcy5nZXRQYXRoQm91bmRpbmdCb3goKSk7XG4gICAgdGhpcy5zdGFydE5ld1BhdGhBbmRDbGlwQm94KGludGVyc2VjdCB8fCBbMCwgMCwgMCwgMF0pO1xuICB9XG4gIGlzRW1wdHlDbGlwKCkge1xuICAgIHJldHVybiB0aGlzLm1pbk1heFswXSA9PT0gSW5maW5pdHk7XG4gIH1cbiAgc3RhcnROZXdQYXRoQW5kQ2xpcEJveChib3gpIHtcbiAgICB0aGlzLmNsaXBCb3guc2V0KGJveCwgMCk7XG4gICAgdGhpcy5taW5NYXguc2V0KE1JTl9NQVhfSU5JVCwgMCk7XG4gIH1cbiAgZ2V0Q2xpcHBlZFBhdGhCb3VuZGluZ0JveChwYXRoVHlwZSA9IFBhdGhUeXBlLkZJTEwsIHRyYW5zZm9ybSA9IG51bGwpIHtcbiAgICByZXR1cm4gVXRpbC5pbnRlcnNlY3QodGhpcy5jbGlwQm94LCB0aGlzLmdldFBhdGhCb3VuZGluZ0JveChwYXRoVHlwZSwgdHJhbnNmb3JtKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHB1dEJpbmFyeUltYWdlRGF0YShjdHgsIGltZ0RhdGEpIHtcbiAgaWYgKGltZ0RhdGEgaW5zdGFuY2VvZiBJbWFnZURhdGEpIHtcbiAgICBjdHgucHV0SW1hZ2VEYXRhKGltZ0RhdGEsIDAsIDApO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodCwgd2lkdGggPSBpbWdEYXRhLndpZHRoO1xuICBjb25zdCBwYXJ0aWFsQ2h1bmtIZWlnaHQgPSBoZWlnaHQgJSBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgY29uc3QgZnVsbENodW5rcyA9IChoZWlnaHQgLSBwYXJ0aWFsQ2h1bmtIZWlnaHQpIC8gRlVMTF9DSFVOS19IRUlHSFQ7XG4gIGNvbnN0IHRvdGFsQ2h1bmtzID0gcGFydGlhbENodW5rSGVpZ2h0ID09PSAwID8gZnVsbENodW5rcyA6IGZ1bGxDaHVua3MgKyAxO1xuICBjb25zdCBjaHVua0ltZ0RhdGEgPSBjdHguY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBGVUxMX0NIVU5LX0hFSUdIVCk7XG4gIGxldCBzcmNQb3MgPSAwLCBkZXN0UG9zO1xuICBjb25zdCBzcmMgPSBpbWdEYXRhLmRhdGE7XG4gIGNvbnN0IGRlc3QgPSBjaHVua0ltZ0RhdGEuZGF0YTtcbiAgbGV0IGksIGosIHRoaXNDaHVua0hlaWdodCwgZWxlbXNJblRoaXNDaHVuaztcbiAgaWYgKGltZ0RhdGEua2luZCA9PT0gdXRpbF9JbWFnZUtpbmQuR1JBWVNDQUxFXzFCUFApIHtcbiAgICBjb25zdCBzcmNMZW5ndGggPSBzcmMuYnl0ZUxlbmd0aDtcbiAgICBjb25zdCBkZXN0MzIgPSBuZXcgVWludDMyQXJyYXkoZGVzdC5idWZmZXIsIDAsIGRlc3QuYnl0ZUxlbmd0aCA+PiAyKTtcbiAgICBjb25zdCBkZXN0MzJEYXRhTGVuZ3RoID0gZGVzdDMyLmxlbmd0aDtcbiAgICBjb25zdCBmdWxsU3JjRGlmZiA9IHdpZHRoICsgNyA+PiAzO1xuICAgIGNvbnN0IHdoaXRlID0gNDI5NDk2NzI5NTtcbiAgICBjb25zdCBibGFjayA9IHV0aWxfRmVhdHVyZVRlc3QuaXNMaXR0bGVFbmRpYW4gPyA0Mjc4MTkwMDgwIDogMjU1O1xuICAgIGZvciAoaSA9IDA7IGkgPCB0b3RhbENodW5rczsgaSsrKSB7XG4gICAgICB0aGlzQ2h1bmtIZWlnaHQgPSBpIDwgZnVsbENodW5rcyA/IEZVTExfQ0hVTktfSEVJR0hUIDogcGFydGlhbENodW5rSGVpZ2h0O1xuICAgICAgZGVzdFBvcyA9IDA7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgdGhpc0NodW5rSGVpZ2h0OyBqKyspIHtcbiAgICAgICAgY29uc3Qgc3JjRGlmZiA9IHNyY0xlbmd0aCAtIHNyY1BvcztcbiAgICAgICAgbGV0IGsgPSAwO1xuICAgICAgICBjb25zdCBrRW5kID0gc3JjRGlmZiA+IGZ1bGxTcmNEaWZmID8gd2lkdGggOiBzcmNEaWZmICogOCAtIDc7XG4gICAgICAgIGNvbnN0IGtFbmRVbnJvbGxlZCA9IGtFbmQgJiAtODtcbiAgICAgICAgbGV0IG1hc2sgPSAwO1xuICAgICAgICBsZXQgc3JjQnl0ZSA9IDA7XG4gICAgICAgIGZvciAoOyBrIDwga0VuZFVucm9sbGVkOyBrICs9IDgpIHtcbiAgICAgICAgICBzcmNCeXRlID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiAxMjggPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDY0ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiAzMiA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgMTYgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDggPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDQgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDIgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDEgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyBrIDwga0VuZDsgaysrKSB7XG4gICAgICAgICAgaWYgKG1hc2sgPT09IDApIHtcbiAgICAgICAgICAgIHNyY0J5dGUgPSBzcmNbc3JjUG9zKytdO1xuICAgICAgICAgICAgbWFzayA9IDEyODtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgbWFzayA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgbWFzayA+Pj0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKGRlc3RQb3MgPCBkZXN0MzJEYXRhTGVuZ3RoKSB7XG4gICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gMDtcbiAgICAgIH1cbiAgICAgIGN0eC5wdXRJbWFnZURhdGEoY2h1bmtJbWdEYXRhLCAwLCBpICogRlVMTF9DSFVOS19IRUlHSFQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpbWdEYXRhLmtpbmQgPT09IHV0aWxfSW1hZ2VLaW5kLlJHQkFfMzJCUFApIHtcbiAgICBqID0gMDtcbiAgICBlbGVtc0luVGhpc0NodW5rID0gd2lkdGggKiBGVUxMX0NIVU5LX0hFSUdIVCAqIDQ7XG4gICAgZm9yIChpID0gMDsgaSA8IGZ1bGxDaHVua3M7IGkrKykge1xuICAgICAgZGVzdC5zZXQoc3JjLnN1YmFycmF5KHNyY1Bvcywgc3JjUG9zICsgZWxlbXNJblRoaXNDaHVuaykpO1xuICAgICAgc3JjUG9zICs9IGVsZW1zSW5UaGlzQ2h1bms7XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKGNodW5rSW1nRGF0YSwgMCwgaik7XG4gICAgICBqICs9IEZVTExfQ0hVTktfSEVJR0hUO1xuICAgIH1cbiAgICBpZiAoaSA8IHRvdGFsQ2h1bmtzKSB7XG4gICAgICBlbGVtc0luVGhpc0NodW5rID0gd2lkdGggKiBwYXJ0aWFsQ2h1bmtIZWlnaHQgKiA0O1xuICAgICAgZGVzdC5zZXQoc3JjLnN1YmFycmF5KHNyY1Bvcywgc3JjUG9zICsgZWxlbXNJblRoaXNDaHVuaykpO1xuICAgICAgY3R4LnB1dEltYWdlRGF0YShjaHVua0ltZ0RhdGEsIDAsIGopO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpbWdEYXRhLmtpbmQgPT09IHV0aWxfSW1hZ2VLaW5kLlJHQl8yNEJQUCkge1xuICAgIHRoaXNDaHVua0hlaWdodCA9IEZVTExfQ0hVTktfSEVJR0hUO1xuICAgIGVsZW1zSW5UaGlzQ2h1bmsgPSB3aWR0aCAqIHRoaXNDaHVua0hlaWdodDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdG90YWxDaHVua3M7IGkrKykge1xuICAgICAgaWYgKGkgPj0gZnVsbENodW5rcykge1xuICAgICAgICB0aGlzQ2h1bmtIZWlnaHQgPSBwYXJ0aWFsQ2h1bmtIZWlnaHQ7XG4gICAgICAgIGVsZW1zSW5UaGlzQ2h1bmsgPSB3aWR0aCAqIHRoaXNDaHVua0hlaWdodDtcbiAgICAgIH1cbiAgICAgIGRlc3RQb3MgPSAwO1xuICAgICAgZm9yIChqID0gZWxlbXNJblRoaXNDaHVuazsgai0tOyApIHtcbiAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gMjU1O1xuICAgICAgfVxuICAgICAgY3R4LnB1dEltYWdlRGF0YShjaHVua0ltZ0RhdGEsIDAsIGkgKiBGVUxMX0NIVU5LX0hFSUdIVCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgYmFkIGltYWdlIGtpbmQ6ICR7aW1nRGF0YS5raW5kfWApO1xuICB9XG59XG5mdW5jdGlvbiBwdXRCaW5hcnlJbWFnZU1hc2soY3R4LCBpbWdEYXRhKSB7XG4gIGlmIChpbWdEYXRhLmJpdG1hcCkge1xuICAgIGN0eC5kcmF3SW1hZ2UoaW1nRGF0YS5iaXRtYXAsIDAsIDApO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodCwgd2lkdGggPSBpbWdEYXRhLndpZHRoO1xuICBjb25zdCBwYXJ0aWFsQ2h1bmtIZWlnaHQgPSBoZWlnaHQgJSBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgY29uc3QgZnVsbENodW5rcyA9IChoZWlnaHQgLSBwYXJ0aWFsQ2h1bmtIZWlnaHQpIC8gRlVMTF9DSFVOS19IRUlHSFQ7XG4gIGNvbnN0IHRvdGFsQ2h1bmtzID0gcGFydGlhbENodW5rSGVpZ2h0ID09PSAwID8gZnVsbENodW5rcyA6IGZ1bGxDaHVua3MgKyAxO1xuICBjb25zdCBjaHVua0ltZ0RhdGEgPSBjdHguY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBGVUxMX0NIVU5LX0hFSUdIVCk7XG4gIGxldCBzcmNQb3MgPSAwO1xuICBjb25zdCBzcmMgPSBpbWdEYXRhLmRhdGE7XG4gIGNvbnN0IGRlc3QgPSBjaHVua0ltZ0RhdGEuZGF0YTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbENodW5rczsgaSsrKSB7XG4gICAgY29uc3QgdGhpc0NodW5rSGVpZ2h0ID0gaSA8IGZ1bGxDaHVua3MgPyBGVUxMX0NIVU5LX0hFSUdIVCA6IHBhcnRpYWxDaHVua0hlaWdodDtcbiAgICAoe1xuICAgICAgc3JjUG9zXG4gICAgfSA9IGNvbnZlcnRCbGFja0FuZFdoaXRlVG9SR0JBKHtcbiAgICAgIHNyYyxcbiAgICAgIHNyY1BvcyxcbiAgICAgIGRlc3QsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodDogdGhpc0NodW5rSGVpZ2h0LFxuICAgICAgbm9uQmxhY2tDb2xvcjogMFxuICAgIH0pKTtcbiAgICBjdHgucHV0SW1hZ2VEYXRhKGNodW5rSW1nRGF0YSwgMCwgaSAqIEZVTExfQ0hVTktfSEVJR0hUKTtcbiAgfVxufVxuZnVuY3Rpb24gY29weUN0eFN0YXRlKHNvdXJjZUN0eCwgZGVzdEN0eCkge1xuICBjb25zdCBwcm9wZXJ0aWVzID0gW1wic3Ryb2tlU3R5bGVcIiwgXCJmaWxsU3R5bGVcIiwgXCJmaWxsUnVsZVwiLCBcImdsb2JhbEFscGhhXCIsIFwibGluZVdpZHRoXCIsIFwibGluZUNhcFwiLCBcImxpbmVKb2luXCIsIFwibWl0ZXJMaW1pdFwiLCBcImdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvblwiLCBcImZvbnRcIiwgXCJmaWx0ZXJcIl07XG4gIGZvciAoY29uc3QgcHJvcGVydHkgb2YgcHJvcGVydGllcykge1xuICAgIGlmIChzb3VyY2VDdHhbcHJvcGVydHldICE9PSB2b2lkIDApIHtcbiAgICAgIGRlc3RDdHhbcHJvcGVydHldID0gc291cmNlQ3R4W3Byb3BlcnR5XTtcbiAgICB9XG4gIH1cbiAgaWYgKHNvdXJjZUN0eC5zZXRMaW5lRGFzaCAhPT0gdm9pZCAwKSB7XG4gICAgZGVzdEN0eC5zZXRMaW5lRGFzaChzb3VyY2VDdHguZ2V0TGluZURhc2goKSk7XG4gICAgZGVzdEN0eC5saW5lRGFzaE9mZnNldCA9IHNvdXJjZUN0eC5saW5lRGFzaE9mZnNldDtcbiAgfVxufVxuZnVuY3Rpb24gcmVzZXRDdHhUb0RlZmF1bHQoY3R4KSB7XG4gIGN0eC5zdHJva2VTdHlsZSA9IGN0eC5maWxsU3R5bGUgPSBcIiMwMDAwMDBcIjtcbiAgY3R4LmZpbGxSdWxlID0gXCJub256ZXJvXCI7XG4gIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gIGN0eC5saW5lV2lkdGggPSAxO1xuICBjdHgubGluZUNhcCA9IFwiYnV0dFwiO1xuICBjdHgubGluZUpvaW4gPSBcIm1pdGVyXCI7XG4gIGN0eC5taXRlckxpbWl0ID0gMTA7XG4gIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1vdmVyXCI7XG4gIGN0eC5mb250ID0gXCIxMHB4IHNhbnMtc2VyaWZcIjtcbiAgaWYgKGN0eC5zZXRMaW5lRGFzaCAhPT0gdm9pZCAwKSB7XG4gICAgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgICBjdHgubGluZURhc2hPZmZzZXQgPSAwO1xuICB9XG4gIGNvbnN0IHtcbiAgICBmaWx0ZXJcbiAgfSA9IGN0eDtcbiAgaWYgKGZpbHRlciAhPT0gXCJub25lXCIgJiYgZmlsdGVyICE9PSBcIlwiKSB7XG4gICAgY3R4LmZpbHRlciA9IFwibm9uZVwiO1xuICB9XG59XG5mdW5jdGlvbiBnZXRJbWFnZVNtb290aGluZ0VuYWJsZWQodHJhbnNmb3JtLCBpbnRlcnBvbGF0ZSkge1xuICBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRyYW5zZm9ybSwgWFkpO1xuICBjb25zdCBhY3R1YWxTY2FsZSA9IE1hdGguZnJvdW5kKE91dHB1dFNjYWxlLnBpeGVsUmF0aW8gKiBQaXhlbHNQZXJJbmNoLlBERl9UT19DU1NfVU5JVFMpO1xuICByZXR1cm4gWFlbMF0gPD0gYWN0dWFsU2NhbGUgJiYgWFlbMV0gPD0gYWN0dWFsU2NhbGU7XG59XG5jb25zdCBMSU5FX0NBUF9TVFlMRVMgPSBbXCJidXR0XCIsIFwicm91bmRcIiwgXCJzcXVhcmVcIl07XG5jb25zdCBMSU5FX0pPSU5fU1RZTEVTID0gW1wibWl0ZXJcIiwgXCJyb3VuZFwiLCBcImJldmVsXCJdO1xuY29uc3QgTk9STUFMX0NMSVAgPSB7fTtcbmNvbnN0IEVPX0NMSVAgPSB7fTtcbmNsYXNzIENhbnZhc0dyYXBoaWNzIHtcbiAgY29uc3RydWN0b3IoY2FudmFzQ3R4LCBjb21tb25PYmpzLCBvYmpzLCBjYW52YXNGYWN0b3J5LCBmaWx0ZXJGYWN0b3J5LCB7XG4gICAgb3B0aW9uYWxDb250ZW50Q29uZmlnLFxuICAgIG1hcmtlZENvbnRlbnRTdGFjayA9IG51bGxcbiAgfSwgYW5ub3RhdGlvbkNhbnZhc01hcCwgcGFnZUNvbG9ycywgZGVwZW5kZW5jeVRyYWNrZXIpIHtcbiAgICB0aGlzLmN0eCA9IGNhbnZhc0N0eDtcbiAgICB0aGlzLmN1cnJlbnQgPSBuZXcgQ2FudmFzRXh0cmFTdGF0ZSh0aGlzLmN0eC5jYW52YXMud2lkdGgsIHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQpO1xuICAgIHRoaXMuc3RhdGVTdGFjayA9IFtdO1xuICAgIHRoaXMucGVuZGluZ0NsaXAgPSBudWxsO1xuICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IGZhbHNlO1xuICAgIHRoaXMucmVzID0gbnVsbDtcbiAgICB0aGlzLnhvYmpzID0gbnVsbDtcbiAgICB0aGlzLmNvbW1vbk9ianMgPSBjb21tb25PYmpzO1xuICAgIHRoaXMub2JqcyA9IG9ianM7XG4gICAgdGhpcy5jYW52YXNGYWN0b3J5ID0gY2FudmFzRmFjdG9yeTtcbiAgICB0aGlzLmZpbHRlckZhY3RvcnkgPSBmaWx0ZXJGYWN0b3J5O1xuICAgIHRoaXMuZ3JvdXBTdGFjayA9IFtdO1xuICAgIHRoaXMuYmFzZVRyYW5zZm9ybSA9IG51bGw7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtU3RhY2sgPSBbXTtcbiAgICB0aGlzLmdyb3VwTGV2ZWwgPSAwO1xuICAgIHRoaXMuc21hc2tTdGFjayA9IFtdO1xuICAgIHRoaXMuc21hc2tDb3VudGVyID0gMDtcbiAgICB0aGlzLnRlbXBTTWFzayA9IG51bGw7XG4gICAgdGhpcy5zdXNwZW5kZWRDdHggPSBudWxsO1xuICAgIHRoaXMuY29udGVudFZpc2libGUgPSB0cnVlO1xuICAgIHRoaXMubWFya2VkQ29udGVudFN0YWNrID0gbWFya2VkQ29udGVudFN0YWNrIHx8IFtdO1xuICAgIHRoaXMub3B0aW9uYWxDb250ZW50Q29uZmlnID0gb3B0aW9uYWxDb250ZW50Q29uZmlnO1xuICAgIHRoaXMuY2FjaGVkQ2FudmFzZXMgPSBuZXcgQ2FjaGVkQ2FudmFzZXModGhpcy5jYW52YXNGYWN0b3J5KTtcbiAgICB0aGlzLmNhY2hlZFBhdHRlcm5zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmFubm90YXRpb25DYW52YXNNYXAgPSBhbm5vdGF0aW9uQ2FudmFzTWFwO1xuICAgIHRoaXMudmlld3BvcnRTY2FsZSA9IDE7XG4gICAgdGhpcy5vdXRwdXRTY2FsZVggPSAxO1xuICAgIHRoaXMub3V0cHV0U2NhbGVZID0gMTtcbiAgICB0aGlzLnBhZ2VDb2xvcnMgPSBwYWdlQ29sb3JzO1xuICAgIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmcgPSBbLTEsIDBdO1xuICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSBudWxsO1xuICAgIHRoaXMuX2NhY2hlZEJpdG1hcHNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXIgPSBkZXBlbmRlbmN5VHJhY2tlciA/PyBudWxsO1xuICB9XG4gIGdldE9iamVjdChvcElkeCwgZGF0YSwgZmFsbGJhY2sgPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmROYW1lZERlcGVuZGVuY3kob3BJZHgsIGRhdGEpO1xuICAgICAgcmV0dXJuIGRhdGEuc3RhcnRzV2l0aChcImdfXCIpID8gdGhpcy5jb21tb25PYmpzLmdldChkYXRhKSA6IHRoaXMub2Jqcy5nZXQoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxsYmFjaztcbiAgfVxuICBiZWdpbkRyYXdpbmcoe1xuICAgIHRyYW5zZm9ybSxcbiAgICB2aWV3cG9ydCxcbiAgICB0cmFuc3BhcmVuY3kgPSBmYWxzZSxcbiAgICBiYWNrZ3JvdW5kID0gbnVsbFxuICB9KSB7XG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLmN0eC5jYW52YXMud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5jdHguY2FudmFzLmhlaWdodDtcbiAgICBjb25zdCBzYXZlZEZpbGxTdHlsZSA9IHRoaXMuY3R4LmZpbGxTdHlsZTtcbiAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kIHx8IFwiI2ZmZmZmZlwiO1xuICAgIHRoaXMuY3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IHNhdmVkRmlsbFN0eWxlO1xuICAgIGlmICh0cmFuc3BhcmVuY3kpIHtcbiAgICAgIGNvbnN0IHRyYW5zcGFyZW50Q2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJ0cmFuc3BhcmVudFwiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMuY29tcG9zaXRlQ3R4ID0gdGhpcy5jdHg7XG4gICAgICB0aGlzLnRyYW5zcGFyZW50Q2FudmFzID0gdHJhbnNwYXJlbnRDYW52YXMuY2FudmFzO1xuICAgICAgdGhpcy5jdHggPSB0cmFuc3BhcmVudENhbnZhcy5jb250ZXh0O1xuICAgICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgICAgdGhpcy5jdHgudHJhbnNmb3JtKC4uLmdldEN1cnJlbnRUcmFuc2Zvcm0odGhpcy5jb21wb3NpdGVDdHgpKTtcbiAgICB9XG4gICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgIHJlc2V0Q3R4VG9EZWZhdWx0KHRoaXMuY3R4KTtcbiAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICB0aGlzLmN0eC50cmFuc2Zvcm0oLi4udHJhbnNmb3JtKTtcbiAgICAgIHRoaXMub3V0cHV0U2NhbGVYID0gdHJhbnNmb3JtWzBdO1xuICAgICAgdGhpcy5vdXRwdXRTY2FsZVkgPSB0cmFuc2Zvcm1bMF07XG4gICAgfVxuICAgIHRoaXMuY3R4LnRyYW5zZm9ybSguLi52aWV3cG9ydC50cmFuc2Zvcm0pO1xuICAgIHRoaXMudmlld3BvcnRTY2FsZSA9IHZpZXdwb3J0LnNjYWxlO1xuICAgIHRoaXMuYmFzZVRyYW5zZm9ybSA9IGdldEN1cnJlbnRUcmFuc2Zvcm0odGhpcy5jdHgpO1xuICB9XG4gIGV4ZWN1dGVPcGVyYXRvckxpc3Qob3BlcmF0b3JMaXN0LCBleGVjdXRpb25TdGFydElkeCwgY29udGludWVDYWxsYmFjaywgc3RlcHBlciwgb3BlcmF0aW9uc0ZpbHRlcikge1xuICAgIGNvbnN0IGFyZ3NBcnJheSA9IG9wZXJhdG9yTGlzdC5hcmdzQXJyYXk7XG4gICAgY29uc3QgZm5BcnJheSA9IG9wZXJhdG9yTGlzdC5mbkFycmF5O1xuICAgIGxldCBpID0gZXhlY3V0aW9uU3RhcnRJZHggfHwgMDtcbiAgICBjb25zdCBhcmdzQXJyYXlMZW4gPSBhcmdzQXJyYXkubGVuZ3RoO1xuICAgIGlmIChhcmdzQXJyYXlMZW4gPT09IGkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICBjb25zdCBjaHVua09wZXJhdGlvbnMgPSBhcmdzQXJyYXlMZW4gLSBpID4gRVhFQ1VUSU9OX1NURVBTICYmIHR5cGVvZiBjb250aW51ZUNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCI7XG4gICAgY29uc3QgZW5kVGltZSA9IGNodW5rT3BlcmF0aW9ucyA/IERhdGUubm93KCkgKyBFWEVDVVRJT05fVElNRSA6IDA7XG4gICAgbGV0IHN0ZXBzID0gMDtcbiAgICBjb25zdCBjb21tb25PYmpzID0gdGhpcy5jb21tb25PYmpzO1xuICAgIGNvbnN0IG9ianMgPSB0aGlzLm9ianM7XG4gICAgbGV0IGZuSWQsIGZuQXJncztcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKHN0ZXBwZXIgIT09IHZvaWQgMCAmJiBpID09PSBzdGVwcGVyLm5leHRCcmVha1BvaW50KSB7XG4gICAgICAgIHN0ZXBwZXIuYnJlYWtJdChpLCBjb250aW51ZUNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgICBpZiAoIW9wZXJhdGlvbnNGaWx0ZXIgfHwgb3BlcmF0aW9uc0ZpbHRlcihpKSkge1xuICAgICAgICBmbklkID0gZm5BcnJheVtpXTtcbiAgICAgICAgZm5BcmdzID0gYXJnc0FycmF5W2ldID8/IG51bGw7XG4gICAgICAgIGlmIChmbklkICE9PSBPUFMuZGVwZW5kZW5jeSkge1xuICAgICAgICAgIGlmIChmbkFyZ3MgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXNbZm5JZF0oaSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNbZm5JZF0oaSwgLi4uZm5BcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChjb25zdCBkZXBPYmpJZCBvZiBmbkFyZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZE5hbWVkRGF0YShkZXBPYmpJZCwgaSk7XG4gICAgICAgICAgICBjb25zdCBvYmpzUG9vbCA9IGRlcE9iaklkLnN0YXJ0c1dpdGgoXCJnX1wiKSA/IGNvbW1vbk9ianMgOiBvYmpzO1xuICAgICAgICAgICAgaWYgKCFvYmpzUG9vbC5oYXMoZGVwT2JqSWQpKSB7XG4gICAgICAgICAgICAgIG9ianNQb29sLmdldChkZXBPYmpJZCwgY29udGludWVDYWxsYmFjayk7XG4gICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaSsrO1xuICAgICAgaWYgKGkgPT09IGFyZ3NBcnJheUxlbikge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICAgIGlmIChjaHVua09wZXJhdGlvbnMgJiYgKytzdGVwcyA+IEVYRUNVVElPTl9TVEVQUykge1xuICAgICAgICBpZiAoRGF0ZS5ub3coKSA+IGVuZFRpbWUpIHtcbiAgICAgICAgICBjb250aW51ZUNhbGxiYWNrKCk7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgICAgc3RlcHMgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAjcmVzdG9yZUluaXRpYWxTdGF0ZSgpIHtcbiAgICB3aGlsZSAodGhpcy5zdGF0ZVN0YWNrLmxlbmd0aCB8fCB0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrID0gbnVsbDtcbiAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgaWYgKHRoaXMudHJhbnNwYXJlbnRDYW52YXMpIHtcbiAgICAgIHRoaXMuY3R4ID0gdGhpcy5jb21wb3NpdGVDdHg7XG4gICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICB0aGlzLmN0eC5kcmF3SW1hZ2UodGhpcy50cmFuc3BhcmVudENhbnZhcywgMCwgMCk7XG4gICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICB0aGlzLnRyYW5zcGFyZW50Q2FudmFzID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZW5kRHJhd2luZygpIHtcbiAgICB0aGlzLiNyZXN0b3JlSW5pdGlhbFN0YXRlKCk7XG4gICAgdGhpcy5jYWNoZWRDYW52YXNlcy5jbGVhcigpO1xuICAgIHRoaXMuY2FjaGVkUGF0dGVybnMuY2xlYXIoKTtcbiAgICBmb3IgKGNvbnN0IGNhY2hlIG9mIHRoaXMuX2NhY2hlZEJpdG1hcHNNYXAudmFsdWVzKCkpIHtcbiAgICAgIGZvciAoY29uc3QgY2FudmFzIG9mIGNhY2hlLnZhbHVlcygpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgY2FudmFzIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpIHtcbiAgICAgICAgICBjYW52YXMud2lkdGggPSBjYW52YXMuaGVpZ2h0ID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gICAgdGhpcy5fY2FjaGVkQml0bWFwc01hcC5jbGVhcigpO1xuICAgIHRoaXMuI2RyYXdGaWx0ZXIoKTtcbiAgfVxuICAjZHJhd0ZpbHRlcigpIHtcbiAgICBpZiAodGhpcy5wYWdlQ29sb3JzKSB7XG4gICAgICBjb25zdCBoY21GaWx0ZXJJZCA9IHRoaXMuZmlsdGVyRmFjdG9yeS5hZGRIQ01GaWx0ZXIodGhpcy5wYWdlQ29sb3JzLmZvcmVncm91bmQsIHRoaXMucGFnZUNvbG9ycy5iYWNrZ3JvdW5kKTtcbiAgICAgIGlmIChoY21GaWx0ZXJJZCAhPT0gXCJub25lXCIpIHtcbiAgICAgICAgY29uc3Qgc2F2ZWRGaWx0ZXIgPSB0aGlzLmN0eC5maWx0ZXI7XG4gICAgICAgIHRoaXMuY3R4LmZpbHRlciA9IGhjbUZpbHRlcklkO1xuICAgICAgICB0aGlzLmN0eC5kcmF3SW1hZ2UodGhpcy5jdHguY2FudmFzLCAwLCAwKTtcbiAgICAgICAgdGhpcy5jdHguZmlsdGVyID0gc2F2ZWRGaWx0ZXI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9zY2FsZUltYWdlKGltZywgaW52ZXJzZVRyYW5zZm9ybSkge1xuICAgIGNvbnN0IHdpZHRoID0gaW1nLndpZHRoID8/IGltZy5kaXNwbGF5V2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1nLmhlaWdodCA/PyBpbWcuZGlzcGxheUhlaWdodDtcbiAgICBsZXQgd2lkdGhTY2FsZSA9IE1hdGgubWF4KE1hdGguaHlwb3QoaW52ZXJzZVRyYW5zZm9ybVswXSwgaW52ZXJzZVRyYW5zZm9ybVsxXSksIDEpO1xuICAgIGxldCBoZWlnaHRTY2FsZSA9IE1hdGgubWF4KE1hdGguaHlwb3QoaW52ZXJzZVRyYW5zZm9ybVsyXSwgaW52ZXJzZVRyYW5zZm9ybVszXSksIDEpO1xuICAgIGxldCBwYWludFdpZHRoID0gd2lkdGgsIHBhaW50SGVpZ2h0ID0gaGVpZ2h0O1xuICAgIGxldCB0bXBDYW52YXNJZCA9IFwicHJlc2NhbGUxXCI7XG4gICAgbGV0IHRtcENhbnZhcywgdG1wQ3R4O1xuICAgIHdoaWxlICh3aWR0aFNjYWxlID4gMiAmJiBwYWludFdpZHRoID4gMSB8fCBoZWlnaHRTY2FsZSA+IDIgJiYgcGFpbnRIZWlnaHQgPiAxKSB7XG4gICAgICBsZXQgbmV3V2lkdGggPSBwYWludFdpZHRoLCBuZXdIZWlnaHQgPSBwYWludEhlaWdodDtcbiAgICAgIGlmICh3aWR0aFNjYWxlID4gMiAmJiBwYWludFdpZHRoID4gMSkge1xuICAgICAgICBuZXdXaWR0aCA9IHBhaW50V2lkdGggPj0gMTYzODQgPyBNYXRoLmZsb29yKHBhaW50V2lkdGggLyAyKSAtIDEgfHwgMSA6IE1hdGguY2VpbChwYWludFdpZHRoIC8gMik7XG4gICAgICAgIHdpZHRoU2NhbGUgLz0gcGFpbnRXaWR0aCAvIG5ld1dpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKGhlaWdodFNjYWxlID4gMiAmJiBwYWludEhlaWdodCA+IDEpIHtcbiAgICAgICAgbmV3SGVpZ2h0ID0gcGFpbnRIZWlnaHQgPj0gMTYzODQgPyBNYXRoLmZsb29yKHBhaW50SGVpZ2h0IC8gMikgLSAxIHx8IDEgOiBNYXRoLmNlaWwocGFpbnRIZWlnaHQpIC8gMjtcbiAgICAgICAgaGVpZ2h0U2NhbGUgLz0gcGFpbnRIZWlnaHQgLyBuZXdIZWlnaHQ7XG4gICAgICB9XG4gICAgICB0bXBDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyh0bXBDYW52YXNJZCwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICAgIHRtcEN0eC5jbGVhclJlY3QoMCwgMCwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICB0bXBDdHguZHJhd0ltYWdlKGltZywgMCwgMCwgcGFpbnRXaWR0aCwgcGFpbnRIZWlnaHQsIDAsIDAsIG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgICAgaW1nID0gdG1wQ2FudmFzLmNhbnZhcztcbiAgICAgIHBhaW50V2lkdGggPSBuZXdXaWR0aDtcbiAgICAgIHBhaW50SGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgdG1wQ2FudmFzSWQgPSB0bXBDYW52YXNJZCA9PT0gXCJwcmVzY2FsZTFcIiA/IFwicHJlc2NhbGUyXCIgOiBcInByZXNjYWxlMVwiO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaW1nLFxuICAgICAgcGFpbnRXaWR0aCxcbiAgICAgIHBhaW50SGVpZ2h0XG4gICAgfTtcbiAgfVxuICBfY3JlYXRlTWFza0NhbnZhcyhvcElkeCwgaW1nKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gaW1nO1xuICAgIGNvbnN0IGZpbGxDb2xvciA9IHRoaXMuY3VycmVudC5maWxsQ29sb3I7XG4gICAgY29uc3QgaXNQYXR0ZXJuRmlsbCA9IHRoaXMuY3VycmVudC5wYXR0ZXJuRmlsbDtcbiAgICBjb25zdCBjdXJyZW50VHJhbnNmb3JtID0gZ2V0Q3VycmVudFRyYW5zZm9ybShjdHgpO1xuICAgIGxldCBjYWNoZSwgY2FjaGVLZXksIHNjYWxlZCwgbWFza0NhbnZhcztcbiAgICBpZiAoKGltZy5iaXRtYXAgfHwgaW1nLmRhdGEpICYmIGltZy5jb3VudCA+IDEpIHtcbiAgICAgIGNvbnN0IG1haW5LZXkgPSBpbWcuYml0bWFwIHx8IGltZy5kYXRhLmJ1ZmZlcjtcbiAgICAgIGNhY2hlS2V5ID0gSlNPTi5zdHJpbmdpZnkoaXNQYXR0ZXJuRmlsbCA/IGN1cnJlbnRUcmFuc2Zvcm0gOiBbY3VycmVudFRyYW5zZm9ybS5zbGljZSgwLCA0KSwgZmlsbENvbG9yXSk7XG4gICAgICBjYWNoZSA9IHRoaXMuX2NhY2hlZEJpdG1hcHNNYXAuZ2V0KG1haW5LZXkpO1xuICAgICAgaWYgKCFjYWNoZSkge1xuICAgICAgICBjYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2NhY2hlZEJpdG1hcHNNYXAuc2V0KG1haW5LZXksIGNhY2hlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhY2hlZEltYWdlID0gY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgIGlmIChjYWNoZWRJbWFnZSAmJiAhaXNQYXR0ZXJuRmlsbCkge1xuICAgICAgICBjb25zdCBvZmZzZXRYMiA9IE1hdGgucm91bmQoTWF0aC5taW4oY3VycmVudFRyYW5zZm9ybVswXSwgY3VycmVudFRyYW5zZm9ybVsyXSkgKyBjdXJyZW50VHJhbnNmb3JtWzRdKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WTIgPSBNYXRoLnJvdW5kKE1hdGgubWluKGN1cnJlbnRUcmFuc2Zvcm1bMV0sIGN1cnJlbnRUcmFuc2Zvcm1bM10pICsgY3VycmVudFRyYW5zZm9ybVs1XSk7XG4gICAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZERlcGVuZGVuY2llcyhvcElkeCwgRGVwZW5kZW5jaWVzLnRyYW5zZm9ybUFuZEZpbGwpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNhbnZhczogY2FjaGVkSW1hZ2UsXG4gICAgICAgICAgb2Zmc2V0WDogb2Zmc2V0WDIsXG4gICAgICAgICAgb2Zmc2V0WTogb2Zmc2V0WTJcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHNjYWxlZCA9IGNhY2hlZEltYWdlO1xuICAgIH1cbiAgICBpZiAoIXNjYWxlZCkge1xuICAgICAgbWFza0NhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwibWFza0NhbnZhc1wiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHB1dEJpbmFyeUltYWdlTWFzayhtYXNrQ2FudmFzLmNvbnRleHQsIGltZyk7XG4gICAgfVxuICAgIGxldCBtYXNrVG9DYW52YXMgPSBVdGlsLnRyYW5zZm9ybShjdXJyZW50VHJhbnNmb3JtLCBbMSAvIHdpZHRoLCAwLCAwLCAtMSAvIGhlaWdodCwgMCwgMF0pO1xuICAgIG1hc2tUb0NhbnZhcyA9IFV0aWwudHJhbnNmb3JtKG1hc2tUb0NhbnZhcywgWzEsIDAsIDAsIDEsIDAsIC1oZWlnaHRdKTtcbiAgICBjb25zdCBtaW5NYXggPSBNSU5fTUFYX0lOSVQuc2xpY2UoKTtcbiAgICBVdGlsLmF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KFswLCAwLCB3aWR0aCwgaGVpZ2h0XSwgbWFza1RvQ2FudmFzLCBtaW5NYXgpO1xuICAgIGNvbnN0IFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSA9IG1pbk1heDtcbiAgICBjb25zdCBkcmF3bldpZHRoID0gTWF0aC5yb3VuZChtYXhYIC0gbWluWCkgfHwgMTtcbiAgICBjb25zdCBkcmF3bkhlaWdodCA9IE1hdGgucm91bmQobWF4WSAtIG1pblkpIHx8IDE7XG4gICAgY29uc3QgZmlsbENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwiZmlsbENhbnZhc1wiLCBkcmF3bldpZHRoLCBkcmF3bkhlaWdodCk7XG4gICAgY29uc3QgZmlsbEN0eCA9IGZpbGxDYW52YXMuY29udGV4dDtcbiAgICBjb25zdCBvZmZzZXRYID0gbWluWDtcbiAgICBjb25zdCBvZmZzZXRZID0gbWluWTtcbiAgICBmaWxsQ3R4LnRyYW5zbGF0ZSgtb2Zmc2V0WCwgLW9mZnNldFkpO1xuICAgIGZpbGxDdHgudHJhbnNmb3JtKC4uLm1hc2tUb0NhbnZhcyk7XG4gICAgaWYgKCFzY2FsZWQpIHtcbiAgICAgIHNjYWxlZCA9IHRoaXMuX3NjYWxlSW1hZ2UobWFza0NhbnZhcy5jYW52YXMsIGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGZpbGxDdHgpKTtcbiAgICAgIHNjYWxlZCA9IHNjYWxlZC5pbWc7XG4gICAgICBpZiAoY2FjaGUgJiYgaXNQYXR0ZXJuRmlsbCkge1xuICAgICAgICBjYWNoZS5zZXQoY2FjaGVLZXksIHNjYWxlZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZpbGxDdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZ2V0SW1hZ2VTbW9vdGhpbmdFbmFibGVkKGdldEN1cnJlbnRUcmFuc2Zvcm0oZmlsbEN0eCksIGltZy5pbnRlcnBvbGF0ZSk7XG4gICAgZHJhd0ltYWdlQXRJbnRlZ2VyQ29vcmRzKGZpbGxDdHgsIHNjYWxlZCwgMCwgMCwgc2NhbGVkLndpZHRoLCBzY2FsZWQuaGVpZ2h0LCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBmaWxsQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLWluXCI7XG4gICAgY29uc3QgaW52ZXJzZSA9IFV0aWwudHJhbnNmb3JtKGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGZpbGxDdHgpLCBbMSwgMCwgMCwgMSwgLW9mZnNldFgsIC1vZmZzZXRZXSk7XG4gICAgZmlsbEN0eC5maWxsU3R5bGUgPSBpc1BhdHRlcm5GaWxsID8gZmlsbENvbG9yLmdldFBhdHRlcm4oY3R4LCB0aGlzLCBpbnZlcnNlLCBQYXRoVHlwZS5GSUxMLCBvcElkeCkgOiBmaWxsQ29sb3I7XG4gICAgZmlsbEN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBpZiAoY2FjaGUgJiYgIWlzUGF0dGVybkZpbGwpIHtcbiAgICAgIHRoaXMuY2FjaGVkQ2FudmFzZXMuZGVsZXRlKFwiZmlsbENhbnZhc1wiKTtcbiAgICAgIGNhY2hlLnNldChjYWNoZUtleSwgZmlsbENhbnZhcy5jYW52YXMpO1xuICAgIH1cbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmREZXBlbmRlbmNpZXMob3BJZHgsIERlcGVuZGVuY2llcy50cmFuc2Zvcm1BbmRGaWxsKTtcbiAgICByZXR1cm4ge1xuICAgICAgY2FudmFzOiBmaWxsQ2FudmFzLmNhbnZhcyxcbiAgICAgIG9mZnNldFg6IE1hdGgucm91bmQob2Zmc2V0WCksXG4gICAgICBvZmZzZXRZOiBNYXRoLnJvdW5kKG9mZnNldFkpXG4gICAgfTtcbiAgfVxuICBzZXRMaW5lV2lkdGgob3BJZHgsIHdpZHRoKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcImxpbmVXaWR0aFwiLCBvcElkeCk7XG4gICAgaWYgKHdpZHRoICE9PSB0aGlzLmN1cnJlbnQubGluZVdpZHRoKSB7XG4gICAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID0gLTE7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudC5saW5lV2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmN0eC5saW5lV2lkdGggPSB3aWR0aDtcbiAgfVxuICBzZXRMaW5lQ2FwKG9wSWR4LCBzdHlsZSkge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJsaW5lQ2FwXCIsIG9wSWR4KTtcbiAgICB0aGlzLmN0eC5saW5lQ2FwID0gTElORV9DQVBfU1RZTEVTW3N0eWxlXTtcbiAgfVxuICBzZXRMaW5lSm9pbihvcElkeCwgc3R5bGUpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwibGluZUpvaW5cIiwgb3BJZHgpO1xuICAgIHRoaXMuY3R4LmxpbmVKb2luID0gTElORV9KT0lOX1NUWUxFU1tzdHlsZV07XG4gIH1cbiAgc2V0TWl0ZXJMaW1pdChvcElkeCwgbGltaXQpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwibWl0ZXJMaW1pdFwiLCBvcElkeCk7XG4gICAgdGhpcy5jdHgubWl0ZXJMaW1pdCA9IGxpbWl0O1xuICB9XG4gIHNldERhc2gob3BJZHgsIGRhc2hBcnJheSwgZGFzaFBoYXNlKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcImRhc2hcIiwgb3BJZHgpO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGlmIChjdHguc2V0TGluZURhc2ggIT09IHZvaWQgMCkge1xuICAgICAgY3R4LnNldExpbmVEYXNoKGRhc2hBcnJheSk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBkYXNoUGhhc2U7XG4gICAgfVxuICB9XG4gIHNldFJlbmRlcmluZ0ludGVudChvcElkeCwgaW50ZW50KSB7XG4gIH1cbiAgc2V0RmxhdG5lc3Mob3BJZHgsIGZsYXRuZXNzKSB7XG4gIH1cbiAgc2V0R1N0YXRlKG9wSWR4LCBzdGF0ZXMpIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBzdGF0ZXMpIHtcbiAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgXCJMV1wiOlxuICAgICAgICAgIHRoaXMuc2V0TGluZVdpZHRoKG9wSWR4LCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJMQ1wiOlxuICAgICAgICAgIHRoaXMuc2V0TGluZUNhcChvcElkeCwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTEpcIjpcbiAgICAgICAgICB0aGlzLnNldExpbmVKb2luKG9wSWR4LCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJNTFwiOlxuICAgICAgICAgIHRoaXMuc2V0TWl0ZXJMaW1pdChvcElkeCwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRFwiOlxuICAgICAgICAgIHRoaXMuc2V0RGFzaChvcElkeCwgdmFsdWVbMF0sIHZhbHVlWzFdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlJJXCI6XG4gICAgICAgICAgdGhpcy5zZXRSZW5kZXJpbmdJbnRlbnQob3BJZHgsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkZMXCI6XG4gICAgICAgICAgdGhpcy5zZXRGbGF0bmVzcyhvcElkeCwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRm9udFwiOlxuICAgICAgICAgIHRoaXMuc2V0Rm9udChvcElkeCwgdmFsdWVbMF0sIHZhbHVlWzFdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkNBXCI6XG4gICAgICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcInN0cm9rZUFscGhhXCIsIG9wSWR4KTtcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQWxwaGEgPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNhXCI6XG4gICAgICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcImZpbGxBbHBoYVwiLCBvcElkeCk7XG4gICAgICAgICAgdGhpcy5jdHguZ2xvYmFsQWxwaGEgPSB0aGlzLmN1cnJlbnQuZmlsbEFscGhhID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJCTVwiOlxuICAgICAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJnbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cIiwgb3BJZHgpO1xuICAgICAgICAgIHRoaXMuY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiU01hc2tcIjpcbiAgICAgICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwiU01hc2tcIiwgb3BJZHgpO1xuICAgICAgICAgIHRoaXMuY3VycmVudC5hY3RpdmVTTWFzayA9IHZhbHVlID8gdGhpcy50ZW1wU01hc2sgOiBudWxsO1xuICAgICAgICAgIHRoaXMudGVtcFNNYXNrID0gbnVsbDtcbiAgICAgICAgICB0aGlzLmNoZWNrU01hc2tTdGF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiVFJcIjpcbiAgICAgICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwiZmlsdGVyXCIsIG9wSWR4KTtcbiAgICAgICAgICB0aGlzLmN0eC5maWx0ZXIgPSB0aGlzLmN1cnJlbnQudHJhbnNmZXJNYXBzID0gdGhpcy5maWx0ZXJGYWN0b3J5LmFkZEZpbHRlcih2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBpblNNYXNrTW9kZSgpIHtcbiAgICByZXR1cm4gISF0aGlzLnN1c3BlbmRlZEN0eDtcbiAgfVxuICBjaGVja1NNYXNrU3RhdGUoKSB7XG4gICAgY29uc3QgaW5TTWFza01vZGUgPSB0aGlzLmluU01hc2tNb2RlO1xuICAgIGlmICh0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2sgJiYgIWluU01hc2tNb2RlKSB7XG4gICAgICB0aGlzLmJlZ2luU01hc2tNb2RlKCk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrICYmIGluU01hc2tNb2RlKSB7XG4gICAgICB0aGlzLmVuZFNNYXNrTW9kZSgpO1xuICAgIH1cbiAgfVxuICBiZWdpblNNYXNrTW9kZShvcElkeCkge1xuICAgIGlmICh0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiZWdpblNNYXNrTW9kZSBjYWxsZWQgd2hpbGUgYWxyZWFkeSBpbiBzbWFzayBtb2RlXCIpO1xuICAgIH1cbiAgICBjb25zdCBkcmF3bldpZHRoID0gdGhpcy5jdHguY2FudmFzLndpZHRoO1xuICAgIGNvbnN0IGRyYXduSGVpZ2h0ID0gdGhpcy5jdHguY2FudmFzLmhlaWdodDtcbiAgICBjb25zdCBjYWNoZUlkID0gXCJzbWFza0dyb3VwQXRcIiArIHRoaXMuZ3JvdXBMZXZlbDtcbiAgICBjb25zdCBzY3JhdGNoQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoY2FjaGVJZCwgZHJhd25XaWR0aCwgZHJhd25IZWlnaHQpO1xuICAgIHRoaXMuc3VzcGVuZGVkQ3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHggPSBzY3JhdGNoQ2FudmFzLmNvbnRleHQ7XG4gICAgY3R4LnNldFRyYW5zZm9ybSh0aGlzLnN1c3BlbmRlZEN0eC5nZXRUcmFuc2Zvcm0oKSk7XG4gICAgY29weUN0eFN0YXRlKHRoaXMuc3VzcGVuZGVkQ3R4LCBjdHgpO1xuICAgIG1pcnJvckNvbnRleHRPcGVyYXRpb25zKGN0eCwgdGhpcy5zdXNwZW5kZWRDdHgpO1xuICAgIHRoaXMuc2V0R1N0YXRlKG9wSWR4LCBbW1wiQk1cIiwgXCJzb3VyY2Utb3ZlclwiXV0pO1xuICB9XG4gIGVuZFNNYXNrTW9kZSgpIHtcbiAgICBpZiAoIXRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImVuZFNNYXNrTW9kZSBjYWxsZWQgd2hpbGUgbm90IGluIHNtYXNrIG1vZGVcIik7XG4gICAgfVxuICAgIHRoaXMuY3R4Ll9yZW1vdmVNaXJyb3JpbmcoKTtcbiAgICBjb3B5Q3R4U3RhdGUodGhpcy5jdHgsIHRoaXMuc3VzcGVuZGVkQ3R4KTtcbiAgICB0aGlzLmN0eCA9IHRoaXMuc3VzcGVuZGVkQ3R4O1xuICAgIHRoaXMuc3VzcGVuZGVkQ3R4ID0gbnVsbDtcbiAgfVxuICBjb21wb3NlKGRpcnR5Qm94KSB7XG4gICAgaWYgKCF0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFkaXJ0eUJveCkge1xuICAgICAgZGlydHlCb3ggPSBbMCwgMCwgdGhpcy5jdHguY2FudmFzLndpZHRoLCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlydHlCb3hbMF0gPSBNYXRoLmZsb29yKGRpcnR5Qm94WzBdKTtcbiAgICAgIGRpcnR5Qm94WzFdID0gTWF0aC5mbG9vcihkaXJ0eUJveFsxXSk7XG4gICAgICBkaXJ0eUJveFsyXSA9IE1hdGguY2VpbChkaXJ0eUJveFsyXSk7XG4gICAgICBkaXJ0eUJveFszXSA9IE1hdGguY2VpbChkaXJ0eUJveFszXSk7XG4gICAgfVxuICAgIGNvbnN0IHNtYXNrID0gdGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrO1xuICAgIGNvbnN0IHN1c3BlbmRlZEN0eCA9IHRoaXMuc3VzcGVuZGVkQ3R4O1xuICAgIHRoaXMuY29tcG9zZVNNYXNrKHN1c3BlbmRlZEN0eCwgc21hc2ssIHRoaXMuY3R4LCBkaXJ0eUJveCk7XG4gICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICB0aGlzLmN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jdHguY2FudmFzLndpZHRoLCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gIH1cbiAgY29tcG9zZVNNYXNrKGN0eCwgc21hc2ssIGxheWVyQ3R4LCBsYXllckJveCkge1xuICAgIGNvbnN0IGxheWVyT2Zmc2V0WCA9IGxheWVyQm94WzBdO1xuICAgIGNvbnN0IGxheWVyT2Zmc2V0WSA9IGxheWVyQm94WzFdO1xuICAgIGNvbnN0IGxheWVyV2lkdGggPSBsYXllckJveFsyXSAtIGxheWVyT2Zmc2V0WDtcbiAgICBjb25zdCBsYXllckhlaWdodCA9IGxheWVyQm94WzNdIC0gbGF5ZXJPZmZzZXRZO1xuICAgIGlmIChsYXllcldpZHRoID09PSAwIHx8IGxheWVySGVpZ2h0ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZ2VuZXJpY0NvbXBvc2VTTWFzayhzbWFzay5jb250ZXh0LCBsYXllckN0eCwgbGF5ZXJXaWR0aCwgbGF5ZXJIZWlnaHQsIHNtYXNrLnN1YnR5cGUsIHNtYXNrLmJhY2tkcm9wLCBzbWFzay50cmFuc2Zlck1hcCwgbGF5ZXJPZmZzZXRYLCBsYXllck9mZnNldFksIHNtYXNrLm9mZnNldFgsIHNtYXNrLm9mZnNldFkpO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJzb3VyY2Utb3ZlclwiO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgY3R4LmRyYXdJbWFnZShsYXllckN0eC5jYW52YXMsIDAsIDApO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbiAgZ2VuZXJpY0NvbXBvc2VTTWFzayhtYXNrQ3R4LCBsYXllckN0eCwgd2lkdGgsIGhlaWdodCwgc3VidHlwZSwgYmFja2Ryb3AsIHRyYW5zZmVyTWFwLCBsYXllck9mZnNldFgsIGxheWVyT2Zmc2V0WSwgbWFza09mZnNldFgsIG1hc2tPZmZzZXRZKSB7XG4gICAgbGV0IG1hc2tDYW52YXMgPSBtYXNrQ3R4LmNhbnZhcztcbiAgICBsZXQgbWFza1ggPSBsYXllck9mZnNldFggLSBtYXNrT2Zmc2V0WDtcbiAgICBsZXQgbWFza1kgPSBsYXllck9mZnNldFkgLSBtYXNrT2Zmc2V0WTtcbiAgICBpZiAoYmFja2Ryb3ApIHtcbiAgICAgIGlmIChtYXNrWCA8IDAgfHwgbWFza1kgPCAwIHx8IG1hc2tYICsgd2lkdGggPiBtYXNrQ2FudmFzLndpZHRoIHx8IG1hc2tZICsgaGVpZ2h0ID4gbWFza0NhbnZhcy5oZWlnaHQpIHtcbiAgICAgICAgY29uc3QgY2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJtYXNrRXh0ZW5zaW9uXCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuY29udGV4dDtcbiAgICAgICAgY3R4LmRyYXdJbWFnZShtYXNrQ2FudmFzLCAtbWFza1gsIC1tYXNrWSk7XG4gICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcImRlc3RpbmF0aW9uLWF0b3BcIjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tkcm9wO1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1vdmVyXCI7XG4gICAgICAgIG1hc2tDYW52YXMgPSBjYW52YXMuY2FudmFzO1xuICAgICAgICBtYXNrWCA9IG1hc2tZID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hc2tDdHguc2F2ZSgpO1xuICAgICAgICBtYXNrQ3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgICAgICAgbWFza0N0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgIGNvbnN0IGNsaXAyID0gbmV3IFBhdGgyRCgpO1xuICAgICAgICBjbGlwMi5yZWN0KG1hc2tYLCBtYXNrWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIG1hc2tDdHguY2xpcChjbGlwMik7XG4gICAgICAgIG1hc2tDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJkZXN0aW5hdGlvbi1hdG9wXCI7XG4gICAgICAgIG1hc2tDdHguZmlsbFN0eWxlID0gYmFja2Ryb3A7XG4gICAgICAgIG1hc2tDdHguZmlsbFJlY3QobWFza1gsIG1hc2tZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgbWFza0N0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGxheWVyQ3R4LnNhdmUoKTtcbiAgICBsYXllckN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgbGF5ZXJDdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIGlmIChzdWJ0eXBlID09PSBcIkFscGhhXCIgJiYgdHJhbnNmZXJNYXApIHtcbiAgICAgIGxheWVyQ3R4LmZpbHRlciA9IHRoaXMuZmlsdGVyRmFjdG9yeS5hZGRBbHBoYUZpbHRlcih0cmFuc2Zlck1hcCk7XG4gICAgfSBlbHNlIGlmIChzdWJ0eXBlID09PSBcIkx1bWlub3NpdHlcIikge1xuICAgICAgbGF5ZXJDdHguZmlsdGVyID0gdGhpcy5maWx0ZXJGYWN0b3J5LmFkZEx1bWlub3NpdHlGaWx0ZXIodHJhbnNmZXJNYXApO1xuICAgIH1cbiAgICBjb25zdCBjbGlwID0gbmV3IFBhdGgyRCgpO1xuICAgIGNsaXAucmVjdChsYXllck9mZnNldFgsIGxheWVyT2Zmc2V0WSwgd2lkdGgsIGhlaWdodCk7XG4gICAgbGF5ZXJDdHguY2xpcChjbGlwKTtcbiAgICBsYXllckN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcImRlc3RpbmF0aW9uLWluXCI7XG4gICAgbGF5ZXJDdHguZHJhd0ltYWdlKG1hc2tDYW52YXMsIG1hc2tYLCBtYXNrWSwgd2lkdGgsIGhlaWdodCwgbGF5ZXJPZmZzZXRYLCBsYXllck9mZnNldFksIHdpZHRoLCBoZWlnaHQpO1xuICAgIGxheWVyQ3R4LnJlc3RvcmUoKTtcbiAgfVxuICBzYXZlKG9wSWR4KSB7XG4gICAgaWYgKHRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgIGNvcHlDdHhTdGF0ZSh0aGlzLmN0eCwgdGhpcy5zdXNwZW5kZWRDdHgpO1xuICAgIH1cbiAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgY29uc3Qgb2xkID0gdGhpcy5jdXJyZW50O1xuICAgIHRoaXMuc3RhdGVTdGFjay5wdXNoKG9sZCk7XG4gICAgdGhpcy5jdXJyZW50ID0gb2xkLmNsb25lKCk7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8uc2F2ZShvcElkeCk7XG4gIH1cbiAgcmVzdG9yZShvcElkeCkge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlc3RvcmUob3BJZHgpO1xuICAgIGlmICh0aGlzLnN0YXRlU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAodGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgICB0aGlzLmVuZFNNYXNrTW9kZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLnN0YXRlU3RhY2sucG9wKCk7XG4gICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgIGlmICh0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICBjb3B5Q3R4U3RhdGUodGhpcy5zdXNwZW5kZWRDdHgsIHRoaXMuY3R4KTtcbiAgICB9XG4gICAgdGhpcy5jaGVja1NNYXNrU3RhdGUoKTtcbiAgICB0aGlzLnBlbmRpbmdDbGlwID0gbnVsbDtcbiAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID0gLTE7XG4gICAgdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9IG51bGw7XG4gIH1cbiAgdHJhbnNmb3JtKG9wSWR4LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkSW5jcmVtZW50YWxEYXRhKFwidHJhbnNmb3JtXCIsIG9wSWR4KTtcbiAgICB0aGlzLmN0eC50cmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZik7XG4gICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZ1swXSA9IC0xO1xuICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSBudWxsO1xuICB9XG4gIGNvbnN0cnVjdFBhdGgob3BJZHgsIG9wLCBkYXRhLCBtaW5NYXgpIHtcbiAgICBsZXQgW3BhdGhdID0gZGF0YTtcbiAgICBpZiAoIW1pbk1heCkge1xuICAgICAgcGF0aCB8fD0gZGF0YVswXSA9IG5ldyBQYXRoMkQoKTtcbiAgICAgIHRoaXNbb3BdKG9wSWR4LCBwYXRoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGVwZW5kZW5jeVRyYWNrZXIgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG91dGVyRXh0cmFTaXplID0gb3AgPT09IE9QUy5zdHJva2UgPyB0aGlzLmN1cnJlbnQubGluZVdpZHRoIC8gMiA6IDA7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyLnJlc2V0QkJveChvcElkeCkucmVjb3JkQkJveChvcElkeCwgdGhpcy5jdHgsIG1pbk1heFswXSAtIG91dGVyRXh0cmFTaXplLCBtaW5NYXhbMl0gKyBvdXRlckV4dHJhU2l6ZSwgbWluTWF4WzFdIC0gb3V0ZXJFeHRyYVNpemUsIG1pbk1heFszXSArIG91dGVyRXh0cmFTaXplKS5yZWNvcmREZXBlbmRlbmNpZXMob3BJZHgsIFtcInRyYW5zZm9ybVwiXSk7XG4gICAgfVxuICAgIGlmICghKHBhdGggaW5zdGFuY2VvZiBQYXRoMkQpKSB7XG4gICAgICBjb25zdCBwYXRoMmQgPSBkYXRhWzBdID0gbmV3IFBhdGgyRCgpO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcGF0aC5sZW5ndGg7IGkgPCBpaTsgKSB7XG4gICAgICAgIHN3aXRjaCAocGF0aFtpKytdKSB7XG4gICAgICAgICAgY2FzZSBEcmF3T1BTLm1vdmVUbzpcbiAgICAgICAgICAgIHBhdGgyZC5tb3ZlVG8ocGF0aFtpKytdLCBwYXRoW2krK10pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBEcmF3T1BTLmxpbmVUbzpcbiAgICAgICAgICAgIHBhdGgyZC5saW5lVG8ocGF0aFtpKytdLCBwYXRoW2krK10pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBEcmF3T1BTLmN1cnZlVG86XG4gICAgICAgICAgICBwYXRoMmQuYmV6aWVyQ3VydmVUbyhwYXRoW2krK10sIHBhdGhbaSsrXSwgcGF0aFtpKytdLCBwYXRoW2krK10sIHBhdGhbaSsrXSwgcGF0aFtpKytdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgRHJhd09QUy5jbG9zZVBhdGg6XG4gICAgICAgICAgICBwYXRoMmQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgd2FybihgVW5yZWNvZ25pemVkIGRyYXdpbmcgcGF0aCBvcGVyYXRvcjogJHtwYXRoW2kgLSAxXX1gKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwYXRoID0gcGF0aDJkO1xuICAgIH1cbiAgICBVdGlsLmF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KG1pbk1heCwgZ2V0Q3VycmVudFRyYW5zZm9ybSh0aGlzLmN0eCksIHRoaXMuY3VycmVudC5taW5NYXgpO1xuICAgIHRoaXNbb3BdKG9wSWR4LCBwYXRoKTtcbiAgICB0aGlzLl9wYXRoU3RhcnRJZHggPSBvcElkeDtcbiAgfVxuICBjbG9zZVBhdGgob3BJZHgpIHtcbiAgICB0aGlzLmN0eC5jbG9zZVBhdGgoKTtcbiAgfVxuICBzdHJva2Uob3BJZHgsIHBhdGgsIGNvbnN1bWVQYXRoID0gdHJ1ZSkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IHN0cm9rZUNvbG9yID0gdGhpcy5jdXJyZW50LnN0cm9rZUNvbG9yO1xuICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuY3VycmVudC5zdHJva2VBbHBoYTtcbiAgICBpZiAodGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgaWYgKHR5cGVvZiBzdHJva2VDb2xvciA9PT0gXCJvYmplY3RcIiAmJiBzdHJva2VDb2xvcj8uZ2V0UGF0dGVybikge1xuICAgICAgICBjb25zdCBiYXNlVHJhbnNmb3JtID0gc3Ryb2tlQ29sb3IuaXNNb2RpZnlpbmdDdXJyZW50VHJhbnNmb3JtKCkgPyBjdHguZ2V0VHJhbnNmb3JtKCkgOiBudWxsO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2VDb2xvci5nZXRQYXR0ZXJuKGN0eCwgdGhpcywgZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoY3R4KSwgUGF0aFR5cGUuU1RST0tFLCBvcElkeCk7XG4gICAgICAgIGlmIChiYXNlVHJhbnNmb3JtKSB7XG4gICAgICAgICAgY29uc3QgbmV3UGF0aCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgICAgICBuZXdQYXRoLmFkZFBhdGgocGF0aCwgY3R4LmdldFRyYW5zZm9ybSgpLmludmVydFNlbGYoKS5tdWx0aXBseVNlbGYoYmFzZVRyYW5zZm9ybSkpO1xuICAgICAgICAgIHBhdGggPSBuZXdQYXRoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzY2FsZUFuZFN0cm9rZShwYXRoLCBmYWxzZSk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlc2NhbGVBbmRTdHJva2UocGF0aCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZERlcGVuZGVuY2llcyhvcElkeCwgRGVwZW5kZW5jaWVzLnN0cm9rZSk7XG4gICAgaWYgKGNvbnN1bWVQYXRoKSB7XG4gICAgICB0aGlzLmNvbnN1bWVQYXRoKG9wSWR4LCBwYXRoLCB0aGlzLmN1cnJlbnQuZ2V0Q2xpcHBlZFBhdGhCb3VuZGluZ0JveChQYXRoVHlwZS5TVFJPS0UsIGdldEN1cnJlbnRUcmFuc2Zvcm0odGhpcy5jdHgpKSk7XG4gICAgfVxuICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuY3VycmVudC5maWxsQWxwaGE7XG4gIH1cbiAgY2xvc2VTdHJva2Uob3BJZHgsIHBhdGgpIHtcbiAgICB0aGlzLnN0cm9rZShvcElkeCwgcGF0aCk7XG4gIH1cbiAgZmlsbChvcElkeCwgcGF0aCwgY29uc3VtZVBhdGggPSB0cnVlKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZmlsbENvbG9yID0gdGhpcy5jdXJyZW50LmZpbGxDb2xvcjtcbiAgICBjb25zdCBpc1BhdHRlcm5GaWxsID0gdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsO1xuICAgIGxldCBuZWVkUmVzdG9yZSA9IGZhbHNlO1xuICAgIGlmIChpc1BhdHRlcm5GaWxsKSB7XG4gICAgICBjb25zdCBiYXNlVHJhbnNmb3JtID0gZmlsbENvbG9yLmlzTW9kaWZ5aW5nQ3VycmVudFRyYW5zZm9ybSgpID8gY3R4LmdldFRyYW5zZm9ybSgpIDogbnVsbDtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnNhdmUob3BJZHgpO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsQ29sb3IuZ2V0UGF0dGVybihjdHgsIHRoaXMsIGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGN0eCksIFBhdGhUeXBlLkZJTEwsIG9wSWR4KTtcbiAgICAgIGlmIChiYXNlVHJhbnNmb3JtKSB7XG4gICAgICAgIGNvbnN0IG5ld1BhdGggPSBuZXcgUGF0aDJEKCk7XG4gICAgICAgIG5ld1BhdGguYWRkUGF0aChwYXRoLCBjdHguZ2V0VHJhbnNmb3JtKCkuaW52ZXJ0U2VsZigpLm11bHRpcGx5U2VsZihiYXNlVHJhbnNmb3JtKSk7XG4gICAgICAgIHBhdGggPSBuZXdQYXRoO1xuICAgICAgfVxuICAgICAgbmVlZFJlc3RvcmUgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBpbnRlcnNlY3QgPSB0aGlzLmN1cnJlbnQuZ2V0Q2xpcHBlZFBhdGhCb3VuZGluZ0JveCgpO1xuICAgIGlmICh0aGlzLmNvbnRlbnRWaXNpYmxlICYmIGludGVyc2VjdCAhPT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMucGVuZGluZ0VPRmlsbCkge1xuICAgICAgICBjdHguZmlsbChwYXRoLCBcImV2ZW5vZGRcIik7XG4gICAgICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LmZpbGwocGF0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZERlcGVuZGVuY2llcyhvcElkeCwgRGVwZW5kZW5jaWVzLmZpbGwpO1xuICAgIGlmIChuZWVkUmVzdG9yZSkge1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlc3RvcmUob3BJZHgpO1xuICAgIH1cbiAgICBpZiAoY29uc3VtZVBhdGgpIHtcbiAgICAgIHRoaXMuY29uc3VtZVBhdGgob3BJZHgsIHBhdGgsIGludGVyc2VjdCk7XG4gICAgfVxuICB9XG4gIGVvRmlsbChvcElkeCwgcGF0aCkge1xuICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IHRydWU7XG4gICAgdGhpcy5maWxsKG9wSWR4LCBwYXRoKTtcbiAgfVxuICBmaWxsU3Ryb2tlKG9wSWR4LCBwYXRoKSB7XG4gICAgdGhpcy5maWxsKG9wSWR4LCBwYXRoLCBmYWxzZSk7XG4gICAgdGhpcy5zdHJva2Uob3BJZHgsIHBhdGgsIGZhbHNlKTtcbiAgICB0aGlzLmNvbnN1bWVQYXRoKG9wSWR4LCBwYXRoKTtcbiAgfVxuICBlb0ZpbGxTdHJva2Uob3BJZHgsIHBhdGgpIHtcbiAgICB0aGlzLnBlbmRpbmdFT0ZpbGwgPSB0cnVlO1xuICAgIHRoaXMuZmlsbFN0cm9rZShvcElkeCwgcGF0aCk7XG4gIH1cbiAgY2xvc2VGaWxsU3Ryb2tlKG9wSWR4LCBwYXRoKSB7XG4gICAgdGhpcy5maWxsU3Ryb2tlKG9wSWR4LCBwYXRoKTtcbiAgfVxuICBjbG9zZUVPRmlsbFN0cm9rZShvcElkeCwgcGF0aCkge1xuICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IHRydWU7XG4gICAgdGhpcy5maWxsU3Ryb2tlKG9wSWR4LCBwYXRoKTtcbiAgfVxuICBlbmRQYXRoKG9wSWR4LCBwYXRoKSB7XG4gICAgdGhpcy5jb25zdW1lUGF0aChvcElkeCwgcGF0aCk7XG4gIH1cbiAgcmF3RmlsbFBhdGgob3BJZHgsIHBhdGgpIHtcbiAgICB0aGlzLmN0eC5maWxsKHBhdGgpO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZERlcGVuZGVuY2llcyhvcElkeCwgRGVwZW5kZW5jaWVzLnJhd0ZpbGxQYXRoKS5yZWNvcmRPcGVyYXRpb24ob3BJZHgpO1xuICB9XG4gIGNsaXAob3BJZHgpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRGdXR1cmVGb3JjZWREZXBlbmRlbmN5KFwiY2xpcE1vZGVcIiwgb3BJZHgpO1xuICAgIHRoaXMucGVuZGluZ0NsaXAgPSBOT1JNQUxfQ0xJUDtcbiAgfVxuICBlb0NsaXAob3BJZHgpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRGdXR1cmVGb3JjZWREZXBlbmRlbmN5KFwiY2xpcE1vZGVcIiwgb3BJZHgpO1xuICAgIHRoaXMucGVuZGluZ0NsaXAgPSBFT19DTElQO1xuICB9XG4gIGJlZ2luVGV4dChvcElkeCkge1xuICAgIHRoaXMuY3VycmVudC50ZXh0TWF0cml4ID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnQudGV4dE1hdHJpeFNjYWxlID0gMTtcbiAgICB0aGlzLmN1cnJlbnQueCA9IHRoaXMuY3VycmVudC5saW5lWCA9IDA7XG4gICAgdGhpcy5jdXJyZW50LnkgPSB0aGlzLmN1cnJlbnQubGluZVkgPSAwO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZE9wZW5NYXJrZXIob3BJZHgpLnJlc2V0SW5jcmVtZW50YWxEYXRhKFwic2FtZUxpbmVUZXh0XCIpLnJlc2V0SW5jcmVtZW50YWxEYXRhKFwibW92ZVRleHRcIiwgb3BJZHgpO1xuICB9XG4gIGVuZFRleHQob3BJZHgpIHtcbiAgICBjb25zdCBwYXRocyA9IHRoaXMucGVuZGluZ1RleHRQYXRocztcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBpZiAodGhpcy5kZXBlbmRlbmN5VHJhY2tlcikge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkZXBlbmRlbmN5VHJhY2tlclxuICAgICAgfSA9IHRoaXM7XG4gICAgICBpZiAocGF0aHMgIT09IHZvaWQgMCkge1xuICAgICAgICBkZXBlbmRlbmN5VHJhY2tlci5yZWNvcmRGdXR1cmVGb3JjZWREZXBlbmRlbmN5KFwidGV4dENsaXBcIiwgZGVwZW5kZW5jeVRyYWNrZXIuZ2V0T3Blbk1hcmtlcigpKS5yZWNvcmRGdXR1cmVGb3JjZWREZXBlbmRlbmN5KFwidGV4dENsaXBcIiwgb3BJZHgpO1xuICAgICAgfVxuICAgICAgZGVwZW5kZW5jeVRyYWNrZXIucmVjb3JkQ2xvc2VNYXJrZXIob3BJZHgpO1xuICAgIH1cbiAgICBpZiAocGF0aHMgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgbmV3UGF0aCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgIGNvbnN0IGludlRyYW5zZiA9IGN0eC5nZXRUcmFuc2Zvcm0oKS5pbnZlcnRTZWxmKCk7XG4gICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBmb250U2l6ZSxcbiAgICAgICAgcGF0aFxuICAgICAgfSBvZiBwYXRocykge1xuICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBuZXdQYXRoLmFkZFBhdGgocGF0aCwgbmV3IERPTU1hdHJpeCh0cmFuc2Zvcm0pLnByZU11bHRpcGx5U2VsZihpbnZUcmFuc2YpLnRyYW5zbGF0ZSh4LCB5KS5zY2FsZShmb250U2l6ZSwgLWZvbnRTaXplKSk7XG4gICAgICB9XG4gICAgICBjdHguY2xpcChuZXdQYXRoKTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMucGVuZGluZ1RleHRQYXRocztcbiAgfVxuICBzZXRDaGFyU3BhY2luZyhvcElkeCwgc3BhY2luZykge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJjaGFyU3BhY2luZ1wiLCBvcElkeCk7XG4gICAgdGhpcy5jdXJyZW50LmNoYXJTcGFjaW5nID0gc3BhY2luZztcbiAgfVxuICBzZXRXb3JkU3BhY2luZyhvcElkeCwgc3BhY2luZykge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJ3b3JkU3BhY2luZ1wiLCBvcElkeCk7XG4gICAgdGhpcy5jdXJyZW50LndvcmRTcGFjaW5nID0gc3BhY2luZztcbiAgfVxuICBzZXRIU2NhbGUob3BJZHgsIHNjYWxlKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcImhTY2FsZVwiLCBvcElkeCk7XG4gICAgdGhpcy5jdXJyZW50LnRleHRIU2NhbGUgPSBzY2FsZSAvIDEwMDtcbiAgfVxuICBzZXRMZWFkaW5nKG9wSWR4LCBsZWFkaW5nKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcImxlYWRpbmdcIiwgb3BJZHgpO1xuICAgIHRoaXMuY3VycmVudC5sZWFkaW5nID0gLWxlYWRpbmc7XG4gIH1cbiAgc2V0Rm9udChvcElkeCwgZm9udFJlZk5hbWUsIHNpemUpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwiZm9udFwiLCBvcElkeCkucmVjb3JkU2ltcGxlRGF0YUZyb21OYW1lZChcImZvbnRPYmpcIiwgZm9udFJlZk5hbWUsIG9wSWR4KTtcbiAgICBjb25zdCBmb250T2JqID0gdGhpcy5jb21tb25PYmpzLmdldChmb250UmVmTmFtZSk7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBpZiAoIWZvbnRPYmopIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgZmluZCBmb250IGZvciAke2ZvbnRSZWZOYW1lfWApO1xuICAgIH1cbiAgICBjdXJyZW50LmZvbnRNYXRyaXggPSBmb250T2JqLmZvbnRNYXRyaXggfHwgRk9OVF9JREVOVElUWV9NQVRSSVg7XG4gICAgaWYgKGN1cnJlbnQuZm9udE1hdHJpeFswXSA9PT0gMCB8fCBjdXJyZW50LmZvbnRNYXRyaXhbM10gPT09IDApIHtcbiAgICAgIHdhcm4oXCJJbnZhbGlkIGZvbnQgbWF0cml4IGZvciBmb250IFwiICsgZm9udFJlZk5hbWUpO1xuICAgIH1cbiAgICBpZiAoc2l6ZSA8IDApIHtcbiAgICAgIHNpemUgPSAtc2l6ZTtcbiAgICAgIGN1cnJlbnQuZm9udERpcmVjdGlvbiA9IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50LmZvbnREaXJlY3Rpb24gPSAxO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQuZm9udCA9IGZvbnRPYmo7XG4gICAgdGhpcy5jdXJyZW50LmZvbnRTaXplID0gc2l6ZTtcbiAgICBpZiAoZm9udE9iai5pc1R5cGUzRm9udCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuYW1lID0gZm9udE9iai5sb2FkZWROYW1lIHx8IFwic2Fucy1zZXJpZlwiO1xuICAgIGNvbnN0IHR5cGVmYWNlID0gZm9udE9iai5zeXN0ZW1Gb250SW5mbz8uY3NzIHx8IGBcIiR7bmFtZX1cIiwgJHtmb250T2JqLmZhbGxiYWNrTmFtZX1gO1xuICAgIGxldCBib2xkID0gXCJub3JtYWxcIjtcbiAgICBpZiAoZm9udE9iai5ibGFjaykge1xuICAgICAgYm9sZCA9IFwiOTAwXCI7XG4gICAgfSBlbHNlIGlmIChmb250T2JqLmJvbGQpIHtcbiAgICAgIGJvbGQgPSBcImJvbGRcIjtcbiAgICB9XG4gICAgY29uc3QgaXRhbGljID0gZm9udE9iai5pdGFsaWMgPyBcIml0YWxpY1wiIDogXCJub3JtYWxcIjtcbiAgICBsZXQgYnJvd3NlckZvbnRTaXplID0gc2l6ZTtcbiAgICBpZiAoc2l6ZSA8IE1JTl9GT05UX1NJWkUpIHtcbiAgICAgIGJyb3dzZXJGb250U2l6ZSA9IE1JTl9GT05UX1NJWkU7XG4gICAgfSBlbHNlIGlmIChzaXplID4gTUFYX0ZPTlRfU0laRSkge1xuICAgICAgYnJvd3NlckZvbnRTaXplID0gTUFYX0ZPTlRfU0laRTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50LmZvbnRTaXplU2NhbGUgPSBzaXplIC8gYnJvd3NlckZvbnRTaXplO1xuICAgIHRoaXMuY3R4LmZvbnQgPSBgJHtpdGFsaWN9ICR7Ym9sZH0gJHticm93c2VyRm9udFNpemV9cHggJHt0eXBlZmFjZX1gO1xuICB9XG4gIHNldFRleHRSZW5kZXJpbmdNb2RlKG9wSWR4LCBtb2RlKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcInRleHRSZW5kZXJpbmdNb2RlXCIsIG9wSWR4KTtcbiAgICB0aGlzLmN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgPSBtb2RlO1xuICB9XG4gIHNldFRleHRSaXNlKG9wSWR4LCByaXNlKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcInRleHRSaXNlXCIsIG9wSWR4KTtcbiAgICB0aGlzLmN1cnJlbnQudGV4dFJpc2UgPSByaXNlO1xuICB9XG4gIG1vdmVUZXh0KG9wSWR4LCB4LCB5KSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVzZXRJbmNyZW1lbnRhbERhdGEoXCJzYW1lTGluZVRleHRcIikucmVjb3JkSW5jcmVtZW50YWxEYXRhKFwibW92ZVRleHRcIiwgb3BJZHgpO1xuICAgIHRoaXMuY3VycmVudC54ID0gdGhpcy5jdXJyZW50LmxpbmVYICs9IHg7XG4gICAgdGhpcy5jdXJyZW50LnkgPSB0aGlzLmN1cnJlbnQubGluZVkgKz0geTtcbiAgfVxuICBzZXRMZWFkaW5nTW92ZVRleHQob3BJZHgsIHgsIHkpIHtcbiAgICB0aGlzLnNldExlYWRpbmcob3BJZHgsIC15KTtcbiAgICB0aGlzLm1vdmVUZXh0KG9wSWR4LCB4LCB5KTtcbiAgfVxuICBzZXRUZXh0TWF0cml4KG9wSWR4LCBtYXRyaXgpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwidGV4dE1hdHJpeFwiLCBvcElkeCk7XG4gICAgY29uc3Qge1xuICAgICAgY3VycmVudFxuICAgIH0gPSB0aGlzO1xuICAgIGN1cnJlbnQudGV4dE1hdHJpeCA9IG1hdHJpeDtcbiAgICBjdXJyZW50LnRleHRNYXRyaXhTY2FsZSA9IE1hdGguaHlwb3QobWF0cml4WzBdLCBtYXRyaXhbMV0pO1xuICAgIGN1cnJlbnQueCA9IGN1cnJlbnQubGluZVggPSAwO1xuICAgIGN1cnJlbnQueSA9IGN1cnJlbnQubGluZVkgPSAwO1xuICB9XG4gIG5leHRMaW5lKG9wSWR4KSB7XG4gICAgdGhpcy5tb3ZlVGV4dChvcElkeCwgMCwgdGhpcy5jdXJyZW50LmxlYWRpbmcpO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZEluY3JlbWVudGFsRGF0YShcIm1vdmVUZXh0XCIsIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXIuZ2V0U2ltcGxlSW5kZXgoXCJsZWFkaW5nXCIpID8/IG9wSWR4KTtcbiAgfVxuICAjZ2V0U2NhbGVkUGF0aChwYXRoLCBjdXJyZW50VHJhbnNmb3JtLCB0cmFuc2Zvcm0pIHtcbiAgICBjb25zdCBuZXdQYXRoID0gbmV3IFBhdGgyRCgpO1xuICAgIG5ld1BhdGguYWRkUGF0aChwYXRoLCBuZXcgRE9NTWF0cml4KHRyYW5zZm9ybSkuaW52ZXJ0U2VsZigpLm11bHRpcGx5U2VsZihjdXJyZW50VHJhbnNmb3JtKSk7XG4gICAgcmV0dXJuIG5ld1BhdGg7XG4gIH1cbiAgcGFpbnRDaGFyKG9wSWR4LCBjaGFyYWN0ZXIsIHgsIHksIHBhdHRlcm5GaWxsVHJhbnNmb3JtLCBwYXR0ZXJuU3Ryb2tlVHJhbnNmb3JtKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBjb25zdCBmb250ID0gY3VycmVudC5mb250O1xuICAgIGNvbnN0IHRleHRSZW5kZXJpbmdNb2RlID0gY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZTtcbiAgICBjb25zdCBmb250U2l6ZSA9IGN1cnJlbnQuZm9udFNpemUgLyBjdXJyZW50LmZvbnRTaXplU2NhbGU7XG4gICAgY29uc3QgZmlsbFN0cm9rZU1vZGUgPSB0ZXh0UmVuZGVyaW5nTW9kZSAmIFRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFX01BU0s7XG4gICAgY29uc3QgaXNBZGRUb1BhdGhTZXQgPSAhISh0ZXh0UmVuZGVyaW5nTW9kZSAmIFRleHRSZW5kZXJpbmdNb2RlLkFERF9UT19QQVRIX0ZMQUcpO1xuICAgIGNvbnN0IHBhdHRlcm5GaWxsID0gY3VycmVudC5wYXR0ZXJuRmlsbCAmJiAhZm9udC5taXNzaW5nRmlsZTtcbiAgICBjb25zdCBwYXR0ZXJuU3Ryb2tlID0gY3VycmVudC5wYXR0ZXJuU3Ryb2tlICYmICFmb250Lm1pc3NpbmdGaWxlO1xuICAgIGxldCBwYXRoO1xuICAgIGlmICgoZm9udC5kaXNhYmxlRm9udEZhY2UgfHwgaXNBZGRUb1BhdGhTZXQgfHwgcGF0dGVybkZpbGwgfHwgcGF0dGVyblN0cm9rZSkgJiYgIWZvbnQubWlzc2luZ0ZpbGUpIHtcbiAgICAgIHBhdGggPSBmb250LmdldFBhdGhHZW5lcmF0b3IodGhpcy5jb21tb25PYmpzLCBjaGFyYWN0ZXIpO1xuICAgIH1cbiAgICBpZiAocGF0aCAmJiAoZm9udC5kaXNhYmxlRm9udEZhY2UgfHwgcGF0dGVybkZpbGwgfHwgcGF0dGVyblN0cm9rZSkpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgY3R4LnNjYWxlKGZvbnRTaXplLCAtZm9udFNpemUpO1xuICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkQ2hhcmFjdGVyQkJveChvcElkeCwgY3R4LCBmb250KTtcbiAgICAgIGxldCBjdXJyZW50VHJhbnNmb3JtO1xuICAgICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBUZXh0UmVuZGVyaW5nTW9kZS5GSUxMIHx8IGZpbGxTdHJva2VNb2RlID09PSBUZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRSkge1xuICAgICAgICBpZiAocGF0dGVybkZpbGxUcmFuc2Zvcm0pIHtcbiAgICAgICAgICBjdXJyZW50VHJhbnNmb3JtID0gY3R4LmdldFRyYW5zZm9ybSgpO1xuICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oLi4ucGF0dGVybkZpbGxUcmFuc2Zvcm0pO1xuICAgICAgICAgIGNvbnN0IHNjYWxlZFBhdGggPSB0aGlzLiNnZXRTY2FsZWRQYXRoKHBhdGgsIGN1cnJlbnRUcmFuc2Zvcm0sIHBhdHRlcm5GaWxsVHJhbnNmb3JtKTtcbiAgICAgICAgICBjdHguZmlsbChzY2FsZWRQYXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHguZmlsbChwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBUZXh0UmVuZGVyaW5nTW9kZS5TVFJPS0UgfHwgZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgIGlmIChwYXR0ZXJuU3Ryb2tlVHJhbnNmb3JtKSB7XG4gICAgICAgICAgY3VycmVudFRyYW5zZm9ybSB8fD0gY3R4LmdldFRyYW5zZm9ybSgpO1xuICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oLi4ucGF0dGVyblN0cm9rZVRyYW5zZm9ybSk7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIGIsXG4gICAgICAgICAgICBjLFxuICAgICAgICAgICAgZFxuICAgICAgICAgIH0gPSBjdXJyZW50VHJhbnNmb3JtO1xuICAgICAgICAgIGNvbnN0IGludlBhdHRlcm5UcmFuc2Zvcm0gPSBVdGlsLmludmVyc2VUcmFuc2Zvcm0ocGF0dGVyblN0cm9rZVRyYW5zZm9ybSk7XG4gICAgICAgICAgY29uc3QgdHJhbnNmID0gVXRpbC50cmFuc2Zvcm0oW2EsIGIsIGMsIGQsIDAsIDBdLCBpbnZQYXR0ZXJuVHJhbnNmb3JtKTtcbiAgICAgICAgICBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRyYW5zZiwgWFkpO1xuICAgICAgICAgIGN0eC5saW5lV2lkdGggKj0gTWF0aC5tYXgoWFlbMF0sIFhZWzFdKSAvIGZvbnRTaXplO1xuICAgICAgICAgIGN0eC5zdHJva2UodGhpcy4jZ2V0U2NhbGVkUGF0aChwYXRoLCBjdXJyZW50VHJhbnNmb3JtLCBwYXR0ZXJuU3Ryb2tlVHJhbnNmb3JtKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4LmxpbmVXaWR0aCAvPSBmb250U2l6ZTtcbiAgICAgICAgICBjdHguc3Ryb2tlKHBhdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLkZJTEwgfHwgZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgIGN0eC5maWxsVGV4dChjaGFyYWN0ZXIsIHgsIHkpO1xuICAgICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRDaGFyYWN0ZXJCQm94KG9wSWR4LCBjdHgsIGZvbnQsIGZvbnRTaXplLCB4LCB5LCAoKSA9PiBjdHgubWVhc3VyZVRleHQoY2hhcmFjdGVyKSk7XG4gICAgICB9XG4gICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLlNUUk9LRSB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVwZW5kZW5jeVRyYWNrZXIpIHtcbiAgICAgICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRDaGFyYWN0ZXJCQm94KG9wSWR4LCBjdHgsIGZvbnQsIGZvbnRTaXplLCB4LCB5LCAoKSA9PiBjdHgubWVhc3VyZVRleHQoY2hhcmFjdGVyKSkucmVjb3JkRGVwZW5kZW5jaWVzKG9wSWR4LCBEZXBlbmRlbmNpZXMuc3Ryb2tlKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguc3Ryb2tlVGV4dChjaGFyYWN0ZXIsIHgsIHkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNBZGRUb1BhdGhTZXQpIHtcbiAgICAgIGNvbnN0IHBhdGhzID0gdGhpcy5wZW5kaW5nVGV4dFBhdGhzIHx8PSBbXTtcbiAgICAgIHBhdGhzLnB1c2goe1xuICAgICAgICB0cmFuc2Zvcm06IGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KSxcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgZm9udFNpemUsXG4gICAgICAgIHBhdGhcbiAgICAgIH0pO1xuICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkQ2hhcmFjdGVyQkJveChvcElkeCwgY3R4LCBmb250LCBmb250U2l6ZSwgeCwgeSk7XG4gICAgfVxuICB9XG4gIGdldCBpc0ZvbnRTdWJwaXhlbEFBRW5hYmxlZCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250ZXh0OiBjdHhcbiAgICB9ID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJpc0ZvbnRTdWJwaXhlbEFBRW5hYmxlZFwiLCAxMCwgMTApO1xuICAgIGN0eC5zY2FsZSgxLjUsIDEpO1xuICAgIGN0eC5maWxsVGV4dChcIklcIiwgMCwgMTApO1xuICAgIGNvbnN0IGRhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEwLCAxMCkuZGF0YTtcbiAgICBsZXQgZW5hYmxlZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAzOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgaWYgKGRhdGFbaV0gPiAwICYmIGRhdGFbaV0gPCAyNTUpIHtcbiAgICAgICAgZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNGb250U3VicGl4ZWxBQUVuYWJsZWRcIiwgZW5hYmxlZCk7XG4gIH1cbiAgc2hvd1RleHQob3BJZHgsIGdseXBocykge1xuICAgIGlmICh0aGlzLmRlcGVuZGVuY3lUcmFja2VyKSB7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyLnJlY29yZERlcGVuZGVuY2llcyhvcElkeCwgRGVwZW5kZW5jaWVzLnNob3dUZXh0KS5yZXNldEJCb3gob3BJZHgpO1xuICAgICAgaWYgKHRoaXMuY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSAmIFRleHRSZW5kZXJpbmdNb2RlLkFERF9UT19QQVRIX0ZMQUcpIHtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlci5yZWNvcmRGdXR1cmVGb3JjZWREZXBlbmRlbmN5KFwidGV4dENsaXBcIiwgb3BJZHgpLmluaGVyaXRQZW5kaW5nRGVwZW5kZW5jaWVzQXNGdXR1cmVGb3JjZWREZXBlbmRlbmNpZXMoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBjb25zdCBmb250ID0gY3VycmVudC5mb250O1xuICAgIGlmIChmb250LmlzVHlwZTNGb250KSB7XG4gICAgICB0aGlzLnNob3dUeXBlM1RleHQob3BJZHgsIGdseXBocyk7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaG93VGV4dE9wZXJhdGlvbihvcElkeCk7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBjb25zdCBmb250U2l6ZSA9IGN1cnJlbnQuZm9udFNpemU7XG4gICAgaWYgKGZvbnRTaXplID09PSAwKSB7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRPcGVyYXRpb24ob3BJZHgpO1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZm9udFNpemVTY2FsZSA9IGN1cnJlbnQuZm9udFNpemVTY2FsZTtcbiAgICBjb25zdCBjaGFyU3BhY2luZyA9IGN1cnJlbnQuY2hhclNwYWNpbmc7XG4gICAgY29uc3Qgd29yZFNwYWNpbmcgPSBjdXJyZW50LndvcmRTcGFjaW5nO1xuICAgIGNvbnN0IGZvbnREaXJlY3Rpb24gPSBjdXJyZW50LmZvbnREaXJlY3Rpb247XG4gICAgY29uc3QgdGV4dEhTY2FsZSA9IGN1cnJlbnQudGV4dEhTY2FsZSAqIGZvbnREaXJlY3Rpb247XG4gICAgY29uc3QgZ2x5cGhzTGVuZ3RoID0gZ2x5cGhzLmxlbmd0aDtcbiAgICBjb25zdCB2ZXJ0aWNhbCA9IGZvbnQudmVydGljYWw7XG4gICAgY29uc3Qgc3BhY2luZ0RpciA9IHZlcnRpY2FsID8gMSA6IC0xO1xuICAgIGNvbnN0IGRlZmF1bHRWTWV0cmljcyA9IGZvbnQuZGVmYXVsdFZNZXRyaWNzO1xuICAgIGNvbnN0IHdpZHRoQWR2YW5jZVNjYWxlID0gZm9udFNpemUgKiBjdXJyZW50LmZvbnRNYXRyaXhbMF07XG4gICAgY29uc3Qgc2ltcGxlRmlsbFRleHQgPSBjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlID09PSBUZXh0UmVuZGVyaW5nTW9kZS5GSUxMICYmICFmb250LmRpc2FibGVGb250RmFjZSAmJiAhY3VycmVudC5wYXR0ZXJuRmlsbDtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGlmIChjdXJyZW50LnRleHRNYXRyaXgpIHtcbiAgICAgIGN0eC50cmFuc2Zvcm0oLi4uY3VycmVudC50ZXh0TWF0cml4KTtcbiAgICB9XG4gICAgY3R4LnRyYW5zbGF0ZShjdXJyZW50LngsIGN1cnJlbnQueSArIGN1cnJlbnQudGV4dFJpc2UpO1xuICAgIGlmIChmb250RGlyZWN0aW9uID4gMCkge1xuICAgICAgY3R4LnNjYWxlKHRleHRIU2NhbGUsIC0xKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LnNjYWxlKHRleHRIU2NhbGUsIDEpO1xuICAgIH1cbiAgICBsZXQgcGF0dGVybkZpbGxUcmFuc2Zvcm0sIHBhdHRlcm5TdHJva2VUcmFuc2Zvcm07XG4gICAgaWYgKGN1cnJlbnQucGF0dGVybkZpbGwpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjb25zdCBwYXR0ZXJuID0gY3VycmVudC5maWxsQ29sb3IuZ2V0UGF0dGVybihjdHgsIHRoaXMsIGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGN0eCksIFBhdGhUeXBlLkZJTEwsIG9wSWR4KTtcbiAgICAgIHBhdHRlcm5GaWxsVHJhbnNmb3JtID0gZ2V0Q3VycmVudFRyYW5zZm9ybShjdHgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBwYXR0ZXJuO1xuICAgIH1cbiAgICBpZiAoY3VycmVudC5wYXR0ZXJuU3Ryb2tlKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY29uc3QgcGF0dGVybiA9IGN1cnJlbnQuc3Ryb2tlQ29sb3IuZ2V0UGF0dGVybihjdHgsIHRoaXMsIGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGN0eCksIFBhdGhUeXBlLlNUUk9LRSwgb3BJZHgpO1xuICAgICAgcGF0dGVyblN0cm9rZVRyYW5zZm9ybSA9IGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBwYXR0ZXJuO1xuICAgIH1cbiAgICBsZXQgbGluZVdpZHRoID0gY3VycmVudC5saW5lV2lkdGg7XG4gICAgY29uc3Qgc2NhbGUgPSBjdXJyZW50LnRleHRNYXRyaXhTY2FsZTtcbiAgICBpZiAoc2NhbGUgPT09IDAgfHwgbGluZVdpZHRoID09PSAwKSB7XG4gICAgICBjb25zdCBmaWxsU3Ryb2tlTW9kZSA9IGN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgJiBUZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRV9NQVNLO1xuICAgICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBUZXh0UmVuZGVyaW5nTW9kZS5TVFJPS0UgfHwgZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgIGxpbmVXaWR0aCA9IHRoaXMuZ2V0U2luZ2xlUGl4ZWxXaWR0aCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lV2lkdGggLz0gc2NhbGU7XG4gICAgfVxuICAgIGlmIChmb250U2l6ZVNjYWxlICE9PSAxKSB7XG4gICAgICBjdHguc2NhbGUoZm9udFNpemVTY2FsZSwgZm9udFNpemVTY2FsZSk7XG4gICAgICBsaW5lV2lkdGggLz0gZm9udFNpemVTY2FsZTtcbiAgICB9XG4gICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICBpZiAoZm9udC5pc0ludmFsaWRQREZqc0ZvbnQpIHtcbiAgICAgIGNvbnN0IGNoYXJzID0gW107XG4gICAgICBsZXQgd2lkdGggPSAwO1xuICAgICAgZm9yIChjb25zdCBnbHlwaCBvZiBnbHlwaHMpIHtcbiAgICAgICAgY2hhcnMucHVzaChnbHlwaC51bmljb2RlKTtcbiAgICAgICAgd2lkdGggKz0gZ2x5cGgud2lkdGg7XG4gICAgICB9XG4gICAgICBjb25zdCBqb2luZWRDaGFycyA9IGNoYXJzLmpvaW4oXCJcIik7XG4gICAgICBjdHguZmlsbFRleHQoam9pbmVkQ2hhcnMsIDAsIDApO1xuICAgICAgaWYgKHRoaXMuZGVwZW5kZW5jeVRyYWNrZXIgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgbWVhc3VyZSA9IGN0eC5tZWFzdXJlVGV4dChqb2luZWRDaGFycyk7XG4gICAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXIucmVjb3JkQkJveChvcElkeCwgdGhpcy5jdHgsIC1tZWFzdXJlLmFjdHVhbEJvdW5kaW5nQm94TGVmdCwgbWVhc3VyZS5hY3R1YWxCb3VuZGluZ0JveFJpZ2h0LCAtbWVhc3VyZS5hY3R1YWxCb3VuZGluZ0JveEFzY2VudCwgbWVhc3VyZS5hY3R1YWxCb3VuZGluZ0JveERlc2NlbnQpLnJlY29yZFNob3dUZXh0T3BlcmF0aW9uKG9wSWR4KTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQueCArPSB3aWR0aCAqIHdpZHRoQWR2YW5jZVNjYWxlICogdGV4dEhTY2FsZTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB0aGlzLmNvbXBvc2UoKTtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGxldCB4ID0gMCwgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2x5cGhzTGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBnbHlwaCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB4ICs9IHNwYWNpbmdEaXIgKiBnbHlwaCAqIGZvbnRTaXplIC8gMWUzO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldCByZXN0b3JlTmVlZGVkID0gZmFsc2U7XG4gICAgICBjb25zdCBzcGFjaW5nID0gKGdseXBoLmlzU3BhY2UgPyB3b3JkU3BhY2luZyA6IDApICsgY2hhclNwYWNpbmc7XG4gICAgICBjb25zdCBjaGFyYWN0ZXIgPSBnbHlwaC5mb250Q2hhcjtcbiAgICAgIGNvbnN0IGFjY2VudCA9IGdseXBoLmFjY2VudDtcbiAgICAgIGxldCBzY2FsZWRYLCBzY2FsZWRZO1xuICAgICAgbGV0IHdpZHRoID0gZ2x5cGgud2lkdGg7XG4gICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgY29uc3Qgdm1ldHJpYyA9IGdseXBoLnZtZXRyaWMgfHwgZGVmYXVsdFZNZXRyaWNzO1xuICAgICAgICBjb25zdCB2eCA9IC0oZ2x5cGgudm1ldHJpYyA/IHZtZXRyaWNbMV0gOiB3aWR0aCAqIDAuNSkgKiB3aWR0aEFkdmFuY2VTY2FsZTtcbiAgICAgICAgY29uc3QgdnkgPSB2bWV0cmljWzJdICogd2lkdGhBZHZhbmNlU2NhbGU7XG4gICAgICAgIHdpZHRoID0gdm1ldHJpYyA/IC12bWV0cmljWzBdIDogd2lkdGg7XG4gICAgICAgIHNjYWxlZFggPSB2eCAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgIHNjYWxlZFkgPSAoeCArIHZ5KSAvIGZvbnRTaXplU2NhbGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2FsZWRYID0geCAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgIHNjYWxlZFkgPSAwO1xuICAgICAgfVxuICAgICAgbGV0IG1lYXN1cmU7XG4gICAgICBpZiAoZm9udC5yZW1lYXN1cmUgJiYgd2lkdGggPiAwKSB7XG4gICAgICAgIG1lYXN1cmUgPSBjdHgubWVhc3VyZVRleHQoY2hhcmFjdGVyKTtcbiAgICAgICAgY29uc3QgbWVhc3VyZWRXaWR0aCA9IG1lYXN1cmUud2lkdGggKiAxZTMgLyBmb250U2l6ZSAqIGZvbnRTaXplU2NhbGU7XG4gICAgICAgIGlmICh3aWR0aCA8IG1lYXN1cmVkV2lkdGggJiYgdGhpcy5pc0ZvbnRTdWJwaXhlbEFBRW5hYmxlZCkge1xuICAgICAgICAgIGNvbnN0IGNoYXJhY3RlclNjYWxlWCA9IHdpZHRoIC8gbWVhc3VyZWRXaWR0aDtcbiAgICAgICAgICByZXN0b3JlTmVlZGVkID0gdHJ1ZTtcbiAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgIGN0eC5zY2FsZShjaGFyYWN0ZXJTY2FsZVgsIDEpO1xuICAgICAgICAgIHNjYWxlZFggLz0gY2hhcmFjdGVyU2NhbGVYO1xuICAgICAgICB9IGVsc2UgaWYgKHdpZHRoICE9PSBtZWFzdXJlZFdpZHRoKSB7XG4gICAgICAgICAgc2NhbGVkWCArPSAod2lkdGggLSBtZWFzdXJlZFdpZHRoKSAvIDJlMyAqIGZvbnRTaXplIC8gZm9udFNpemVTY2FsZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY29udGVudFZpc2libGUgJiYgKGdseXBoLmlzSW5Gb250IHx8IGZvbnQubWlzc2luZ0ZpbGUpKSB7XG4gICAgICAgIGlmIChzaW1wbGVGaWxsVGV4dCAmJiAhYWNjZW50KSB7XG4gICAgICAgICAgY3R4LmZpbGxUZXh0KGNoYXJhY3Rlciwgc2NhbGVkWCwgc2NhbGVkWSk7XG4gICAgICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkQ2hhcmFjdGVyQkJveChvcElkeCwgY3R4LCBtZWFzdXJlID8ge1xuICAgICAgICAgICAgYmJveDogbnVsbFxuICAgICAgICAgIH0gOiBmb250LCBmb250U2l6ZSAvIGZvbnRTaXplU2NhbGUsIHNjYWxlZFgsIHNjYWxlZFksICgpID0+IG1lYXN1cmUgPz8gY3R4Lm1lYXN1cmVUZXh0KGNoYXJhY3RlcikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucGFpbnRDaGFyKG9wSWR4LCBjaGFyYWN0ZXIsIHNjYWxlZFgsIHNjYWxlZFksIHBhdHRlcm5GaWxsVHJhbnNmb3JtLCBwYXR0ZXJuU3Ryb2tlVHJhbnNmb3JtKTtcbiAgICAgICAgICBpZiAoYWNjZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzY2FsZWRBY2NlbnRYID0gc2NhbGVkWCArIGZvbnRTaXplICogYWNjZW50Lm9mZnNldC54IC8gZm9udFNpemVTY2FsZTtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlZEFjY2VudFkgPSBzY2FsZWRZIC0gZm9udFNpemUgKiBhY2NlbnQub2Zmc2V0LnkgLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICAgICAgdGhpcy5wYWludENoYXIob3BJZHgsIGFjY2VudC5mb250Q2hhciwgc2NhbGVkQWNjZW50WCwgc2NhbGVkQWNjZW50WSwgcGF0dGVybkZpbGxUcmFuc2Zvcm0sIHBhdHRlcm5TdHJva2VUcmFuc2Zvcm0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgY2hhcldpZHRoID0gdmVydGljYWwgPyB3aWR0aCAqIHdpZHRoQWR2YW5jZVNjYWxlIC0gc3BhY2luZyAqIGZvbnREaXJlY3Rpb24gOiB3aWR0aCAqIHdpZHRoQWR2YW5jZVNjYWxlICsgc3BhY2luZyAqIGZvbnREaXJlY3Rpb247XG4gICAgICB4ICs9IGNoYXJXaWR0aDtcbiAgICAgIGlmIChyZXN0b3JlTmVlZGVkKSB7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgY3VycmVudC55IC09IHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQueCArPSB4ICogdGV4dEhTY2FsZTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaG93VGV4dE9wZXJhdGlvbihvcElkeCk7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBzaG93VHlwZTNUZXh0KG9wSWR4LCBnbHlwaHMpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGNvbnN0IGZvbnQgPSBjdXJyZW50LmZvbnQ7XG4gICAgY29uc3QgZm9udFNpemUgPSBjdXJyZW50LmZvbnRTaXplO1xuICAgIGNvbnN0IGZvbnREaXJlY3Rpb24gPSBjdXJyZW50LmZvbnREaXJlY3Rpb247XG4gICAgY29uc3Qgc3BhY2luZ0RpciA9IGZvbnQudmVydGljYWwgPyAxIDogLTE7XG4gICAgY29uc3QgY2hhclNwYWNpbmcgPSBjdXJyZW50LmNoYXJTcGFjaW5nO1xuICAgIGNvbnN0IHdvcmRTcGFjaW5nID0gY3VycmVudC53b3JkU3BhY2luZztcbiAgICBjb25zdCB0ZXh0SFNjYWxlID0gY3VycmVudC50ZXh0SFNjYWxlICogZm9udERpcmVjdGlvbjtcbiAgICBjb25zdCBmb250TWF0cml4ID0gY3VycmVudC5mb250TWF0cml4IHx8IEZPTlRfSURFTlRJVFlfTUFUUklYO1xuICAgIGNvbnN0IGdseXBoc0xlbmd0aCA9IGdseXBocy5sZW5ndGg7XG4gICAgY29uc3QgaXNUZXh0SW52aXNpYmxlID0gY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuSU5WSVNJQkxFO1xuICAgIGxldCBpLCBnbHlwaCwgd2lkdGgsIHNwYWNpbmdMZW5ndGg7XG4gICAgaWYgKGlzVGV4dEludmlzaWJsZSB8fCBmb250U2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID0gLTE7XG4gICAgdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9IG51bGw7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBpZiAoY3VycmVudC50ZXh0TWF0cml4KSB7XG4gICAgICBjdHgudHJhbnNmb3JtKC4uLmN1cnJlbnQudGV4dE1hdHJpeCk7XG4gICAgfVxuICAgIGN0eC50cmFuc2xhdGUoY3VycmVudC54LCBjdXJyZW50LnkgKyBjdXJyZW50LnRleHRSaXNlKTtcbiAgICBjdHguc2NhbGUodGV4dEhTY2FsZSwgZm9udERpcmVjdGlvbik7XG4gICAgY29uc3QgZGVwZW5kZW5jeVRyYWNrZXIgPSB0aGlzLmRlcGVuZGVuY3lUcmFja2VyO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXIgPSBkZXBlbmRlbmN5VHJhY2tlciA/IG5ldyBDYW52YXNOZXN0ZWREZXBlbmRlbmN5VHJhY2tlcihkZXBlbmRlbmN5VHJhY2tlciwgb3BJZHgpIDogbnVsbDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2x5cGhzTGVuZ3RoOyArK2kpIHtcbiAgICAgIGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBnbHlwaCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBzcGFjaW5nTGVuZ3RoID0gc3BhY2luZ0RpciAqIGdseXBoICogZm9udFNpemUgLyAxZTM7XG4gICAgICAgIHRoaXMuY3R4LnRyYW5zbGF0ZShzcGFjaW5nTGVuZ3RoLCAwKTtcbiAgICAgICAgY3VycmVudC54ICs9IHNwYWNpbmdMZW5ndGggKiB0ZXh0SFNjYWxlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNwYWNpbmcgPSAoZ2x5cGguaXNTcGFjZSA/IHdvcmRTcGFjaW5nIDogMCkgKyBjaGFyU3BhY2luZztcbiAgICAgIGNvbnN0IG9wZXJhdG9yTGlzdCA9IGZvbnQuY2hhclByb2NPcGVyYXRvckxpc3RbZ2x5cGgub3BlcmF0b3JMaXN0SWRdO1xuICAgICAgaWYgKCFvcGVyYXRvckxpc3QpIHtcbiAgICAgICAgd2FybihgVHlwZTMgY2hhcmFjdGVyIFwiJHtnbHlwaC5vcGVyYXRvckxpc3RJZH1cIiBpcyBub3QgYXZhaWxhYmxlLmApO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgICAgICBjdHguc2NhbGUoZm9udFNpemUsIGZvbnRTaXplKTtcbiAgICAgICAgY3R4LnRyYW5zZm9ybSguLi5mb250TWF0cml4KTtcbiAgICAgICAgdGhpcy5leGVjdXRlT3BlcmF0b3JMaXN0KG9wZXJhdG9yTGlzdCk7XG4gICAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgICAgfVxuICAgICAgY29uc3QgcCA9IFtnbHlwaC53aWR0aCwgMF07XG4gICAgICBVdGlsLmFwcGx5VHJhbnNmb3JtKHAsIGZvbnRNYXRyaXgpO1xuICAgICAgd2lkdGggPSBwWzBdICogZm9udFNpemUgKyBzcGFjaW5nO1xuICAgICAgY3R4LnRyYW5zbGF0ZSh3aWR0aCwgMCk7XG4gICAgICBjdXJyZW50LnggKz0gd2lkdGggKiB0ZXh0SFNjYWxlO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIGlmIChkZXBlbmRlbmN5VHJhY2tlcikge1xuICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlciA9IGRlcGVuZGVuY3lUcmFja2VyO1xuICAgIH1cbiAgfVxuICBzZXRDaGFyV2lkdGgob3BJZHgsIHhXaWR0aCwgeVdpZHRoKSB7XG4gIH1cbiAgc2V0Q2hhcldpZHRoQW5kQm91bmRzKG9wSWR4LCB4V2lkdGgsIHlXaWR0aCwgbGx4LCBsbHksIHVyeCwgdXJ5KSB7XG4gICAgY29uc3QgY2xpcCA9IG5ldyBQYXRoMkQoKTtcbiAgICBjbGlwLnJlY3QobGx4LCBsbHksIHVyeCAtIGxseCwgdXJ5IC0gbGx5KTtcbiAgICB0aGlzLmN0eC5jbGlwKGNsaXApO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZEJCb3gob3BJZHgsIHRoaXMuY3R4LCBsbHgsIHVyeCwgbGx5LCB1cnkpLnJlY29yZENsaXBCb3gob3BJZHgsIHRoaXMuY3R4LCBsbHgsIHVyeCwgbGx5LCB1cnkpO1xuICAgIHRoaXMuZW5kUGF0aChvcElkeCk7XG4gIH1cbiAgZ2V0Q29sb3JOX1BhdHRlcm4ob3BJZHgsIElSKSB7XG4gICAgbGV0IHBhdHRlcm47XG4gICAgaWYgKElSWzBdID09PSBcIlRpbGluZ1BhdHRlcm5cIikge1xuICAgICAgY29uc3QgYmFzZVRyYW5zZm9ybSA9IHRoaXMuYmFzZVRyYW5zZm9ybSB8fCBnZXRDdXJyZW50VHJhbnNmb3JtKHRoaXMuY3R4KTtcbiAgICAgIGNvbnN0IGNhbnZhc0dyYXBoaWNzRmFjdG9yeSA9IHtcbiAgICAgICAgY3JlYXRlQ2FudmFzR3JhcGhpY3M6IChjdHgsIHJlbmRlcmluZ09wSWR4KSA9PiBuZXcgQ2FudmFzR3JhcGhpY3MoY3R4LCB0aGlzLmNvbW1vbk9ianMsIHRoaXMub2JqcywgdGhpcy5jYW52YXNGYWN0b3J5LCB0aGlzLmZpbHRlckZhY3RvcnksIHtcbiAgICAgICAgICBvcHRpb25hbENvbnRlbnRDb25maWc6IHRoaXMub3B0aW9uYWxDb250ZW50Q29uZmlnLFxuICAgICAgICAgIG1hcmtlZENvbnRlbnRTdGFjazogdGhpcy5tYXJrZWRDb250ZW50U3RhY2tcbiAgICAgICAgfSwgdm9pZCAwLCB2b2lkIDAsIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXIgPyBuZXcgQ2FudmFzTmVzdGVkRGVwZW5kZW5jeVRyYWNrZXIodGhpcy5kZXBlbmRlbmN5VHJhY2tlciwgcmVuZGVyaW5nT3BJZHgsIHRydWUpIDogbnVsbClcbiAgICAgIH07XG4gICAgICBwYXR0ZXJuID0gbmV3IFRpbGluZ1BhdHRlcm4oSVIsIHRoaXMuY3R4LCBjYW52YXNHcmFwaGljc0ZhY3RvcnksIGJhc2VUcmFuc2Zvcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXR0ZXJuID0gdGhpcy5fZ2V0UGF0dGVybihvcElkeCwgSVJbMV0sIElSWzJdKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdHRlcm47XG4gIH1cbiAgc2V0U3Ryb2tlQ29sb3JOKG9wSWR4LCAuLi5hcmdzKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcInN0cm9rZUNvbG9yXCIsIG9wSWR4KTtcbiAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3IgPSB0aGlzLmdldENvbG9yTl9QYXR0ZXJuKG9wSWR4LCBhcmdzKTtcbiAgICB0aGlzLmN1cnJlbnQucGF0dGVyblN0cm9rZSA9IHRydWU7XG4gIH1cbiAgc2V0RmlsbENvbG9yTihvcElkeCwgLi4uYXJncykge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJmaWxsQ29sb3JcIiwgb3BJZHgpO1xuICAgIHRoaXMuY3VycmVudC5maWxsQ29sb3IgPSB0aGlzLmdldENvbG9yTl9QYXR0ZXJuKG9wSWR4LCBhcmdzKTtcbiAgICB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGwgPSB0cnVlO1xuICB9XG4gIHNldFN0cm9rZVJHQkNvbG9yKG9wSWR4LCBjb2xvcikge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJzdHJva2VDb2xvclwiLCBvcElkeCk7XG4gICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3IgPSBjb2xvcjtcbiAgICB0aGlzLmN1cnJlbnQucGF0dGVyblN0cm9rZSA9IGZhbHNlO1xuICB9XG4gIHNldFN0cm9rZVRyYW5zcGFyZW50KG9wSWR4KSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcInN0cm9rZUNvbG9yXCIsIG9wSWR4KTtcbiAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY3VycmVudC5zdHJva2VDb2xvciA9IFwidHJhbnNwYXJlbnRcIjtcbiAgICB0aGlzLmN1cnJlbnQucGF0dGVyblN0cm9rZSA9IGZhbHNlO1xuICB9XG4gIHNldEZpbGxSR0JDb2xvcihvcElkeCwgY29sb3IpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwiZmlsbENvbG9yXCIsIG9wSWR4KTtcbiAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSB0aGlzLmN1cnJlbnQuZmlsbENvbG9yID0gY29sb3I7XG4gICAgdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsID0gZmFsc2U7XG4gIH1cbiAgc2V0RmlsbFRyYW5zcGFyZW50KG9wSWR4KSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcImZpbGxDb2xvclwiLCBvcElkeCk7XG4gICAgdGhpcy5jdHguZmlsbFN0eWxlID0gdGhpcy5jdXJyZW50LmZpbGxDb2xvciA9IFwidHJhbnNwYXJlbnRcIjtcbiAgICB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGwgPSBmYWxzZTtcbiAgfVxuICBfZ2V0UGF0dGVybihvcElkeCwgb2JqSWQsIG1hdHJpeCA9IG51bGwpIHtcbiAgICBsZXQgcGF0dGVybjtcbiAgICBpZiAodGhpcy5jYWNoZWRQYXR0ZXJucy5oYXMob2JqSWQpKSB7XG4gICAgICBwYXR0ZXJuID0gdGhpcy5jYWNoZWRQYXR0ZXJucy5nZXQob2JqSWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXR0ZXJuID0gZ2V0U2hhZGluZ1BhdHRlcm4odGhpcy5nZXRPYmplY3Qob3BJZHgsIG9iaklkKSk7XG4gICAgICB0aGlzLmNhY2hlZFBhdHRlcm5zLnNldChvYmpJZCwgcGF0dGVybik7XG4gICAgfVxuICAgIGlmIChtYXRyaXgpIHtcbiAgICAgIHBhdHRlcm4ubWF0cml4ID0gbWF0cml4O1xuICAgIH1cbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfVxuICBzaGFkaW5nRmlsbChvcElkeCwgb2JqSWQpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgdGhpcy5zYXZlKG9wSWR4KTtcbiAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5fZ2V0UGF0dGVybihvcElkeCwgb2JqSWQpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBwYXR0ZXJuLmdldFBhdHRlcm4oY3R4LCB0aGlzLCBnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShjdHgpLCBQYXRoVHlwZS5TSEFESU5HLCBvcElkeCk7XG4gICAgY29uc3QgaW52ID0gZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoY3R4KTtcbiAgICBpZiAoaW52KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0gPSBjdHguY2FudmFzO1xuICAgICAgY29uc3QgbWluTWF4ID0gTUlOX01BWF9JTklULnNsaWNlKCk7XG4gICAgICBVdGlsLmF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KFswLCAwLCB3aWR0aCwgaGVpZ2h0XSwgaW52LCBtaW5NYXgpO1xuICAgICAgY29uc3QgW3gwLCB5MCwgeDEsIHkxXSA9IG1pbk1heDtcbiAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KHgwLCB5MCwgeDEgLSB4MCwgeTEgLSB5MCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KC0xZTEwLCAtMWUxMCwgMmUxMCwgMmUxMCk7XG4gICAgfVxuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlc2V0QkJveChvcElkeCkucmVjb3JkRnVsbFBhZ2VCQm94KG9wSWR4KS5yZWNvcmREZXBlbmRlbmNpZXMob3BJZHgsIERlcGVuZGVuY2llcy50cmFuc2Zvcm0pLnJlY29yZERlcGVuZGVuY2llcyhvcElkeCwgRGVwZW5kZW5jaWVzLmZpbGwpLnJlY29yZE9wZXJhdGlvbihvcElkeCk7XG4gICAgdGhpcy5jb21wb3NlKHRoaXMuY3VycmVudC5nZXRDbGlwcGVkUGF0aEJvdW5kaW5nQm94KCkpO1xuICAgIHRoaXMucmVzdG9yZShvcElkeCk7XG4gIH1cbiAgYmVnaW5JbmxpbmVJbWFnZSgpIHtcbiAgICB1bnJlYWNoYWJsZShcIlNob3VsZCBub3QgY2FsbCBiZWdpbklubGluZUltYWdlXCIpO1xuICB9XG4gIGJlZ2luSW1hZ2VEYXRhKCkge1xuICAgIHVucmVhY2hhYmxlKFwiU2hvdWxkIG5vdCBjYWxsIGJlZ2luSW1hZ2VEYXRhXCIpO1xuICB9XG4gIHBhaW50Rm9ybVhPYmplY3RCZWdpbihvcElkeCwgbWF0cml4LCBiYm94KSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2F2ZShvcElkeCk7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtU3RhY2sucHVzaCh0aGlzLmJhc2VUcmFuc2Zvcm0pO1xuICAgIGlmIChtYXRyaXgpIHtcbiAgICAgIHRoaXMudHJhbnNmb3JtKG9wSWR4LCAuLi5tYXRyaXgpO1xuICAgIH1cbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKHRoaXMuY3R4KTtcbiAgICBpZiAoYmJveCkge1xuICAgICAgVXRpbC5heGlhbEFsaWduZWRCb3VuZGluZ0JveChiYm94LCB0aGlzLmJhc2VUcmFuc2Zvcm0sIHRoaXMuY3VycmVudC5taW5NYXgpO1xuICAgICAgY29uc3QgW3gwLCB5MCwgeDEsIHkxXSA9IGJib3g7XG4gICAgICBjb25zdCBjbGlwID0gbmV3IFBhdGgyRCgpO1xuICAgICAgY2xpcC5yZWN0KHgwLCB5MCwgeDEgLSB4MCwgeTEgLSB5MCk7XG4gICAgICB0aGlzLmN0eC5jbGlwKGNsaXApO1xuICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkQ2xpcEJveChvcElkeCwgdGhpcy5jdHgsIHgwLCB4MSwgeTAsIHkxKTtcbiAgICAgIHRoaXMuZW5kUGF0aChvcElkeCk7XG4gICAgfVxuICB9XG4gIHBhaW50Rm9ybVhPYmplY3RFbmQob3BJZHgpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZXN0b3JlKG9wSWR4KTtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSB0aGlzLmJhc2VUcmFuc2Zvcm1TdGFjay5wb3AoKTtcbiAgfVxuICBiZWdpbkdyb3VwKG9wSWR4LCBncm91cCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNhdmUob3BJZHgpO1xuICAgIGlmICh0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICB0aGlzLmVuZFNNYXNrTW9kZSgpO1xuICAgICAgdGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudEN0eCA9IHRoaXMuY3R4O1xuICAgIGlmICghZ3JvdXAuaXNvbGF0ZWQpIHtcbiAgICAgIGluZm8oXCJUT0RPOiBTdXBwb3J0IG5vbi1pc29sYXRlZCBncm91cHMuXCIpO1xuICAgIH1cbiAgICBpZiAoZ3JvdXAua25vY2tvdXQpIHtcbiAgICAgIHdhcm4oXCJLbm9ja291dCBncm91cHMgbm90IHN1cHBvcnRlZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKGN1cnJlbnRDdHgpO1xuICAgIGlmIChncm91cC5tYXRyaXgpIHtcbiAgICAgIGN1cnJlbnRDdHgudHJhbnNmb3JtKC4uLmdyb3VwLm1hdHJpeCk7XG4gICAgfVxuICAgIGlmICghZ3JvdXAuYmJveCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQm91bmRpbmcgYm94IGlzIHJlcXVpcmVkLlwiKTtcbiAgICB9XG4gICAgbGV0IGJvdW5kcyA9IE1JTl9NQVhfSU5JVC5zbGljZSgpO1xuICAgIFV0aWwuYXhpYWxBbGlnbmVkQm91bmRpbmdCb3goZ3JvdXAuYmJveCwgZ2V0Q3VycmVudFRyYW5zZm9ybShjdXJyZW50Q3R4KSwgYm91bmRzKTtcbiAgICBjb25zdCBjYW52YXNCb3VuZHMgPSBbMCwgMCwgY3VycmVudEN0eC5jYW52YXMud2lkdGgsIGN1cnJlbnRDdHguY2FudmFzLmhlaWdodF07XG4gICAgYm91bmRzID0gVXRpbC5pbnRlcnNlY3QoYm91bmRzLCBjYW52YXNCb3VuZHMpIHx8IFswLCAwLCAwLCAwXTtcbiAgICBjb25zdCBvZmZzZXRYID0gTWF0aC5mbG9vcihib3VuZHNbMF0pO1xuICAgIGNvbnN0IG9mZnNldFkgPSBNYXRoLmZsb29yKGJvdW5kc1sxXSk7XG4gICAgY29uc3QgZHJhd25XaWR0aCA9IE1hdGgubWF4KE1hdGguY2VpbChib3VuZHNbMl0pIC0gb2Zmc2V0WCwgMSk7XG4gICAgY29uc3QgZHJhd25IZWlnaHQgPSBNYXRoLm1heChNYXRoLmNlaWwoYm91bmRzWzNdKSAtIG9mZnNldFksIDEpO1xuICAgIHRoaXMuY3VycmVudC5zdGFydE5ld1BhdGhBbmRDbGlwQm94KFswLCAwLCBkcmF3bldpZHRoLCBkcmF3bkhlaWdodF0pO1xuICAgIGxldCBjYWNoZUlkID0gXCJncm91cEF0XCIgKyB0aGlzLmdyb3VwTGV2ZWw7XG4gICAgaWYgKGdyb3VwLnNtYXNrKSB7XG4gICAgICBjYWNoZUlkICs9IFwiX3NtYXNrX1wiICsgdGhpcy5zbWFza0NvdW50ZXIrKyAlIDI7XG4gICAgfVxuICAgIGNvbnN0IHNjcmF0Y2hDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhjYWNoZUlkLCBkcmF3bldpZHRoLCBkcmF3bkhlaWdodCk7XG4gICAgY29uc3QgZ3JvdXBDdHggPSBzY3JhdGNoQ2FudmFzLmNvbnRleHQ7XG4gICAgZ3JvdXBDdHgudHJhbnNsYXRlKC1vZmZzZXRYLCAtb2Zmc2V0WSk7XG4gICAgZ3JvdXBDdHgudHJhbnNmb3JtKC4uLmN1cnJlbnRUcmFuc2Zvcm0pO1xuICAgIGxldCBjbGlwID0gbmV3IFBhdGgyRCgpO1xuICAgIGNvbnN0IFt4MCwgeTAsIHgxLCB5MV0gPSBncm91cC5iYm94O1xuICAgIGNsaXAucmVjdCh4MCwgeTAsIHgxIC0geDAsIHkxIC0geTApO1xuICAgIGlmIChncm91cC5tYXRyaXgpIHtcbiAgICAgIGNvbnN0IHBhdGggPSBuZXcgUGF0aDJEKCk7XG4gICAgICBwYXRoLmFkZFBhdGgoY2xpcCwgbmV3IERPTU1hdHJpeChncm91cC5tYXRyaXgpKTtcbiAgICAgIGNsaXAgPSBwYXRoO1xuICAgIH1cbiAgICBncm91cEN0eC5jbGlwKGNsaXApO1xuICAgIGlmIChncm91cC5zbWFzaykge1xuICAgICAgdGhpcy5zbWFza1N0YWNrLnB1c2goe1xuICAgICAgICBjYW52YXM6IHNjcmF0Y2hDYW52YXMuY2FudmFzLFxuICAgICAgICBjb250ZXh0OiBncm91cEN0eCxcbiAgICAgICAgb2Zmc2V0WCxcbiAgICAgICAgb2Zmc2V0WSxcbiAgICAgICAgc3VidHlwZTogZ3JvdXAuc21hc2suc3VidHlwZSxcbiAgICAgICAgYmFja2Ryb3A6IGdyb3VwLnNtYXNrLmJhY2tkcm9wLFxuICAgICAgICB0cmFuc2Zlck1hcDogZ3JvdXAuc21hc2sudHJhbnNmZXJNYXAgfHwgbnVsbCxcbiAgICAgICAgc3RhcnRUcmFuc2Zvcm1JbnZlcnNlOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFncm91cC5zbWFzayB8fCB0aGlzLmRlcGVuZGVuY3lUcmFja2VyKSB7XG4gICAgICBjdXJyZW50Q3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIGN1cnJlbnRDdHgudHJhbnNsYXRlKG9mZnNldFgsIG9mZnNldFkpO1xuICAgICAgY3VycmVudEN0eC5zYXZlKCk7XG4gICAgfVxuICAgIGNvcHlDdHhTdGF0ZShjdXJyZW50Q3R4LCBncm91cEN0eCk7XG4gICAgdGhpcy5jdHggPSBncm91cEN0eDtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5pbmhlcml0U2ltcGxlRGF0YUFzRnV0dXJlRm9yY2VkRGVwZW5kZW5jaWVzKFtcImZpbGxBbHBoYVwiLCBcInN0cm9rZUFscGhhXCIsIFwiZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXCJdKS5wdXNoQmFzZVRyYW5zZm9ybShjdXJyZW50Q3R4KTtcbiAgICB0aGlzLnNldEdTdGF0ZShvcElkeCwgW1tcIkJNXCIsIFwic291cmNlLW92ZXJcIl0sIFtcImNhXCIsIDFdLCBbXCJDQVwiLCAxXV0pO1xuICAgIHRoaXMuZ3JvdXBTdGFjay5wdXNoKGN1cnJlbnRDdHgpO1xuICAgIHRoaXMuZ3JvdXBMZXZlbCsrO1xuICB9XG4gIGVuZEdyb3VwKG9wSWR4LCBncm91cCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmdyb3VwTGV2ZWwtLTtcbiAgICBjb25zdCBncm91cEN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuZ3JvdXBTdGFjay5wb3AoKTtcbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLmN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5wb3BCYXNlVHJhbnNmb3JtKCk7XG4gICAgaWYgKGdyb3VwLnNtYXNrKSB7XG4gICAgICB0aGlzLnRlbXBTTWFzayA9IHRoaXMuc21hc2tTdGFjay5wb3AoKTtcbiAgICAgIHRoaXMucmVzdG9yZShvcElkeCk7XG4gICAgICBpZiAodGhpcy5kZXBlbmRlbmN5VHJhY2tlcikge1xuICAgICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRNdHggPSBnZXRDdXJyZW50VHJhbnNmb3JtKHRoaXMuY3R4KTtcbiAgICAgIHRoaXMucmVzdG9yZShvcElkeCk7XG4gICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oLi4uY3VycmVudE10eCk7XG4gICAgICBjb25zdCBkaXJ0eUJveCA9IE1JTl9NQVhfSU5JVC5zbGljZSgpO1xuICAgICAgVXRpbC5heGlhbEFsaWduZWRCb3VuZGluZ0JveChbMCwgMCwgZ3JvdXBDdHguY2FudmFzLndpZHRoLCBncm91cEN0eC5jYW52YXMuaGVpZ2h0XSwgY3VycmVudE10eCwgZGlydHlCb3gpO1xuICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKGdyb3VwQ3R4LmNhbnZhcywgMCwgMCk7XG4gICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICB0aGlzLmNvbXBvc2UoZGlydHlCb3gpO1xuICAgIH1cbiAgfVxuICBiZWdpbkFubm90YXRpb24ob3BJZHgsIGlkLCByZWN0LCB0cmFuc2Zvcm0sIG1hdHJpeCwgaGFzT3duQ2FudmFzKSB7XG4gICAgdGhpcy4jcmVzdG9yZUluaXRpYWxTdGF0ZSgpO1xuICAgIHJlc2V0Q3R4VG9EZWZhdWx0KHRoaXMuY3R4KTtcbiAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgdGhpcy5zYXZlKG9wSWR4KTtcbiAgICBpZiAodGhpcy5iYXNlVHJhbnNmb3JtKSB7XG4gICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oLi4udGhpcy5iYXNlVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgaWYgKHJlY3QpIHtcbiAgICAgIGNvbnN0IHdpZHRoID0gcmVjdFsyXSAtIHJlY3RbMF07XG4gICAgICBjb25zdCBoZWlnaHQgPSByZWN0WzNdIC0gcmVjdFsxXTtcbiAgICAgIGlmIChoYXNPd25DYW52YXMgJiYgdGhpcy5hbm5vdGF0aW9uQ2FudmFzTWFwKSB7XG4gICAgICAgIHRyYW5zZm9ybSA9IHRyYW5zZm9ybS5zbGljZSgpO1xuICAgICAgICB0cmFuc2Zvcm1bNF0gLT0gcmVjdFswXTtcbiAgICAgICAgdHJhbnNmb3JtWzVdIC09IHJlY3RbMV07XG4gICAgICAgIHJlY3QgPSByZWN0LnNsaWNlKCk7XG4gICAgICAgIHJlY3RbMF0gPSByZWN0WzFdID0gMDtcbiAgICAgICAgcmVjdFsyXSA9IHdpZHRoO1xuICAgICAgICByZWN0WzNdID0gaGVpZ2h0O1xuICAgICAgICBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKGdldEN1cnJlbnRUcmFuc2Zvcm0odGhpcy5jdHgpLCBYWSk7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB2aWV3cG9ydFNjYWxlXG4gICAgICAgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBjYW52YXNXaWR0aCA9IE1hdGguY2VpbCh3aWR0aCAqIHRoaXMub3V0cHV0U2NhbGVYICogdmlld3BvcnRTY2FsZSk7XG4gICAgICAgIGNvbnN0IGNhbnZhc0hlaWdodCA9IE1hdGguY2VpbChoZWlnaHQgKiB0aGlzLm91dHB1dFNjYWxlWSAqIHZpZXdwb3J0U2NhbGUpO1xuICAgICAgICB0aGlzLmFubm90YXRpb25DYW52YXMgPSB0aGlzLmNhbnZhc0ZhY3RvcnkuY3JlYXRlKGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgY2FudmFzLFxuICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgfSA9IHRoaXMuYW5ub3RhdGlvbkNhbnZhcztcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uQ2FudmFzTWFwLnNldChpZCwgY2FudmFzKTtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uQ2FudmFzLnNhdmVkQ3R4ID0gdGhpcy5jdHg7XG4gICAgICAgIHRoaXMuY3R4ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oWFlbMF0sIDAsIDAsIC1YWVsxXSwgMCwgaGVpZ2h0ICogWFlbMV0pO1xuICAgICAgICByZXNldEN0eFRvRGVmYXVsdCh0aGlzLmN0eCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNldEN0eFRvRGVmYXVsdCh0aGlzLmN0eCk7XG4gICAgICAgIHRoaXMuZW5kUGF0aChvcElkeCk7XG4gICAgICAgIGNvbnN0IGNsaXAgPSBuZXcgUGF0aDJEKCk7XG4gICAgICAgIGNsaXAucmVjdChyZWN0WzBdLCByZWN0WzFdLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5jdHguY2xpcChjbGlwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jdXJyZW50ID0gbmV3IENhbnZhc0V4dHJhU3RhdGUodGhpcy5jdHguY2FudmFzLndpZHRoLCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICB0aGlzLnRyYW5zZm9ybShvcElkeCwgLi4udHJhbnNmb3JtKTtcbiAgICB0aGlzLnRyYW5zZm9ybShvcElkeCwgLi4ubWF0cml4KTtcbiAgfVxuICBlbmRBbm5vdGF0aW9uKG9wSWR4KSB7XG4gICAgaWYgKHRoaXMuYW5ub3RhdGlvbkNhbnZhcykge1xuICAgICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgICAgdGhpcy4jZHJhd0ZpbHRlcigpO1xuICAgICAgdGhpcy5jdHggPSB0aGlzLmFubm90YXRpb25DYW52YXMuc2F2ZWRDdHg7XG4gICAgICBkZWxldGUgdGhpcy5hbm5vdGF0aW9uQ2FudmFzLnNhdmVkQ3R4O1xuICAgICAgZGVsZXRlIHRoaXMuYW5ub3RhdGlvbkNhbnZhcztcbiAgICB9XG4gIH1cbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0KG9wSWR4LCBpbWcpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY291bnQgPSBpbWcuY291bnQ7XG4gICAgaW1nID0gdGhpcy5nZXRPYmplY3Qob3BJZHgsIGltZy5kYXRhLCBpbWcpO1xuICAgIGltZy5jb3VudCA9IGNvdW50O1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IG1hc2sgPSB0aGlzLl9jcmVhdGVNYXNrQ2FudmFzKG9wSWR4LCBpbWcpO1xuICAgIGNvbnN0IG1hc2tDYW52YXMgPSBtYXNrLmNhbnZhcztcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgY3R4LmRyYXdJbWFnZShtYXNrQ2FudmFzLCBtYXNrLm9mZnNldFgsIG1hc2sub2Zmc2V0WSk7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVzZXRCQm94KG9wSWR4KS5yZWNvcmRCQm94KG9wSWR4LCB0aGlzLmN0eCwgbWFzay5vZmZzZXRYLCBtYXNrLm9mZnNldFggKyBtYXNrQ2FudmFzLndpZHRoLCBtYXNrLm9mZnNldFksIG1hc2sub2Zmc2V0WSArIG1hc2tDYW52YXMuaGVpZ2h0KS5yZWNvcmRPcGVyYXRpb24ob3BJZHgpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgdGhpcy5jb21wb3NlKCk7XG4gIH1cbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0UmVwZWF0KG9wSWR4LCBpbWcsIHNjYWxlWCwgc2tld1ggPSAwLCBza2V3WSA9IDAsIHNjYWxlWSwgcG9zaXRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGltZyA9IHRoaXMuZ2V0T2JqZWN0KG9wSWR4LCBpbWcuZGF0YSwgaW1nKTtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKGN0eCk7XG4gICAgY3R4LnRyYW5zZm9ybShzY2FsZVgsIHNrZXdYLCBza2V3WSwgc2NhbGVZLCAwLCAwKTtcbiAgICBjb25zdCBtYXNrID0gdGhpcy5fY3JlYXRlTWFza0NhbnZhcyhvcElkeCwgaW1nKTtcbiAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIG1hc2sub2Zmc2V0WCAtIGN1cnJlbnRUcmFuc2Zvcm1bNF0sIG1hc2sub2Zmc2V0WSAtIGN1cnJlbnRUcmFuc2Zvcm1bNV0pO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlc2V0QkJveChvcElkeCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IHRyYW5zID0gVXRpbC50cmFuc2Zvcm0oY3VycmVudFRyYW5zZm9ybSwgW3NjYWxlWCwgc2tld1gsIHNrZXdZLCBzY2FsZVksIHBvc2l0aW9uc1tpXSwgcG9zaXRpb25zW2kgKyAxXV0pO1xuICAgICAgY3R4LmRyYXdJbWFnZShtYXNrLmNhbnZhcywgdHJhbnNbNF0sIHRyYW5zWzVdKTtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZEJCb3gob3BJZHgsIHRoaXMuY3R4LCB0cmFuc1s0XSwgdHJhbnNbNF0gKyBtYXNrLmNhbnZhcy53aWR0aCwgdHJhbnNbNV0sIHRyYW5zWzVdICsgbWFzay5jYW52YXMuaGVpZ2h0KTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRPcGVyYXRpb24ob3BJZHgpO1xuICB9XG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdEdyb3VwKG9wSWR4LCBpbWFnZXMpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZmlsbENvbG9yID0gdGhpcy5jdXJyZW50LmZpbGxDb2xvcjtcbiAgICBjb25zdCBpc1BhdHRlcm5GaWxsID0gdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlc2V0QkJveChvcElkeCkucmVjb3JkRGVwZW5kZW5jaWVzKG9wSWR4LCBEZXBlbmRlbmNpZXMudHJhbnNmb3JtQW5kRmlsbCk7XG4gICAgZm9yIChjb25zdCBpbWFnZSBvZiBpbWFnZXMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgdHJhbnNmb3JtXG4gICAgICB9ID0gaW1hZ2U7XG4gICAgICBjb25zdCBtYXNrQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJtYXNrQ2FudmFzXCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY29uc3QgbWFza0N0eCA9IG1hc2tDYW52YXMuY29udGV4dDtcbiAgICAgIG1hc2tDdHguc2F2ZSgpO1xuICAgICAgY29uc3QgaW1nID0gdGhpcy5nZXRPYmplY3Qob3BJZHgsIGRhdGEsIGltYWdlKTtcbiAgICAgIHB1dEJpbmFyeUltYWdlTWFzayhtYXNrQ3R4LCBpbWcpO1xuICAgICAgbWFza0N0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1pblwiO1xuICAgICAgbWFza0N0eC5maWxsU3R5bGUgPSBpc1BhdHRlcm5GaWxsID8gZmlsbENvbG9yLmdldFBhdHRlcm4obWFza0N0eCwgdGhpcywgZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoY3R4KSwgUGF0aFR5cGUuRklMTCwgb3BJZHgpIDogZmlsbENvbG9yO1xuICAgICAgbWFza0N0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIG1hc2tDdHgucmVzdG9yZSgpO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2Zvcm0oLi4udHJhbnNmb3JtKTtcbiAgICAgIGN0eC5zY2FsZSgxLCAtMSk7XG4gICAgICBkcmF3SW1hZ2VBdEludGVnZXJDb29yZHMoY3R4LCBtYXNrQ2FudmFzLmNhbnZhcywgMCwgMCwgd2lkdGgsIGhlaWdodCwgMCwgLTEsIDEsIDEpO1xuICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkQkJveChvcElkeCwgY3R4LCAwLCB3aWR0aCwgMCwgaGVpZ2h0KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIHRoaXMuY29tcG9zZSgpO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZE9wZXJhdGlvbihvcElkeCk7XG4gIH1cbiAgcGFpbnRJbWFnZVhPYmplY3Qob3BJZHgsIG9iaklkKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGltZ0RhdGEgPSB0aGlzLmdldE9iamVjdChvcElkeCwgb2JqSWQpO1xuICAgIGlmICghaW1nRGF0YSkge1xuICAgICAgd2FybihcIkRlcGVuZGVudCBpbWFnZSBpc24ndCByZWFkeSB5ZXRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGFpbnRJbmxpbmVJbWFnZVhPYmplY3Qob3BJZHgsIGltZ0RhdGEpO1xuICB9XG4gIHBhaW50SW1hZ2VYT2JqZWN0UmVwZWF0KG9wSWR4LCBvYmpJZCwgc2NhbGVYLCBzY2FsZVksIHBvc2l0aW9ucykge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbWdEYXRhID0gdGhpcy5nZXRPYmplY3Qob3BJZHgsIG9iaklkKTtcbiAgICBpZiAoIWltZ0RhdGEpIHtcbiAgICAgIHdhcm4oXCJEZXBlbmRlbnQgaW1hZ2UgaXNuJ3QgcmVhZHkgeWV0XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1nRGF0YS5oZWlnaHQ7XG4gICAgY29uc3QgbWFwID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIG1hcC5wdXNoKHtcbiAgICAgICAgdHJhbnNmb3JtOiBbc2NhbGVYLCAwLCAwLCBzY2FsZVksIHBvc2l0aW9uc1tpXSwgcG9zaXRpb25zW2kgKyAxXV0sXG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHc6IHdpZHRoLFxuICAgICAgICBoOiBoZWlnaHRcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnBhaW50SW5saW5lSW1hZ2VYT2JqZWN0R3JvdXAob3BJZHgsIGltZ0RhdGEsIG1hcCk7XG4gIH1cbiAgYXBwbHlUcmFuc2Zlck1hcHNUb0NhbnZhcyhjdHgpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50LnRyYW5zZmVyTWFwcyAhPT0gXCJub25lXCIpIHtcbiAgICAgIGN0eC5maWx0ZXIgPSB0aGlzLmN1cnJlbnQudHJhbnNmZXJNYXBzO1xuICAgICAgY3R4LmRyYXdJbWFnZShjdHguY2FudmFzLCAwLCAwKTtcbiAgICAgIGN0eC5maWx0ZXIgPSBcIm5vbmVcIjtcbiAgICB9XG4gICAgcmV0dXJuIGN0eC5jYW52YXM7XG4gIH1cbiAgYXBwbHlUcmFuc2Zlck1hcHNUb0JpdG1hcChpbWdEYXRhKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudC50cmFuc2Zlck1hcHMgPT09IFwibm9uZVwiKSB7XG4gICAgICByZXR1cm4gaW1nRGF0YS5iaXRtYXA7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGJpdG1hcCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGltZ0RhdGE7XG4gICAgY29uc3QgdG1wQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJpbmxpbmVJbWFnZVwiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICB0bXBDdHguZmlsdGVyID0gdGhpcy5jdXJyZW50LnRyYW5zZmVyTWFwcztcbiAgICB0bXBDdHguZHJhd0ltYWdlKGJpdG1hcCwgMCwgMCk7XG4gICAgdG1wQ3R4LmZpbHRlciA9IFwibm9uZVwiO1xuICAgIHJldHVybiB0bXBDYW52YXMuY2FudmFzO1xuICB9XG4gIHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0KG9wSWR4LCBpbWdEYXRhKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodDtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICB0aGlzLnNhdmUob3BJZHgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGZpbHRlclxuICAgIH0gPSBjdHg7XG4gICAgaWYgKGZpbHRlciAhPT0gXCJub25lXCIgJiYgZmlsdGVyICE9PSBcIlwiKSB7XG4gICAgICBjdHguZmlsdGVyID0gXCJub25lXCI7XG4gICAgfVxuICAgIGN0eC5zY2FsZSgxIC8gd2lkdGgsIC0xIC8gaGVpZ2h0KTtcbiAgICBsZXQgaW1nVG9QYWludDtcbiAgICBpZiAoaW1nRGF0YS5iaXRtYXApIHtcbiAgICAgIGltZ1RvUGFpbnQgPSB0aGlzLmFwcGx5VHJhbnNmZXJNYXBzVG9CaXRtYXAoaW1nRGF0YSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgSFRNTEVsZW1lbnQgPT09IFwiZnVuY3Rpb25cIiAmJiBpbWdEYXRhIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgIWltZ0RhdGEuZGF0YSkge1xuICAgICAgaW1nVG9QYWludCA9IGltZ0RhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRtcENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwiaW5saW5lSW1hZ2VcIiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjb25zdCB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICAgIHB1dEJpbmFyeUltYWdlRGF0YSh0bXBDdHgsIGltZ0RhdGEpO1xuICAgICAgaW1nVG9QYWludCA9IHRoaXMuYXBwbHlUcmFuc2Zlck1hcHNUb0NhbnZhcyh0bXBDdHgpO1xuICAgIH1cbiAgICBjb25zdCBzY2FsZWQgPSB0aGlzLl9zY2FsZUltYWdlKGltZ1RvUGFpbnQsIGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGN0eCkpO1xuICAgIGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBnZXRJbWFnZVNtb290aGluZ0VuYWJsZWQoZ2V0Q3VycmVudFRyYW5zZm9ybShjdHgpLCBpbWdEYXRhLmludGVycG9sYXRlKTtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZXNldEJCb3gob3BJZHgpLnJlY29yZEJCb3gob3BJZHgsIGN0eCwgMCwgd2lkdGgsIC1oZWlnaHQsIDApLnJlY29yZERlcGVuZGVuY2llcyhvcElkeCwgRGVwZW5kZW5jaWVzLmltYWdlWE9iamVjdCkucmVjb3JkT3BlcmF0aW9uKG9wSWR4KTtcbiAgICBkcmF3SW1hZ2VBdEludGVnZXJDb29yZHMoY3R4LCBzY2FsZWQuaW1nLCAwLCAwLCBzY2FsZWQucGFpbnRXaWR0aCwgc2NhbGVkLnBhaW50SGVpZ2h0LCAwLCAtaGVpZ2h0LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgICB0aGlzLnJlc3RvcmUob3BJZHgpO1xuICB9XG4gIHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0R3JvdXAob3BJZHgsIGltZ0RhdGEsIG1hcCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBsZXQgaW1nVG9QYWludDtcbiAgICBpZiAoaW1nRGF0YS5iaXRtYXApIHtcbiAgICAgIGltZ1RvUGFpbnQgPSBpbWdEYXRhLmJpdG1hcDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdyA9IGltZ0RhdGEud2lkdGg7XG4gICAgICBjb25zdCBoID0gaW1nRGF0YS5oZWlnaHQ7XG4gICAgICBjb25zdCB0bXBDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcImlubGluZUltYWdlXCIsIHcsIGgpO1xuICAgICAgY29uc3QgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgICBwdXRCaW5hcnlJbWFnZURhdGEodG1wQ3R4LCBpbWdEYXRhKTtcbiAgICAgIGltZ1RvUGFpbnQgPSB0aGlzLmFwcGx5VHJhbnNmZXJNYXBzVG9DYW52YXModG1wQ3R4KTtcbiAgICB9XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVzZXRCQm94KG9wSWR4KTtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIG1hcCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2Zvcm0oLi4uZW50cnkudHJhbnNmb3JtKTtcbiAgICAgIGN0eC5zY2FsZSgxLCAtMSk7XG4gICAgICBkcmF3SW1hZ2VBdEludGVnZXJDb29yZHMoY3R4LCBpbWdUb1BhaW50LCBlbnRyeS54LCBlbnRyeS55LCBlbnRyeS53LCBlbnRyeS5oLCAwLCAtMSwgMSwgMSk7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRCQm94KG9wSWR4LCBjdHgsIDAsIDEsIC0xLCAwKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZE9wZXJhdGlvbihvcElkeCk7XG4gICAgdGhpcy5jb21wb3NlKCk7XG4gIH1cbiAgcGFpbnRTb2xpZENvbG9ySW1hZ2VNYXNrKG9wSWR4KSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlc2V0QkJveChvcElkeCkucmVjb3JkQkJveChvcElkeCwgdGhpcy5jdHgsIDAsIDEsIDAsIDEpLnJlY29yZERlcGVuZGVuY2llcyhvcElkeCwgRGVwZW5kZW5jaWVzLmZpbGwpLnJlY29yZE9wZXJhdGlvbihvcElkeCk7XG4gICAgdGhpcy5jdHguZmlsbFJlY3QoMCwgMCwgMSwgMSk7XG4gICAgdGhpcy5jb21wb3NlKCk7XG4gIH1cbiAgbWFya1BvaW50KG9wSWR4LCB0YWcpIHtcbiAgfVxuICBtYXJrUG9pbnRQcm9wcyhvcElkeCwgdGFnLCBwcm9wZXJ0aWVzKSB7XG4gIH1cbiAgYmVnaW5NYXJrZWRDb250ZW50KG9wSWR4LCB0YWcpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5iZWdpbk1hcmtlZENvbnRlbnQob3BJZHgpO1xuICAgIHRoaXMubWFya2VkQ29udGVudFN0YWNrLnB1c2goe1xuICAgICAgdmlzaWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGJlZ2luTWFya2VkQ29udGVudFByb3BzKG9wSWR4LCB0YWcsIHByb3BlcnRpZXMpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5iZWdpbk1hcmtlZENvbnRlbnQob3BJZHgpO1xuICAgIGlmICh0YWcgPT09IFwiT0NcIikge1xuICAgICAgdGhpcy5tYXJrZWRDb250ZW50U3RhY2sucHVzaCh7XG4gICAgICAgIHZpc2libGU6IHRoaXMub3B0aW9uYWxDb250ZW50Q29uZmlnLmlzVmlzaWJsZShwcm9wZXJ0aWVzKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWFya2VkQ29udGVudFN0YWNrLnB1c2goe1xuICAgICAgICB2aXNpYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5jb250ZW50VmlzaWJsZSA9IHRoaXMuaXNDb250ZW50VmlzaWJsZSgpO1xuICB9XG4gIGVuZE1hcmtlZENvbnRlbnQob3BJZHgpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5lbmRNYXJrZWRDb250ZW50KG9wSWR4KTtcbiAgICB0aGlzLm1hcmtlZENvbnRlbnRTdGFjay5wb3AoKTtcbiAgICB0aGlzLmNvbnRlbnRWaXNpYmxlID0gdGhpcy5pc0NvbnRlbnRWaXNpYmxlKCk7XG4gIH1cbiAgYmVnaW5Db21wYXQob3BJZHgpIHtcbiAgfVxuICBlbmRDb21wYXQob3BJZHgpIHtcbiAgfVxuICBjb25zdW1lUGF0aChvcElkeCwgcGF0aCwgY2xpcEJveCkge1xuICAgIGNvbnN0IGlzRW1wdHkgPSB0aGlzLmN1cnJlbnQuaXNFbXB0eUNsaXAoKTtcbiAgICBpZiAodGhpcy5wZW5kaW5nQ2xpcCkge1xuICAgICAgdGhpcy5jdXJyZW50LnVwZGF0ZUNsaXBGcm9tUGF0aCgpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucGVuZGluZ0NsaXApIHtcbiAgICAgIHRoaXMuY29tcG9zZShjbGlwQm94KTtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgaWYgKHRoaXMucGVuZGluZ0NsaXApIHtcbiAgICAgIGlmICghaXNFbXB0eSkge1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nQ2xpcCA9PT0gRU9fQ0xJUCkge1xuICAgICAgICAgIGN0eC5jbGlwKHBhdGgsIFwiZXZlbm9kZFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHguY2xpcChwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5wZW5kaW5nQ2xpcCA9IG51bGw7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5iYm94VG9DbGlwQm94RHJvcE9wZXJhdGlvbihvcElkeCkucmVjb3JkRnV0dXJlRm9yY2VkRGVwZW5kZW5jeShcImNsaXBQYXRoXCIsIG9wSWR4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkT3BlcmF0aW9uKG9wSWR4KTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50LnN0YXJ0TmV3UGF0aEFuZENsaXBCb3godGhpcy5jdXJyZW50LmNsaXBCb3gpO1xuICB9XG4gIGdldFNpbmdsZVBpeGVsV2lkdGgoKSB7XG4gICAgaWYgKCF0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoKSB7XG4gICAgICBjb25zdCBtID0gZ2V0Q3VycmVudFRyYW5zZm9ybSh0aGlzLmN0eCk7XG4gICAgICBpZiAobVsxXSA9PT0gMCAmJiBtWzJdID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSAxIC8gTWF0aC5taW4oTWF0aC5hYnMobVswXSksIE1hdGguYWJzKG1bM10pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGFic0RldCA9IE1hdGguYWJzKG1bMF0gKiBtWzNdIC0gbVsyXSAqIG1bMV0pO1xuICAgICAgICBjb25zdCBub3JtWCA9IE1hdGguaHlwb3QobVswXSwgbVsyXSk7XG4gICAgICAgIGNvbnN0IG5vcm1ZID0gTWF0aC5oeXBvdChtWzFdLCBtWzNdKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9IE1hdGgubWF4KG5vcm1YLCBub3JtWSkgLyBhYnNEZXQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoO1xuICB9XG4gIGdldFNjYWxlRm9yU3Ryb2tpbmcoKSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmdbMF0gPT09IC0xKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxpbmVXaWR0aFxuICAgICAgfSA9IHRoaXMuY3VycmVudDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYSxcbiAgICAgICAgYixcbiAgICAgICAgYyxcbiAgICAgICAgZFxuICAgICAgfSA9IHRoaXMuY3R4LmdldFRyYW5zZm9ybSgpO1xuICAgICAgbGV0IHNjYWxlWCwgc2NhbGVZO1xuICAgICAgaWYgKGIgPT09IDAgJiYgYyA9PT0gMCkge1xuICAgICAgICBjb25zdCBub3JtWCA9IE1hdGguYWJzKGEpO1xuICAgICAgICBjb25zdCBub3JtWSA9IE1hdGguYWJzKGQpO1xuICAgICAgICBpZiAobm9ybVggPT09IG5vcm1ZKSB7XG4gICAgICAgICAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgc2NhbGVYID0gc2NhbGVZID0gMSAvIG5vcm1YO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzY2FsZWRMaW5lV2lkdGggPSBub3JtWCAqIGxpbmVXaWR0aDtcbiAgICAgICAgICAgIHNjYWxlWCA9IHNjYWxlWSA9IHNjYWxlZExpbmVXaWR0aCA8IDEgPyAxIC8gc2NhbGVkTGluZVdpZHRoIDogMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgICAgICAgc2NhbGVYID0gMSAvIG5vcm1YO1xuICAgICAgICAgIHNjYWxlWSA9IDEgLyBub3JtWTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBzY2FsZWRYTGluZVdpZHRoID0gbm9ybVggKiBsaW5lV2lkdGg7XG4gICAgICAgICAgY29uc3Qgc2NhbGVkWUxpbmVXaWR0aCA9IG5vcm1ZICogbGluZVdpZHRoO1xuICAgICAgICAgIHNjYWxlWCA9IHNjYWxlZFhMaW5lV2lkdGggPCAxID8gMSAvIHNjYWxlZFhMaW5lV2lkdGggOiAxO1xuICAgICAgICAgIHNjYWxlWSA9IHNjYWxlZFlMaW5lV2lkdGggPCAxID8gMSAvIHNjYWxlZFlMaW5lV2lkdGggOiAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBhYnNEZXQgPSBNYXRoLmFicyhhICogZCAtIGIgKiBjKTtcbiAgICAgICAgY29uc3Qgbm9ybVggPSBNYXRoLmh5cG90KGEsIGIpO1xuICAgICAgICBjb25zdCBub3JtWSA9IE1hdGguaHlwb3QoYywgZCk7XG4gICAgICAgIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICAgICAgICBzY2FsZVggPSBub3JtWSAvIGFic0RldDtcbiAgICAgICAgICBzY2FsZVkgPSBub3JtWCAvIGFic0RldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBiYXNlQXJlYSA9IGxpbmVXaWR0aCAqIGFic0RldDtcbiAgICAgICAgICBzY2FsZVggPSBub3JtWSA+IGJhc2VBcmVhID8gbm9ybVkgLyBiYXNlQXJlYSA6IDE7XG4gICAgICAgICAgc2NhbGVZID0gbm9ybVggPiBiYXNlQXJlYSA/IG5vcm1YIC8gYmFzZUFyZWEgOiAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID0gc2NhbGVYO1xuICAgICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZ1sxXSA9IHNjYWxlWTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmc7XG4gIH1cbiAgcmVzY2FsZUFuZFN0cm9rZShwYXRoLCBzYXZlUmVzdG9yZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGN0eCxcbiAgICAgIGN1cnJlbnQ6IHtcbiAgICAgICAgbGluZVdpZHRoXG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgW3NjYWxlWCwgc2NhbGVZXSA9IHRoaXMuZ2V0U2NhbGVGb3JTdHJva2luZygpO1xuICAgIGlmIChzY2FsZVggPT09IHNjYWxlWSkge1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IChsaW5lV2lkdGggfHwgMSkgKiBzY2FsZVg7XG4gICAgICBjdHguc3Ryb2tlKHBhdGgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkYXNoZXMgPSBjdHguZ2V0TGluZURhc2goKTtcbiAgICBpZiAoc2F2ZVJlc3RvcmUpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgfVxuICAgIGN0eC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgU0NBTEVfTUFUUklYLmEgPSAxIC8gc2NhbGVYO1xuICAgIFNDQUxFX01BVFJJWC5kID0gMSAvIHNjYWxlWTtcbiAgICBjb25zdCBuZXdQYXRoID0gbmV3IFBhdGgyRCgpO1xuICAgIG5ld1BhdGguYWRkUGF0aChwYXRoLCBTQ0FMRV9NQVRSSVgpO1xuICAgIGlmIChkYXNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgc2NhbGUgPSBNYXRoLm1heChzY2FsZVgsIHNjYWxlWSk7XG4gICAgICBjdHguc2V0TGluZURhc2goZGFzaGVzLm1hcCgoeCkgPT4geCAvIHNjYWxlKSk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgLz0gc2NhbGU7XG4gICAgfVxuICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGggfHwgMTtcbiAgICBjdHguc3Ryb2tlKG5ld1BhdGgpO1xuICAgIGlmIChzYXZlUmVzdG9yZSkge1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cbiAgaXNDb250ZW50VmlzaWJsZSgpIHtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5tYXJrZWRDb250ZW50U3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmICghdGhpcy5tYXJrZWRDb250ZW50U3RhY2tbaV0udmlzaWJsZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5mb3IgKGNvbnN0IG9wIGluIE9QUykge1xuICBpZiAoQ2FudmFzR3JhcGhpY3MucHJvdG90eXBlW29wXSAhPT0gdm9pZCAwKSB7XG4gICAgQ2FudmFzR3JhcGhpY3MucHJvdG90eXBlW09QU1tvcF1dID0gQ2FudmFzR3JhcGhpY3MucHJvdG90eXBlW29wXTtcbiAgfVxufVxuY2xhc3MgQ3NzRm9udEluZm8ge1xuICAjYnVmZmVyO1xuICAjdmlldztcbiAgI2RlY29kZXI7XG4gIHN0YXRpYyBzdHJpbmdzID0gW1wiZm9udEZhbWlseVwiLCBcImZvbnRXZWlnaHRcIiwgXCJpdGFsaWNBbmdsZVwiXTtcbiAgc3RhdGljIHdyaXRlKGluZm8yKSB7XG4gICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIGNvbnN0IGVuY29kZWRTdHJpbmdzID0ge307XG4gICAgbGV0IHN0cmluZ3NMZW5ndGggPSAwO1xuICAgIGZvciAoY29uc3QgcHJvcCBvZiBDc3NGb250SW5mby5zdHJpbmdzKSB7XG4gICAgICBjb25zdCBlbmNvZGVkID0gZW5jb2Rlci5lbmNvZGUoaW5mbzJbcHJvcF0pO1xuICAgICAgZW5jb2RlZFN0cmluZ3NbcHJvcF0gPSBlbmNvZGVkO1xuICAgICAgc3RyaW5nc0xlbmd0aCArPSA0ICsgZW5jb2RlZC5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihzdHJpbmdzTGVuZ3RoKTtcbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgZm9yIChjb25zdCBwcm9wIG9mIENzc0ZvbnRJbmZvLnN0cmluZ3MpIHtcbiAgICAgIGNvbnN0IGVuY29kZWQgPSBlbmNvZGVkU3RyaW5nc1twcm9wXTtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IGVuY29kZWQubGVuZ3RoO1xuICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgZGF0YS5zZXQoZW5jb2RlZCwgb2Zmc2V0ICsgNCk7XG4gICAgICBvZmZzZXQgKz0gNCArIGxlbmd0aDtcbiAgICB9XG4gICAgYXNzZXJ0KG9mZnNldCA9PT0gYnVmZmVyLmJ5dGVMZW5ndGgsIFwiQ3NzRm9udEluZm8ud3JpdGU6IEJ1ZmZlciBvdmVyZmxvd1wiKTtcbiAgICByZXR1cm4gYnVmZmVyO1xuICB9XG4gIGNvbnN0cnVjdG9yKGJ1ZmZlcikge1xuICAgIHRoaXMuI2J1ZmZlciA9IGJ1ZmZlcjtcbiAgICB0aGlzLiN2aWV3ID0gbmV3IERhdGFWaWV3KHRoaXMuI2J1ZmZlcik7XG4gICAgdGhpcy4jZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICB9XG4gICNyZWFkU3RyaW5nKGluZGV4KSB7XG4gICAgYXNzZXJ0KGluZGV4IDwgQ3NzRm9udEluZm8uc3RyaW5ncy5sZW5ndGgsIFwiSW52YWxpZCBzdHJpbmcgaW5kZXhcIik7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleDsgaSsrKSB7XG4gICAgICBvZmZzZXQgKz0gdGhpcy4jdmlldy5nZXRVaW50MzIob2Zmc2V0KSArIDQ7XG4gICAgfVxuICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMuI3ZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgcmV0dXJuIHRoaXMuI2RlY29kZXIuZGVjb2RlKG5ldyBVaW50OEFycmF5KHRoaXMuI2J1ZmZlciwgb2Zmc2V0ICsgNCwgbGVuZ3RoKSk7XG4gIH1cbiAgZ2V0IGZvbnRGYW1pbHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JlYWRTdHJpbmcoMCk7XG4gIH1cbiAgZ2V0IGZvbnRXZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JlYWRTdHJpbmcoMSk7XG4gIH1cbiAgZ2V0IGl0YWxpY0FuZ2xlKCkge1xuICAgIHJldHVybiB0aGlzLiNyZWFkU3RyaW5nKDIpO1xuICB9XG59XG5jbGFzcyBTeXN0ZW1Gb250SW5mbyB7XG4gICNidWZmZXI7XG4gICN2aWV3O1xuICAjZGVjb2RlcjtcbiAgc3RhdGljIHN0cmluZ3MgPSBbXCJjc3NcIiwgXCJsb2FkZWROYW1lXCIsIFwiYmFzZUZvbnROYW1lXCIsIFwic3JjXCJdO1xuICBzdGF0aWMgd3JpdGUoaW5mbzIpIHtcbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgY29uc3QgZW5jb2RlZFN0cmluZ3MgPSB7fTtcbiAgICBsZXQgc3RyaW5nc0xlbmd0aCA9IDA7XG4gICAgZm9yIChjb25zdCBwcm9wIG9mIFN5c3RlbUZvbnRJbmZvLnN0cmluZ3MpIHtcbiAgICAgIGNvbnN0IGVuY29kZWQgPSBlbmNvZGVyLmVuY29kZShpbmZvMltwcm9wXSk7XG4gICAgICBlbmNvZGVkU3RyaW5nc1twcm9wXSA9IGVuY29kZWQ7XG4gICAgICBzdHJpbmdzTGVuZ3RoICs9IDQgKyBlbmNvZGVkLmxlbmd0aDtcbiAgICB9XG4gICAgc3RyaW5nc0xlbmd0aCArPSA0O1xuICAgIGxldCBlbmNvZGVkU3R5bGVTdHlsZSwgZW5jb2RlZFN0eWxlV2VpZ2h0LCBsZW5ndGhFc3RpbWF0ZSA9IDEgKyBzdHJpbmdzTGVuZ3RoO1xuICAgIGlmIChpbmZvMi5zdHlsZSkge1xuICAgICAgZW5jb2RlZFN0eWxlU3R5bGUgPSBlbmNvZGVyLmVuY29kZShpbmZvMi5zdHlsZS5zdHlsZSk7XG4gICAgICBlbmNvZGVkU3R5bGVXZWlnaHQgPSBlbmNvZGVyLmVuY29kZShpbmZvMi5zdHlsZS53ZWlnaHQpO1xuICAgICAgbGVuZ3RoRXN0aW1hdGUgKz0gNCArIGVuY29kZWRTdHlsZVN0eWxlLmxlbmd0aCArIDQgKyBlbmNvZGVkU3R5bGVXZWlnaHQubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIobGVuZ3RoRXN0aW1hdGUpO1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBpbmZvMi5ndWVzc0ZhbGxiYWNrID8gMSA6IDApO1xuICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCwgMCk7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgc3RyaW5nc0xlbmd0aCA9IDA7XG4gICAgZm9yIChjb25zdCBwcm9wIG9mIFN5c3RlbUZvbnRJbmZvLnN0cmluZ3MpIHtcbiAgICAgIGNvbnN0IGVuY29kZWQgPSBlbmNvZGVkU3RyaW5nc1twcm9wXTtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IGVuY29kZWQubGVuZ3RoO1xuICAgICAgc3RyaW5nc0xlbmd0aCArPSA0ICsgbGVuZ3RoO1xuICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgZGF0YS5zZXQoZW5jb2RlZCwgb2Zmc2V0ICsgNCk7XG4gICAgICBvZmZzZXQgKz0gNCArIGxlbmd0aDtcbiAgICB9XG4gICAgdmlldy5zZXRVaW50MzIob2Zmc2V0IC0gc3RyaW5nc0xlbmd0aCAtIDQsIHN0cmluZ3NMZW5ndGgpO1xuICAgIGlmIChpbmZvMi5zdHlsZSkge1xuICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCBlbmNvZGVkU3R5bGVTdHlsZS5sZW5ndGgpO1xuICAgICAgZGF0YS5zZXQoZW5jb2RlZFN0eWxlU3R5bGUsIG9mZnNldCArIDQpO1xuICAgICAgb2Zmc2V0ICs9IDQgKyBlbmNvZGVkU3R5bGVTdHlsZS5sZW5ndGg7XG4gICAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQsIGVuY29kZWRTdHlsZVdlaWdodC5sZW5ndGgpO1xuICAgICAgZGF0YS5zZXQoZW5jb2RlZFN0eWxlV2VpZ2h0LCBvZmZzZXQgKyA0KTtcbiAgICAgIG9mZnNldCArPSA0ICsgZW5jb2RlZFN0eWxlV2VpZ2h0Lmxlbmd0aDtcbiAgICB9XG4gICAgYXNzZXJ0KG9mZnNldCA8PSBidWZmZXIuYnl0ZUxlbmd0aCwgXCJTdWJzdGl0aW9uSW5mby53cml0ZTogQnVmZmVyIG92ZXJmbG93XCIpO1xuICAgIHJldHVybiBidWZmZXIudHJhbnNmZXJUb0ZpeGVkTGVuZ3RoKG9mZnNldCk7XG4gIH1cbiAgY29uc3RydWN0b3IoYnVmZmVyKSB7XG4gICAgdGhpcy4jYnVmZmVyID0gYnVmZmVyO1xuICAgIHRoaXMuI3ZpZXcgPSBuZXcgRGF0YVZpZXcodGhpcy4jYnVmZmVyKTtcbiAgICB0aGlzLiNkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIH1cbiAgZ2V0IGd1ZXNzRmFsbGJhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuI3ZpZXcuZ2V0VWludDgoMCkgIT09IDA7XG4gIH1cbiAgI3JlYWRTdHJpbmcoaW5kZXgpIHtcbiAgICBhc3NlcnQoaW5kZXggPCBTeXN0ZW1Gb250SW5mby5zdHJpbmdzLmxlbmd0aCwgXCJJbnZhbGlkIHN0cmluZyBpbmRleFwiKTtcbiAgICBsZXQgb2Zmc2V0ID0gNTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4OyBpKyspIHtcbiAgICAgIG9mZnNldCArPSB0aGlzLiN2aWV3LmdldFVpbnQzMihvZmZzZXQpICsgNDtcbiAgICB9XG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy4jdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICByZXR1cm4gdGhpcy4jZGVjb2Rlci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkodGhpcy4jYnVmZmVyLCBvZmZzZXQgKyA0LCBsZW5ndGgpKTtcbiAgfVxuICBnZXQgY3NzKCkge1xuICAgIHJldHVybiB0aGlzLiNyZWFkU3RyaW5nKDApO1xuICB9XG4gIGdldCBsb2FkZWROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLiNyZWFkU3RyaW5nKDEpO1xuICB9XG4gIGdldCBiYXNlRm9udE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JlYWRTdHJpbmcoMik7XG4gIH1cbiAgZ2V0IHNyYygpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVhZFN0cmluZygzKTtcbiAgfVxuICBnZXQgc3R5bGUoKSB7XG4gICAgbGV0IG9mZnNldCA9IDE7XG4gICAgb2Zmc2V0ICs9IDQgKyB0aGlzLiN2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgIGNvbnN0IHN0eWxlTGVuZ3RoID0gdGhpcy4jdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICBjb25zdCBzdHlsZSA9IHRoaXMuI2RlY29kZXIuZGVjb2RlKG5ldyBVaW50OEFycmF5KHRoaXMuI2J1ZmZlciwgb2Zmc2V0ICsgNCwgc3R5bGVMZW5ndGgpKTtcbiAgICBvZmZzZXQgKz0gNCArIHN0eWxlTGVuZ3RoO1xuICAgIGNvbnN0IHdlaWdodExlbmd0aCA9IHRoaXMuI3ZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgY29uc3Qgd2VpZ2h0ID0gdGhpcy4jZGVjb2Rlci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkodGhpcy4jYnVmZmVyLCBvZmZzZXQgKyA0LCB3ZWlnaHRMZW5ndGgpKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3R5bGUsXG4gICAgICB3ZWlnaHRcbiAgICB9O1xuICB9XG59XG5jbGFzcyBGb250SW5mbyB7XG4gIHN0YXRpYyBib29scyA9IFtcImJsYWNrXCIsIFwiYm9sZFwiLCBcImRpc2FibGVGb250RmFjZVwiLCBcImZvbnRFeHRyYVByb3BlcnRpZXNcIiwgXCJpc0ludmFsaWRQREZqc0ZvbnRcIiwgXCJpc1R5cGUzRm9udFwiLCBcIml0YWxpY1wiLCBcIm1pc3NpbmdGaWxlXCIsIFwicmVtZWFzdXJlXCIsIFwidmVydGljYWxcIl07XG4gIHN0YXRpYyBudW1iZXJzID0gW1wiYXNjZW50XCIsIFwiZGVmYXVsdFdpZHRoXCIsIFwiZGVzY2VudFwiXTtcbiAgc3RhdGljIHN0cmluZ3MgPSBbXCJmYWxsYmFja05hbWVcIiwgXCJsb2FkZWROYW1lXCIsIFwibWltZXR5cGVcIiwgXCJuYW1lXCJdO1xuICBzdGF0aWMgI09GRlNFVF9OVU1CRVJTID0gTWF0aC5jZWlsKHRoaXMuYm9vbHMubGVuZ3RoICogMiAvIDgpO1xuICBzdGF0aWMgI09GRlNFVF9CQk9YID0gdGhpcy4jT0ZGU0VUX05VTUJFUlMgKyB0aGlzLm51bWJlcnMubGVuZ3RoICogODtcbiAgc3RhdGljICNPRkZTRVRfRk9OVF9NQVRSSVggPSB0aGlzLiNPRkZTRVRfQkJPWCArIDEgKyAyICogNDtcbiAgc3RhdGljICNPRkZTRVRfREVGQVVMVF9WTUVUUklDUyA9IHRoaXMuI09GRlNFVF9GT05UX01BVFJJWCArIDEgKyA4ICogNjtcbiAgc3RhdGljICNPRkZTRVRfU1RSSU5HUyA9IHRoaXMuI09GRlNFVF9ERUZBVUxUX1ZNRVRSSUNTICsgMSArIDIgKiAzO1xuICAjYnVmZmVyO1xuICAjZGVjb2RlcjtcbiAgI3ZpZXc7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBkYXRhLFxuICAgIGV4dHJhXG4gIH0pIHtcbiAgICB0aGlzLiNidWZmZXIgPSBkYXRhO1xuICAgIHRoaXMuI2RlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICB0aGlzLiN2aWV3ID0gbmV3IERhdGFWaWV3KHRoaXMuI2J1ZmZlcik7XG4gICAgaWYgKGV4dHJhKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGV4dHJhKTtcbiAgICB9XG4gIH1cbiAgI3JlYWRCb29sZWFuKGluZGV4KSB7XG4gICAgYXNzZXJ0KGluZGV4IDwgRm9udEluZm8uYm9vbHMubGVuZ3RoLCBcIkludmFsaWQgYm9vbGVhbiBpbmRleFwiKTtcbiAgICBjb25zdCBieXRlT2Zmc2V0ID0gTWF0aC5mbG9vcihpbmRleCAvIDQpO1xuICAgIGNvbnN0IGJpdE9mZnNldCA9IGluZGV4ICogMiAlIDg7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLiN2aWV3LmdldFVpbnQ4KGJ5dGVPZmZzZXQpID4+IGJpdE9mZnNldCAmIDM7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdm9pZCAwIDogdmFsdWUgPT09IDI7XG4gIH1cbiAgZ2V0IGJsYWNrKCkge1xuICAgIHJldHVybiB0aGlzLiNyZWFkQm9vbGVhbigwKTtcbiAgfVxuICBnZXQgYm9sZCgpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVhZEJvb2xlYW4oMSk7XG4gIH1cbiAgZ2V0IGRpc2FibGVGb250RmFjZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVhZEJvb2xlYW4oMik7XG4gIH1cbiAgZ2V0IGZvbnRFeHRyYVByb3BlcnRpZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JlYWRCb29sZWFuKDMpO1xuICB9XG4gIGdldCBpc0ludmFsaWRQREZqc0ZvbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JlYWRCb29sZWFuKDQpO1xuICB9XG4gIGdldCBpc1R5cGUzRm9udCgpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVhZEJvb2xlYW4oNSk7XG4gIH1cbiAgZ2V0IGl0YWxpYygpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVhZEJvb2xlYW4oNik7XG4gIH1cbiAgZ2V0IG1pc3NpbmdGaWxlKCkge1xuICAgIHJldHVybiB0aGlzLiNyZWFkQm9vbGVhbig3KTtcbiAgfVxuICBnZXQgcmVtZWFzdXJlKCkge1xuICAgIHJldHVybiB0aGlzLiNyZWFkQm9vbGVhbig4KTtcbiAgfVxuICBnZXQgdmVydGljYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JlYWRCb29sZWFuKDkpO1xuICB9XG4gICNyZWFkTnVtYmVyKGluZGV4KSB7XG4gICAgYXNzZXJ0KGluZGV4IDwgRm9udEluZm8ubnVtYmVycy5sZW5ndGgsIFwiSW52YWxpZCBudW1iZXIgaW5kZXhcIik7XG4gICAgcmV0dXJuIHRoaXMuI3ZpZXcuZ2V0RmxvYXQ2NChGb250SW5mby4jT0ZGU0VUX05VTUJFUlMgKyBpbmRleCAqIDgpO1xuICB9XG4gIGdldCBhc2NlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JlYWROdW1iZXIoMCk7XG4gIH1cbiAgZ2V0IGRlZmF1bHRXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVhZE51bWJlcigxKTtcbiAgfVxuICBnZXQgZGVzY2VudCgpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVhZE51bWJlcigyKTtcbiAgfVxuICBnZXQgYmJveCgpIHtcbiAgICBsZXQgb2Zmc2V0ID0gRm9udEluZm8uI09GRlNFVF9CQk9YO1xuICAgIGNvbnN0IG51bUNvb3JkcyA9IHRoaXMuI3ZpZXcuZ2V0VWludDgob2Zmc2V0KTtcbiAgICBpZiAobnVtQ29vcmRzID09PSAwKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBvZmZzZXQgKz0gMTtcbiAgICBjb25zdCBiYm94ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIGJib3gucHVzaCh0aGlzLiN2aWV3LmdldEludDE2KG9mZnNldCwgdHJ1ZSkpO1xuICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgfVxuICAgIHJldHVybiBiYm94O1xuICB9XG4gIGdldCBmb250TWF0cml4KCkge1xuICAgIGxldCBvZmZzZXQgPSBGb250SW5mby4jT0ZGU0VUX0ZPTlRfTUFUUklYO1xuICAgIGNvbnN0IG51bVBvaW50cyA9IHRoaXMuI3ZpZXcuZ2V0VWludDgob2Zmc2V0KTtcbiAgICBpZiAobnVtUG9pbnRzID09PSAwKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBvZmZzZXQgKz0gMTtcbiAgICBjb25zdCBmb250TWF0cml4ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgIGZvbnRNYXRyaXgucHVzaCh0aGlzLiN2aWV3LmdldEZsb2F0NjQob2Zmc2V0LCB0cnVlKSk7XG4gICAgICBvZmZzZXQgKz0gODtcbiAgICB9XG4gICAgcmV0dXJuIGZvbnRNYXRyaXg7XG4gIH1cbiAgZ2V0IGRlZmF1bHRWTWV0cmljcygpIHtcbiAgICBsZXQgb2Zmc2V0ID0gRm9udEluZm8uI09GRlNFVF9ERUZBVUxUX1ZNRVRSSUNTO1xuICAgIGNvbnN0IG51bU1ldHJpY3MgPSB0aGlzLiN2aWV3LmdldFVpbnQ4KG9mZnNldCk7XG4gICAgaWYgKG51bU1ldHJpY3MgPT09IDApIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIG9mZnNldCArPSAxO1xuICAgIGNvbnN0IGRlZmF1bHRWTWV0cmljcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICBkZWZhdWx0Vk1ldHJpY3MucHVzaCh0aGlzLiN2aWV3LmdldEludDE2KG9mZnNldCwgdHJ1ZSkpO1xuICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0Vk1ldHJpY3M7XG4gIH1cbiAgI3JlYWRTdHJpbmcoaW5kZXgpIHtcbiAgICBhc3NlcnQoaW5kZXggPCBGb250SW5mby5zdHJpbmdzLmxlbmd0aCwgXCJJbnZhbGlkIHN0cmluZyBpbmRleFwiKTtcbiAgICBsZXQgb2Zmc2V0ID0gRm9udEluZm8uI09GRlNFVF9TVFJJTkdTICsgNDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4OyBpKyspIHtcbiAgICAgIG9mZnNldCArPSB0aGlzLiN2aWV3LmdldFVpbnQzMihvZmZzZXQpICsgNDtcbiAgICB9XG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy4jdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICBjb25zdCBzdHJpbmdEYXRhID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBzdHJpbmdEYXRhLnNldChuZXcgVWludDhBcnJheSh0aGlzLiNidWZmZXIsIG9mZnNldCArIDQsIGxlbmd0aCkpO1xuICAgIHJldHVybiB0aGlzLiNkZWNvZGVyLmRlY29kZShzdHJpbmdEYXRhKTtcbiAgfVxuICBnZXQgZmFsbGJhY2tOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLiNyZWFkU3RyaW5nKDApO1xuICB9XG4gIGdldCBsb2FkZWROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLiNyZWFkU3RyaW5nKDEpO1xuICB9XG4gIGdldCBtaW1ldHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVhZFN0cmluZygyKTtcbiAgfVxuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVhZFN0cmluZygzKTtcbiAgfVxuICBnZXQgZGF0YSgpIHtcbiAgICBsZXQgb2Zmc2V0ID0gRm9udEluZm8uI09GRlNFVF9TVFJJTkdTO1xuICAgIGNvbnN0IHN0cmluZ3NMZW5ndGggPSB0aGlzLiN2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0ICsgc3RyaW5nc0xlbmd0aDtcbiAgICBjb25zdCBzeXN0ZW1Gb250SW5mb0xlbmd0aCA9IHRoaXMuI3ZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IDQgKyBzeXN0ZW1Gb250SW5mb0xlbmd0aDtcbiAgICBjb25zdCBjc3NGb250SW5mb0xlbmd0aCA9IHRoaXMuI3ZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IDQgKyBjc3NGb250SW5mb0xlbmd0aDtcbiAgICBjb25zdCBsZW5ndGggPSB0aGlzLiN2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheSh0aGlzLiNidWZmZXIsIG9mZnNldCArIDQsIGxlbmd0aCk7XG4gIH1cbiAgY2xlYXJEYXRhKCkge1xuICAgIGxldCBvZmZzZXQgPSBGb250SW5mby4jT0ZGU0VUX1NUUklOR1M7XG4gICAgY29uc3Qgc3RyaW5nc0xlbmd0aCA9IHRoaXMuI3ZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IDQgKyBzdHJpbmdzTGVuZ3RoO1xuICAgIGNvbnN0IHN5c3RlbUZvbnRJbmZvTGVuZ3RoID0gdGhpcy4jdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gNCArIHN5c3RlbUZvbnRJbmZvTGVuZ3RoO1xuICAgIGNvbnN0IGNzc0ZvbnRJbmZvTGVuZ3RoID0gdGhpcy4jdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gNCArIGNzc0ZvbnRJbmZvTGVuZ3RoO1xuICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMuI3ZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KHRoaXMuI2J1ZmZlciwgb2Zmc2V0ICsgNCwgbGVuZ3RoKTtcbiAgICBkYXRhLmZpbGwoMCk7XG4gICAgdGhpcy4jdmlldy5zZXRVaW50MzIob2Zmc2V0LCAwKTtcbiAgfVxuICBnZXQgY3NzRm9udEluZm8oKSB7XG4gICAgbGV0IG9mZnNldCA9IEZvbnRJbmZvLiNPRkZTRVRfU1RSSU5HUztcbiAgICBjb25zdCBzdHJpbmdzTGVuZ3RoID0gdGhpcy4jdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gNCArIHN0cmluZ3NMZW5ndGg7XG4gICAgY29uc3Qgc3lzdGVtRm9udEluZm9MZW5ndGggPSB0aGlzLiN2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0ICsgc3lzdGVtRm9udEluZm9MZW5ndGg7XG4gICAgY29uc3QgY3NzRm9udEluZm9MZW5ndGggPSB0aGlzLiN2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgIGlmIChjc3NGb250SW5mb0xlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGNzc0ZvbnRJbmZvRGF0YSA9IG5ldyBVaW50OEFycmF5KGNzc0ZvbnRJbmZvTGVuZ3RoKTtcbiAgICBjc3NGb250SW5mb0RhdGEuc2V0KG5ldyBVaW50OEFycmF5KHRoaXMuI2J1ZmZlciwgb2Zmc2V0ICsgNCwgY3NzRm9udEluZm9MZW5ndGgpKTtcbiAgICByZXR1cm4gbmV3IENzc0ZvbnRJbmZvKGNzc0ZvbnRJbmZvRGF0YS5idWZmZXIpO1xuICB9XG4gIGdldCBzeXN0ZW1Gb250SW5mbygpIHtcbiAgICBsZXQgb2Zmc2V0ID0gRm9udEluZm8uI09GRlNFVF9TVFJJTkdTO1xuICAgIGNvbnN0IHN0cmluZ3NMZW5ndGggPSB0aGlzLiN2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0ICsgc3RyaW5nc0xlbmd0aDtcbiAgICBjb25zdCBzeXN0ZW1Gb250SW5mb0xlbmd0aCA9IHRoaXMuI3ZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgaWYgKHN5c3RlbUZvbnRJbmZvTGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc3lzdGVtRm9udEluZm9EYXRhID0gbmV3IFVpbnQ4QXJyYXkoc3lzdGVtRm9udEluZm9MZW5ndGgpO1xuICAgIHN5c3RlbUZvbnRJbmZvRGF0YS5zZXQobmV3IFVpbnQ4QXJyYXkodGhpcy4jYnVmZmVyLCBvZmZzZXQgKyA0LCBzeXN0ZW1Gb250SW5mb0xlbmd0aCkpO1xuICAgIHJldHVybiBuZXcgU3lzdGVtRm9udEluZm8oc3lzdGVtRm9udEluZm9EYXRhLmJ1ZmZlcik7XG4gIH1cbiAgc3RhdGljIHdyaXRlKGZvbnQpIHtcbiAgICBjb25zdCBzeXN0ZW1Gb250SW5mb0J1ZmZlciA9IGZvbnQuc3lzdGVtRm9udEluZm8gPyBTeXN0ZW1Gb250SW5mby53cml0ZShmb250LnN5c3RlbUZvbnRJbmZvKSA6IG51bGw7XG4gICAgY29uc3QgY3NzRm9udEluZm9CdWZmZXIgPSBmb250LmNzc0ZvbnRJbmZvID8gQ3NzRm9udEluZm8ud3JpdGUoZm9udC5jc3NGb250SW5mbykgOiBudWxsO1xuICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICBjb25zdCBlbmNvZGVkU3RyaW5ncyA9IHt9O1xuICAgIGxldCBzdHJpbmdzTGVuZ3RoID0gMDtcbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgRm9udEluZm8uc3RyaW5ncykge1xuICAgICAgZW5jb2RlZFN0cmluZ3NbcHJvcF0gPSBlbmNvZGVyLmVuY29kZShmb250W3Byb3BdKTtcbiAgICAgIHN0cmluZ3NMZW5ndGggKz0gNCArIGVuY29kZWRTdHJpbmdzW3Byb3BdLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgbGVuZ3RoRXN0aW1hdGUgPSBGb250SW5mby4jT0ZGU0VUX1NUUklOR1MgKyA0ICsgc3RyaW5nc0xlbmd0aCArIDQgKyAoc3lzdGVtRm9udEluZm9CdWZmZXIgPyBzeXN0ZW1Gb250SW5mb0J1ZmZlci5ieXRlTGVuZ3RoIDogMCkgKyA0ICsgKGNzc0ZvbnRJbmZvQnVmZmVyID8gY3NzRm9udEluZm9CdWZmZXIuYnl0ZUxlbmd0aCA6IDApICsgNCArIChmb250LmRhdGEgPyBmb250LmRhdGEubGVuZ3RoIDogMCk7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGxlbmd0aEVzdGltYXRlKTtcbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgY29uc3QgbnVtQm9vbHMgPSBGb250SW5mby5ib29scy5sZW5ndGg7XG4gICAgbGV0IGJvb2xCeXRlID0gMCwgYm9vbEJpdCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Cb29sczsgaSsrKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGZvbnRbRm9udEluZm8uYm9vbHNbaV1dO1xuICAgICAgY29uc3QgYml0cyA9IHZhbHVlID09PSB2b2lkIDAgPyAwIDogdmFsdWUgPyAyIDogMTtcbiAgICAgIGJvb2xCeXRlIHw9IGJpdHMgPDwgYm9vbEJpdDtcbiAgICAgIGJvb2xCaXQgKz0gMjtcbiAgICAgIGlmIChib29sQml0ID09PSA4IHx8IGkgPT09IG51bUJvb2xzIC0gMSkge1xuICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBib29sQnl0ZSk7XG4gICAgICAgIGJvb2xCeXRlID0gMDtcbiAgICAgICAgYm9vbEJpdCA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGFzc2VydChvZmZzZXQgPT09IEZvbnRJbmZvLiNPRkZTRVRfTlVNQkVSUywgXCJGb250SW5mby53cml0ZTogQm9vbGVhbiBwcm9wZXJ0aWVzIG9mZnNldCBtaXNtYXRjaFwiKTtcbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgRm9udEluZm8ubnVtYmVycykge1xuICAgICAgdmlldy5zZXRGbG9hdDY0KG9mZnNldCwgZm9udFtwcm9wXSk7XG4gICAgICBvZmZzZXQgKz0gODtcbiAgICB9XG4gICAgYXNzZXJ0KG9mZnNldCA9PT0gRm9udEluZm8uI09GRlNFVF9CQk9YLCBcIkZvbnRJbmZvLndyaXRlOiBOdW1iZXIgcHJvcGVydGllcyBvZmZzZXQgbWlzbWF0Y2hcIik7XG4gICAgaWYgKGZvbnQuYmJveCkge1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgNCk7XG4gICAgICBmb3IgKGNvbnN0IGNvb3JkIG9mIGZvbnQuYmJveCkge1xuICAgICAgICB2aWV3LnNldEludDE2KG9mZnNldCwgY29vcmQsIHRydWUpO1xuICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgMCk7XG4gICAgICBvZmZzZXQgKz0gMiAqIDQ7XG4gICAgfVxuICAgIGFzc2VydChvZmZzZXQgPT09IEZvbnRJbmZvLiNPRkZTRVRfRk9OVF9NQVRSSVgsIFwiRm9udEluZm8ud3JpdGU6IEJCb3ggcHJvcGVydGllcyBvZmZzZXQgbWlzbWF0Y2hcIik7XG4gICAgaWYgKGZvbnQuZm9udE1hdHJpeCkge1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgNik7XG4gICAgICBmb3IgKGNvbnN0IHBvaW50IG9mIGZvbnQuZm9udE1hdHJpeCkge1xuICAgICAgICB2aWV3LnNldEZsb2F0NjQob2Zmc2V0LCBwb2ludCwgdHJ1ZSk7XG4gICAgICAgIG9mZnNldCArPSA4O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCAwKTtcbiAgICAgIG9mZnNldCArPSA4ICogNjtcbiAgICB9XG4gICAgYXNzZXJ0KG9mZnNldCA9PT0gRm9udEluZm8uI09GRlNFVF9ERUZBVUxUX1ZNRVRSSUNTLCBcIkZvbnRJbmZvLndyaXRlOiBGb250TWF0cml4IHByb3BlcnRpZXMgb2Zmc2V0IG1pc21hdGNoXCIpO1xuICAgIGlmIChmb250LmRlZmF1bHRWTWV0cmljcykge1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgMSk7XG4gICAgICBmb3IgKGNvbnN0IG1ldHJpYyBvZiBmb250LmRlZmF1bHRWTWV0cmljcykge1xuICAgICAgICB2aWV3LnNldEludDE2KG9mZnNldCwgbWV0cmljLCB0cnVlKTtcbiAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIDApO1xuICAgICAgb2Zmc2V0ICs9IDMgKiAyO1xuICAgIH1cbiAgICBhc3NlcnQob2Zmc2V0ID09PSBGb250SW5mby4jT0ZGU0VUX1NUUklOR1MsIFwiRm9udEluZm8ud3JpdGU6IERlZmF1bHRWTWV0cmljcyBwcm9wZXJ0aWVzIG9mZnNldCBtaXNtYXRjaFwiKTtcbiAgICB2aWV3LnNldFVpbnQzMihGb250SW5mby4jT0ZGU0VUX1NUUklOR1MsIDApO1xuICAgIG9mZnNldCArPSA0O1xuICAgIGZvciAoY29uc3QgcHJvcCBvZiBGb250SW5mby5zdHJpbmdzKSB7XG4gICAgICBjb25zdCBlbmNvZGVkID0gZW5jb2RlZFN0cmluZ3NbcHJvcF07XG4gICAgICBjb25zdCBsZW5ndGggPSBlbmNvZGVkLmxlbmd0aDtcbiAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGRhdGEuc2V0KGVuY29kZWQsIG9mZnNldCArIDQpO1xuICAgICAgb2Zmc2V0ICs9IDQgKyBsZW5ndGg7XG4gICAgfVxuICAgIHZpZXcuc2V0VWludDMyKEZvbnRJbmZvLiNPRkZTRVRfU1RSSU5HUywgb2Zmc2V0IC0gRm9udEluZm8uI09GRlNFVF9TVFJJTkdTIC0gNCk7XG4gICAgaWYgKCFzeXN0ZW1Gb250SW5mb0J1ZmZlcikge1xuICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCAwKTtcbiAgICAgIG9mZnNldCArPSA0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsZW5ndGggPSBzeXN0ZW1Gb250SW5mb0J1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgYXNzZXJ0KG9mZnNldCArIDQgKyBsZW5ndGggPD0gYnVmZmVyLmJ5dGVMZW5ndGgsIFwiRm9udEluZm8ud3JpdGU6IEJ1ZmZlciBvdmVyZmxvdyBhdCBzeXN0ZW1Gb250SW5mb1wiKTtcbiAgICAgIGRhdGEuc2V0KG5ldyBVaW50OEFycmF5KHN5c3RlbUZvbnRJbmZvQnVmZmVyKSwgb2Zmc2V0ICsgNCk7XG4gICAgICBvZmZzZXQgKz0gNCArIGxlbmd0aDtcbiAgICB9XG4gICAgaWYgKCFjc3NGb250SW5mb0J1ZmZlcikge1xuICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCAwKTtcbiAgICAgIG9mZnNldCArPSA0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsZW5ndGggPSBjc3NGb250SW5mb0J1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgYXNzZXJ0KG9mZnNldCArIDQgKyBsZW5ndGggPD0gYnVmZmVyLmJ5dGVMZW5ndGgsIFwiRm9udEluZm8ud3JpdGU6IEJ1ZmZlciBvdmVyZmxvdyBhdCBjc3NGb250SW5mb1wiKTtcbiAgICAgIGRhdGEuc2V0KG5ldyBVaW50OEFycmF5KGNzc0ZvbnRJbmZvQnVmZmVyKSwgb2Zmc2V0ICsgNCk7XG4gICAgICBvZmZzZXQgKz0gNCArIGxlbmd0aDtcbiAgICB9XG4gICAgaWYgKGZvbnQuZGF0YSA9PT0gdm9pZCAwKSB7XG4gICAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQsIDApO1xuICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCwgZm9udC5kYXRhLmxlbmd0aCk7XG4gICAgICBkYXRhLnNldChmb250LmRhdGEsIG9mZnNldCArIDQpO1xuICAgICAgb2Zmc2V0ICs9IDQgKyBmb250LmRhdGEubGVuZ3RoO1xuICAgIH1cbiAgICBhc3NlcnQob2Zmc2V0IDw9IGJ1ZmZlci5ieXRlTGVuZ3RoLCBcIkZvbnRJbmZvLndyaXRlOiBCdWZmZXIgb3ZlcmZsb3dcIik7XG4gICAgcmV0dXJuIGJ1ZmZlci50cmFuc2ZlclRvRml4ZWRMZW5ndGgob2Zmc2V0KTtcbiAgfVxufVxuY2xhc3MgR2xvYmFsV29ya2VyT3B0aW9ucyB7XG4gIHN0YXRpYyAjcG9ydCA9IG51bGw7XG4gIHN0YXRpYyAjc3JjID0gXCJcIjtcbiAgc3RhdGljIGdldCB3b3JrZXJQb3J0KCkge1xuICAgIHJldHVybiB0aGlzLiNwb3J0O1xuICB9XG4gIHN0YXRpYyBzZXQgd29ya2VyUG9ydCh2YWwpIHtcbiAgICBpZiAoISh0eXBlb2YgV29ya2VyICE9PSBcInVuZGVmaW5lZFwiICYmIHZhbCBpbnN0YW5jZW9mIFdvcmtlcikgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGB3b3JrZXJQb3J0YCB0eXBlLlwiKTtcbiAgICB9XG4gICAgdGhpcy4jcG9ydCA9IHZhbDtcbiAgfVxuICBzdGF0aWMgZ2V0IHdvcmtlclNyYygpIHtcbiAgICByZXR1cm4gdGhpcy4jc3JjO1xuICB9XG4gIHN0YXRpYyBzZXQgd29ya2VyU3JjKHZhbCkge1xuICAgIGlmICh0eXBlb2YgdmFsICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGB3b3JrZXJTcmNgIHR5cGUuXCIpO1xuICAgIH1cbiAgICB0aGlzLiNzcmMgPSB2YWw7XG4gIH1cbn1cbmNsYXNzIE1ldGFkYXRhIHtcbiAgI21hcDtcbiAgI2RhdGE7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBwYXJzZWREYXRhLFxuICAgIHJhd0RhdGFcbiAgfSkge1xuICAgIHRoaXMuI21hcCA9IHBhcnNlZERhdGE7XG4gICAgdGhpcy4jZGF0YSA9IHJhd0RhdGE7XG4gIH1cbiAgZ2V0UmF3KCkge1xuICAgIHJldHVybiB0aGlzLiNkYXRhO1xuICB9XG4gIGdldChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuI21hcC5nZXQobmFtZSkgPz8gbnVsbDtcbiAgfVxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gdGhpcy4jbWFwLmVudHJpZXMoKTtcbiAgfVxufVxuY29uc3QgSU5URVJOQUwgPSBTeW1ib2woXCJJTlRFUk5BTFwiKTtcbmNsYXNzIE9wdGlvbmFsQ29udGVudEdyb3VwIHtcbiAgI2lzRGlzcGxheSA9IGZhbHNlO1xuICAjaXNQcmludCA9IGZhbHNlO1xuICAjdXNlclNldCA9IGZhbHNlO1xuICAjdmlzaWJsZSA9IHRydWU7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmluZ0ludGVudCwge1xuICAgIG5hbWUsXG4gICAgaW50ZW50LFxuICAgIHVzYWdlLFxuICAgIHJiR3JvdXBzXG4gIH0pIHtcbiAgICB0aGlzLiNpc0Rpc3BsYXkgPSAhIShyZW5kZXJpbmdJbnRlbnQgJiBSZW5kZXJpbmdJbnRlbnRGbGFnLkRJU1BMQVkpO1xuICAgIHRoaXMuI2lzUHJpbnQgPSAhIShyZW5kZXJpbmdJbnRlbnQgJiBSZW5kZXJpbmdJbnRlbnRGbGFnLlBSSU5UKTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuaW50ZW50ID0gaW50ZW50O1xuICAgIHRoaXMudXNhZ2UgPSB1c2FnZTtcbiAgICB0aGlzLnJiR3JvdXBzID0gcmJHcm91cHM7XG4gIH1cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgaWYgKHRoaXMuI3VzZXJTZXQpIHtcbiAgICAgIHJldHVybiB0aGlzLiN2aXNpYmxlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI3Zpc2libGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcHJpbnQsXG4gICAgICB2aWV3XG4gICAgfSA9IHRoaXMudXNhZ2U7XG4gICAgaWYgKHRoaXMuI2lzRGlzcGxheSkge1xuICAgICAgcmV0dXJuIHZpZXc/LnZpZXdTdGF0ZSAhPT0gXCJPRkZcIjtcbiAgICB9IGVsc2UgaWYgKHRoaXMuI2lzUHJpbnQpIHtcbiAgICAgIHJldHVybiBwcmludD8ucHJpbnRTdGF0ZSAhPT0gXCJPRkZcIjtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgX3NldFZpc2libGUoaW50ZXJuYWwsIHZpc2libGUsIHVzZXJTZXQgPSBmYWxzZSkge1xuICAgIGlmIChpbnRlcm5hbCAhPT0gSU5URVJOQUwpIHtcbiAgICAgIHVucmVhY2hhYmxlKFwiSW50ZXJuYWwgbWV0aG9kIGBfc2V0VmlzaWJsZWAgY2FsbGVkLlwiKTtcbiAgICB9XG4gICAgdGhpcy4jdXNlclNldCA9IHVzZXJTZXQ7XG4gICAgdGhpcy4jdmlzaWJsZSA9IHZpc2libGU7XG4gIH1cbn1cbmNsYXNzIE9wdGlvbmFsQ29udGVudENvbmZpZyB7XG4gICNjYWNoZWRHZXRIYXNoID0gbnVsbDtcbiAgI2dyb3VwcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICNpbml0aWFsSGFzaCA9IG51bGw7XG4gICNvcmRlciA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIHJlbmRlcmluZ0ludGVudCA9IFJlbmRlcmluZ0ludGVudEZsYWcuRElTUExBWSkge1xuICAgIHRoaXMucmVuZGVyaW5nSW50ZW50ID0gcmVuZGVyaW5nSW50ZW50O1xuICAgIHRoaXMubmFtZSA9IG51bGw7XG4gICAgdGhpcy5jcmVhdG9yID0gbnVsbDtcbiAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm5hbWUgPSBkYXRhLm5hbWU7XG4gICAgdGhpcy5jcmVhdG9yID0gZGF0YS5jcmVhdG9yO1xuICAgIHRoaXMuI29yZGVyID0gZGF0YS5vcmRlcjtcbiAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIGRhdGEuZ3JvdXBzKSB7XG4gICAgICB0aGlzLiNncm91cHMuc2V0KGdyb3VwLmlkLCBuZXcgT3B0aW9uYWxDb250ZW50R3JvdXAocmVuZGVyaW5nSW50ZW50LCBncm91cCkpO1xuICAgIH1cbiAgICBpZiAoZGF0YS5iYXNlU3RhdGUgPT09IFwiT0ZGXCIpIHtcbiAgICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgdGhpcy4jZ3JvdXBzLnZhbHVlcygpKSB7XG4gICAgICAgIGdyb3VwLl9zZXRWaXNpYmxlKElOVEVSTkFMLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qgb24gb2YgZGF0YS5vbikge1xuICAgICAgdGhpcy4jZ3JvdXBzLmdldChvbikuX3NldFZpc2libGUoSU5URVJOQUwsIHRydWUpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG9mZiBvZiBkYXRhLm9mZikge1xuICAgICAgdGhpcy4jZ3JvdXBzLmdldChvZmYpLl9zZXRWaXNpYmxlKElOVEVSTkFMLCBmYWxzZSk7XG4gICAgfVxuICAgIHRoaXMuI2luaXRpYWxIYXNoID0gdGhpcy5nZXRIYXNoKCk7XG4gIH1cbiAgI2V2YWx1YXRlVmlzaWJpbGl0eUV4cHJlc3Npb24oYXJyYXkpIHtcbiAgICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBvcGVyYXRvciA9IGFycmF5WzBdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBhcnJheVtpXTtcbiAgICAgIGxldCBzdGF0ZTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGVsZW1lbnQpKSB7XG4gICAgICAgIHN0YXRlID0gdGhpcy4jZXZhbHVhdGVWaXNpYmlsaXR5RXhwcmVzc2lvbihlbGVtZW50KTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy4jZ3JvdXBzLmhhcyhlbGVtZW50KSkge1xuICAgICAgICBzdGF0ZSA9IHRoaXMuI2dyb3Vwcy5nZXQoZWxlbWVudCkudmlzaWJsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2VsZW1lbnR9YCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICBjYXNlIFwiQW5kXCI6XG4gICAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIk9yXCI6XG4gICAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJOb3RcIjpcbiAgICAgICAgICByZXR1cm4gIXN0YXRlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3BlcmF0b3IgPT09IFwiQW5kXCI7XG4gIH1cbiAgaXNWaXNpYmxlKGdyb3VwKSB7XG4gICAgaWYgKHRoaXMuI2dyb3Vwcy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFncm91cCkge1xuICAgICAgaW5mbyhcIk9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGRlZmluZWQuXCIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChncm91cC50eXBlID09PSBcIk9DR1wiKSB7XG4gICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5oYXMoZ3JvdXAuaWQpKSB7XG4gICAgICAgIHdhcm4oYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2dyb3VwLmlkfWApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLiNncm91cHMuZ2V0KGdyb3VwLmlkKS52aXNpYmxlO1xuICAgIH0gZWxzZSBpZiAoZ3JvdXAudHlwZSA9PT0gXCJPQ01EXCIpIHtcbiAgICAgIGlmIChncm91cC5leHByZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNldmFsdWF0ZVZpc2liaWxpdHlFeHByZXNzaW9uKGdyb3VwLmV4cHJlc3Npb24pO1xuICAgICAgfVxuICAgICAgaWYgKCFncm91cC5wb2xpY3kgfHwgZ3JvdXAucG9saWN5ID09PSBcIkFueU9uXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBncm91cC5pZHMpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICB3YXJuKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtpZH1gKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy4jZ3JvdXBzLmdldChpZCkudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoZ3JvdXAucG9saWN5ID09PSBcIkFsbE9uXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBncm91cC5pZHMpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICB3YXJuKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtpZH1gKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5nZXQoaWQpLnZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGdyb3VwLnBvbGljeSA9PT0gXCJBbnlPZmZcIikge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGdyb3VwLmlkcykge1xuICAgICAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIHdhcm4oYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2lkfWApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmdldChpZCkudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoZ3JvdXAucG9saWN5ID09PSBcIkFsbE9mZlwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgZ3JvdXAuaWRzKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLiNncm91cHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgd2FybihgT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6ICR7aWR9YCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuI2dyb3Vwcy5nZXQoaWQpLnZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB3YXJuKGBVbmtub3duIG9wdGlvbmFsIGNvbnRlbnQgcG9saWN5ICR7Z3JvdXAucG9saWN5fS5gKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB3YXJuKGBVbmtub3duIGdyb3VwIHR5cGUgJHtncm91cC50eXBlfS5gKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzZXRWaXNpYmlsaXR5KGlkLCB2aXNpYmxlID0gdHJ1ZSwgcHJlc2VydmVSQiA9IHRydWUpIHtcbiAgICBjb25zdCBncm91cCA9IHRoaXMuI2dyb3Vwcy5nZXQoaWQpO1xuICAgIGlmICghZ3JvdXApIHtcbiAgICAgIHdhcm4oYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2lkfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocHJlc2VydmVSQiAmJiB2aXNpYmxlICYmIGdyb3VwLnJiR3JvdXBzLmxlbmd0aCkge1xuICAgICAgZm9yIChjb25zdCByYkdyb3VwIG9mIGdyb3VwLnJiR3JvdXBzKSB7XG4gICAgICAgIGZvciAoY29uc3Qgb3RoZXJJZCBvZiByYkdyb3VwKSB7XG4gICAgICAgICAgaWYgKG90aGVySWQgIT09IGlkKSB7XG4gICAgICAgICAgICB0aGlzLiNncm91cHMuZ2V0KG90aGVySWQpPy5fc2V0VmlzaWJsZShJTlRFUk5BTCwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBncm91cC5fc2V0VmlzaWJsZShJTlRFUk5BTCwgISF2aXNpYmxlLCB0cnVlKTtcbiAgICB0aGlzLiNjYWNoZWRHZXRIYXNoID0gbnVsbDtcbiAgfVxuICBzZXRPQ0dTdGF0ZSh7XG4gICAgc3RhdGUsXG4gICAgcHJlc2VydmVSQlxuICB9KSB7XG4gICAgbGV0IG9wZXJhdG9yO1xuICAgIGZvciAoY29uc3QgZWxlbSBvZiBzdGF0ZSkge1xuICAgICAgc3dpdGNoIChlbGVtKSB7XG4gICAgICAgIGNhc2UgXCJPTlwiOlxuICAgICAgICBjYXNlIFwiT0ZGXCI6XG4gICAgICAgIGNhc2UgXCJUb2dnbGVcIjpcbiAgICAgICAgICBvcGVyYXRvciA9IGVsZW07XG4gICAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBncm91cCA9IHRoaXMuI2dyb3Vwcy5nZXQoZWxlbSk7XG4gICAgICBpZiAoIWdyb3VwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICBjYXNlIFwiT05cIjpcbiAgICAgICAgICB0aGlzLnNldFZpc2liaWxpdHkoZWxlbSwgdHJ1ZSwgcHJlc2VydmVSQik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJPRkZcIjpcbiAgICAgICAgICB0aGlzLnNldFZpc2liaWxpdHkoZWxlbSwgZmFsc2UsIHByZXNlcnZlUkIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiVG9nZ2xlXCI6XG4gICAgICAgICAgdGhpcy5zZXRWaXNpYmlsaXR5KGVsZW0sICFncm91cC52aXNpYmxlLCBwcmVzZXJ2ZVJCKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jY2FjaGVkR2V0SGFzaCA9IG51bGw7XG4gIH1cbiAgZ2V0IGhhc0luaXRpYWxWaXNpYmlsaXR5KCkge1xuICAgIHJldHVybiB0aGlzLiNpbml0aWFsSGFzaCA9PT0gbnVsbCB8fCB0aGlzLmdldEhhc2goKSA9PT0gdGhpcy4jaW5pdGlhbEhhc2g7XG4gIH1cbiAgZ2V0T3JkZXIoKSB7XG4gICAgaWYgKCF0aGlzLiNncm91cHMuc2l6ZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLiNvcmRlcikge1xuICAgICAgcmV0dXJuIHRoaXMuI29yZGVyLnNsaWNlKCk7XG4gICAgfVxuICAgIHJldHVybiBbLi4udGhpcy4jZ3JvdXBzLmtleXMoKV07XG4gIH1cbiAgZ2V0R3JvdXAoaWQpIHtcbiAgICByZXR1cm4gdGhpcy4jZ3JvdXBzLmdldChpZCkgfHwgbnVsbDtcbiAgfVxuICBnZXRIYXNoKCkge1xuICAgIGlmICh0aGlzLiNjYWNoZWRHZXRIYXNoICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy4jY2FjaGVkR2V0SGFzaDtcbiAgICB9XG4gICAgY29uc3QgaGFzaCA9IG5ldyBNdXJtdXJIYXNoM182NCgpO1xuICAgIGZvciAoY29uc3QgW2lkLCBncm91cF0gb2YgdGhpcy4jZ3JvdXBzKSB7XG4gICAgICBoYXNoLnVwZGF0ZShgJHtpZH06JHtncm91cC52aXNpYmxlfWApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy4jY2FjaGVkR2V0SGFzaCA9IGhhc2guaGV4ZGlnZXN0KCk7XG4gIH1cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIHRoaXMuI2dyb3Vwcy5lbnRyaWVzKCk7XG4gIH1cbn1cbmNsYXNzIFBERkRhdGFUcmFuc3BvcnRTdHJlYW0ge1xuICBjb25zdHJ1Y3RvcihwZGZEYXRhUmFuZ2VUcmFuc3BvcnQsIHtcbiAgICBkaXNhYmxlUmFuZ2UgPSBmYWxzZSxcbiAgICBkaXNhYmxlU3RyZWFtID0gZmFsc2VcbiAgfSkge1xuICAgIGFzc2VydChwZGZEYXRhUmFuZ2VUcmFuc3BvcnQsICdQREZEYXRhVHJhbnNwb3J0U3RyZWFtIC0gbWlzc2luZyByZXF1aXJlZCBcInBkZkRhdGFSYW5nZVRyYW5zcG9ydFwiIGFyZ3VtZW50LicpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxlbmd0aCxcbiAgICAgIGluaXRpYWxEYXRhLFxuICAgICAgcHJvZ3Jlc3NpdmVEb25lLFxuICAgICAgY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWVcbiAgICB9ID0gcGRmRGF0YVJhbmdlVHJhbnNwb3J0O1xuICAgIHRoaXMuX3F1ZXVlZENodW5rcyA9IFtdO1xuICAgIHRoaXMuX3Byb2dyZXNzaXZlRG9uZSA9IHByb2dyZXNzaXZlRG9uZTtcbiAgICB0aGlzLl9jb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSA9IGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lO1xuICAgIGlmIChpbml0aWFsRGF0YT8ubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgYnVmZmVyID0gaW5pdGlhbERhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIGluaXRpYWxEYXRhLmJ5dGVMZW5ndGggPT09IGluaXRpYWxEYXRhLmJ1ZmZlci5ieXRlTGVuZ3RoID8gaW5pdGlhbERhdGEuYnVmZmVyIDogbmV3IFVpbnQ4QXJyYXkoaW5pdGlhbERhdGEpLmJ1ZmZlcjtcbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rcy5wdXNoKGJ1ZmZlcik7XG4gICAgfVxuICAgIHRoaXMuX3BkZkRhdGFSYW5nZVRyYW5zcG9ydCA9IHBkZkRhdGFSYW5nZVRyYW5zcG9ydDtcbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9ICFkaXNhYmxlU3RyZWFtO1xuICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSAhZGlzYWJsZVJhbmdlO1xuICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBsZW5ndGg7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX3JhbmdlUmVhZGVycyA9IFtdO1xuICAgIHBkZkRhdGFSYW5nZVRyYW5zcG9ydC5hZGRSYW5nZUxpc3RlbmVyKChiZWdpbiwgY2h1bmspID0+IHtcbiAgICAgIHRoaXMuX29uUmVjZWl2ZURhdGEoe1xuICAgICAgICBiZWdpbixcbiAgICAgICAgY2h1bmtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHBkZkRhdGFSYW5nZVRyYW5zcG9ydC5hZGRQcm9ncmVzc0xpc3RlbmVyKChsb2FkZWQsIHRvdGFsKSA9PiB7XG4gICAgICB0aGlzLl9vblByb2dyZXNzKHtcbiAgICAgICAgbG9hZGVkLFxuICAgICAgICB0b3RhbFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcGRmRGF0YVJhbmdlVHJhbnNwb3J0LmFkZFByb2dyZXNzaXZlUmVhZExpc3RlbmVyKChjaHVuaykgPT4ge1xuICAgICAgdGhpcy5fb25SZWNlaXZlRGF0YSh7XG4gICAgICAgIGNodW5rXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBwZGZEYXRhUmFuZ2VUcmFuc3BvcnQuYWRkUHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXIoKCkgPT4ge1xuICAgICAgdGhpcy5fb25Qcm9ncmVzc2l2ZURvbmUoKTtcbiAgICB9KTtcbiAgICBwZGZEYXRhUmFuZ2VUcmFuc3BvcnQudHJhbnNwb3J0UmVhZHkoKTtcbiAgfVxuICBfb25SZWNlaXZlRGF0YSh7XG4gICAgYmVnaW4sXG4gICAgY2h1bmtcbiAgfSkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IGNodW5rIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiBjaHVuay5ieXRlTGVuZ3RoID09PSBjaHVuay5idWZmZXIuYnl0ZUxlbmd0aCA/IGNodW5rLmJ1ZmZlciA6IG5ldyBVaW50OEFycmF5KGNodW5rKS5idWZmZXI7XG4gICAgaWYgKGJlZ2luID09PSB2b2lkIDApIHtcbiAgICAgIGlmICh0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcikge1xuICAgICAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlci5fZW5xdWV1ZShidWZmZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcXVldWVkQ2h1bmtzLnB1c2goYnVmZmVyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZm91bmQgPSB0aGlzLl9yYW5nZVJlYWRlcnMuc29tZShmdW5jdGlvbihyYW5nZVJlYWRlcikge1xuICAgICAgICBpZiAocmFuZ2VSZWFkZXIuX2JlZ2luICE9PSBiZWdpbikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByYW5nZVJlYWRlci5fZW5xdWV1ZShidWZmZXIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgYXNzZXJ0KGZvdW5kLCBcIl9vblJlY2VpdmVEYXRhIC0gbm8gYFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SYW5nZVJlYWRlcmAgaW5zdGFuY2UgZm91bmQuXCIpO1xuICAgIH1cbiAgfVxuICBnZXQgX3Byb2dyZXNzaXZlRGF0YUxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/Ll9sb2FkZWQgPz8gMDtcbiAgfVxuICBfb25Qcm9ncmVzcyhldnQpIHtcbiAgICBpZiAoZXZ0LnRvdGFsID09PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuX3JhbmdlUmVhZGVyc1swXT8ub25Qcm9ncmVzcz8uKHtcbiAgICAgICAgbG9hZGVkOiBldnQubG9hZGVkXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/Lm9uUHJvZ3Jlc3M/Lih7XG4gICAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZCxcbiAgICAgICAgdG90YWw6IGV2dC50b3RhbFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIF9vblByb2dyZXNzaXZlRG9uZSgpIHtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8ucHJvZ3Jlc3NpdmVEb25lKCk7XG4gICAgdGhpcy5fcHJvZ3Jlc3NpdmVEb25lID0gdHJ1ZTtcbiAgfVxuICBfcmVtb3ZlUmFuZ2VSZWFkZXIocmVhZGVyKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuX3JhbmdlUmVhZGVycy5pbmRleE9mKHJlYWRlcik7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgdGhpcy5fcmFuZ2VSZWFkZXJzLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cbiAgZ2V0RnVsbFJlYWRlcigpIHtcbiAgICBhc3NlcnQoIXRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLCBcIlBERkRhdGFUcmFuc3BvcnRTdHJlYW0uZ2V0RnVsbFJlYWRlciBjYW4gb25seSBiZSBjYWxsZWQgb25jZS5cIik7XG4gICAgY29uc3QgcXVldWVkQ2h1bmtzID0gdGhpcy5fcXVldWVkQ2h1bmtzO1xuICAgIHRoaXMuX3F1ZXVlZENodW5rcyA9IG51bGw7XG4gICAgcmV0dXJuIG5ldyBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmVhZGVyKHRoaXMsIHF1ZXVlZENodW5rcywgdGhpcy5fcHJvZ3Jlc3NpdmVEb25lLCB0aGlzLl9jb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSk7XG4gIH1cbiAgZ2V0UmFuZ2VSZWFkZXIoYmVnaW4sIGVuZCkge1xuICAgIGlmIChlbmQgPD0gdGhpcy5fcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SYW5nZVJlYWRlcih0aGlzLCBiZWdpbiwgZW5kKTtcbiAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQucmVxdWVzdERhdGFSYW5nZShiZWdpbiwgZW5kKTtcbiAgICB0aGlzLl9yYW5nZVJlYWRlcnMucHVzaChyZWFkZXIpO1xuICAgIHJldHVybiByZWFkZXI7XG4gIH1cbiAgY2FuY2VsQWxsUmVxdWVzdHMocmVhc29uKSB7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHRoaXMuX3JhbmdlUmVhZGVycy5zbGljZSgwKSkge1xuICAgICAgcmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgIH1cbiAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQuYWJvcnQoKTtcbiAgfVxufVxuY2xhc3MgUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSwgcXVldWVkQ2h1bmtzLCBwcm9ncmVzc2l2ZURvbmUgPSBmYWxzZSwgY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUgPSBudWxsKSB7XG4gICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuICAgIHRoaXMuX2RvbmUgPSBwcm9ncmVzc2l2ZURvbmUgfHwgZmFsc2U7XG4gICAgdGhpcy5fZmlsZW5hbWUgPSBpc1BkZkZpbGUoY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUpID8gY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUgOiBudWxsO1xuICAgIHRoaXMuX3F1ZXVlZENodW5rcyA9IHF1ZXVlZENodW5rcyB8fCBbXTtcbiAgICB0aGlzLl9sb2FkZWQgPSAwO1xuICAgIGZvciAoY29uc3QgY2h1bmsgb2YgdGhpcy5fcXVldWVkQ2h1bmtzKSB7XG4gICAgICB0aGlzLl9sb2FkZWQgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLl9oZWFkZXJzUmVhZHkgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBzdHJlYW0uX2Z1bGxSZXF1ZXN0UmVhZGVyID0gdGhpcztcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG4gIF9lbnF1ZXVlKGNodW5rKSB7XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gdGhpcy5fcmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcXVldWVkQ2h1bmtzLnB1c2goY2h1bmspO1xuICAgIH1cbiAgICB0aGlzLl9sb2FkZWQgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgfVxuICBnZXQgaGVhZGVyc1JlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJzUmVhZHk7XG4gIH1cbiAgZ2V0IGZpbGVuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxlbmFtZTtcbiAgfVxuICBnZXQgaXNSYW5nZVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyZWFtLl9pc1JhbmdlU3VwcG9ydGVkO1xuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyZWFtLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBnZXQgY29udGVudExlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyZWFtLl9jb250ZW50TGVuZ3RoO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgaWYgKHRoaXMuX3F1ZXVlZENodW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBjaHVuayA9IHRoaXMuX3F1ZXVlZENodW5rcy5zaGlmdCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB2b2lkIDAsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5fcmVxdWVzdHMucHVzaChyZXF1ZXN0Q2FwYWJpbGl0eSk7XG4gICAgcmV0dXJuIHJlcXVlc3RDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdm9pZCAwLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgfVxuICBwcm9ncmVzc2l2ZURvbmUoKSB7XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gIH1cbn1cbmNsYXNzIFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SYW5nZVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSwgYmVnaW4sIGVuZCkge1xuICAgIHRoaXMuX3N0cmVhbSA9IHN0cmVhbTtcbiAgICB0aGlzLl9iZWdpbiA9IGJlZ2luO1xuICAgIHRoaXMuX2VuZCA9IGVuZDtcbiAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLl9kb25lID0gZmFsc2U7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgfVxuICBfZW5xdWV1ZShjaHVuaykge1xuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rID0gY2h1bms7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlcXVlc3RzQ2FwYWJpbGl0eSA9IHRoaXMuX3JlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICByZXF1ZXN0c0NhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgICB2YWx1ZTogdm9pZCAwLFxuICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgIH1cbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICB0aGlzLl9zdHJlYW0uX3JlbW92ZVJhbmdlUmVhZGVyKHRoaXMpO1xuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBpZiAodGhpcy5fcXVldWVkQ2h1bmspIHtcbiAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fcXVldWVkQ2h1bms7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHZvaWQgMCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKHJlcXVlc3RDYXBhYmlsaXR5KTtcbiAgICByZXR1cm4gcmVxdWVzdENhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiB2b2lkIDAsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX3N0cmVhbS5fcmVtb3ZlUmFuZ2VSZWFkZXIodGhpcyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEZpbGVuYW1lRnJvbUNvbnRlbnREaXNwb3NpdGlvbkhlYWRlcihjb250ZW50RGlzcG9zaXRpb24pIHtcbiAgbGV0IG5lZWRzRW5jb2RpbmdGaXh1cCA9IHRydWU7XG4gIGxldCB0bXAgPSB0b1BhcmFtUmVnRXhwKFwiZmlsZW5hbWVcXFxcKlwiLCBcImlcIikuZXhlYyhjb250ZW50RGlzcG9zaXRpb24pO1xuICBpZiAodG1wKSB7XG4gICAgdG1wID0gdG1wWzFdO1xuICAgIGxldCBmaWxlbmFtZSA9IHJmYzI2MTZ1bnF1b3RlKHRtcCk7XG4gICAgZmlsZW5hbWUgPSB1bmVzY2FwZShmaWxlbmFtZSk7XG4gICAgZmlsZW5hbWUgPSByZmM1OTg3ZGVjb2RlKGZpbGVuYW1lKTtcbiAgICBmaWxlbmFtZSA9IHJmYzIwNDdkZWNvZGUoZmlsZW5hbWUpO1xuICAgIHJldHVybiBmaXh1cEVuY29kaW5nKGZpbGVuYW1lKTtcbiAgfVxuICB0bXAgPSByZmMyMjMxZ2V0cGFyYW0oY29udGVudERpc3Bvc2l0aW9uKTtcbiAgaWYgKHRtcCkge1xuICAgIGNvbnN0IGZpbGVuYW1lID0gcmZjMjA0N2RlY29kZSh0bXApO1xuICAgIHJldHVybiBmaXh1cEVuY29kaW5nKGZpbGVuYW1lKTtcbiAgfVxuICB0bXAgPSB0b1BhcmFtUmVnRXhwKFwiZmlsZW5hbWVcIiwgXCJpXCIpLmV4ZWMoY29udGVudERpc3Bvc2l0aW9uKTtcbiAgaWYgKHRtcCkge1xuICAgIHRtcCA9IHRtcFsxXTtcbiAgICBsZXQgZmlsZW5hbWUgPSByZmMyNjE2dW5xdW90ZSh0bXApO1xuICAgIGZpbGVuYW1lID0gcmZjMjA0N2RlY29kZShmaWxlbmFtZSk7XG4gICAgcmV0dXJuIGZpeHVwRW5jb2RpbmcoZmlsZW5hbWUpO1xuICB9XG4gIGZ1bmN0aW9uIHRvUGFyYW1SZWdFeHAoYXR0cmlidXRlUGF0dGVybiwgZmxhZ3MpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChcIig/Ol58OylcXFxccypcIiArIGF0dHJpYnV0ZVBhdHRlcm4gKyAnXFxcXHMqPVxcXFxzKihbXlwiO1xcXFxzXVteO1xcXFxzXSp8XCIoPzpbXlwiXFxcXFxcXFxdfFxcXFxcXFxcXCI/KStcIj8pJywgZmxhZ3MpO1xuICB9XG4gIGZ1bmN0aW9uIHRleHRkZWNvZGUoZW5jb2RpbmcsIHZhbHVlKSB7XG4gICAgaWYgKGVuY29kaW5nKSB7XG4gICAgICBpZiAoIS9eW1xceDAwLVxceEZGXSskLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKGVuY29kaW5nLCB7XG4gICAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHN0cmluZ1RvQnl0ZXModmFsdWUpO1xuICAgICAgICB2YWx1ZSA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlcik7XG4gICAgICAgIG5lZWRzRW5jb2RpbmdGaXh1cCA9IGZhbHNlO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBmaXh1cEVuY29kaW5nKHZhbHVlKSB7XG4gICAgaWYgKG5lZWRzRW5jb2RpbmdGaXh1cCAmJiAvW1xceDgwLVxceGZmXS8udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gdGV4dGRlY29kZShcInV0Zi04XCIsIHZhbHVlKTtcbiAgICAgIGlmIChuZWVkc0VuY29kaW5nRml4dXApIHtcbiAgICAgICAgdmFsdWUgPSB0ZXh0ZGVjb2RlKFwiaXNvLTg4NTktMVwiLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiByZmMyMjMxZ2V0cGFyYW0oY29udGVudERpc3Bvc2l0aW9uU3RyKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IFtdO1xuICAgIGxldCBtYXRjaDtcbiAgICBjb25zdCBpdGVyID0gdG9QYXJhbVJlZ0V4cChcImZpbGVuYW1lXFxcXCooKD8hMFxcXFxkKVxcXFxkKykoXFxcXCo/KVwiLCBcImlnXCIpO1xuICAgIHdoaWxlICgobWF0Y2ggPSBpdGVyLmV4ZWMoY29udGVudERpc3Bvc2l0aW9uU3RyKSkgIT09IG51bGwpIHtcbiAgICAgIGxldCBbLCBuLCBxdW90LCBwYXJ0XSA9IG1hdGNoO1xuICAgICAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgICAgIGlmIChuIGluIG1hdGNoZXMpIHtcbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIG1hdGNoZXNbbl0gPSBbcXVvdCwgcGFydF07XG4gICAgfVxuICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCBtYXRjaGVzLmxlbmd0aDsgKytuKSB7XG4gICAgICBpZiAoIShuIGluIG1hdGNoZXMpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbGV0IFtxdW90LCBwYXJ0XSA9IG1hdGNoZXNbbl07XG4gICAgICBwYXJ0ID0gcmZjMjYxNnVucXVvdGUocGFydCk7XG4gICAgICBpZiAocXVvdCkge1xuICAgICAgICBwYXJ0ID0gdW5lc2NhcGUocGFydCk7XG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgcGFydCA9IHJmYzU5ODdkZWNvZGUocGFydCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBhcnRzLnB1c2gocGFydCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cy5qb2luKFwiXCIpO1xuICB9XG4gIGZ1bmN0aW9uIHJmYzI2MTZ1bnF1b3RlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoJ1wiJykpIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gdmFsdWUuc2xpY2UoMSkuc3BsaXQoJ1xcXFxcIicpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBxdW90aW5kZXggPSBwYXJ0c1tpXS5pbmRleE9mKCdcIicpO1xuICAgICAgICBpZiAocXVvdGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIHBhcnRzW2ldID0gcGFydHNbaV0uc2xpY2UoMCwgcXVvdGluZGV4KTtcbiAgICAgICAgICBwYXJ0cy5sZW5ndGggPSBpICsgMTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0c1tpXSA9IHBhcnRzW2ldLnJlcGxhY2VBbGwoL1xcXFwoLikvZywgXCIkMVwiKTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gcGFydHMuam9pbignXCInKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIHJmYzU5ODdkZWNvZGUoZXh0dmFsdWUpIHtcbiAgICBjb25zdCBlbmNvZGluZ2VuZCA9IGV4dHZhbHVlLmluZGV4T2YoXCInXCIpO1xuICAgIGlmIChlbmNvZGluZ2VuZCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBleHR2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgZW5jb2RpbmcgPSBleHR2YWx1ZS5zbGljZSgwLCBlbmNvZGluZ2VuZCk7XG4gICAgY29uc3QgbGFuZ3ZhbHVlID0gZXh0dmFsdWUuc2xpY2UoZW5jb2RpbmdlbmQgKyAxKTtcbiAgICBjb25zdCB2YWx1ZSA9IGxhbmd2YWx1ZS5yZXBsYWNlKC9eW14nXSonLywgXCJcIik7XG4gICAgcmV0dXJuIHRleHRkZWNvZGUoZW5jb2RpbmcsIHZhbHVlKTtcbiAgfVxuICBmdW5jdGlvbiByZmMyMDQ3ZGVjb2RlKHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZS5zdGFydHNXaXRoKFwiPT9cIikgfHwgL1tcXHgwMC1cXHgxOVxceDgwLVxceGZmXS8udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2VBbGwoLz1cXD8oW1xcdy1dKilcXD8oW1FxQmJdKVxcPygoPzpbXj9dfFxcPyg/IT0pKSopXFw/PS9nLCBmdW5jdGlvbihtYXRjaGVzLCBjaGFyc2V0LCBlbmNvZGluZywgdGV4dCkge1xuICAgICAgaWYgKGVuY29kaW5nID09PSBcInFcIiB8fCBlbmNvZGluZyA9PT0gXCJRXCIpIHtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZUFsbChcIl9cIiwgXCIgXCIpO1xuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlQWxsKC89KFswLTlhLWZBLUZdezJ9KS9nLCBmdW5jdGlvbihtYXRjaCwgaGV4KSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoaGV4LCAxNikpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRleHRkZWNvZGUoY2hhcnNldCwgdGV4dCk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB0ZXh0ID0gYXRvYih0ZXh0KTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRleHRkZWNvZGUoY2hhcnNldCwgdGV4dCk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIFwiXCI7XG59XG5mdW5jdGlvbiBjcmVhdGVIZWFkZXJzKGlzSHR0cCwgaHR0cEhlYWRlcnMpIHtcbiAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gIGlmICghaXNIdHRwIHx8ICFodHRwSGVhZGVycyB8fCB0eXBlb2YgaHR0cEhlYWRlcnMgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gaGVhZGVycztcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBodHRwSGVhZGVycykge1xuICAgIGNvbnN0IHZhbCA9IGh0dHBIZWFkZXJzW2tleV07XG4gICAgaWYgKHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBoZWFkZXJzO1xufVxuZnVuY3Rpb24gZ2V0UmVzcG9uc2VPcmlnaW4odXJsKSB7XG4gIHJldHVybiBVUkwucGFyc2UodXJsKT8ub3JpZ2luID8/IG51bGw7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVJhbmdlUmVxdWVzdENhcGFiaWxpdGllcyh7XG4gIHJlc3BvbnNlSGVhZGVycyxcbiAgaXNIdHRwLFxuICByYW5nZUNodW5rU2l6ZSxcbiAgZGlzYWJsZVJhbmdlXG59KSB7XG4gIGNvbnN0IHJldHVyblZhbHVlcyA9IHtcbiAgICBhbGxvd1JhbmdlUmVxdWVzdHM6IGZhbHNlLFxuICAgIHN1Z2dlc3RlZExlbmd0aDogdm9pZCAwXG4gIH07XG4gIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KHJlc3BvbnNlSGVhZGVycy5nZXQoXCJDb250ZW50LUxlbmd0aFwiKSwgMTApO1xuICBpZiAoIU51bWJlci5pc0ludGVnZXIobGVuZ3RoKSkge1xuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gIH1cbiAgcmV0dXJuVmFsdWVzLnN1Z2dlc3RlZExlbmd0aCA9IGxlbmd0aDtcbiAgaWYgKGxlbmd0aCA8PSAyICogcmFuZ2VDaHVua1NpemUpIHtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xuICB9XG4gIGlmIChkaXNhYmxlUmFuZ2UgfHwgIWlzSHR0cCkge1xuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gIH1cbiAgaWYgKHJlc3BvbnNlSGVhZGVycy5nZXQoXCJBY2NlcHQtUmFuZ2VzXCIpICE9PSBcImJ5dGVzXCIpIHtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xuICB9XG4gIGNvbnN0IGNvbnRlbnRFbmNvZGluZyA9IHJlc3BvbnNlSGVhZGVycy5nZXQoXCJDb250ZW50LUVuY29kaW5nXCIpIHx8IFwiaWRlbnRpdHlcIjtcbiAgaWYgKGNvbnRlbnRFbmNvZGluZyAhPT0gXCJpZGVudGl0eVwiKSB7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlcztcbiAgfVxuICByZXR1cm5WYWx1ZXMuYWxsb3dSYW5nZVJlcXVlc3RzID0gdHJ1ZTtcbiAgcmV0dXJuIHJldHVyblZhbHVlcztcbn1cbmZ1bmN0aW9uIGV4dHJhY3RGaWxlbmFtZUZyb21IZWFkZXIocmVzcG9uc2VIZWFkZXJzKSB7XG4gIGNvbnN0IGNvbnRlbnREaXNwb3NpdGlvbiA9IHJlc3BvbnNlSGVhZGVycy5nZXQoXCJDb250ZW50LURpc3Bvc2l0aW9uXCIpO1xuICBpZiAoY29udGVudERpc3Bvc2l0aW9uKSB7XG4gICAgbGV0IGZpbGVuYW1lID0gZ2V0RmlsZW5hbWVGcm9tQ29udGVudERpc3Bvc2l0aW9uSGVhZGVyKGNvbnRlbnREaXNwb3NpdGlvbik7XG4gICAgaWYgKGZpbGVuYW1lLmluY2x1ZGVzKFwiJVwiKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZmlsZW5hbWUgPSBkZWNvZGVVUklDb21wb25lbnQoZmlsZW5hbWUpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc1BkZkZpbGUoZmlsZW5hbWUpKSB7XG4gICAgICByZXR1cm4gZmlsZW5hbWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVzcG9uc2VFcnJvcihzdGF0dXMsIHVybCkge1xuICByZXR1cm4gbmV3IFJlc3BvbnNlRXhjZXB0aW9uKGBVbmV4cGVjdGVkIHNlcnZlciByZXNwb25zZSAoJHtzdGF0dXN9KSB3aGlsZSByZXRyaWV2aW5nIFBERiBcIiR7dXJsfVwiLmAsIHN0YXR1cywgc3RhdHVzID09PSA0MDQgfHwgc3RhdHVzID09PSAwICYmIHVybC5zdGFydHNXaXRoKFwiZmlsZTpcIikpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVSZXNwb25zZVN0YXR1cyhzdGF0dXMpIHtcbiAgcmV0dXJuIHN0YXR1cyA9PT0gMjAwIHx8IHN0YXR1cyA9PT0gMjA2O1xufVxuZnVuY3Rpb24gY3JlYXRlRmV0Y2hPcHRpb25zKGhlYWRlcnMsIHdpdGhDcmVkZW50aWFscywgYWJvcnRDb250cm9sbGVyKSB7XG4gIHJldHVybiB7XG4gICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgIGhlYWRlcnMsXG4gICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgIG1vZGU6IFwiY29yc1wiLFxuICAgIGNyZWRlbnRpYWxzOiB3aXRoQ3JlZGVudGlhbHMgPyBcImluY2x1ZGVcIiA6IFwic2FtZS1vcmlnaW5cIixcbiAgICByZWRpcmVjdDogXCJmb2xsb3dcIlxuICB9O1xufVxuZnVuY3Rpb24gZ2V0QXJyYXlCdWZmZXIodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIHZhbC5idWZmZXI7XG4gIH1cbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICB3YXJuKGBnZXRBcnJheUJ1ZmZlciAtIHVuZXhwZWN0ZWQgZGF0YSBmb3JtYXQ6ICR7dmFsfWApO1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodmFsKS5idWZmZXI7XG59XG5jbGFzcyBQREZGZXRjaFN0cmVhbSB7XG4gIF9yZXNwb25zZU9yaWdpbiA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMuaXNIdHRwID0gL15odHRwcz86L2kudGVzdChzb3VyY2UudXJsKTtcbiAgICB0aGlzLmhlYWRlcnMgPSBjcmVhdGVIZWFkZXJzKHRoaXMuaXNIdHRwLCBzb3VyY2UuaHR0cEhlYWRlcnMpO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzID0gW107XG4gIH1cbiAgZ2V0IF9wcm9ncmVzc2l2ZURhdGFMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5fbG9hZGVkID8/IDA7XG4gIH1cbiAgZ2V0RnVsbFJlYWRlcigpIHtcbiAgICBhc3NlcnQoIXRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLCBcIlBERkZldGNoU3RyZWFtLmdldEZ1bGxSZWFkZXIgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UuXCIpO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbmV3IFBERkZldGNoU3RyZWFtUmVhZGVyKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcjtcbiAgfVxuICBnZXRSYW5nZVJlYWRlcihiZWdpbiwgZW5kKSB7XG4gICAgaWYgKGVuZCA8PSB0aGlzLl9wcm9ncmVzc2l2ZURhdGFMZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZWFkZXIgPSBuZXcgUERGRmV0Y2hTdHJlYW1SYW5nZVJlYWRlcih0aGlzLCBiZWdpbiwgZW5kKTtcbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnB1c2gocmVhZGVyKTtcbiAgICByZXR1cm4gcmVhZGVyO1xuICB9XG4gIGNhbmNlbEFsbFJlcXVlc3RzKHJlYXNvbikge1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5jYW5jZWwocmVhc29uKTtcbiAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnNsaWNlKDApKSB7XG4gICAgICByZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgfVxuICB9XG59XG5jbGFzcyBQREZGZXRjaFN0cmVhbVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuICAgIHRoaXMuX3N0cmVhbSA9IHN0cmVhbTtcbiAgICB0aGlzLl9yZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX2xvYWRlZCA9IDA7XG4gICAgdGhpcy5fZmlsZW5hbWUgPSBudWxsO1xuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmVhbS5zb3VyY2U7XG4gICAgdGhpcy5fd2l0aENyZWRlbnRpYWxzID0gc291cmNlLndpdGhDcmVkZW50aWFscyB8fCBmYWxzZTtcbiAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHNvdXJjZS5kaXNhYmxlUmFuZ2UgfHwgZmFsc2U7XG4gICAgdGhpcy5fcmFuZ2VDaHVua1NpemUgPSBzb3VyY2UucmFuZ2VDaHVua1NpemU7XG4gICAgaWYgKCF0aGlzLl9yYW5nZUNodW5rU2l6ZSAmJiAhdGhpcy5fZGlzYWJsZVJhbmdlKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9hYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVTdHJlYW07XG4gICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVJhbmdlO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhzdHJlYW0uaGVhZGVycyk7XG4gICAgY29uc3QgdXJsID0gc291cmNlLnVybDtcbiAgICBmZXRjaCh1cmwsIGNyZWF0ZUZldGNoT3B0aW9ucyhoZWFkZXJzLCB0aGlzLl93aXRoQ3JlZGVudGlhbHMsIHRoaXMuX2Fib3J0Q29udHJvbGxlcikpLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICBzdHJlYW0uX3Jlc3BvbnNlT3JpZ2luID0gZ2V0UmVzcG9uc2VPcmlnaW4ocmVzcG9uc2UudXJsKTtcbiAgICAgIGlmICghdmFsaWRhdGVSZXNwb25zZVN0YXR1cyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZVJlc3BvbnNlRXJyb3IocmVzcG9uc2Uuc3RhdHVzLCB1cmwpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IHJlc3BvbnNlLmhlYWRlcnM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFsbG93UmFuZ2VSZXF1ZXN0cyxcbiAgICAgICAgc3VnZ2VzdGVkTGVuZ3RoXG4gICAgICB9ID0gdmFsaWRhdGVSYW5nZVJlcXVlc3RDYXBhYmlsaXRpZXMoe1xuICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIGlzSHR0cDogc3RyZWFtLmlzSHR0cCxcbiAgICAgICAgcmFuZ2VDaHVua1NpemU6IHRoaXMuX3JhbmdlQ2h1bmtTaXplLFxuICAgICAgICBkaXNhYmxlUmFuZ2U6IHRoaXMuX2Rpc2FibGVSYW5nZVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gYWxsb3dSYW5nZVJlcXVlc3RzO1xuICAgICAgdGhpcy5fY29udGVudExlbmd0aCA9IHN1Z2dlc3RlZExlbmd0aCB8fCB0aGlzLl9jb250ZW50TGVuZ3RoO1xuICAgICAgdGhpcy5fZmlsZW5hbWUgPSBleHRyYWN0RmlsZW5hbWVGcm9tSGVhZGVyKHJlc3BvbnNlSGVhZGVycyk7XG4gICAgICBpZiAoIXRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkICYmIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgdGhpcy5jYW5jZWwobmV3IEFib3J0RXhjZXB0aW9uKFwiU3RyZWFtaW5nIGlzIGRpc2FibGVkLlwiKSk7XG4gICAgICB9XG4gICAgfSkuY2F0Y2godGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVqZWN0KTtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG4gIGdldCBoZWFkZXJzUmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgZ2V0IGZpbGVuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxlbmFtZTtcbiAgfVxuICBnZXQgY29udGVudExlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGVudExlbmd0aDtcbiAgfVxuICBnZXQgaXNSYW5nZVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNSYW5nZVN1cHBvcnRlZDtcbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgYXdhaXQgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgICBjb25zdCB7XG4gICAgICB2YWx1ZSxcbiAgICAgIGRvbmVcbiAgICB9ID0gYXdhaXQgdGhpcy5fcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAoZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGRvbmVcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMuX2xvYWRlZCArPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgIHRoaXMub25Qcm9ncmVzcz8uKHtcbiAgICAgIGxvYWRlZDogdGhpcy5fbG9hZGVkLFxuICAgICAgdG90YWw6IHRoaXMuX2NvbnRlbnRMZW5ndGhcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGdldEFycmF5QnVmZmVyKHZhbHVlKSxcbiAgICAgIGRvbmU6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fcmVhZGVyPy5jYW5jZWwocmVhc29uKTtcbiAgICB0aGlzLl9hYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgfVxufVxuY2xhc3MgUERGRmV0Y2hTdHJlYW1SYW5nZVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSwgYmVnaW4sIGVuZCkge1xuICAgIHRoaXMuX3N0cmVhbSA9IHN0cmVhbTtcbiAgICB0aGlzLl9yZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX2xvYWRlZCA9IDA7XG4gICAgY29uc3Qgc291cmNlID0gc3RyZWFtLnNvdXJjZTtcbiAgICB0aGlzLl93aXRoQ3JlZGVudGlhbHMgPSBzb3VyY2Uud2l0aENyZWRlbnRpYWxzIHx8IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVTdHJlYW07XG4gICAgdGhpcy5fYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhzdHJlYW0uaGVhZGVycyk7XG4gICAgaGVhZGVycy5hcHBlbmQoXCJSYW5nZVwiLCBgYnl0ZXM9JHtiZWdpbn0tJHtlbmQgLSAxfWApO1xuICAgIGNvbnN0IHVybCA9IHNvdXJjZS51cmw7XG4gICAgZmV0Y2godXJsLCBjcmVhdGVGZXRjaE9wdGlvbnMoaGVhZGVycywgdGhpcy5fd2l0aENyZWRlbnRpYWxzLCB0aGlzLl9hYm9ydENvbnRyb2xsZXIpKS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgY29uc3QgcmVzcG9uc2VPcmlnaW4gPSBnZXRSZXNwb25zZU9yaWdpbihyZXNwb25zZS51cmwpO1xuICAgICAgaWYgKHJlc3BvbnNlT3JpZ2luICE9PSBzdHJlYW0uX3Jlc3BvbnNlT3JpZ2luKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgcmFuZ2UgcmVzcG9uc2Utb3JpZ2luIFwiJHtyZXNwb25zZU9yaWdpbn1cIiB0byBtYXRjaCBcIiR7c3RyZWFtLl9yZXNwb25zZU9yaWdpbn1cIi5gKTtcbiAgICAgIH1cbiAgICAgIGlmICghdmFsaWRhdGVSZXNwb25zZVN0YXR1cyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZVJlc3BvbnNlRXJyb3IocmVzcG9uc2Uuc3RhdHVzLCB1cmwpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgdGhpcy5fcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgICB9KS5jYXRjaCh0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZWplY3QpO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGF3YWl0IHRoaXMuX3JlYWRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgY29uc3Qge1xuICAgICAgdmFsdWUsXG4gICAgICBkb25lXG4gICAgfSA9IGF3YWl0IHRoaXMuX3JlYWRlci5yZWFkKCk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBkb25lXG4gICAgICB9O1xuICAgIH1cbiAgICB0aGlzLl9sb2FkZWQgKz0gdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICBsb2FkZWQ6IHRoaXMuX2xvYWRlZFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogZ2V0QXJyYXlCdWZmZXIodmFsdWUpLFxuICAgICAgZG9uZTogZmFsc2VcbiAgICB9O1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICB0aGlzLl9yZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICB9XG59XG5jb25zdCBPS19SRVNQT05TRSA9IDIwMDtcbmNvbnN0IFBBUlRJQUxfQ09OVEVOVF9SRVNQT05TRSA9IDIwNjtcbmZ1bmN0aW9uIG5ldHdvcmtfZ2V0QXJyYXlCdWZmZXIoeGhyKSB7XG4gIGNvbnN0IGRhdGEgPSB4aHIucmVzcG9uc2U7XG4gIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIHJldHVybiBzdHJpbmdUb0J5dGVzKGRhdGEpLmJ1ZmZlcjtcbn1cbmNsYXNzIE5ldHdvcmtNYW5hZ2VyIHtcbiAgX3Jlc3BvbnNlT3JpZ2luID0gbnVsbDtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHVybCxcbiAgICBodHRwSGVhZGVycyxcbiAgICB3aXRoQ3JlZGVudGlhbHNcbiAgfSkge1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMuaXNIdHRwID0gL15odHRwcz86L2kudGVzdCh1cmwpO1xuICAgIHRoaXMuaGVhZGVycyA9IGNyZWF0ZUhlYWRlcnModGhpcy5pc0h0dHAsIGh0dHBIZWFkZXJzKTtcbiAgICB0aGlzLndpdGhDcmVkZW50aWFscyA9IHdpdGhDcmVkZW50aWFscyB8fCBmYWxzZTtcbiAgICB0aGlzLmN1cnJYaHJJZCA9IDA7XG4gICAgdGhpcy5wZW5kaW5nUmVxdWVzdHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICByZXF1ZXN0KGFyZ3MpIHtcbiAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICBjb25zdCB4aHJJZCA9IHRoaXMuY3VyclhocklkKys7XG4gICAgY29uc3QgcGVuZGluZ1JlcXVlc3QgPSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF0gPSB7XG4gICAgICB4aHJcbiAgICB9O1xuICAgIHhoci5vcGVuKFwiR0VUXCIsIHRoaXMudXJsKTtcbiAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdGhpcy53aXRoQ3JlZGVudGlhbHM7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIHRoaXMuaGVhZGVycykge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0h0dHAgJiYgXCJiZWdpblwiIGluIGFyZ3MgJiYgXCJlbmRcIiBpbiBhcmdzKSB7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIlJhbmdlXCIsIGBieXRlcz0ke2FyZ3MuYmVnaW59LSR7YXJncy5lbmQgLSAxfWApO1xuICAgICAgcGVuZGluZ1JlcXVlc3QuZXhwZWN0ZWRTdGF0dXMgPSBQQVJUSUFMX0NPTlRFTlRfUkVTUE9OU0U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0LmV4cGVjdGVkU3RhdHVzID0gT0tfUkVTUE9OU0U7XG4gICAgfVxuICAgIHhoci5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XG4gICAgYXNzZXJ0KGFyZ3Mub25FcnJvciwgXCJFeHBlY3RlZCBgb25FcnJvcmAgY2FsbGJhY2sgdG8gYmUgcHJvdmlkZWQuXCIpO1xuICAgIHhoci5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgYXJncy5vbkVycm9yKHhoci5zdGF0dXMpO1xuICAgIH07XG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHRoaXMub25TdGF0ZUNoYW5nZS5iaW5kKHRoaXMsIHhocklkKTtcbiAgICB4aHIub25wcm9ncmVzcyA9IHRoaXMub25Qcm9ncmVzcy5iaW5kKHRoaXMsIHhocklkKTtcbiAgICBwZW5kaW5nUmVxdWVzdC5vbkhlYWRlcnNSZWNlaXZlZCA9IGFyZ3Mub25IZWFkZXJzUmVjZWl2ZWQ7XG4gICAgcGVuZGluZ1JlcXVlc3Qub25Eb25lID0gYXJncy5vbkRvbmU7XG4gICAgcGVuZGluZ1JlcXVlc3Qub25FcnJvciA9IGFyZ3Mub25FcnJvcjtcbiAgICBwZW5kaW5nUmVxdWVzdC5vblByb2dyZXNzID0gYXJncy5vblByb2dyZXNzO1xuICAgIHhoci5zZW5kKG51bGwpO1xuICAgIHJldHVybiB4aHJJZDtcbiAgfVxuICBvblByb2dyZXNzKHhocklkLCBldnQpIHtcbiAgICBjb25zdCBwZW5kaW5nUmVxdWVzdCA9IHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXTtcbiAgICBpZiAoIXBlbmRpbmdSZXF1ZXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHBlbmRpbmdSZXF1ZXN0Lm9uUHJvZ3Jlc3M/LihldnQpO1xuICB9XG4gIG9uU3RhdGVDaGFuZ2UoeGhySWQsIGV2dCkge1xuICAgIGNvbnN0IHBlbmRpbmdSZXF1ZXN0ID0gdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdO1xuICAgIGlmICghcGVuZGluZ1JlcXVlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeGhyID0gcGVuZGluZ1JlcXVlc3QueGhyO1xuICAgIGlmICh4aHIucmVhZHlTdGF0ZSA+PSAyICYmIHBlbmRpbmdSZXF1ZXN0Lm9uSGVhZGVyc1JlY2VpdmVkKSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vbkhlYWRlcnNSZWNlaXZlZCgpO1xuICAgICAgZGVsZXRlIHBlbmRpbmdSZXF1ZXN0Lm9uSGVhZGVyc1JlY2VpdmVkO1xuICAgIH1cbiAgICBpZiAoeGhyLnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCEoeGhySWQgaW4gdGhpcy5wZW5kaW5nUmVxdWVzdHMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF07XG4gICAgaWYgKHhoci5zdGF0dXMgPT09IDAgJiYgdGhpcy5pc0h0dHApIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRXJyb3IoeGhyLnN0YXR1cyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHhoclN0YXR1cyA9IHhoci5zdGF0dXMgfHwgT0tfUkVTUE9OU0U7XG4gICAgY29uc3Qgb2tfcmVzcG9uc2Vfb25fcmFuZ2VfcmVxdWVzdCA9IHhoclN0YXR1cyA9PT0gT0tfUkVTUE9OU0UgJiYgcGVuZGluZ1JlcXVlc3QuZXhwZWN0ZWRTdGF0dXMgPT09IFBBUlRJQUxfQ09OVEVOVF9SRVNQT05TRTtcbiAgICBpZiAoIW9rX3Jlc3BvbnNlX29uX3JhbmdlX3JlcXVlc3QgJiYgeGhyU3RhdHVzICE9PSBwZW5kaW5nUmVxdWVzdC5leHBlY3RlZFN0YXR1cykge1xuICAgICAgcGVuZGluZ1JlcXVlc3Qub25FcnJvcih4aHIuc3RhdHVzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2h1bmsgPSBuZXR3b3JrX2dldEFycmF5QnVmZmVyKHhocik7XG4gICAgaWYgKHhoclN0YXR1cyA9PT0gUEFSVElBTF9DT05URU5UX1JFU1BPTlNFKSB7XG4gICAgICBjb25zdCByYW5nZUhlYWRlciA9IHhoci5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtUmFuZ2VcIik7XG4gICAgICBjb25zdCBtYXRjaGVzID0gL2J5dGVzIChcXGQrKS0oXFxkKylcXC8oXFxkKykvLmV4ZWMocmFuZ2VIZWFkZXIpO1xuICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgcGVuZGluZ1JlcXVlc3Qub25Eb25lKHtcbiAgICAgICAgICBiZWdpbjogcGFyc2VJbnQobWF0Y2hlc1sxXSwgMTApLFxuICAgICAgICAgIGNodW5rXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybihgTWlzc2luZyBvciBpbnZhbGlkIFwiQ29udGVudC1SYW5nZVwiIGhlYWRlci5gKTtcbiAgICAgICAgcGVuZGluZ1JlcXVlc3Qub25FcnJvcigwKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNodW5rKSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vbkRvbmUoe1xuICAgICAgICBiZWdpbjogMCxcbiAgICAgICAgY2h1bmtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vbkVycm9yKHhoci5zdGF0dXMpO1xuICAgIH1cbiAgfVxuICBnZXRSZXF1ZXN0WGhyKHhocklkKSB7XG4gICAgcmV0dXJuIHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXS54aHI7XG4gIH1cbiAgaXNQZW5kaW5nUmVxdWVzdCh4aHJJZCkge1xuICAgIHJldHVybiB4aHJJZCBpbiB0aGlzLnBlbmRpbmdSZXF1ZXN0cztcbiAgfVxuICBhYm9ydFJlcXVlc3QoeGhySWQpIHtcbiAgICBjb25zdCB4aHIgPSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF0ueGhyO1xuICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF07XG4gICAgeGhyLmFib3J0KCk7XG4gIH1cbn1cbmNsYXNzIFBERk5ldHdvcmtTdHJlYW0ge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5fbWFuYWdlciA9IG5ldyBOZXR3b3JrTWFuYWdlcihzb3VyY2UpO1xuICAgIHRoaXMuX3JhbmdlQ2h1bmtTaXplID0gc291cmNlLnJhbmdlQ2h1bmtTaXplO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzID0gW107XG4gIH1cbiAgX29uUmFuZ2VSZXF1ZXN0UmVhZGVyQ2xvc2VkKHJlYWRlcikge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLmluZGV4T2YocmVhZGVyKTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cbiAgZ2V0RnVsbFJlYWRlcigpIHtcbiAgICBhc3NlcnQoIXRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLCBcIlBERk5ldHdvcmtTdHJlYW0uZ2V0RnVsbFJlYWRlciBjYW4gb25seSBiZSBjYWxsZWQgb25jZS5cIik7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBuZXcgUERGTmV0d29ya1N0cmVhbUZ1bGxSZXF1ZXN0UmVhZGVyKHRoaXMuX21hbmFnZXIsIHRoaXMuX3NvdXJjZSk7XG4gICAgcmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyO1xuICB9XG4gIGdldFJhbmdlUmVhZGVyKGJlZ2luLCBlbmQpIHtcbiAgICBjb25zdCByZWFkZXIgPSBuZXcgUERGTmV0d29ya1N0cmVhbVJhbmdlUmVxdWVzdFJlYWRlcih0aGlzLl9tYW5hZ2VyLCBiZWdpbiwgZW5kKTtcbiAgICByZWFkZXIub25DbG9zZWQgPSB0aGlzLl9vblJhbmdlUmVxdWVzdFJlYWRlckNsb3NlZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMucHVzaChyZWFkZXIpO1xuICAgIHJldHVybiByZWFkZXI7XG4gIH1cbiAgY2FuY2VsQWxsUmVxdWVzdHMocmVhc29uKSB7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuc2xpY2UoMCkpIHtcbiAgICAgIHJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIFBERk5ldHdvcmtTdHJlYW1GdWxsUmVxdWVzdFJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIsIHNvdXJjZSkge1xuICAgIHRoaXMuX21hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIHRoaXMuX3VybCA9IHNvdXJjZS51cmw7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RJZCA9IG1hbmFnZXIucmVxdWVzdCh7XG4gICAgICBvbkhlYWRlcnNSZWNlaXZlZDogdGhpcy5fb25IZWFkZXJzUmVjZWl2ZWQuYmluZCh0aGlzKSxcbiAgICAgIG9uRG9uZTogdGhpcy5fb25Eb25lLmJpbmQodGhpcyksXG4gICAgICBvbkVycm9yOiB0aGlzLl9vbkVycm9yLmJpbmQodGhpcyksXG4gICAgICBvblByb2dyZXNzOiB0aGlzLl9vblByb2dyZXNzLmJpbmQodGhpcylcbiAgICB9KTtcbiAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHNvdXJjZS5kaXNhYmxlUmFuZ2UgfHwgZmFsc2U7XG4gICAgdGhpcy5fY29udGVudExlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgdGhpcy5fcmFuZ2VDaHVua1NpemUgPSBzb3VyY2UucmFuZ2VDaHVua1NpemU7XG4gICAgaWYgKCF0aGlzLl9yYW5nZUNodW5rU2l6ZSAmJiAhdGhpcy5fZGlzYWJsZVJhbmdlKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9jYWNoZWRDaHVua3MgPSBbXTtcbiAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IHZvaWQgMDtcbiAgICB0aGlzLl9maWxlbmFtZSA9IG51bGw7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgfVxuICBfb25IZWFkZXJzUmVjZWl2ZWQoKSB7XG4gICAgY29uc3QgZnVsbFJlcXVlc3RYaHJJZCA9IHRoaXMuX2Z1bGxSZXF1ZXN0SWQ7XG4gICAgY29uc3QgZnVsbFJlcXVlc3RYaHIgPSB0aGlzLl9tYW5hZ2VyLmdldFJlcXVlc3RYaHIoZnVsbFJlcXVlc3RYaHJJZCk7XG4gICAgdGhpcy5fbWFuYWdlci5fcmVzcG9uc2VPcmlnaW4gPSBnZXRSZXNwb25zZU9yaWdpbihmdWxsUmVxdWVzdFhoci5yZXNwb25zZVVSTCk7XG4gICAgY29uc3QgcmF3UmVzcG9uc2VIZWFkZXJzID0gZnVsbFJlcXVlc3RYaHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCk7XG4gICAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gbmV3IEhlYWRlcnMocmF3UmVzcG9uc2VIZWFkZXJzID8gcmF3UmVzcG9uc2VIZWFkZXJzLnRyaW1TdGFydCgpLnJlcGxhY2UoL1teXFxTIF0rJC8sIFwiXCIpLnNwbGl0KC9bXFxyXFxuXSsvKS5tYXAoKHgpID0+IHtcbiAgICAgIGNvbnN0IFtrZXksIC4uLnZhbF0gPSB4LnNwbGl0KFwiOiBcIik7XG4gICAgICByZXR1cm4gW2tleSwgdmFsLmpvaW4oXCI6IFwiKV07XG4gICAgfSkgOiBbXSk7XG4gICAgY29uc3Qge1xuICAgICAgYWxsb3dSYW5nZVJlcXVlc3RzLFxuICAgICAgc3VnZ2VzdGVkTGVuZ3RoXG4gICAgfSA9IHZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzKHtcbiAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgIGlzSHR0cDogdGhpcy5fbWFuYWdlci5pc0h0dHAsXG4gICAgICByYW5nZUNodW5rU2l6ZTogdGhpcy5fcmFuZ2VDaHVua1NpemUsXG4gICAgICBkaXNhYmxlUmFuZ2U6IHRoaXMuX2Rpc2FibGVSYW5nZVxuICAgIH0pO1xuICAgIGlmIChhbGxvd1JhbmdlUmVxdWVzdHMpIHtcbiAgICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc3VnZ2VzdGVkTGVuZ3RoIHx8IHRoaXMuX2NvbnRlbnRMZW5ndGg7XG4gICAgdGhpcy5fZmlsZW5hbWUgPSBleHRyYWN0RmlsZW5hbWVGcm9tSGVhZGVyKHJlc3BvbnNlSGVhZGVycyk7XG4gICAgaWYgKHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQpIHtcbiAgICAgIHRoaXMuX21hbmFnZXIuYWJvcnRSZXF1ZXN0KGZ1bGxSZXF1ZXN0WGhySWQpO1xuICAgIH1cbiAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gIH1cbiAgX29uRG9uZShkYXRhKSB7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIGlmICh0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gdGhpcy5fcmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgICAgdmFsdWU6IGRhdGEuY2h1bmssXG4gICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jYWNoZWRDaHVua3MucHVzaChkYXRhLmNodW5rKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgaWYgKHRoaXMuX2NhY2hlZENodW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdm9pZCAwLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgfVxuICBfb25FcnJvcihzdGF0dXMpIHtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IGNyZWF0ZVJlc3BvbnNlRXJyb3Ioc3RhdHVzLCB0aGlzLl91cmwpO1xuICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlamVjdCh0aGlzLl9zdG9yZWRFcnJvcik7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVqZWN0KHRoaXMuX3N0b3JlZEVycm9yKTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9jYWNoZWRDaHVua3MubGVuZ3RoID0gMDtcbiAgfVxuICBfb25Qcm9ncmVzcyhldnQpIHtcbiAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICBsb2FkZWQ6IGV2dC5sb2FkZWQsXG4gICAgICB0b3RhbDogZXZ0Lmxlbmd0aENvbXB1dGFibGUgPyBldnQudG90YWwgOiB0aGlzLl9jb250ZW50TGVuZ3RoXG4gICAgfSk7XG4gIH1cbiAgZ2V0IGZpbGVuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxlbmFtZTtcbiAgfVxuICBnZXQgaXNSYW5nZVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNSYW5nZVN1cHBvcnRlZDtcbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkO1xuICB9XG4gIGdldCBjb250ZW50TGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZW50TGVuZ3RoO1xuICB9XG4gIGdldCBoZWFkZXJzUmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBhd2FpdCB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIGlmICh0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5fc3RvcmVkRXJyb3I7XG4gICAgfVxuICAgIGlmICh0aGlzLl9jYWNoZWRDaHVua3MubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9jYWNoZWRDaHVua3Muc2hpZnQoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdm9pZCAwLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuX3JlcXVlc3RzLnB1c2gocmVxdWVzdENhcGFiaWxpdHkpO1xuICAgIHJldHVybiByZXF1ZXN0Q2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZWplY3QocmVhc29uKTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHZvaWQgMCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgaWYgKHRoaXMuX21hbmFnZXIuaXNQZW5kaW5nUmVxdWVzdCh0aGlzLl9mdWxsUmVxdWVzdElkKSkge1xuICAgICAgdGhpcy5fbWFuYWdlci5hYm9ydFJlcXVlc3QodGhpcy5fZnVsbFJlcXVlc3RJZCk7XG4gICAgfVxuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbnVsbDtcbiAgfVxufVxuY2xhc3MgUERGTmV0d29ya1N0cmVhbVJhbmdlUmVxdWVzdFJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIsIGJlZ2luLCBlbmQpIHtcbiAgICB0aGlzLl9tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICB0aGlzLl91cmwgPSBtYW5hZ2VyLnVybDtcbiAgICB0aGlzLl9yZXF1ZXN0SWQgPSBtYW5hZ2VyLnJlcXVlc3Qoe1xuICAgICAgYmVnaW4sXG4gICAgICBlbmQsXG4gICAgICBvbkhlYWRlcnNSZWNlaXZlZDogdGhpcy5fb25IZWFkZXJzUmVjZWl2ZWQuYmluZCh0aGlzKSxcbiAgICAgIG9uRG9uZTogdGhpcy5fb25Eb25lLmJpbmQodGhpcyksXG4gICAgICBvbkVycm9yOiB0aGlzLl9vbkVycm9yLmJpbmQodGhpcyksXG4gICAgICBvblByb2dyZXNzOiB0aGlzLl9vblByb2dyZXNzLmJpbmQodGhpcylcbiAgICB9KTtcbiAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMuX3F1ZXVlZENodW5rID0gbnVsbDtcbiAgICB0aGlzLl9kb25lID0gZmFsc2U7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSB2b2lkIDA7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgICB0aGlzLm9uQ2xvc2VkID0gbnVsbDtcbiAgfVxuICBfb25IZWFkZXJzUmVjZWl2ZWQoKSB7XG4gICAgY29uc3QgcmVzcG9uc2VPcmlnaW4gPSBnZXRSZXNwb25zZU9yaWdpbih0aGlzLl9tYW5hZ2VyLmdldFJlcXVlc3RYaHIodGhpcy5fcmVxdWVzdElkKT8ucmVzcG9uc2VVUkwpO1xuICAgIGlmIChyZXNwb25zZU9yaWdpbiAhPT0gdGhpcy5fbWFuYWdlci5fcmVzcG9uc2VPcmlnaW4pIHtcbiAgICAgIHRoaXMuX3N0b3JlZEVycm9yID0gbmV3IEVycm9yKGBFeHBlY3RlZCByYW5nZSByZXNwb25zZS1vcmlnaW4gXCIke3Jlc3BvbnNlT3JpZ2lufVwiIHRvIG1hdGNoIFwiJHt0aGlzLl9tYW5hZ2VyLl9yZXNwb25zZU9yaWdpbn1cIi5gKTtcbiAgICAgIHRoaXMuX29uRXJyb3IoMCk7XG4gICAgfVxuICB9XG4gIF9jbG9zZSgpIHtcbiAgICB0aGlzLm9uQ2xvc2VkPy4odGhpcyk7XG4gIH1cbiAgX29uRG9uZShkYXRhKSB7XG4gICAgY29uc3QgY2h1bmsgPSBkYXRhLmNodW5rO1xuICAgIGlmICh0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IHRoaXMuX3JlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rID0gY2h1bms7XG4gICAgfVxuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdm9pZCAwLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9jbG9zZSgpO1xuICB9XG4gIF9vbkVycm9yKHN0YXR1cykge1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID8/PSBjcmVhdGVSZXNwb25zZUVycm9yKHN0YXR1cywgdGhpcy5fdXJsKTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZWplY3QodGhpcy5fc3RvcmVkRXJyb3IpO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX3F1ZXVlZENodW5rID0gbnVsbDtcbiAgfVxuICBfb25Qcm9ncmVzcyhldnQpIHtcbiAgICBpZiAoIXRoaXMuaXNTdHJlYW1pbmdTdXBwb3J0ZWQpIHtcbiAgICAgIHRoaXMub25Qcm9ncmVzcz8uKHtcbiAgICAgICAgbG9hZGVkOiBldnQubG9hZGVkXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGlmICh0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5fc3RvcmVkRXJyb3I7XG4gICAgfVxuICAgIGlmICh0aGlzLl9xdWV1ZWRDaHVuayAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9xdWV1ZWRDaHVuaztcbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rID0gbnVsbDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdm9pZCAwLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuX3JlcXVlc3RzLnB1c2gocmVxdWVzdENhcGFiaWxpdHkpO1xuICAgIHJldHVybiByZXF1ZXN0Q2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHZvaWQgMCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgaWYgKHRoaXMuX21hbmFnZXIuaXNQZW5kaW5nUmVxdWVzdCh0aGlzLl9yZXF1ZXN0SWQpKSB7XG4gICAgICB0aGlzLl9tYW5hZ2VyLmFib3J0UmVxdWVzdCh0aGlzLl9yZXF1ZXN0SWQpO1xuICAgIH1cbiAgICB0aGlzLl9jbG9zZSgpO1xuICB9XG59XG5jb25zdCB1cmxSZWdleCA9IC9eW2Etel1bYS16MC05XFwtKy5dKzovaTtcbmZ1bmN0aW9uIHBhcnNlVXJsT3JQYXRoKHNvdXJjZVVybCkge1xuICBpZiAodXJsUmVnZXgudGVzdChzb3VyY2VVcmwpKSB7XG4gICAgcmV0dXJuIG5ldyBVUkwoc291cmNlVXJsKTtcbiAgfVxuICBjb25zdCB1cmwgPSBwcm9jZXNzLmdldEJ1aWx0aW5Nb2R1bGUoXCJ1cmxcIik7XG4gIHJldHVybiBuZXcgVVJMKHVybC5wYXRoVG9GaWxlVVJMKHNvdXJjZVVybCkpO1xufVxuY2xhc3MgUERGTm9kZVN0cmVhbSB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMudXJsID0gcGFyc2VVcmxPclBhdGgoc291cmNlLnVybCk7XG4gICAgYXNzZXJ0KHRoaXMudXJsLnByb3RvY29sID09PSBcImZpbGU6XCIsIFwiUERGTm9kZVN0cmVhbSBvbmx5IHN1cHBvcnRzIGZpbGU6Ly8gVVJMcy5cIik7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMgPSBbXTtcbiAgfVxuICBnZXQgX3Byb2dyZXNzaXZlRGF0YUxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/Ll9sb2FkZWQgPz8gMDtcbiAgfVxuICBnZXRGdWxsUmVhZGVyKCkge1xuICAgIGFzc2VydCghdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIsIFwiUERGTm9kZVN0cmVhbS5nZXRGdWxsUmVhZGVyIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLlwiKTtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG5ldyBQREZOb2RlU3RyZWFtRnNGdWxsUmVhZGVyKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcjtcbiAgfVxuICBnZXRSYW5nZVJlYWRlcihzdGFydCwgZW5kKSB7XG4gICAgaWYgKGVuZCA8PSB0aGlzLl9wcm9ncmVzc2l2ZURhdGFMZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByYW5nZVJlYWRlciA9IG5ldyBQREZOb2RlU3RyZWFtRnNSYW5nZVJlYWRlcih0aGlzLCBzdGFydCwgZW5kKTtcbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnB1c2gocmFuZ2VSZWFkZXIpO1xuICAgIHJldHVybiByYW5nZVJlYWRlcjtcbiAgfVxuICBjYW5jZWxBbGxSZXF1ZXN0cyhyZWFzb24pIHtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8uY2FuY2VsKHJlYXNvbik7XG4gICAgZm9yIChjb25zdCByZWFkZXIgb2YgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5zbGljZSgwKSkge1xuICAgICAgcmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgUERGTm9kZVN0cmVhbUZzRnVsbFJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuICAgIHRoaXMuX3VybCA9IHN0cmVhbS51cmw7XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gbnVsbDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmVhbS5zb3VyY2U7XG4gICAgdGhpcy5fY29udGVudExlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgdGhpcy5fbG9hZGVkID0gMDtcbiAgICB0aGlzLl9maWxlbmFtZSA9IG51bGw7XG4gICAgdGhpcy5fZGlzYWJsZVJhbmdlID0gc291cmNlLmRpc2FibGVSYW5nZSB8fCBmYWxzZTtcbiAgICB0aGlzLl9yYW5nZUNodW5rU2l6ZSA9IHNvdXJjZS5yYW5nZUNodW5rU2l6ZTtcbiAgICBpZiAoIXRoaXMuX3JhbmdlQ2h1bmtTaXplICYmICF0aGlzLl9kaXNhYmxlUmFuZ2UpIHtcbiAgICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlU3RyZWFtO1xuICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVSYW5nZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbSA9IG51bGw7XG4gICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIGNvbnN0IGZzID0gcHJvY2Vzcy5nZXRCdWlsdGluTW9kdWxlKFwiZnNcIik7XG4gICAgZnMucHJvbWlzZXMubHN0YXQodGhpcy5fdXJsKS50aGVuKChzdGF0KSA9PiB7XG4gICAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc3RhdC5zaXplO1xuICAgICAgdGhpcy5fc2V0UmVhZGFibGVTdHJlYW0oZnMuY3JlYXRlUmVhZFN0cmVhbSh0aGlzLl91cmwpKTtcbiAgICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgIGlmIChlcnJvci5jb2RlID09PSBcIkVOT0VOVFwiKSB7XG4gICAgICAgIGVycm9yID0gY3JlYXRlUmVzcG9uc2VFcnJvcigwLCB0aGlzLl91cmwuaHJlZik7XG4gICAgICB9XG4gICAgICB0aGlzLl9zdG9yZWRFcnJvciA9IGVycm9yO1xuICAgICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVqZWN0KGVycm9yKTtcbiAgICB9KTtcbiAgfVxuICBnZXQgaGVhZGVyc1JlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGdldCBmaWxlbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZW5hbWU7XG4gIH1cbiAgZ2V0IGNvbnRlbnRMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRlbnRMZW5ndGg7XG4gIH1cbiAgZ2V0IGlzUmFuZ2VTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQ7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGF3YWl0IHRoaXMuX3JlYWRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB2b2lkIDAsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5fc3RvcmVkRXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGNodW5rID0gdGhpcy5fcmVhZGFibGVTdHJlYW0ucmVhZCgpO1xuICAgIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICAgIHJldHVybiB0aGlzLnJlYWQoKTtcbiAgICB9XG4gICAgdGhpcy5fbG9hZGVkICs9IGNodW5rLmxlbmd0aDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICBsb2FkZWQ6IHRoaXMuX2xvYWRlZCxcbiAgICAgIHRvdGFsOiB0aGlzLl9jb250ZW50TGVuZ3RoXG4gICAgfSk7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmspLmJ1ZmZlcjtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGJ1ZmZlcixcbiAgICAgIGRvbmU6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0cmVhbSkge1xuICAgICAgdGhpcy5fZXJyb3IocmVhc29uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0uZGVzdHJveShyZWFzb24pO1xuICB9XG4gIF9lcnJvcihyZWFzb24pIHtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IHJlYXNvbjtcbiAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gIH1cbiAgX3NldFJlYWRhYmxlU3RyZWFtKHJlYWRhYmxlU3RyZWFtKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0gPSByZWFkYWJsZVN0cmVhbTtcbiAgICByZWFkYWJsZVN0cmVhbS5vbihcInJlYWRhYmxlXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9KTtcbiAgICByZWFkYWJsZVN0cmVhbS5vbihcImVuZFwiLCAoKSA9PiB7XG4gICAgICByZWFkYWJsZVN0cmVhbS5kZXN0cm95KCk7XG4gICAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9KTtcbiAgICByZWFkYWJsZVN0cmVhbS5vbihcImVycm9yXCIsIChyZWFzb24pID0+IHtcbiAgICAgIHRoaXMuX2Vycm9yKHJlYXNvbik7XG4gICAgfSk7XG4gICAgaWYgKCF0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCAmJiB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzLl9lcnJvcihuZXcgQWJvcnRFeGNlcHRpb24oXCJzdHJlYW1pbmcgaXMgZGlzYWJsZWRcIikpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtLmRlc3Ryb3kodGhpcy5fc3RvcmVkRXJyb3IpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgUERGTm9kZVN0cmVhbUZzUmFuZ2VSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0sIHN0YXJ0LCBlbmQpIHtcbiAgICB0aGlzLl91cmwgPSBzdHJlYW0udXJsO1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IG51bGw7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgICB0aGlzLl9sb2FkZWQgPSAwO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtID0gbnVsbDtcbiAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmVhbS5zb3VyY2U7XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVTdHJlYW07XG4gICAgY29uc3QgZnMgPSBwcm9jZXNzLmdldEJ1aWx0aW5Nb2R1bGUoXCJmc1wiKTtcbiAgICB0aGlzLl9zZXRSZWFkYWJsZVN0cmVhbShmcy5jcmVhdGVSZWFkU3RyZWFtKHRoaXMuX3VybCwge1xuICAgICAgc3RhcnQsXG4gICAgICBlbmQ6IGVuZCAtIDFcbiAgICB9KSk7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGF3YWl0IHRoaXMuX3JlYWRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB2b2lkIDAsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5fc3RvcmVkRXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGNodW5rID0gdGhpcy5fcmVhZGFibGVTdHJlYW0ucmVhZCgpO1xuICAgIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICAgIHJldHVybiB0aGlzLnJlYWQoKTtcbiAgICB9XG4gICAgdGhpcy5fbG9hZGVkICs9IGNodW5rLmxlbmd0aDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICBsb2FkZWQ6IHRoaXMuX2xvYWRlZFxuICAgIH0pO1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGNodW5rKS5idWZmZXI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBidWZmZXIsXG4gICAgICBkb25lOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdHJlYW0pIHtcbiAgICAgIHRoaXMuX2Vycm9yKHJlYXNvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtLmRlc3Ryb3kocmVhc29uKTtcbiAgfVxuICBfZXJyb3IocmVhc29uKSB7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSByZWFzb247XG4gICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICB9XG4gIF9zZXRSZWFkYWJsZVN0cmVhbShyZWFkYWJsZVN0cmVhbSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtID0gcmVhZGFibGVTdHJlYW07XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJyZWFkYWJsZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSk7XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJlbmRcIiwgKCkgPT4ge1xuICAgICAgcmVhZGFibGVTdHJlYW0uZGVzdHJveSgpO1xuICAgICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSk7XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJlcnJvclwiLCAocmVhc29uKSA9PiB7XG4gICAgICB0aGlzLl9lcnJvcihyZWFzb24pO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgdGhpcy5fcmVhZGFibGVTdHJlYW0uZGVzdHJveSh0aGlzLl9zdG9yZWRFcnJvcik7XG4gICAgfVxuICB9XG59XG5jb25zdCBJTklUSUFMX0RBVEEgPSBTeW1ib2woXCJJTklUSUFMX0RBVEFcIik7XG5jbGFzcyBQREZPYmplY3RzIHtcbiAgI29ianMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgI2Vuc3VyZU9iaihvYmpJZCkge1xuICAgIHJldHVybiB0aGlzLiNvYmpzW29iaklkXSB8fD0ge1xuICAgICAgLi4uUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCksXG4gICAgICBkYXRhOiBJTklUSUFMX0RBVEFcbiAgICB9O1xuICB9XG4gIGdldChvYmpJZCwgY2FsbGJhY2sgPSBudWxsKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjb25zdCBvYmoyID0gdGhpcy4jZW5zdXJlT2JqKG9iaklkKTtcbiAgICAgIG9iajIucHJvbWlzZS50aGVuKCgpID0+IGNhbGxiYWNrKG9iajIuZGF0YSkpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG9iaiA9IHRoaXMuI29ianNbb2JqSWRdO1xuICAgIGlmICghb2JqIHx8IG9iai5kYXRhID09PSBJTklUSUFMX0RBVEEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUmVxdWVzdGluZyBvYmplY3QgdGhhdCBpc24ndCByZXNvbHZlZCB5ZXQgJHtvYmpJZH0uYCk7XG4gICAgfVxuICAgIHJldHVybiBvYmouZGF0YTtcbiAgfVxuICBoYXMob2JqSWQpIHtcbiAgICBjb25zdCBvYmogPSB0aGlzLiNvYmpzW29iaklkXTtcbiAgICByZXR1cm4gISFvYmogJiYgb2JqLmRhdGEgIT09IElOSVRJQUxfREFUQTtcbiAgfVxuICBkZWxldGUob2JqSWQpIHtcbiAgICBjb25zdCBvYmogPSB0aGlzLiNvYmpzW29iaklkXTtcbiAgICBpZiAoIW9iaiB8fCBvYmouZGF0YSA9PT0gSU5JVElBTF9EQVRBKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLiNvYmpzW29iaklkXTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXNvbHZlKG9iaklkLCBkYXRhID0gbnVsbCkge1xuICAgIGNvbnN0IG9iaiA9IHRoaXMuI2Vuc3VyZU9iaihvYmpJZCk7XG4gICAgb2JqLmRhdGEgPSBkYXRhO1xuICAgIG9iai5yZXNvbHZlKCk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgZm9yIChjb25zdCBvYmpJZCBpbiB0aGlzLiNvYmpzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGFcbiAgICAgIH0gPSB0aGlzLiNvYmpzW29iaklkXTtcbiAgICAgIGRhdGE/LmJpdG1hcD8uY2xvc2UoKTtcbiAgICB9XG4gICAgdGhpcy4jb2JqcyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICBmb3IgKGNvbnN0IG9iaklkIGluIHRoaXMuI29ianMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YVxuICAgICAgfSA9IHRoaXMuI29ianNbb2JqSWRdO1xuICAgICAgaWYgKGRhdGEgPT09IElOSVRJQUxfREFUQSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHlpZWxkIFtvYmpJZCwgZGF0YV07XG4gICAgfVxuICB9XG59XG5jb25zdCBNQVhfVEVYVF9ESVZTX1RPX1JFTkRFUiA9IDFlNTtcbmNvbnN0IERFRkFVTFRfRk9OVF9TSVpFID0gMzA7XG5jbGFzcyBUZXh0TGF5ZXIge1xuICAjY2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAjY29udGFpbmVyID0gbnVsbDtcbiAgI2Rpc2FibGVQcm9jZXNzSXRlbXMgPSBmYWxzZTtcbiAgI2ZvbnRJbnNwZWN0b3JFbmFibGVkID0gISFnbG9iYWxUaGlzLkZvbnRJbnNwZWN0b3I/LmVuYWJsZWQ7XG4gICNsYW5nID0gbnVsbDtcbiAgI2xheW91dFRleHRQYXJhbXMgPSBudWxsO1xuICAjcGFnZUhlaWdodCA9IDA7XG4gICNwYWdlV2lkdGggPSAwO1xuICAjcmVhZGVyID0gbnVsbDtcbiAgI3Jvb3RDb250YWluZXIgPSBudWxsO1xuICAjcm90YXRpb24gPSAwO1xuICAjc2NhbGUgPSAwO1xuICAjc3R5bGVDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAjdGV4dENvbnRlbnRJdGVtc1N0ciA9IFtdO1xuICAjdGV4dENvbnRlbnRTb3VyY2UgPSBudWxsO1xuICAjdGV4dERpdnMgPSBbXTtcbiAgI3RleHREaXZQcm9wZXJ0aWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gICN0cmFuc2Zvcm0gPSBudWxsO1xuICBzdGF0aWMgI2FzY2VudENhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgc3RhdGljICNjYW52YXNDb250ZXh0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHN0YXRpYyAjY2FudmFzQ3R4Rm9udHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgc3RhdGljICNtaW5Gb250U2l6ZSA9IG51bGw7XG4gIHN0YXRpYyAjcGVuZGluZ1RleHRMYXllcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdGV4dENvbnRlbnRTb3VyY2UsXG4gICAgY29udGFpbmVyLFxuICAgIHZpZXdwb3J0XG4gIH0pIHtcbiAgICBpZiAodGV4dENvbnRlbnRTb3VyY2UgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbSkge1xuICAgICAgdGhpcy4jdGV4dENvbnRlbnRTb3VyY2UgPSB0ZXh0Q29udGVudFNvdXJjZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0ZXh0Q29udGVudFNvdXJjZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgdGhpcy4jdGV4dENvbnRlbnRTb3VyY2UgPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRleHRDb250ZW50U291cmNlKTtcbiAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFwidGV4dENvbnRlbnRTb3VyY2VcIiBwYXJhbWV0ZXIgc3BlY2lmaWVkLicpO1xuICAgIH1cbiAgICB0aGlzLiNjb250YWluZXIgPSB0aGlzLiNyb290Q29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuI3NjYWxlID0gdmlld3BvcnQuc2NhbGUgKiBPdXRwdXRTY2FsZS5waXhlbFJhdGlvO1xuICAgIHRoaXMuI3JvdGF0aW9uID0gdmlld3BvcnQucm90YXRpb247XG4gICAgdGhpcy4jbGF5b3V0VGV4dFBhcmFtcyA9IHtcbiAgICAgIGRpdjogbnVsbCxcbiAgICAgIHByb3BlcnRpZXM6IG51bGwsXG4gICAgICBjdHg6IG51bGxcbiAgICB9O1xuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2VXaWR0aCxcbiAgICAgIHBhZ2VIZWlnaHQsXG4gICAgICBwYWdlWCxcbiAgICAgIHBhZ2VZXG4gICAgfSA9IHZpZXdwb3J0LnJhd0RpbXM7XG4gICAgdGhpcy4jdHJhbnNmb3JtID0gWzEsIDAsIDAsIC0xLCAtcGFnZVgsIHBhZ2VZICsgcGFnZUhlaWdodF07XG4gICAgdGhpcy4jcGFnZVdpZHRoID0gcGFnZVdpZHRoO1xuICAgIHRoaXMuI3BhZ2VIZWlnaHQgPSBwYWdlSGVpZ2h0O1xuICAgIFRleHRMYXllci4jZW5zdXJlTWluRm9udFNpemVDb21wdXRlZCgpO1xuICAgIHNldExheWVyRGltZW5zaW9ucyhjb250YWluZXIsIHZpZXdwb3J0KTtcbiAgICB0aGlzLiNjYXBhYmlsaXR5LnByb21pc2UuZmluYWxseSgoKSA9PiB7XG4gICAgICBUZXh0TGF5ZXIuI3BlbmRpbmdUZXh0TGF5ZXJzLmRlbGV0ZSh0aGlzKTtcbiAgICAgIHRoaXMuI2xheW91dFRleHRQYXJhbXMgPSBudWxsO1xuICAgICAgdGhpcy4jc3R5bGVDYWNoZSA9IG51bGw7XG4gICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXQgZm9udEZhbWlseU1hcCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBpc1dpbmRvd3MsXG4gICAgICBpc0ZpcmVmb3hcbiAgICB9ID0gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiZm9udEZhbWlseU1hcFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbW1wic2Fucy1zZXJpZlwiLCBgJHtpc1dpbmRvd3MgJiYgaXNGaXJlZm94ID8gXCJDYWxpYnJpLCBcIiA6IFwiXCJ9c2Fucy1zZXJpZmBdLCBbXCJtb25vc3BhY2VcIiwgYCR7aXNXaW5kb3dzICYmIGlzRmlyZWZveCA/IFwiTHVjaWRhIENvbnNvbGUsIFwiIDogXCJcIn1tb25vc3BhY2VgXV0pKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgcHVtcCA9ICgpID0+IHtcbiAgICAgIHRoaXMuI3JlYWRlci5yZWFkKCkudGhlbigoe1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZG9uZVxuICAgICAgfSkgPT4ge1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIHRoaXMuI2NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNsYW5nID8/PSB2YWx1ZS5sYW5nO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuI3N0eWxlQ2FjaGUsIHZhbHVlLnN0eWxlcyk7XG4gICAgICAgIHRoaXMuI3Byb2Nlc3NJdGVtcyh2YWx1ZS5pdGVtcyk7XG4gICAgICAgIHB1bXAoKTtcbiAgICAgIH0sIHRoaXMuI2NhcGFiaWxpdHkucmVqZWN0KTtcbiAgICB9O1xuICAgIHRoaXMuI3JlYWRlciA9IHRoaXMuI3RleHRDb250ZW50U291cmNlLmdldFJlYWRlcigpO1xuICAgIFRleHRMYXllci4jcGVuZGluZ1RleHRMYXllcnMuYWRkKHRoaXMpO1xuICAgIHB1bXAoKTtcbiAgICByZXR1cm4gdGhpcy4jY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIHVwZGF0ZSh7XG4gICAgdmlld3BvcnQsXG4gICAgb25CZWZvcmUgPSBudWxsXG4gIH0pIHtcbiAgICBjb25zdCBzY2FsZSA9IHZpZXdwb3J0LnNjYWxlICogT3V0cHV0U2NhbGUucGl4ZWxSYXRpbztcbiAgICBjb25zdCByb3RhdGlvbiA9IHZpZXdwb3J0LnJvdGF0aW9uO1xuICAgIGlmIChyb3RhdGlvbiAhPT0gdGhpcy4jcm90YXRpb24pIHtcbiAgICAgIG9uQmVmb3JlPy4oKTtcbiAgICAgIHRoaXMuI3JvdGF0aW9uID0gcm90YXRpb247XG4gICAgICBzZXRMYXllckRpbWVuc2lvbnModGhpcy4jcm9vdENvbnRhaW5lciwge1xuICAgICAgICByb3RhdGlvblxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzY2FsZSAhPT0gdGhpcy4jc2NhbGUpIHtcbiAgICAgIG9uQmVmb3JlPy4oKTtcbiAgICAgIHRoaXMuI3NjYWxlID0gc2NhbGU7XG4gICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgIGRpdjogbnVsbCxcbiAgICAgICAgcHJvcGVydGllczogbnVsbCxcbiAgICAgICAgY3R4OiBUZXh0TGF5ZXIuI2dldEN0eCh0aGlzLiNsYW5nKVxuICAgICAgfTtcbiAgICAgIGZvciAoY29uc3QgZGl2IG9mIHRoaXMuI3RleHREaXZzKSB7XG4gICAgICAgIHBhcmFtcy5wcm9wZXJ0aWVzID0gdGhpcy4jdGV4dERpdlByb3BlcnRpZXMuZ2V0KGRpdik7XG4gICAgICAgIHBhcmFtcy5kaXYgPSBkaXY7XG4gICAgICAgIHRoaXMuI2xheW91dChwYXJhbXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjYW5jZWwoKSB7XG4gICAgY29uc3QgYWJvcnRFeCA9IG5ldyBBYm9ydEV4Y2VwdGlvbihcIlRleHRMYXllciB0YXNrIGNhbmNlbGxlZC5cIik7XG4gICAgdGhpcy4jcmVhZGVyPy5jYW5jZWwoYWJvcnRFeCkuY2F0Y2goKCkgPT4ge1xuICAgIH0pO1xuICAgIHRoaXMuI3JlYWRlciA9IG51bGw7XG4gICAgdGhpcy4jY2FwYWJpbGl0eS5yZWplY3QoYWJvcnRFeCk7XG4gIH1cbiAgZ2V0IHRleHREaXZzKCkge1xuICAgIHJldHVybiB0aGlzLiN0ZXh0RGl2cztcbiAgfVxuICBnZXQgdGV4dENvbnRlbnRJdGVtc1N0cigpIHtcbiAgICByZXR1cm4gdGhpcy4jdGV4dENvbnRlbnRJdGVtc1N0cjtcbiAgfVxuICAjcHJvY2Vzc0l0ZW1zKGl0ZW1zKSB7XG4gICAgaWYgKHRoaXMuI2Rpc2FibGVQcm9jZXNzSXRlbXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jbGF5b3V0VGV4dFBhcmFtcy5jdHggPz89IFRleHRMYXllci4jZ2V0Q3R4KHRoaXMuI2xhbmcpO1xuICAgIGNvbnN0IHRleHREaXZzID0gdGhpcy4jdGV4dERpdnMsIHRleHRDb250ZW50SXRlbXNTdHIgPSB0aGlzLiN0ZXh0Q29udGVudEl0ZW1zU3RyO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgaWYgKHRleHREaXZzLmxlbmd0aCA+IE1BWF9URVhUX0RJVlNfVE9fUkVOREVSKSB7XG4gICAgICAgIHdhcm4oXCJJZ25vcmluZyBhZGRpdGlvbmFsIHRleHREaXZzIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLlwiKTtcbiAgICAgICAgdGhpcy4jZGlzYWJsZVByb2Nlc3NJdGVtcyA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtLnN0ciA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlmIChpdGVtLnR5cGUgPT09IFwiYmVnaW5NYXJrZWRDb250ZW50UHJvcHNcIiB8fCBpdGVtLnR5cGUgPT09IFwiYmVnaW5NYXJrZWRDb250ZW50XCIpIHtcbiAgICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLiNjb250YWluZXI7XG4gICAgICAgICAgdGhpcy4jY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgdGhpcy4jY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJtYXJrZWRDb250ZW50XCIpO1xuICAgICAgICAgIGlmIChpdGVtLmlkKSB7XG4gICAgICAgICAgICB0aGlzLiNjb250YWluZXIuc2V0QXR0cmlidXRlKFwiaWRcIiwgYCR7aXRlbS5pZH1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyZW50LmFwcGVuZCh0aGlzLiNjb250YWluZXIpO1xuICAgICAgICB9IGVsc2UgaWYgKGl0ZW0udHlwZSA9PT0gXCJlbmRNYXJrZWRDb250ZW50XCIpIHtcbiAgICAgICAgICB0aGlzLiNjb250YWluZXIgPSB0aGlzLiNjb250YWluZXIucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRleHRDb250ZW50SXRlbXNTdHIucHVzaChpdGVtLnN0cik7XG4gICAgICB0aGlzLiNhcHBlbmRUZXh0KGl0ZW0pO1xuICAgIH1cbiAgfVxuICAjYXBwZW5kVGV4dChnZW9tKSB7XG4gICAgY29uc3QgdGV4dERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIGNvbnN0IHRleHREaXZQcm9wZXJ0aWVzID0ge1xuICAgICAgYW5nbGU6IDAsXG4gICAgICBjYW52YXNXaWR0aDogMCxcbiAgICAgIGhhc1RleHQ6IGdlb20uc3RyICE9PSBcIlwiLFxuICAgICAgaGFzRU9MOiBnZW9tLmhhc0VPTCxcbiAgICAgIGZvbnRTaXplOiAwXG4gICAgfTtcbiAgICB0aGlzLiN0ZXh0RGl2cy5wdXNoKHRleHREaXYpO1xuICAgIGNvbnN0IHR4ID0gVXRpbC50cmFuc2Zvcm0odGhpcy4jdHJhbnNmb3JtLCBnZW9tLnRyYW5zZm9ybSk7XG4gICAgbGV0IGFuZ2xlID0gTWF0aC5hdGFuMih0eFsxXSwgdHhbMF0pO1xuICAgIGNvbnN0IHN0eWxlID0gdGhpcy4jc3R5bGVDYWNoZVtnZW9tLmZvbnROYW1lXTtcbiAgICBpZiAoc3R5bGUudmVydGljYWwpIHtcbiAgICAgIGFuZ2xlICs9IE1hdGguUEkgLyAyO1xuICAgIH1cbiAgICBsZXQgZm9udEZhbWlseSA9IHRoaXMuI2ZvbnRJbnNwZWN0b3JFbmFibGVkICYmIHN0eWxlLmZvbnRTdWJzdGl0dXRpb24gfHwgc3R5bGUuZm9udEZhbWlseTtcbiAgICBmb250RmFtaWx5ID0gVGV4dExheWVyLmZvbnRGYW1pbHlNYXAuZ2V0KGZvbnRGYW1pbHkpIHx8IGZvbnRGYW1pbHk7XG4gICAgY29uc3QgZm9udEhlaWdodCA9IE1hdGguaHlwb3QodHhbMl0sIHR4WzNdKTtcbiAgICBjb25zdCBmb250QXNjZW50ID0gZm9udEhlaWdodCAqIFRleHRMYXllci4jZ2V0QXNjZW50KGZvbnRGYW1pbHksIHN0eWxlLCB0aGlzLiNsYW5nKTtcbiAgICBsZXQgbGVmdCwgdG9wO1xuICAgIGlmIChhbmdsZSA9PT0gMCkge1xuICAgICAgbGVmdCA9IHR4WzRdO1xuICAgICAgdG9wID0gdHhbNV0gLSBmb250QXNjZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBsZWZ0ID0gdHhbNF0gKyBmb250QXNjZW50ICogTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgdG9wID0gdHhbNV0gLSBmb250QXNjZW50ICogTWF0aC5jb3MoYW5nbGUpO1xuICAgIH1cbiAgICBjb25zdCBzY2FsZUZhY3RvclN0ciA9IFwiY2FsYyh2YXIoLS10b3RhbC1zY2FsZS1mYWN0b3IpICpcIjtcbiAgICBjb25zdCBkaXZTdHlsZSA9IHRleHREaXYuc3R5bGU7XG4gICAgaWYgKHRoaXMuI2NvbnRhaW5lciA9PT0gdGhpcy4jcm9vdENvbnRhaW5lcikge1xuICAgICAgZGl2U3R5bGUubGVmdCA9IGAkeygxMDAgKiBsZWZ0IC8gdGhpcy4jcGFnZVdpZHRoKS50b0ZpeGVkKDIpfSVgO1xuICAgICAgZGl2U3R5bGUudG9wID0gYCR7KDEwMCAqIHRvcCAvIHRoaXMuI3BhZ2VIZWlnaHQpLnRvRml4ZWQoMil9JWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpdlN0eWxlLmxlZnQgPSBgJHtzY2FsZUZhY3RvclN0cn0ke2xlZnQudG9GaXhlZCgyKX1weClgO1xuICAgICAgZGl2U3R5bGUudG9wID0gYCR7c2NhbGVGYWN0b3JTdHJ9JHt0b3AudG9GaXhlZCgyKX1weClgO1xuICAgIH1cbiAgICBkaXZTdHlsZS5mb250U2l6ZSA9IGAke3NjYWxlRmFjdG9yU3RyfSR7KFRleHRMYXllci4jbWluRm9udFNpemUgKiBmb250SGVpZ2h0KS50b0ZpeGVkKDIpfXB4KWA7XG4gICAgZGl2U3R5bGUuZm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XG4gICAgdGV4dERpdlByb3BlcnRpZXMuZm9udFNpemUgPSBmb250SGVpZ2h0O1xuICAgIHRleHREaXYuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInByZXNlbnRhdGlvblwiKTtcbiAgICB0ZXh0RGl2LnRleHRDb250ZW50ID0gZ2VvbS5zdHI7XG4gICAgdGV4dERpdi5kaXIgPSBnZW9tLmRpcjtcbiAgICBpZiAodGhpcy4jZm9udEluc3BlY3RvckVuYWJsZWQpIHtcbiAgICAgIHRleHREaXYuZGF0YXNldC5mb250TmFtZSA9IHN0eWxlLmZvbnRTdWJzdGl0dXRpb25Mb2FkZWROYW1lIHx8IGdlb20uZm9udE5hbWU7XG4gICAgfVxuICAgIGlmIChhbmdsZSAhPT0gMCkge1xuICAgICAgdGV4dERpdlByb3BlcnRpZXMuYW5nbGUgPSBhbmdsZSAqICgxODAgLyBNYXRoLlBJKTtcbiAgICB9XG4gICAgbGV0IHNob3VsZFNjYWxlVGV4dCA9IGZhbHNlO1xuICAgIGlmIChnZW9tLnN0ci5sZW5ndGggPiAxKSB7XG4gICAgICBzaG91bGRTY2FsZVRleHQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZ2VvbS5zdHIgIT09IFwiIFwiICYmIGdlb20udHJhbnNmb3JtWzBdICE9PSBnZW9tLnRyYW5zZm9ybVszXSkge1xuICAgICAgY29uc3QgYWJzU2NhbGVYID0gTWF0aC5hYnMoZ2VvbS50cmFuc2Zvcm1bMF0pLCBhYnNTY2FsZVkgPSBNYXRoLmFicyhnZW9tLnRyYW5zZm9ybVszXSk7XG4gICAgICBpZiAoYWJzU2NhbGVYICE9PSBhYnNTY2FsZVkgJiYgTWF0aC5tYXgoYWJzU2NhbGVYLCBhYnNTY2FsZVkpIC8gTWF0aC5taW4oYWJzU2NhbGVYLCBhYnNTY2FsZVkpID4gMS41KSB7XG4gICAgICAgIHNob3VsZFNjYWxlVGV4dCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzaG91bGRTY2FsZVRleHQpIHtcbiAgICAgIHRleHREaXZQcm9wZXJ0aWVzLmNhbnZhc1dpZHRoID0gc3R5bGUudmVydGljYWwgPyBnZW9tLmhlaWdodCA6IGdlb20ud2lkdGg7XG4gICAgfVxuICAgIHRoaXMuI3RleHREaXZQcm9wZXJ0aWVzLnNldCh0ZXh0RGl2LCB0ZXh0RGl2UHJvcGVydGllcyk7XG4gICAgdGhpcy4jbGF5b3V0VGV4dFBhcmFtcy5kaXYgPSB0ZXh0RGl2O1xuICAgIHRoaXMuI2xheW91dFRleHRQYXJhbXMucHJvcGVydGllcyA9IHRleHREaXZQcm9wZXJ0aWVzO1xuICAgIHRoaXMuI2xheW91dCh0aGlzLiNsYXlvdXRUZXh0UGFyYW1zKTtcbiAgICBpZiAodGV4dERpdlByb3BlcnRpZXMuaGFzVGV4dCkge1xuICAgICAgdGhpcy4jY29udGFpbmVyLmFwcGVuZCh0ZXh0RGl2KTtcbiAgICB9XG4gICAgaWYgKHRleHREaXZQcm9wZXJ0aWVzLmhhc0VPTCkge1xuICAgICAgY29uc3QgYnIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIik7XG4gICAgICBici5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwicHJlc2VudGF0aW9uXCIpO1xuICAgICAgdGhpcy4jY29udGFpbmVyLmFwcGVuZChicik7XG4gICAgfVxuICB9XG4gICNsYXlvdXQocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGl2LFxuICAgICAgcHJvcGVydGllcyxcbiAgICAgIGN0eFxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gZGl2O1xuICAgIGxldCB0cmFuc2Zvcm0gPSBcIlwiO1xuICAgIGlmIChUZXh0TGF5ZXIuI21pbkZvbnRTaXplID4gMSkge1xuICAgICAgdHJhbnNmb3JtID0gYHNjYWxlKCR7MSAvIFRleHRMYXllci4jbWluRm9udFNpemV9KWA7XG4gICAgfVxuICAgIGlmIChwcm9wZXJ0aWVzLmNhbnZhc1dpZHRoICE9PSAwICYmIHByb3BlcnRpZXMuaGFzVGV4dCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBmb250RmFtaWx5XG4gICAgICB9ID0gc3R5bGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNhbnZhc1dpZHRoLFxuICAgICAgICBmb250U2l6ZVxuICAgICAgfSA9IHByb3BlcnRpZXM7XG4gICAgICBUZXh0TGF5ZXIuI2Vuc3VyZUN0eEZvbnQoY3R4LCBmb250U2l6ZSAqIHRoaXMuI3NjYWxlLCBmb250RmFtaWx5KTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgd2lkdGhcbiAgICAgIH0gPSBjdHgubWVhc3VyZVRleHQoZGl2LnRleHRDb250ZW50KTtcbiAgICAgIGlmICh3aWR0aCA+IDApIHtcbiAgICAgICAgdHJhbnNmb3JtID0gYHNjYWxlWCgke2NhbnZhc1dpZHRoICogdGhpcy4jc2NhbGUgLyB3aWR0aH0pICR7dHJhbnNmb3JtfWA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wZXJ0aWVzLmFuZ2xlICE9PSAwKSB7XG4gICAgICB0cmFuc2Zvcm0gPSBgcm90YXRlKCR7cHJvcGVydGllcy5hbmdsZX1kZWcpICR7dHJhbnNmb3JtfWA7XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm0ubGVuZ3RoID4gMCkge1xuICAgICAgc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgY2xlYW51cCgpIHtcbiAgICBpZiAodGhpcy4jcGVuZGluZ1RleHRMYXllcnMuc2l6ZSA+IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYXNjZW50Q2FjaGUuY2xlYXIoKTtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIGNhbnZhc1xuICAgIH0gb2YgdGhpcy4jY2FudmFzQ29udGV4dHMudmFsdWVzKCkpIHtcbiAgICAgIGNhbnZhcy5yZW1vdmUoKTtcbiAgICB9XG4gICAgdGhpcy4jY2FudmFzQ29udGV4dHMuY2xlYXIoKTtcbiAgfVxuICBzdGF0aWMgI2dldEN0eChsYW5nID0gbnVsbCkge1xuICAgIGxldCBjdHggPSB0aGlzLiNjYW52YXNDb250ZXh0cy5nZXQobGFuZyB8fD0gXCJcIik7XG4gICAgaWYgKCFjdHgpIHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICBjYW52YXMuY2xhc3NOYW1lID0gXCJoaWRkZW5DYW52YXNFbGVtZW50XCI7XG4gICAgICBjYW52YXMubGFuZyA9IGxhbmc7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZChjYW52YXMpO1xuICAgICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICAgIGFscGhhOiBmYWxzZSxcbiAgICAgICAgd2lsbFJlYWRGcmVxdWVudGx5OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuI2NhbnZhc0NvbnRleHRzLnNldChsYW5nLCBjdHgpO1xuICAgICAgdGhpcy4jY2FudmFzQ3R4Rm9udHMuc2V0KGN0eCwge1xuICAgICAgICBzaXplOiAwLFxuICAgICAgICBmYW1pbHk6IFwiXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY3R4O1xuICB9XG4gIHN0YXRpYyAjZW5zdXJlQ3R4Rm9udChjdHgsIHNpemUsIGZhbWlseSkge1xuICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuI2NhbnZhc0N0eEZvbnRzLmdldChjdHgpO1xuICAgIGlmIChzaXplID09PSBjYWNoZWQuc2l6ZSAmJiBmYW1pbHkgPT09IGNhY2hlZC5mYW1pbHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3R4LmZvbnQgPSBgJHtzaXplfXB4ICR7ZmFtaWx5fWA7XG4gICAgY2FjaGVkLnNpemUgPSBzaXplO1xuICAgIGNhY2hlZC5mYW1pbHkgPSBmYW1pbHk7XG4gIH1cbiAgc3RhdGljICNlbnN1cmVNaW5Gb250U2l6ZUNvbXB1dGVkKCkge1xuICAgIGlmICh0aGlzLiNtaW5Gb250U2l6ZSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdi5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICBkaXYuc3R5bGUubGluZUhlaWdodCA9IDE7XG4gICAgZGl2LnN0eWxlLmZvbnRTaXplID0gXCIxcHhcIjtcbiAgICBkaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgZGl2LnRleHRDb250ZW50ID0gXCJYXCI7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmQoZGl2KTtcbiAgICB0aGlzLiNtaW5Gb250U2l6ZSA9IGRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgZGl2LnJlbW92ZSgpO1xuICB9XG4gIHN0YXRpYyAjZ2V0QXNjZW50KGZvbnRGYW1pbHksIHN0eWxlLCBsYW5nKSB7XG4gICAgY29uc3QgY2FjaGVkQXNjZW50ID0gdGhpcy4jYXNjZW50Q2FjaGUuZ2V0KGZvbnRGYW1pbHkpO1xuICAgIGlmIChjYWNoZWRBc2NlbnQpIHtcbiAgICAgIHJldHVybiBjYWNoZWRBc2NlbnQ7XG4gICAgfVxuICAgIGNvbnN0IGN0eCA9IHRoaXMuI2dldEN0eChsYW5nKTtcbiAgICBjdHguY2FudmFzLndpZHRoID0gY3R4LmNhbnZhcy5oZWlnaHQgPSBERUZBVUxUX0ZPTlRfU0laRTtcbiAgICB0aGlzLiNlbnN1cmVDdHhGb250KGN0eCwgREVGQVVMVF9GT05UX1NJWkUsIGZvbnRGYW1pbHkpO1xuICAgIGNvbnN0IG1ldHJpY3MgPSBjdHgubWVhc3VyZVRleHQoXCJcIik7XG4gICAgY29uc3QgYXNjZW50ID0gbWV0cmljcy5mb250Qm91bmRpbmdCb3hBc2NlbnQ7XG4gICAgY29uc3QgZGVzY2VudCA9IE1hdGguYWJzKG1ldHJpY3MuZm9udEJvdW5kaW5nQm94RGVzY2VudCk7XG4gICAgY3R4LmNhbnZhcy53aWR0aCA9IGN0eC5jYW52YXMuaGVpZ2h0ID0gMDtcbiAgICBsZXQgcmF0aW8gPSAwLjg7XG4gICAgaWYgKGFzY2VudCkge1xuICAgICAgcmF0aW8gPSBhc2NlbnQgLyAoYXNjZW50ICsgZGVzY2VudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtLmlzRmlyZWZveCkge1xuICAgICAgICB3YXJuKFwiRW5hYmxlIHRoZSBgZG9tLnRleHRNZXRyaWNzLmZvbnRCb3VuZGluZ0JveC5lbmFibGVkYCBwcmVmZXJlbmNlIGluIGBhYm91dDpjb25maWdgIHRvIGltcHJvdmUgVGV4dExheWVyIHJlbmRlcmluZy5cIik7XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGUuYXNjZW50KSB7XG4gICAgICAgIHJhdGlvID0gc3R5bGUuYXNjZW50O1xuICAgICAgfSBlbHNlIGlmIChzdHlsZS5kZXNjZW50KSB7XG4gICAgICAgIHJhdGlvID0gMSArIHN0eWxlLmRlc2NlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2FzY2VudENhY2hlLnNldChmb250RmFtaWx5LCByYXRpbyk7XG4gICAgcmV0dXJuIHJhdGlvO1xuICB9XG59XG5jb25zdCBSRU5ERVJJTkdfQ0FOQ0VMTEVEX1RJTUVPVVQgPSAxMDA7XG5mdW5jdGlvbiBnZXREb2N1bWVudChzcmMgPSB7fSkge1xuICBpZiAodHlwZW9mIHNyYyA9PT0gXCJzdHJpbmdcIiB8fCBzcmMgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICBzcmMgPSB7XG4gICAgICB1cmw6IHNyY1xuICAgIH07XG4gIH0gZWxzZSBpZiAoc3JjIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KHNyYykpIHtcbiAgICBzcmMgPSB7XG4gICAgICBkYXRhOiBzcmNcbiAgICB9O1xuICB9XG4gIGNvbnN0IHRhc2sgPSBuZXcgUERGRG9jdW1lbnRMb2FkaW5nVGFzaygpO1xuICBjb25zdCB7XG4gICAgZG9jSWRcbiAgfSA9IHRhc2s7XG4gIGNvbnN0IHVybCA9IHNyYy51cmwgPyBnZXRVcmxQcm9wKHNyYy51cmwpIDogbnVsbDtcbiAgY29uc3QgZGF0YSA9IHNyYy5kYXRhID8gZ2V0RGF0YVByb3Aoc3JjLmRhdGEpIDogbnVsbDtcbiAgY29uc3QgaHR0cEhlYWRlcnMgPSBzcmMuaHR0cEhlYWRlcnMgfHwgbnVsbDtcbiAgY29uc3Qgd2l0aENyZWRlbnRpYWxzID0gc3JjLndpdGhDcmVkZW50aWFscyA9PT0gdHJ1ZTtcbiAgY29uc3QgcGFzc3dvcmQgPSBzcmMucGFzc3dvcmQgPz8gbnVsbDtcbiAgY29uc3QgcmFuZ2VUcmFuc3BvcnQgPSBzcmMucmFuZ2UgaW5zdGFuY2VvZiBQREZEYXRhUmFuZ2VUcmFuc3BvcnQgPyBzcmMucmFuZ2UgOiBudWxsO1xuICBjb25zdCByYW5nZUNodW5rU2l6ZSA9IE51bWJlci5pc0ludGVnZXIoc3JjLnJhbmdlQ2h1bmtTaXplKSAmJiBzcmMucmFuZ2VDaHVua1NpemUgPiAwID8gc3JjLnJhbmdlQ2h1bmtTaXplIDogMiAqKiAxNjtcbiAgbGV0IHdvcmtlciA9IHNyYy53b3JrZXIgaW5zdGFuY2VvZiBQREZXb3JrZXIgPyBzcmMud29ya2VyIDogbnVsbDtcbiAgY29uc3QgdmVyYm9zaXR5MiA9IHNyYy52ZXJib3NpdHk7XG4gIGNvbnN0IGRvY0Jhc2VVcmwgPSB0eXBlb2Ygc3JjLmRvY0Jhc2VVcmwgPT09IFwic3RyaW5nXCIgJiYgIWlzRGF0YVNjaGVtZShzcmMuZG9jQmFzZVVybCkgPyBzcmMuZG9jQmFzZVVybCA6IG51bGw7XG4gIGNvbnN0IGNNYXBVcmwgPSBnZXRGYWN0b3J5VXJsUHJvcChzcmMuY01hcFVybCk7XG4gIGNvbnN0IGNNYXBQYWNrZWQgPSBzcmMuY01hcFBhY2tlZCAhPT0gZmFsc2U7XG4gIGNvbnN0IENNYXBSZWFkZXJGYWN0b3J5ID0gc3JjLkNNYXBSZWFkZXJGYWN0b3J5IHx8IChpc05vZGVKUyA/IE5vZGVDTWFwUmVhZGVyRmFjdG9yeSA6IERPTUNNYXBSZWFkZXJGYWN0b3J5KTtcbiAgY29uc3QgaWNjVXJsID0gZ2V0RmFjdG9yeVVybFByb3Aoc3JjLmljY1VybCk7XG4gIGNvbnN0IHN0YW5kYXJkRm9udERhdGFVcmwgPSBnZXRGYWN0b3J5VXJsUHJvcChzcmMuc3RhbmRhcmRGb250RGF0YVVybCk7XG4gIGNvbnN0IFN0YW5kYXJkRm9udERhdGFGYWN0b3J5ID0gc3JjLlN0YW5kYXJkRm9udERhdGFGYWN0b3J5IHx8IChpc05vZGVKUyA/IE5vZGVTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA6IERPTVN0YW5kYXJkRm9udERhdGFGYWN0b3J5KTtcbiAgY29uc3Qgd2FzbVVybCA9IGdldEZhY3RvcnlVcmxQcm9wKHNyYy53YXNtVXJsKTtcbiAgY29uc3QgV2FzbUZhY3RvcnkgPSBzcmMuV2FzbUZhY3RvcnkgfHwgKGlzTm9kZUpTID8gTm9kZVdhc21GYWN0b3J5IDogRE9NV2FzbUZhY3RvcnkpO1xuICBjb25zdCBpZ25vcmVFcnJvcnMgPSBzcmMuc3RvcEF0RXJyb3JzICE9PSB0cnVlO1xuICBjb25zdCBtYXhJbWFnZVNpemUgPSBOdW1iZXIuaXNJbnRlZ2VyKHNyYy5tYXhJbWFnZVNpemUpICYmIHNyYy5tYXhJbWFnZVNpemUgPiAtMSA/IHNyYy5tYXhJbWFnZVNpemUgOiAtMTtcbiAgY29uc3QgaXNFdmFsU3VwcG9ydGVkMiA9IHNyYy5pc0V2YWxTdXBwb3J0ZWQgIT09IGZhbHNlO1xuICBjb25zdCBpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCA9IHR5cGVvZiBzcmMuaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQgPT09IFwiYm9vbGVhblwiID8gc3JjLmlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkIDogIWlzTm9kZUpTO1xuICBjb25zdCBpc0ltYWdlRGVjb2RlclN1cHBvcnRlZCA9IHR5cGVvZiBzcmMuaXNJbWFnZURlY29kZXJTdXBwb3J0ZWQgPT09IFwiYm9vbGVhblwiID8gc3JjLmlzSW1hZ2VEZWNvZGVyU3VwcG9ydGVkIDogIWlzTm9kZUpTICYmICh1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtLmlzRmlyZWZveCB8fCAhZ2xvYmFsVGhpcy5jaHJvbWUpO1xuICBjb25zdCBjYW52YXNNYXhBcmVhSW5CeXRlcyA9IE51bWJlci5pc0ludGVnZXIoc3JjLmNhbnZhc01heEFyZWFJbkJ5dGVzKSA/IHNyYy5jYW52YXNNYXhBcmVhSW5CeXRlcyA6IC0xO1xuICBjb25zdCBkaXNhYmxlRm9udEZhY2UgPSB0eXBlb2Ygc3JjLmRpc2FibGVGb250RmFjZSA9PT0gXCJib29sZWFuXCIgPyBzcmMuZGlzYWJsZUZvbnRGYWNlIDogaXNOb2RlSlM7XG4gIGNvbnN0IGZvbnRFeHRyYVByb3BlcnRpZXMgPSBzcmMuZm9udEV4dHJhUHJvcGVydGllcyA9PT0gdHJ1ZTtcbiAgY29uc3QgZW5hYmxlWGZhID0gc3JjLmVuYWJsZVhmYSA9PT0gdHJ1ZTtcbiAgY29uc3Qgb3duZXJEb2N1bWVudCA9IHNyYy5vd25lckRvY3VtZW50IHx8IGdsb2JhbFRoaXMuZG9jdW1lbnQ7XG4gIGNvbnN0IGRpc2FibGVSYW5nZSA9IHNyYy5kaXNhYmxlUmFuZ2UgPT09IHRydWU7XG4gIGNvbnN0IGRpc2FibGVTdHJlYW0gPSBzcmMuZGlzYWJsZVN0cmVhbSA9PT0gdHJ1ZTtcbiAgY29uc3QgZGlzYWJsZUF1dG9GZXRjaCA9IHNyYy5kaXNhYmxlQXV0b0ZldGNoID09PSB0cnVlO1xuICBjb25zdCBwZGZCdWcgPSBzcmMucGRmQnVnID09PSB0cnVlO1xuICBjb25zdCBDYW52YXNGYWN0b3J5ID0gc3JjLkNhbnZhc0ZhY3RvcnkgfHwgKGlzTm9kZUpTID8gTm9kZUNhbnZhc0ZhY3RvcnkgOiBET01DYW52YXNGYWN0b3J5KTtcbiAgY29uc3QgRmlsdGVyRmFjdG9yeSA9IHNyYy5GaWx0ZXJGYWN0b3J5IHx8IChpc05vZGVKUyA/IE5vZGVGaWx0ZXJGYWN0b3J5IDogRE9NRmlsdGVyRmFjdG9yeSk7XG4gIGNvbnN0IGVuYWJsZUhXQSA9IHNyYy5lbmFibGVIV0EgPT09IHRydWU7XG4gIGNvbnN0IHVzZVdhc20gPSBzcmMudXNlV2FzbSAhPT0gZmFsc2U7XG4gIGNvbnN0IGxlbmd0aCA9IHJhbmdlVHJhbnNwb3J0ID8gcmFuZ2VUcmFuc3BvcnQubGVuZ3RoIDogc3JjLmxlbmd0aCA/PyBOYU47XG4gIGNvbnN0IHVzZVN5c3RlbUZvbnRzID0gdHlwZW9mIHNyYy51c2VTeXN0ZW1Gb250cyA9PT0gXCJib29sZWFuXCIgPyBzcmMudXNlU3lzdGVtRm9udHMgOiAhaXNOb2RlSlMgJiYgIWRpc2FibGVGb250RmFjZTtcbiAgY29uc3QgdXNlV29ya2VyRmV0Y2ggPSB0eXBlb2Ygc3JjLnVzZVdvcmtlckZldGNoID09PSBcImJvb2xlYW5cIiA/IHNyYy51c2VXb3JrZXJGZXRjaCA6ICEhKENNYXBSZWFkZXJGYWN0b3J5ID09PSBET01DTWFwUmVhZGVyRmFjdG9yeSAmJiBTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9PT0gRE9NU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgJiYgV2FzbUZhY3RvcnkgPT09IERPTVdhc21GYWN0b3J5ICYmIGNNYXBVcmwgJiYgc3RhbmRhcmRGb250RGF0YVVybCAmJiB3YXNtVXJsICYmIGlzVmFsaWRGZXRjaFVybChjTWFwVXJsLCBkb2N1bWVudC5iYXNlVVJJKSAmJiBpc1ZhbGlkRmV0Y2hVcmwoc3RhbmRhcmRGb250RGF0YVVybCwgZG9jdW1lbnQuYmFzZVVSSSkgJiYgaXNWYWxpZEZldGNoVXJsKHdhc21VcmwsIGRvY3VtZW50LmJhc2VVUkkpKTtcbiAgY29uc3Qgc3R5bGVFbGVtZW50ID0gbnVsbDtcbiAgc2V0VmVyYm9zaXR5TGV2ZWwodmVyYm9zaXR5Mik7XG4gIGNvbnN0IHRyYW5zcG9ydEZhY3RvcnkgPSB7XG4gICAgY2FudmFzRmFjdG9yeTogbmV3IENhbnZhc0ZhY3Rvcnkoe1xuICAgICAgb3duZXJEb2N1bWVudCxcbiAgICAgIGVuYWJsZUhXQVxuICAgIH0pLFxuICAgIGZpbHRlckZhY3Rvcnk6IG5ldyBGaWx0ZXJGYWN0b3J5KHtcbiAgICAgIGRvY0lkLFxuICAgICAgb3duZXJEb2N1bWVudFxuICAgIH0pLFxuICAgIGNNYXBSZWFkZXJGYWN0b3J5OiB1c2VXb3JrZXJGZXRjaCA/IG51bGwgOiBuZXcgQ01hcFJlYWRlckZhY3Rvcnkoe1xuICAgICAgYmFzZVVybDogY01hcFVybCxcbiAgICAgIGlzQ29tcHJlc3NlZDogY01hcFBhY2tlZFxuICAgIH0pLFxuICAgIHN0YW5kYXJkRm9udERhdGFGYWN0b3J5OiB1c2VXb3JrZXJGZXRjaCA/IG51bGwgOiBuZXcgU3RhbmRhcmRGb250RGF0YUZhY3Rvcnkoe1xuICAgICAgYmFzZVVybDogc3RhbmRhcmRGb250RGF0YVVybFxuICAgIH0pLFxuICAgIHdhc21GYWN0b3J5OiB1c2VXb3JrZXJGZXRjaCA/IG51bGwgOiBuZXcgV2FzbUZhY3Rvcnkoe1xuICAgICAgYmFzZVVybDogd2FzbVVybFxuICAgIH0pXG4gIH07XG4gIGlmICghd29ya2VyKSB7XG4gICAgd29ya2VyID0gUERGV29ya2VyLmNyZWF0ZSh7XG4gICAgICB2ZXJib3NpdHk6IHZlcmJvc2l0eTIsXG4gICAgICBwb3J0OiBHbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclBvcnRcbiAgICB9KTtcbiAgICB0YXNrLl93b3JrZXIgPSB3b3JrZXI7XG4gIH1cbiAgY29uc3QgZG9jUGFyYW1zID0ge1xuICAgIGRvY0lkLFxuICAgIGFwaVZlcnNpb246IFwiNS40LjI5NlwiLFxuICAgIGRhdGEsXG4gICAgcGFzc3dvcmQsXG4gICAgZGlzYWJsZUF1dG9GZXRjaCxcbiAgICByYW5nZUNodW5rU2l6ZSxcbiAgICBsZW5ndGgsXG4gICAgZG9jQmFzZVVybCxcbiAgICBlbmFibGVYZmEsXG4gICAgZXZhbHVhdG9yT3B0aW9uczoge1xuICAgICAgbWF4SW1hZ2VTaXplLFxuICAgICAgZGlzYWJsZUZvbnRGYWNlLFxuICAgICAgaWdub3JlRXJyb3JzLFxuICAgICAgaXNFdmFsU3VwcG9ydGVkOiBpc0V2YWxTdXBwb3J0ZWQyLFxuICAgICAgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQsXG4gICAgICBpc0ltYWdlRGVjb2RlclN1cHBvcnRlZCxcbiAgICAgIGNhbnZhc01heEFyZWFJbkJ5dGVzLFxuICAgICAgZm9udEV4dHJhUHJvcGVydGllcyxcbiAgICAgIHVzZVN5c3RlbUZvbnRzLFxuICAgICAgdXNlV2FzbSxcbiAgICAgIHVzZVdvcmtlckZldGNoLFxuICAgICAgY01hcFVybCxcbiAgICAgIGljY1VybCxcbiAgICAgIHN0YW5kYXJkRm9udERhdGFVcmwsXG4gICAgICB3YXNtVXJsXG4gICAgfVxuICB9O1xuICBjb25zdCB0cmFuc3BvcnRQYXJhbXMgPSB7XG4gICAgb3duZXJEb2N1bWVudCxcbiAgICBwZGZCdWcsXG4gICAgc3R5bGVFbGVtZW50LFxuICAgIGxvYWRpbmdQYXJhbXM6IHtcbiAgICAgIGRpc2FibGVBdXRvRmV0Y2gsXG4gICAgICBlbmFibGVYZmFcbiAgICB9XG4gIH07XG4gIHdvcmtlci5wcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRhc2suZGVzdHJveWVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb2FkaW5nIGFib3J0ZWRcIik7XG4gICAgfVxuICAgIGlmICh3b3JrZXIuZGVzdHJveWVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZFwiKTtcbiAgICB9XG4gICAgY29uc3Qgd29ya2VySWRQcm9taXNlID0gd29ya2VyLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldERvY1JlcXVlc3RcIiwgZG9jUGFyYW1zLCBkYXRhID8gW2RhdGEuYnVmZmVyXSA6IG51bGwpO1xuICAgIGxldCBuZXR3b3JrU3RyZWFtO1xuICAgIGlmIChyYW5nZVRyYW5zcG9ydCkge1xuICAgICAgbmV0d29ya1N0cmVhbSA9IG5ldyBQREZEYXRhVHJhbnNwb3J0U3RyZWFtKHJhbmdlVHJhbnNwb3J0LCB7XG4gICAgICAgIGRpc2FibGVSYW5nZSxcbiAgICAgICAgZGlzYWJsZVN0cmVhbVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICghZGF0YSkge1xuICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2V0RG9jdW1lbnQgLSBubyBgdXJsYCBwYXJhbWV0ZXIgcHJvdmlkZWQuXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgTmV0d29ya1N0cmVhbSA9IGlzVmFsaWRGZXRjaFVybCh1cmwpID8gUERGRmV0Y2hTdHJlYW0gOiBpc05vZGVKUyA/IFBERk5vZGVTdHJlYW0gOiBQREZOZXR3b3JrU3RyZWFtO1xuICAgICAgbmV0d29ya1N0cmVhbSA9IG5ldyBOZXR3b3JrU3RyZWFtKHtcbiAgICAgICAgdXJsLFxuICAgICAgICBsZW5ndGgsXG4gICAgICAgIGh0dHBIZWFkZXJzLFxuICAgICAgICB3aXRoQ3JlZGVudGlhbHMsXG4gICAgICAgIHJhbmdlQ2h1bmtTaXplLFxuICAgICAgICBkaXNhYmxlUmFuZ2UsXG4gICAgICAgIGRpc2FibGVTdHJlYW1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gd29ya2VySWRQcm9taXNlLnRoZW4oKHdvcmtlcklkKSA9PiB7XG4gICAgICBpZiAodGFzay5kZXN0cm95ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTG9hZGluZyBhYm9ydGVkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHdvcmtlci5kZXN0cm95ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBtZXNzYWdlSGFuZGxlciA9IG5ldyBNZXNzYWdlSGFuZGxlcihkb2NJZCwgd29ya2VySWQsIHdvcmtlci5wb3J0KTtcbiAgICAgIGNvbnN0IHRyYW5zcG9ydCA9IG5ldyBXb3JrZXJUcmFuc3BvcnQobWVzc2FnZUhhbmRsZXIsIHRhc2ssIG5ldHdvcmtTdHJlYW0sIHRyYW5zcG9ydFBhcmFtcywgdHJhbnNwb3J0RmFjdG9yeSwgZW5hYmxlSFdBKTtcbiAgICAgIHRhc2suX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLnNlbmQoXCJSZWFkeVwiLCBudWxsKTtcbiAgICB9KTtcbiAgfSkuY2F0Y2godGFzay5fY2FwYWJpbGl0eS5yZWplY3QpO1xuICByZXR1cm4gdGFzaztcbn1cbmNsYXNzIFBERkRvY3VtZW50TG9hZGluZ1Rhc2sge1xuICBzdGF0aWMgI2RvY0lkID0gMDtcbiAgX2NhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgX3RyYW5zcG9ydCA9IG51bGw7XG4gIF93b3JrZXIgPSBudWxsO1xuICBkb2NJZCA9IGBkJHtQREZEb2N1bWVudExvYWRpbmdUYXNrLiNkb2NJZCsrfWA7XG4gIGRlc3Ryb3llZCA9IGZhbHNlO1xuICBvblBhc3N3b3JkID0gbnVsbDtcbiAgb25Qcm9ncmVzcyA9IG51bGw7XG4gIGdldCBwcm9taXNlKCkge1xuICAgIHJldHVybiB0aGlzLl9jYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgYXN5bmMgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLl93b3JrZXI/LnBvcnQpIHtcbiAgICAgICAgdGhpcy5fd29ya2VyLl9wZW5kaW5nRGVzdHJveSA9IHRydWU7XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLl90cmFuc3BvcnQ/LmRlc3Ryb3koKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgaWYgKHRoaXMuX3dvcmtlcj8ucG9ydCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fd29ya2VyLl9wZW5kaW5nRGVzdHJveTtcbiAgICAgIH1cbiAgICAgIHRocm93IGV4O1xuICAgIH1cbiAgICB0aGlzLl90cmFuc3BvcnQgPSBudWxsO1xuICAgIHRoaXMuX3dvcmtlcj8uZGVzdHJveSgpO1xuICAgIHRoaXMuX3dvcmtlciA9IG51bGw7XG4gIH1cbiAgYXN5bmMgZ2V0RGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldERhdGEoKTtcbiAgfVxufVxuY2xhc3MgUERGRGF0YVJhbmdlVHJhbnNwb3J0IHtcbiAgI2NhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgI3Byb2dyZXNzaXZlRG9uZUxpc3RlbmVycyA9IFtdO1xuICAjcHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXJzID0gW107XG4gICNwcm9ncmVzc0xpc3RlbmVycyA9IFtdO1xuICAjcmFuZ2VMaXN0ZW5lcnMgPSBbXTtcbiAgY29uc3RydWN0b3IobGVuZ3RoLCBpbml0aWFsRGF0YSwgcHJvZ3Jlc3NpdmVEb25lID0gZmFsc2UsIGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lID0gbnVsbCkge1xuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIHRoaXMuaW5pdGlhbERhdGEgPSBpbml0aWFsRGF0YTtcbiAgICB0aGlzLnByb2dyZXNzaXZlRG9uZSA9IHByb2dyZXNzaXZlRG9uZTtcbiAgICB0aGlzLmNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lID0gY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWU7XG4gIH1cbiAgYWRkUmFuZ2VMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIHRoaXMuI3JhbmdlTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9XG4gIGFkZFByb2dyZXNzTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICB0aGlzLiNwcm9ncmVzc0xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgfVxuICBhZGRQcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIHRoaXMuI3Byb2dyZXNzaXZlUmVhZExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgfVxuICBhZGRQcm9ncmVzc2l2ZURvbmVMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIHRoaXMuI3Byb2dyZXNzaXZlRG9uZUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgfVxuICBvbkRhdGFSYW5nZShiZWdpbiwgY2h1bmspIHtcbiAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuI3JhbmdlTGlzdGVuZXJzKSB7XG4gICAgICBsaXN0ZW5lcihiZWdpbiwgY2h1bmspO1xuICAgIH1cbiAgfVxuICBvbkRhdGFQcm9ncmVzcyhsb2FkZWQsIHRvdGFsKSB7XG4gICAgdGhpcy4jY2FwYWJpbGl0eS5wcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLiNwcm9ncmVzc0xpc3RlbmVycykge1xuICAgICAgICBsaXN0ZW5lcihsb2FkZWQsIHRvdGFsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBvbkRhdGFQcm9ncmVzc2l2ZVJlYWQoY2h1bmspIHtcbiAgICB0aGlzLiNjYXBhYmlsaXR5LnByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuI3Byb2dyZXNzaXZlUmVhZExpc3RlbmVycykge1xuICAgICAgICBsaXN0ZW5lcihjaHVuayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgb25EYXRhUHJvZ3Jlc3NpdmVEb25lKCkge1xuICAgIHRoaXMuI2NhcGFiaWxpdHkucHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy4jcHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXJzKSB7XG4gICAgICAgIGxpc3RlbmVyKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgdHJhbnNwb3J0UmVhZHkoKSB7XG4gICAgdGhpcy4jY2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gIH1cbiAgcmVxdWVzdERhdGFSYW5nZShiZWdpbiwgZW5kKSB7XG4gICAgdW5yZWFjaGFibGUoXCJBYnN0cmFjdCBtZXRob2QgUERGRGF0YVJhbmdlVHJhbnNwb3J0LnJlcXVlc3REYXRhUmFuZ2VcIik7XG4gIH1cbiAgYWJvcnQoKSB7XG4gIH1cbn1cbmNsYXNzIFBERkRvY3VtZW50UHJveHkge1xuICBjb25zdHJ1Y3RvcihwZGZJbmZvLCB0cmFuc3BvcnQpIHtcbiAgICB0aGlzLl9wZGZJbmZvID0gcGRmSW5mbztcbiAgICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gIH1cbiAgZ2V0IGFubm90YXRpb25TdG9yYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuYW5ub3RhdGlvblN0b3JhZ2U7XG4gIH1cbiAgZ2V0IGNhbnZhc0ZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5jYW52YXNGYWN0b3J5O1xuICB9XG4gIGdldCBmaWx0ZXJGYWN0b3J5KCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZmlsdGVyRmFjdG9yeTtcbiAgfVxuICBnZXQgbnVtUGFnZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BkZkluZm8ubnVtUGFnZXM7XG4gIH1cbiAgZ2V0IGZpbmdlcnByaW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGRmSW5mby5maW5nZXJwcmludHM7XG4gIH1cbiAgZ2V0IGlzUHVyZVhmYSgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNQdXJlWGZhXCIsICEhdGhpcy5fdHJhbnNwb3J0Ll9odG1sRm9yWGZhKTtcbiAgfVxuICBnZXQgYWxsWGZhSHRtbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0Ll9odG1sRm9yWGZhO1xuICB9XG4gIGdldFBhZ2UocGFnZU51bWJlcikge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZShwYWdlTnVtYmVyKTtcbiAgfVxuICBnZXRQYWdlSW5kZXgocmVmKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlSW5kZXgocmVmKTtcbiAgfVxuICBnZXREZXN0aW5hdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXREZXN0aW5hdGlvbnMoKTtcbiAgfVxuICBnZXREZXN0aW5hdGlvbihpZCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0RGVzdGluYXRpb24oaWQpO1xuICB9XG4gIGdldFBhZ2VMYWJlbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlTGFiZWxzKCk7XG4gIH1cbiAgZ2V0UGFnZUxheW91dCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBhZ2VMYXlvdXQoKTtcbiAgfVxuICBnZXRQYWdlTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBhZ2VNb2RlKCk7XG4gIH1cbiAgZ2V0Vmlld2VyUHJlZmVyZW5jZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRWaWV3ZXJQcmVmZXJlbmNlcygpO1xuICB9XG4gIGdldE9wZW5BY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRPcGVuQWN0aW9uKCk7XG4gIH1cbiAgZ2V0QXR0YWNobWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRBdHRhY2htZW50cygpO1xuICB9XG4gIGdldEFubm90YXRpb25zQnlUeXBlKHR5cGVzLCBwYWdlSW5kZXhlc1RvU2tpcCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0QW5ub3RhdGlvbnNCeVR5cGUodHlwZXMsIHBhZ2VJbmRleGVzVG9Ta2lwKTtcbiAgfVxuICBnZXRKU0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXREb2NKU0FjdGlvbnMoKTtcbiAgfVxuICBnZXRPdXRsaW5lKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0T3V0bGluZSgpO1xuICB9XG4gIGdldE9wdGlvbmFsQ29udGVudENvbmZpZyh7XG4gICAgaW50ZW50ID0gXCJkaXNwbGF5XCJcbiAgfSA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVuZGVyaW5nSW50ZW50XG4gICAgfSA9IHRoaXMuX3RyYW5zcG9ydC5nZXRSZW5kZXJpbmdJbnRlbnQoaW50ZW50KTtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldE9wdGlvbmFsQ29udGVudENvbmZpZyhyZW5kZXJpbmdJbnRlbnQpO1xuICB9XG4gIGdldFBlcm1pc3Npb25zKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGVybWlzc2lvbnMoKTtcbiAgfVxuICBnZXRNZXRhZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldE1ldGFkYXRhKCk7XG4gIH1cbiAgZ2V0TWFya0luZm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRNYXJrSW5mbygpO1xuICB9XG4gIGdldERhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXREYXRhKCk7XG4gIH1cbiAgc2F2ZURvY3VtZW50KCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuc2F2ZURvY3VtZW50KCk7XG4gIH1cbiAgZ2V0RG93bmxvYWRJbmZvKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZG93bmxvYWRJbmZvQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGNsZWFudXAoa2VlcExvYWRlZEZvbnRzID0gZmFsc2UpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LnN0YXJ0Q2xlYW51cChrZWVwTG9hZGVkRm9udHMgfHwgdGhpcy5pc1B1cmVYZmEpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgcmV0dXJuIHRoaXMubG9hZGluZ1Rhc2suZGVzdHJveSgpO1xuICB9XG4gIGNhY2hlZFBhZ2VOdW1iZXIocmVmKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5jYWNoZWRQYWdlTnVtYmVyKHJlZik7XG4gIH1cbiAgZ2V0IGxvYWRpbmdQYXJhbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5sb2FkaW5nUGFyYW1zO1xuICB9XG4gIGdldCBsb2FkaW5nVGFzaygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmxvYWRpbmdUYXNrO1xuICB9XG4gIGdldEZpZWxkT2JqZWN0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldEZpZWxkT2JqZWN0cygpO1xuICB9XG4gIGhhc0pTQWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0Lmhhc0pTQWN0aW9ucygpO1xuICB9XG4gIGdldENhbGN1bGF0aW9uT3JkZXJJZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRDYWxjdWxhdGlvbk9yZGVySWRzKCk7XG4gIH1cbn1cbmNsYXNzIFBERlBhZ2VQcm94eSB7XG4gICNwZW5kaW5nQ2xlYW51cCA9IGZhbHNlO1xuICBjb25zdHJ1Y3RvcihwYWdlSW5kZXgsIHBhZ2VJbmZvLCB0cmFuc3BvcnQsIHBkZkJ1ZyA9IGZhbHNlKSB7XG4gICAgdGhpcy5fcGFnZUluZGV4ID0gcGFnZUluZGV4O1xuICAgIHRoaXMuX3BhZ2VJbmZvID0gcGFnZUluZm87XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIHRoaXMuX3N0YXRzID0gcGRmQnVnID8gbmV3IFN0YXRUaW1lcigpIDogbnVsbDtcbiAgICB0aGlzLl9wZGZCdWcgPSBwZGZCdWc7XG4gICAgdGhpcy5jb21tb25PYmpzID0gdHJhbnNwb3J0LmNvbW1vbk9ianM7XG4gICAgdGhpcy5vYmpzID0gbmV3IFBERk9iamVjdHMoKTtcbiAgICB0aGlzLl9pbnRlbnRTdGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5yZWNvcmRlZEJCb3hlcyA9IG51bGw7XG4gIH1cbiAgZ2V0IHBhZ2VOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VJbmRleCArIDE7XG4gIH1cbiAgZ2V0IHJvdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZUluZm8ucm90YXRlO1xuICB9XG4gIGdldCByZWYoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VJbmZvLnJlZjtcbiAgfVxuICBnZXQgdXNlclVuaXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VJbmZvLnVzZXJVbml0O1xuICB9XG4gIGdldCB2aWV3KCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlSW5mby52aWV3O1xuICB9XG4gIGdldFZpZXdwb3J0KHtcbiAgICBzY2FsZSxcbiAgICByb3RhdGlvbiA9IHRoaXMucm90YXRlLFxuICAgIG9mZnNldFggPSAwLFxuICAgIG9mZnNldFkgPSAwLFxuICAgIGRvbnRGbGlwID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBQYWdlVmlld3BvcnQoe1xuICAgICAgdmlld0JveDogdGhpcy52aWV3LFxuICAgICAgdXNlclVuaXQ6IHRoaXMudXNlclVuaXQsXG4gICAgICBzY2FsZSxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgb2Zmc2V0WCxcbiAgICAgIG9mZnNldFksXG4gICAgICBkb250RmxpcFxuICAgIH0pO1xuICB9XG4gIGdldEFubm90YXRpb25zKHtcbiAgICBpbnRlbnQgPSBcImRpc3BsYXlcIlxuICB9ID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICByZW5kZXJpbmdJbnRlbnRcbiAgICB9ID0gdGhpcy5fdHJhbnNwb3J0LmdldFJlbmRlcmluZ0ludGVudChpbnRlbnQpO1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0QW5ub3RhdGlvbnModGhpcy5fcGFnZUluZGV4LCByZW5kZXJpbmdJbnRlbnQpO1xuICB9XG4gIGdldEpTQWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBhZ2VKU0FjdGlvbnModGhpcy5fcGFnZUluZGV4KTtcbiAgfVxuICBnZXQgZmlsdGVyRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmZpbHRlckZhY3Rvcnk7XG4gIH1cbiAgZ2V0IGlzUHVyZVhmYSgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNQdXJlWGZhXCIsICEhdGhpcy5fdHJhbnNwb3J0Ll9odG1sRm9yWGZhKTtcbiAgfVxuICBhc3luYyBnZXRYZmEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5faHRtbEZvclhmYT8uY2hpbGRyZW5bdGhpcy5fcGFnZUluZGV4XSB8fCBudWxsO1xuICB9XG4gIHJlbmRlcih7XG4gICAgY2FudmFzQ29udGV4dCxcbiAgICBjYW52YXMgPSBjYW52YXNDb250ZXh0LmNhbnZhcyxcbiAgICB2aWV3cG9ydCxcbiAgICBpbnRlbnQgPSBcImRpc3BsYXlcIixcbiAgICBhbm5vdGF0aW9uTW9kZSA9IEFubm90YXRpb25Nb2RlLkVOQUJMRSxcbiAgICB0cmFuc2Zvcm0gPSBudWxsLFxuICAgIGJhY2tncm91bmQgPSBudWxsLFxuICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2UgPSBudWxsLFxuICAgIGFubm90YXRpb25DYW52YXNNYXAgPSBudWxsLFxuICAgIHBhZ2VDb2xvcnMgPSBudWxsLFxuICAgIHByaW50QW5ub3RhdGlvblN0b3JhZ2UgPSBudWxsLFxuICAgIGlzRWRpdGluZyA9IGZhbHNlLFxuICAgIHJlY29yZE9wZXJhdGlvbnMgPSBmYWxzZSxcbiAgICBvcGVyYXRpb25zRmlsdGVyID0gbnVsbFxuICB9KSB7XG4gICAgdGhpcy5fc3RhdHM/LnRpbWUoXCJPdmVyYWxsXCIpO1xuICAgIGNvbnN0IGludGVudEFyZ3MgPSB0aGlzLl90cmFuc3BvcnQuZ2V0UmVuZGVyaW5nSW50ZW50KGludGVudCwgYW5ub3RhdGlvbk1vZGUsIHByaW50QW5ub3RhdGlvblN0b3JhZ2UsIGlzRWRpdGluZyk7XG4gICAgY29uc3Qge1xuICAgICAgcmVuZGVyaW5nSW50ZW50LFxuICAgICAgY2FjaGVLZXlcbiAgICB9ID0gaW50ZW50QXJncztcbiAgICB0aGlzLiNwZW5kaW5nQ2xlYW51cCA9IGZhbHNlO1xuICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2UgfHw9IHRoaXMuX3RyYW5zcG9ydC5nZXRPcHRpb25hbENvbnRlbnRDb25maWcocmVuZGVyaW5nSW50ZW50KTtcbiAgICBsZXQgaW50ZW50U3RhdGUgPSB0aGlzLl9pbnRlbnRTdGF0ZXMuZ2V0KGNhY2hlS2V5KTtcbiAgICBpZiAoIWludGVudFN0YXRlKSB7XG4gICAgICBpbnRlbnRTdGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy5faW50ZW50U3RhdGVzLnNldChjYWNoZUtleSwgaW50ZW50U3RhdGUpO1xuICAgIH1cbiAgICBpZiAoaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQpO1xuICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGludGVudFByaW50ID0gISEocmVuZGVyaW5nSW50ZW50ICYgUmVuZGVyaW5nSW50ZW50RmxhZy5QUklOVCk7XG4gICAgaWYgKCFpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5KSB7XG4gICAgICBpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QgPSB7XG4gICAgICAgIGZuQXJyYXk6IFtdLFxuICAgICAgICBhcmdzQXJyYXk6IFtdLFxuICAgICAgICBsYXN0Q2h1bms6IGZhbHNlLFxuICAgICAgICBzZXBhcmF0ZUFubm90czogbnVsbFxuICAgICAgfTtcbiAgICAgIHRoaXMuX3N0YXRzPy50aW1lKFwiUGFnZSBSZXF1ZXN0XCIpO1xuICAgICAgdGhpcy5fcHVtcE9wZXJhdG9yTGlzdChpbnRlbnRBcmdzKTtcbiAgICB9XG4gICAgY29uc3QgcmVjb3JkRm9yRGVidWdnZXIgPSBCb29sZWFuKHRoaXMuX3BkZkJ1ZyAmJiBnbG9iYWxUaGlzLlN0ZXBwZXJNYW5hZ2VyPy5lbmFibGVkKTtcbiAgICBjb25zdCBzaG91bGRSZWNvcmRPcGVyYXRpb25zID0gIXRoaXMucmVjb3JkZWRCQm94ZXMgJiYgKHJlY29yZE9wZXJhdGlvbnMgfHwgcmVjb3JkRm9yRGVidWdnZXIpO1xuICAgIGNvbnN0IGNvbXBsZXRlID0gKGVycm9yKSA9PiB7XG4gICAgICBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcy5kZWxldGUoaW50ZXJuYWxSZW5kZXJUYXNrKTtcbiAgICAgIGlmIChzaG91bGRSZWNvcmRPcGVyYXRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlY29yZGVkQkJveGVzID0gaW50ZXJuYWxSZW5kZXJUYXNrLmdmeD8uZGVwZW5kZW5jeVRyYWNrZXIudGFrZSgpO1xuICAgICAgICBpZiAocmVjb3JkZWRCQm94ZXMpIHtcbiAgICAgICAgICBpZiAoaW50ZXJuYWxSZW5kZXJUYXNrLnN0ZXBwZXIpIHtcbiAgICAgICAgICAgIGludGVybmFsUmVuZGVyVGFzay5zdGVwcGVyLnNldE9wZXJhdG9yQkJveGVzKHJlY29yZGVkQkJveGVzLCBpbnRlcm5hbFJlbmRlclRhc2suZ2Z4LmRlcGVuZGVuY3lUcmFja2VyLnRha2VEZWJ1Z01ldGFkYXRhKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVjb3JkT3BlcmF0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5yZWNvcmRlZEJCb3hlcyA9IHJlY29yZGVkQkJveGVzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGludGVudFByaW50KSB7XG4gICAgICAgIHRoaXMuI3BlbmRpbmdDbGVhbnVwID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3RyeUNsZWFudXAoKTtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBpbnRlcm5hbFJlbmRlclRhc2suY2FwYWJpbGl0eS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB0aGlzLl9hYm9ydE9wZXJhdG9yTGlzdCh7XG4gICAgICAgICAgaW50ZW50U3RhdGUsXG4gICAgICAgICAgcmVhc29uOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoZXJyb3IpXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLmNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3N0YXRzKSB7XG4gICAgICAgIHRoaXMuX3N0YXRzLnRpbWVFbmQoXCJSZW5kZXJpbmdcIik7XG4gICAgICAgIHRoaXMuX3N0YXRzLnRpbWVFbmQoXCJPdmVyYWxsXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5TdGF0cz8uZW5hYmxlZCkge1xuICAgICAgICAgIGdsb2JhbFRoaXMuU3RhdHMuYWRkKHRoaXMucGFnZU51bWJlciwgdGhpcy5fc3RhdHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpbnRlcm5hbFJlbmRlclRhc2sgPSBuZXcgSW50ZXJuYWxSZW5kZXJUYXNrKHtcbiAgICAgIGNhbGxiYWNrOiBjb21wbGV0ZSxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBjYW52YXMsXG4gICAgICAgIGNhbnZhc0NvbnRleHQsXG4gICAgICAgIGRlcGVuZGVuY3lUcmFja2VyOiBzaG91bGRSZWNvcmRPcGVyYXRpb25zID8gbmV3IENhbnZhc0RlcGVuZGVuY3lUcmFja2VyKGNhbnZhcywgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0Lmxlbmd0aCwgcmVjb3JkRm9yRGVidWdnZXIpIDogbnVsbCxcbiAgICAgICAgdmlld3BvcnQsXG4gICAgICAgIHRyYW5zZm9ybSxcbiAgICAgICAgYmFja2dyb3VuZFxuICAgICAgfSxcbiAgICAgIG9ianM6IHRoaXMub2JqcyxcbiAgICAgIGNvbW1vbk9ianM6IHRoaXMuY29tbW9uT2JqcyxcbiAgICAgIGFubm90YXRpb25DYW52YXNNYXAsXG4gICAgICBvcGVyYXRvckxpc3Q6IGludGVudFN0YXRlLm9wZXJhdG9yTGlzdCxcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5fcGFnZUluZGV4LFxuICAgICAgY2FudmFzRmFjdG9yeTogdGhpcy5fdHJhbnNwb3J0LmNhbnZhc0ZhY3RvcnksXG4gICAgICBmaWx0ZXJGYWN0b3J5OiB0aGlzLl90cmFuc3BvcnQuZmlsdGVyRmFjdG9yeSxcbiAgICAgIHVzZVJlcXVlc3RBbmltYXRpb25GcmFtZTogIWludGVudFByaW50LFxuICAgICAgcGRmQnVnOiB0aGlzLl9wZGZCdWcsXG4gICAgICBwYWdlQ29sb3JzLFxuICAgICAgZW5hYmxlSFdBOiB0aGlzLl90cmFuc3BvcnQuZW5hYmxlSFdBLFxuICAgICAgb3BlcmF0aW9uc0ZpbHRlclxuICAgIH0pO1xuICAgIChpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcyB8fD0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSkuYWRkKGludGVybmFsUmVuZGVyVGFzayk7XG4gICAgY29uc3QgcmVuZGVyVGFzayA9IGludGVybmFsUmVuZGVyVGFzay50YXNrO1xuICAgIFByb21pc2UuYWxsKFtpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5LnByb21pc2UsIG9wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2VdKS50aGVuKChbdHJhbnNwYXJlbmN5LCBvcHRpb25hbENvbnRlbnRDb25maWddKSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgY29tcGxldGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3RhdHM/LnRpbWUoXCJSZW5kZXJpbmdcIik7XG4gICAgICBpZiAoIShvcHRpb25hbENvbnRlbnRDb25maWcucmVuZGVyaW5nSW50ZW50ICYgcmVuZGVyaW5nSW50ZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHVzZSB0aGUgc2FtZSBgaW50ZW50YC1hcmd1bWVudCB3aGVuIGNhbGxpbmcgdGhlIGBQREZQYWdlUHJveHkucmVuZGVyYCBhbmQgYFBERkRvY3VtZW50UHJveHkuZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnYCBtZXRob2RzLlwiKTtcbiAgICAgIH1cbiAgICAgIGludGVybmFsUmVuZGVyVGFzay5pbml0aWFsaXplR3JhcGhpY3Moe1xuICAgICAgICB0cmFuc3BhcmVuY3ksXG4gICAgICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1xuICAgICAgfSk7XG4gICAgICBpbnRlcm5hbFJlbmRlclRhc2sub3BlcmF0b3JMaXN0Q2hhbmdlZCgpO1xuICAgIH0pLmNhdGNoKGNvbXBsZXRlKTtcbiAgICByZXR1cm4gcmVuZGVyVGFzaztcbiAgfVxuICBnZXRPcGVyYXRvckxpc3Qoe1xuICAgIGludGVudCA9IFwiZGlzcGxheVwiLFxuICAgIGFubm90YXRpb25Nb2RlID0gQW5ub3RhdGlvbk1vZGUuRU5BQkxFLFxuICAgIHByaW50QW5ub3RhdGlvblN0b3JhZ2UgPSBudWxsLFxuICAgIGlzRWRpdGluZyA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIGZ1bmN0aW9uIG9wZXJhdG9yTGlzdENoYW5nZWQoKSB7XG4gICAgICBpZiAoaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0Lmxhc3RDaHVuaykge1xuICAgICAgICBpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKGludGVudFN0YXRlLm9wZXJhdG9yTGlzdCk7XG4gICAgICAgIGludGVudFN0YXRlLnJlbmRlclRhc2tzLmRlbGV0ZShvcExpc3RUYXNrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW50ZW50QXJncyA9IHRoaXMuX3RyYW5zcG9ydC5nZXRSZW5kZXJpbmdJbnRlbnQoaW50ZW50LCBhbm5vdGF0aW9uTW9kZSwgcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSwgaXNFZGl0aW5nLCB0cnVlKTtcbiAgICBsZXQgaW50ZW50U3RhdGUgPSB0aGlzLl9pbnRlbnRTdGF0ZXMuZ2V0KGludGVudEFyZ3MuY2FjaGVLZXkpO1xuICAgIGlmICghaW50ZW50U3RhdGUpIHtcbiAgICAgIGludGVudFN0YXRlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLl9pbnRlbnRTdGF0ZXMuc2V0KGludGVudEFyZ3MuY2FjaGVLZXksIGludGVudFN0YXRlKTtcbiAgICB9XG4gICAgbGV0IG9wTGlzdFRhc2s7XG4gICAgaWYgKCFpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eSkge1xuICAgICAgb3BMaXN0VGFzayA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgb3BMaXN0VGFzay5vcGVyYXRvckxpc3RDaGFuZ2VkID0gb3BlcmF0b3JMaXN0Q2hhbmdlZDtcbiAgICAgIGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgICAoaW50ZW50U3RhdGUucmVuZGVyVGFza3MgfHw9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpLmFkZChvcExpc3RUYXNrKTtcbiAgICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdCA9IHtcbiAgICAgICAgZm5BcnJheTogW10sXG4gICAgICAgIGFyZ3NBcnJheTogW10sXG4gICAgICAgIGxhc3RDaHVuazogZmFsc2UsXG4gICAgICAgIHNlcGFyYXRlQW5ub3RzOiBudWxsXG4gICAgICB9O1xuICAgICAgdGhpcy5fc3RhdHM/LnRpbWUoXCJQYWdlIFJlcXVlc3RcIik7XG4gICAgICB0aGlzLl9wdW1wT3BlcmF0b3JMaXN0KGludGVudEFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBzdHJlYW1UZXh0Q29udGVudCh7XG4gICAgaW5jbHVkZU1hcmtlZENvbnRlbnQgPSBmYWxzZSxcbiAgICBkaXNhYmxlTm9ybWFsaXphdGlvbiA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIGNvbnN0IFRFWFRfQ09OVEVOVF9DSFVOS19TSVpFID0gMTAwO1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhTdHJlYW0oXCJHZXRUZXh0Q29udGVudFwiLCB7XG4gICAgICBwYWdlSW5kZXg6IHRoaXMuX3BhZ2VJbmRleCxcbiAgICAgIGluY2x1ZGVNYXJrZWRDb250ZW50OiBpbmNsdWRlTWFya2VkQ29udGVudCA9PT0gdHJ1ZSxcbiAgICAgIGRpc2FibGVOb3JtYWxpemF0aW9uOiBkaXNhYmxlTm9ybWFsaXphdGlvbiA9PT0gdHJ1ZVxuICAgIH0sIHtcbiAgICAgIGhpZ2hXYXRlck1hcms6IFRFWFRfQ09OVEVOVF9DSFVOS19TSVpFLFxuICAgICAgc2l6ZSh0ZXh0Q29udGVudCkge1xuICAgICAgICByZXR1cm4gdGV4dENvbnRlbnQuaXRlbXMubGVuZ3RoO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldFRleHRDb250ZW50KHBhcmFtcyA9IHt9KSB7XG4gICAgaWYgKHRoaXMuX3RyYW5zcG9ydC5faHRtbEZvclhmYSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0WGZhKCkudGhlbigoeGZhKSA9PiBYZmFUZXh0LnRleHRDb250ZW50KHhmYSkpO1xuICAgIH1cbiAgICBjb25zdCByZWFkYWJsZVN0cmVhbSA9IHRoaXMuc3RyZWFtVGV4dENvbnRlbnQocGFyYW1zKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBmdW5jdGlvbiBwdW1wKCkge1xuICAgICAgICByZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24oe1xuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGRvbmVcbiAgICAgICAgfSkge1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICByZXNvbHZlKHRleHRDb250ZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGV4dENvbnRlbnQubGFuZyA/Pz0gdmFsdWUubGFuZztcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHRleHRDb250ZW50LnN0eWxlcywgdmFsdWUuc3R5bGVzKTtcbiAgICAgICAgICB0ZXh0Q29udGVudC5pdGVtcy5wdXNoKC4uLnZhbHVlLml0ZW1zKTtcbiAgICAgICAgICBwdW1wKCk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZWFkZXIgPSByZWFkYWJsZVN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICAgIGNvbnN0IHRleHRDb250ZW50ID0ge1xuICAgICAgICBpdGVtczogW10sXG4gICAgICAgIHN0eWxlczogLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgIGxhbmc6IG51bGxcbiAgICAgIH07XG4gICAgICBwdW1wKCk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0U3RydWN0VHJlZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFN0cnVjdFRyZWUodGhpcy5fcGFnZUluZGV4KTtcbiAgfVxuICBfZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgY29uc3Qgd2FpdE9uID0gW107XG4gICAgZm9yIChjb25zdCBpbnRlbnRTdGF0ZSBvZiB0aGlzLl9pbnRlbnRTdGF0ZXMudmFsdWVzKCkpIHtcbiAgICAgIHRoaXMuX2Fib3J0T3BlcmF0b3JMaXN0KHtcbiAgICAgICAgaW50ZW50U3RhdGUsXG4gICAgICAgIHJlYXNvbjogbmV3IEVycm9yKFwiUGFnZSB3YXMgZGVzdHJveWVkLlwiKSxcbiAgICAgICAgZm9yY2U6IHRydWVcbiAgICAgIH0pO1xuICAgICAgaWYgKGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBpbnRlcm5hbFJlbmRlclRhc2sgb2YgaW50ZW50U3RhdGUucmVuZGVyVGFza3MpIHtcbiAgICAgICAgd2FpdE9uLnB1c2goaW50ZXJuYWxSZW5kZXJUYXNrLmNvbXBsZXRlZCk7XG4gICAgICAgIGludGVybmFsUmVuZGVyVGFzay5jYW5jZWwoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5vYmpzLmNsZWFyKCk7XG4gICAgdGhpcy4jcGVuZGluZ0NsZWFudXAgPSBmYWxzZTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwod2FpdE9uKTtcbiAgfVxuICBjbGVhbnVwKHJlc2V0U3RhdHMgPSBmYWxzZSkge1xuICAgIHRoaXMuI3BlbmRpbmdDbGVhbnVwID0gdHJ1ZTtcbiAgICBjb25zdCBzdWNjZXNzID0gdGhpcy4jdHJ5Q2xlYW51cCgpO1xuICAgIGlmIChyZXNldFN0YXRzICYmIHN1Y2Nlc3MpIHtcbiAgICAgIHRoaXMuX3N0YXRzICYmPSBuZXcgU3RhdFRpbWVyKCk7XG4gICAgfVxuICAgIHJldHVybiBzdWNjZXNzO1xuICB9XG4gICN0cnlDbGVhbnVwKCkge1xuICAgIGlmICghdGhpcy4jcGVuZGluZ0NsZWFudXAgfHwgdGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB7XG4gICAgICByZW5kZXJUYXNrcyxcbiAgICAgIG9wZXJhdG9yTGlzdFxuICAgIH0gb2YgdGhpcy5faW50ZW50U3RhdGVzLnZhbHVlcygpKSB7XG4gICAgICBpZiAocmVuZGVyVGFza3Muc2l6ZSA+IDAgfHwgIW9wZXJhdG9yTGlzdC5sYXN0Q2h1bmspIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9pbnRlbnRTdGF0ZXMuY2xlYXIoKTtcbiAgICB0aGlzLm9ianMuY2xlYXIoKTtcbiAgICB0aGlzLiNwZW5kaW5nQ2xlYW51cCA9IGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIF9zdGFydFJlbmRlclBhZ2UodHJhbnNwYXJlbmN5LCBjYWNoZUtleSkge1xuICAgIGNvbnN0IGludGVudFN0YXRlID0gdGhpcy5faW50ZW50U3RhdGVzLmdldChjYWNoZUtleSk7XG4gICAgaWYgKCFpbnRlbnRTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9zdGF0cz8udGltZUVuZChcIlBhZ2UgUmVxdWVzdFwiKTtcbiAgICBpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5Py5yZXNvbHZlKHRyYW5zcGFyZW5jeSk7XG4gIH1cbiAgX3JlbmRlclBhZ2VDaHVuayhvcGVyYXRvckxpc3RDaHVuaywgaW50ZW50U3RhdGUpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBvcGVyYXRvckxpc3RDaHVuay5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QuZm5BcnJheS5wdXNoKG9wZXJhdG9yTGlzdENodW5rLmZuQXJyYXlbaV0pO1xuICAgICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0LmFyZ3NBcnJheS5wdXNoKG9wZXJhdG9yTGlzdENodW5rLmFyZ3NBcnJheVtpXSk7XG4gICAgfVxuICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5sYXN0Q2h1bmsgPSBvcGVyYXRvckxpc3RDaHVuay5sYXN0Q2h1bms7XG4gICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0LnNlcGFyYXRlQW5ub3RzID0gb3BlcmF0b3JMaXN0Q2h1bmsuc2VwYXJhdGVBbm5vdHM7XG4gICAgZm9yIChjb25zdCBpbnRlcm5hbFJlbmRlclRhc2sgb2YgaW50ZW50U3RhdGUucmVuZGVyVGFza3MpIHtcbiAgICAgIGludGVybmFsUmVuZGVyVGFzay5vcGVyYXRvckxpc3RDaGFuZ2VkKCk7XG4gICAgfVxuICAgIGlmIChvcGVyYXRvckxpc3RDaHVuay5sYXN0Q2h1bmspIHtcbiAgICAgIHRoaXMuI3RyeUNsZWFudXAoKTtcbiAgICB9XG4gIH1cbiAgX3B1bXBPcGVyYXRvckxpc3Qoe1xuICAgIHJlbmRlcmluZ0ludGVudCxcbiAgICBjYWNoZUtleSxcbiAgICBhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZSxcbiAgICBtb2RpZmllZElkc1xuICB9KSB7XG4gICAgY29uc3Qge1xuICAgICAgbWFwLFxuICAgICAgdHJhbnNmZXJcbiAgICB9ID0gYW5ub3RhdGlvblN0b3JhZ2VTZXJpYWxpemFibGU7XG4gICAgY29uc3QgcmVhZGFibGVTdHJlYW0gPSB0aGlzLl90cmFuc3BvcnQubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhTdHJlYW0oXCJHZXRPcGVyYXRvckxpc3RcIiwge1xuICAgICAgcGFnZUluZGV4OiB0aGlzLl9wYWdlSW5kZXgsXG4gICAgICBpbnRlbnQ6IHJlbmRlcmluZ0ludGVudCxcbiAgICAgIGNhY2hlS2V5LFxuICAgICAgYW5ub3RhdGlvblN0b3JhZ2U6IG1hcCxcbiAgICAgIG1vZGlmaWVkSWRzXG4gICAgfSwgdHJhbnNmZXIpO1xuICAgIGNvbnN0IHJlYWRlciA9IHJlYWRhYmxlU3RyZWFtLmdldFJlYWRlcigpO1xuICAgIGNvbnN0IGludGVudFN0YXRlID0gdGhpcy5faW50ZW50U3RhdGVzLmdldChjYWNoZUtleSk7XG4gICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyID0gcmVhZGVyO1xuICAgIGNvbnN0IHB1bXAgPSAoKSA9PiB7XG4gICAgICByZWFkZXIucmVhZCgpLnRoZW4oKHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGRvbmVcbiAgICAgIH0pID0+IHtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXIgPSBudWxsO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdHJhbnNwb3J0LmRlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZW5kZXJQYWdlQ2h1bmsodmFsdWUsIGludGVudFN0YXRlKTtcbiAgICAgICAgcHVtcCgpO1xuICAgICAgfSwgKHJlYXNvbikgPT4ge1xuICAgICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXIgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5fdHJhbnNwb3J0LmRlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0KSB7XG4gICAgICAgICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0Lmxhc3RDaHVuayA9IHRydWU7XG4gICAgICAgICAgZm9yIChjb25zdCBpbnRlcm5hbFJlbmRlclRhc2sgb2YgaW50ZW50U3RhdGUucmVuZGVyVGFza3MpIHtcbiAgICAgICAgICAgIGludGVybmFsUmVuZGVyVGFzay5vcGVyYXRvckxpc3RDaGFuZ2VkKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuI3RyeUNsZWFudXAoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eSkge1xuICAgICAgICAgIGludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkucmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH0gZWxzZSBpZiAoaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkpIHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eS5yZWplY3QocmVhc29uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyByZWFzb247XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgcHVtcCgpO1xuICB9XG4gIF9hYm9ydE9wZXJhdG9yTGlzdCh7XG4gICAgaW50ZW50U3RhdGUsXG4gICAgcmVhc29uLFxuICAgIGZvcmNlID0gZmFsc2VcbiAgfSkge1xuICAgIGlmICghaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQoaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCk7XG4gICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFmb3JjZSkge1xuICAgICAgaWYgKGludGVudFN0YXRlLnJlbmRlclRhc2tzLnNpemUgPiAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChyZWFzb24gaW5zdGFuY2VvZiBSZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24pIHtcbiAgICAgICAgbGV0IGRlbGF5ID0gUkVOREVSSU5HX0NBTkNFTExFRF9USU1FT1VUO1xuICAgICAgICBpZiAocmVhc29uLmV4dHJhRGVsYXkgPiAwICYmIHJlYXNvbi5leHRyYURlbGF5IDwgMWUzKSB7XG4gICAgICAgICAgZGVsYXkgKz0gcmVhc29uLmV4dHJhRGVsYXk7XG4gICAgICAgIH1cbiAgICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgIHRoaXMuX2Fib3J0T3BlcmF0b3JMaXN0KHtcbiAgICAgICAgICAgIGludGVudFN0YXRlLFxuICAgICAgICAgICAgcmVhc29uLFxuICAgICAgICAgICAgZm9yY2U6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlci5jYW5jZWwobmV3IEFib3J0RXhjZXB0aW9uKHJlYXNvbi5tZXNzYWdlKSkuY2F0Y2goKCkgPT4ge1xuICAgIH0pO1xuICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlciA9IG51bGw7XG4gICAgaWYgKHRoaXMuX3RyYW5zcG9ydC5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbY3VyQ2FjaGVLZXksIGN1ckludGVudFN0YXRlXSBvZiB0aGlzLl9pbnRlbnRTdGF0ZXMpIHtcbiAgICAgIGlmIChjdXJJbnRlbnRTdGF0ZSA9PT0gaW50ZW50U3RhdGUpIHtcbiAgICAgICAgdGhpcy5faW50ZW50U3RhdGVzLmRlbGV0ZShjdXJDYWNoZUtleSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNsZWFudXAoKTtcbiAgfVxuICBnZXQgc3RhdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRzO1xuICB9XG59XG5jb25zdCBfUERGV29ya2VyID0gY2xhc3MgX1BERldvcmtlciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBuYW1lID0gbnVsbCxcbiAgICBwb3J0ID0gbnVsbCxcbiAgICB2ZXJib3NpdHk6IHZlcmJvc2l0eTIgPSBnZXRWZXJib3NpdHlMZXZlbCgpXG4gIH0gPSB7fSkge1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfUERGV29ya2VyX2luc3RhbmNlcyk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9jYXBhYmlsaXR5LCBQcm9taXNlLndpdGhSZXNvbHZlcnMoKSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9tZXNzYWdlSGFuZGxlciwgbnVsbCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9wb3J0LCBudWxsKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3dlYldvcmtlciwgbnVsbCk7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMudmVyYm9zaXR5ID0gdmVyYm9zaXR5MjtcbiAgICBpZiAocG9ydCkge1xuICAgICAgaWYgKF9fcHJpdmF0ZUdldChfUERGV29ya2VyLCBfd29ya2VyUG9ydHMpLmhhcyhwb3J0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdXNlIG1vcmUgdGhhbiBvbmUgUERGV29ya2VyIHBlciBwb3J0LlwiKTtcbiAgICAgIH1cbiAgICAgIF9fcHJpdmF0ZUdldChfUERGV29ya2VyLCBfd29ya2VyUG9ydHMpLnNldChwb3J0LCB0aGlzKTtcbiAgICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfUERGV29ya2VyX2luc3RhbmNlcywgaW5pdGlhbGl6ZUZyb21Qb3J0X2ZuKS5jYWxsKHRoaXMsIHBvcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfX3ByaXZhdGVNZXRob2QodGhpcywgX1BERldvcmtlcl9pbnN0YW5jZXMsIGluaXRpYWxpemVfZm4pLmNhbGwodGhpcyk7XG4gICAgfVxuICB9XG4gIGdldCBwcm9taXNlKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX2NhcGFiaWxpdHkpLnByb21pc2U7XG4gIH1cbiAgZ2V0IHBvcnQoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfcG9ydCk7XG4gIH1cbiAgZ2V0IG1lc3NhZ2VIYW5kbGVyKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX21lc3NhZ2VIYW5kbGVyKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX3dlYldvcmtlcik/LnRlcm1pbmF0ZSgpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfd2ViV29ya2VyLCBudWxsKTtcbiAgICBfX3ByaXZhdGVHZXQoX1BERldvcmtlciwgX3dvcmtlclBvcnRzKS5kZWxldGUoX19wcml2YXRlR2V0KHRoaXMsIF9wb3J0KSk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9wb3J0LCBudWxsKTtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX21lc3NhZ2VIYW5kbGVyKT8uZGVzdHJveSgpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfbWVzc2FnZUhhbmRsZXIsIG51bGwpO1xuICB9XG4gIHN0YXRpYyBjcmVhdGUocGFyYW1zKSB7XG4gICAgY29uc3QgY2FjaGVkUG9ydCA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfd29ya2VyUG9ydHMpLmdldChwYXJhbXM/LnBvcnQpO1xuICAgIGlmIChjYWNoZWRQb3J0KSB7XG4gICAgICBpZiAoY2FjaGVkUG9ydC5fcGVuZGluZ0Rlc3Ryb3kpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUERGV29ya2VyLmNyZWF0ZSAtIHRoZSB3b3JrZXIgaXMgYmVpbmcgZGVzdHJveWVkLlxcblBsZWFzZSByZW1lbWJlciB0byBhd2FpdCBgUERGRG9jdW1lbnRMb2FkaW5nVGFzay5kZXN0cm95KClgLWNhbGxzLlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYWNoZWRQb3J0O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9QREZXb3JrZXIocGFyYW1zKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHdvcmtlclNyYygpIHtcbiAgICBpZiAoR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmMpIHtcbiAgICAgIHJldHVybiBHbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyYztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBcIkdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjXCIgc3BlY2lmaWVkLicpO1xuICB9XG4gIHN0YXRpYyBnZXQgX3NldHVwRmFrZVdvcmtlckdsb2JhbCgpIHtcbiAgICBjb25zdCBsb2FkZXIgPSBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9QREZXb3JrZXJfc3RhdGljLCBtYWluVGhyZWFkV29ya2VyTWVzc2FnZUhhbmRsZXJfZ2V0KSkge1xuICAgICAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9QREZXb3JrZXJfc3RhdGljLCBtYWluVGhyZWFkV29ya2VyTWVzc2FnZUhhbmRsZXJfZ2V0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdvcmtlciA9IGF3YWl0IGltcG9ydChcbiAgICAgICAgLyp3ZWJwYWNrSWdub3JlOiB0cnVlKi9cbiAgICAgICAgLypAdml0ZS1pZ25vcmUqL1xuICAgICAgICB0aGlzLndvcmtlclNyY1xuICAgICAgKTtcbiAgICAgIHJldHVybiB3b3JrZXIuV29ya2VyTWVzc2FnZUhhbmRsZXI7XG4gICAgfTtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX3NldHVwRmFrZVdvcmtlckdsb2JhbFwiLCBsb2FkZXIoKSk7XG4gIH1cbn07XG5fY2FwYWJpbGl0eSA9IG5ldyBXZWFrTWFwKCk7XG5fbWVzc2FnZUhhbmRsZXIgPSBuZXcgV2Vha01hcCgpO1xuX3BvcnQgPSBuZXcgV2Vha01hcCgpO1xuX3dlYldvcmtlciA9IG5ldyBXZWFrTWFwKCk7XG5fZmFrZVdvcmtlcklkID0gbmV3IFdlYWtNYXAoKTtcbl9pc1dvcmtlckRpc2FibGVkID0gbmV3IFdlYWtNYXAoKTtcbl93b3JrZXJQb3J0cyA9IG5ldyBXZWFrTWFwKCk7XG5fUERGV29ya2VyX2luc3RhbmNlcyA9IG5ldyBXZWFrU2V0KCk7XG5yZXNvbHZlX2ZuID0gZnVuY3Rpb24oKSB7XG4gIF9fcHJpdmF0ZUdldCh0aGlzLCBfY2FwYWJpbGl0eSkucmVzb2x2ZSgpO1xuICBfX3ByaXZhdGVHZXQodGhpcywgX21lc3NhZ2VIYW5kbGVyKS5zZW5kKFwiY29uZmlndXJlXCIsIHtcbiAgICB2ZXJib3NpdHk6IHRoaXMudmVyYm9zaXR5XG4gIH0pO1xufTtcbmluaXRpYWxpemVGcm9tUG9ydF9mbiA9IGZ1bmN0aW9uKHBvcnQpIHtcbiAgX19wcml2YXRlU2V0KHRoaXMsIF9wb3J0LCBwb3J0KTtcbiAgX19wcml2YXRlU2V0KHRoaXMsIF9tZXNzYWdlSGFuZGxlciwgbmV3IE1lc3NhZ2VIYW5kbGVyKFwibWFpblwiLCBcIndvcmtlclwiLCBwb3J0KSk7XG4gIF9fcHJpdmF0ZUdldCh0aGlzLCBfbWVzc2FnZUhhbmRsZXIpLm9uKFwicmVhZHlcIiwgKCkgPT4ge1xuICB9KTtcbiAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9QREZXb3JrZXJfaW5zdGFuY2VzLCByZXNvbHZlX2ZuKS5jYWxsKHRoaXMpO1xufTtcbmluaXRpYWxpemVfZm4gPSBmdW5jdGlvbigpIHtcbiAgaWYgKF9fcHJpdmF0ZUdldChfUERGV29ya2VyLCBfaXNXb3JrZXJEaXNhYmxlZCkgfHwgX19wcml2YXRlR2V0KF9QREZXb3JrZXIsIF9QREZXb3JrZXJfc3RhdGljLCBtYWluVGhyZWFkV29ya2VyTWVzc2FnZUhhbmRsZXJfZ2V0KSkge1xuICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfUERGV29ya2VyX2luc3RhbmNlcywgc2V0dXBGYWtlV29ya2VyX2ZuKS5jYWxsKHRoaXMpO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQge1xuICAgIHdvcmtlclNyY1xuICB9ID0gX1BERldvcmtlcjtcbiAgdHJ5IHtcbiAgICBpZiAoIV9QREZXb3JrZXIuX2lzU2FtZU9yaWdpbih3aW5kb3cubG9jYXRpb24sIHdvcmtlclNyYykpIHtcbiAgICAgIHdvcmtlclNyYyA9IF9QREZXb3JrZXIuX2NyZWF0ZUNETldyYXBwZXIobmV3IFVSTCh3b3JrZXJTcmMsIHdpbmRvdy5sb2NhdGlvbikuaHJlZik7XG4gICAgfVxuICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyU3JjLCB7XG4gICAgICB0eXBlOiBcIm1vZHVsZVwiXG4gICAgfSk7XG4gICAgY29uc3QgbWVzc2FnZUhhbmRsZXIgPSBuZXcgTWVzc2FnZUhhbmRsZXIoXCJtYWluXCIsIFwid29ya2VyXCIsIHdvcmtlcik7XG4gICAgY29uc3QgdGVybWluYXRlRWFybHkgPSAoKSA9PiB7XG4gICAgICBhYy5hYm9ydCgpO1xuICAgICAgbWVzc2FnZUhhbmRsZXIuZGVzdHJveSgpO1xuICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfY2FwYWJpbGl0eSkucmVqZWN0KG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkXCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfUERGV29ya2VyX2luc3RhbmNlcywgc2V0dXBGYWtlV29ya2VyX2ZuKS5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgYWMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoKSA9PiB7XG4gICAgICBpZiAoIV9fcHJpdmF0ZUdldCh0aGlzLCBfd2ViV29ya2VyKSkge1xuICAgICAgICB0ZXJtaW5hdGVFYXJseSgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHNpZ25hbDogYWMuc2lnbmFsXG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJ0ZXN0XCIsIChkYXRhKSA9PiB7XG4gICAgICBhYy5hYm9ydCgpO1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkIHx8ICFkYXRhKSB7XG4gICAgICAgIHRlcm1pbmF0ZUVhcmx5KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfbWVzc2FnZUhhbmRsZXIsIG1lc3NhZ2VIYW5kbGVyKTtcbiAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfcG9ydCwgd29ya2VyKTtcbiAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfd2ViV29ya2VyLCB3b3JrZXIpO1xuICAgICAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9QREZXb3JrZXJfaW5zdGFuY2VzLCByZXNvbHZlX2ZuKS5jYWxsKHRoaXMpO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwicmVhZHlcIiwgKGRhdGEpID0+IHtcbiAgICAgIGFjLmFib3J0KCk7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgdGVybWluYXRlRWFybHkoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgc2VuZFRlc3QoKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICBfX3ByaXZhdGVNZXRob2QodGhpcywgX1BERldvcmtlcl9pbnN0YW5jZXMsIHNldHVwRmFrZVdvcmtlcl9mbikuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBzZW5kVGVzdCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RPYmogPSBuZXcgVWludDhBcnJheSgpO1xuICAgICAgbWVzc2FnZUhhbmRsZXIuc2VuZChcInRlc3RcIiwgdGVzdE9iaiwgW3Rlc3RPYmouYnVmZmVyXSk7XG4gICAgfTtcbiAgICBzZW5kVGVzdCgpO1xuICAgIHJldHVybjtcbiAgfSBjYXRjaCB7XG4gICAgaW5mbyhcIlRoZSB3b3JrZXIgaGFzIGJlZW4gZGlzYWJsZWQuXCIpO1xuICB9XG4gIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfUERGV29ya2VyX2luc3RhbmNlcywgc2V0dXBGYWtlV29ya2VyX2ZuKS5jYWxsKHRoaXMpO1xufTtcbnNldHVwRmFrZVdvcmtlcl9mbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIV9fcHJpdmF0ZUdldChfUERGV29ya2VyLCBfaXNXb3JrZXJEaXNhYmxlZCkpIHtcbiAgICB3YXJuKFwiU2V0dGluZyB1cCBmYWtlIHdvcmtlci5cIik7XG4gICAgX19wcml2YXRlU2V0KF9QREZXb3JrZXIsIF9pc1dvcmtlckRpc2FibGVkLCB0cnVlKTtcbiAgfVxuICBfUERGV29ya2VyLl9zZXR1cEZha2VXb3JrZXJHbG9iYWwudGhlbigoV29ya2VyTWVzc2FnZUhhbmRsZXIpID0+IHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfY2FwYWJpbGl0eSkucmVqZWN0KG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkXCIpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcG9ydCA9IG5ldyBMb29wYmFja1BvcnQoKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX3BvcnQsIHBvcnQpO1xuICAgIGNvbnN0IGlkID0gYGZha2Uke19fcHJpdmF0ZVdyYXBwZXIoX1BERldvcmtlciwgX2Zha2VXb3JrZXJJZCkuXysrfWA7XG4gICAgY29uc3Qgd29ya2VySGFuZGxlciA9IG5ldyBNZXNzYWdlSGFuZGxlcihpZCArIFwiX3dvcmtlclwiLCBpZCwgcG9ydCk7XG4gICAgV29ya2VyTWVzc2FnZUhhbmRsZXIuc2V0dXAod29ya2VySGFuZGxlciwgcG9ydCk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9tZXNzYWdlSGFuZGxlciwgbmV3IE1lc3NhZ2VIYW5kbGVyKGlkLCBpZCArIFwiX3dvcmtlclwiLCBwb3J0KSk7XG4gICAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9QREZXb3JrZXJfaW5zdGFuY2VzLCByZXNvbHZlX2ZuKS5jYWxsKHRoaXMpO1xuICB9KS5jYXRjaCgocmVhc29uKSA9PiB7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9jYXBhYmlsaXR5KS5yZWplY3QobmV3IEVycm9yKGBTZXR0aW5nIHVwIGZha2Ugd29ya2VyIGZhaWxlZDogXCIke3JlYXNvbi5tZXNzYWdlfVwiLmApKTtcbiAgfSk7XG59O1xuX1BERldvcmtlcl9zdGF0aWMgPSBuZXcgV2Vha1NldCgpO1xubWFpblRocmVhZFdvcmtlck1lc3NhZ2VIYW5kbGVyX2dldCA9IGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHJldHVybiBnbG9iYWxUaGlzLnBkZmpzV29ya2VyPy5Xb3JrZXJNZXNzYWdlSGFuZGxlciB8fCBudWxsO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcbl9fcHJpdmF0ZUFkZChfUERGV29ya2VyLCBfUERGV29ya2VyX3N0YXRpYyk7XG5fX3ByaXZhdGVBZGQoX1BERldvcmtlciwgX2Zha2VXb3JrZXJJZCwgMCk7XG5fX3ByaXZhdGVBZGQoX1BERldvcmtlciwgX2lzV29ya2VyRGlzYWJsZWQsIGZhbHNlKTtcbl9fcHJpdmF0ZUFkZChfUERGV29ya2VyLCBfd29ya2VyUG9ydHMsIC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpKTtcbigoKSA9PiB7XG4gIGlmIChpc05vZGVKUykge1xuICAgIF9fcHJpdmF0ZVNldChfUERGV29ya2VyLCBfaXNXb3JrZXJEaXNhYmxlZCwgdHJ1ZSk7XG4gICAgR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmMgfHw9IFwiLi9wZGYud29ya2VyLm1qc1wiO1xuICB9XG4gIF9QREZXb3JrZXIuX2lzU2FtZU9yaWdpbiA9IChiYXNlVXJsLCBvdGhlclVybCkgPT4ge1xuICAgIGNvbnN0IGJhc2UgPSBVUkwucGFyc2UoYmFzZVVybCk7XG4gICAgaWYgKCFiYXNlPy5vcmlnaW4gfHwgYmFzZS5vcmlnaW4gPT09IFwibnVsbFwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG90aGVyID0gbmV3IFVSTChvdGhlclVybCwgYmFzZSk7XG4gICAgcmV0dXJuIGJhc2Uub3JpZ2luID09PSBvdGhlci5vcmlnaW47XG4gIH07XG4gIF9QREZXb3JrZXIuX2NyZWF0ZUNETldyYXBwZXIgPSAodXJsKSA9PiB7XG4gICAgY29uc3Qgd3JhcHBlciA9IGBhd2FpdCBpbXBvcnQoXCIke3VybH1cIik7YDtcbiAgICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbd3JhcHBlcl0sIHtcbiAgICAgIHR5cGU6IFwidGV4dC9qYXZhc2NyaXB0XCJcbiAgICB9KSk7XG4gIH07XG4gIF9QREZXb3JrZXIuZnJvbVBvcnQgPSAocGFyYW1zKSA9PiB7XG4gICAgZGVwcmVjYXRlZChcImBQREZXb3JrZXIuZnJvbVBvcnRgIC0gcGxlYXNlIHVzZSBgUERGV29ya2VyLmNyZWF0ZWAgaW5zdGVhZC5cIik7XG4gICAgaWYgKCFwYXJhbXM/LnBvcnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBERldvcmtlci5mcm9tUG9ydCAtIGludmFsaWQgbWV0aG9kIHNpZ25hdHVyZS5cIik7XG4gICAgfVxuICAgIHJldHVybiBfUERGV29ya2VyLmNyZWF0ZShwYXJhbXMpO1xuICB9O1xufSkoKTtcbmxldCBQREZXb3JrZXIgPSBfUERGV29ya2VyO1xuY2xhc3MgV29ya2VyVHJhbnNwb3J0IHtcbiAgI21ldGhvZFByb21pc2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgI3BhZ2VDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICNwYWdlUHJvbWlzZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAjcGFnZVJlZkNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgI3Bhc3N3b3JkQ2FwYWJpbGl0eSA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2VIYW5kbGVyLCBsb2FkaW5nVGFzaywgbmV0d29ya1N0cmVhbSwgcGFyYW1zLCBmYWN0b3J5LCBlbmFibGVIV0EpIHtcbiAgICB0aGlzLm1lc3NhZ2VIYW5kbGVyID0gbWVzc2FnZUhhbmRsZXI7XG4gICAgdGhpcy5sb2FkaW5nVGFzayA9IGxvYWRpbmdUYXNrO1xuICAgIHRoaXMuY29tbW9uT2JqcyA9IG5ldyBQREZPYmplY3RzKCk7XG4gICAgdGhpcy5mb250TG9hZGVyID0gbmV3IEZvbnRMb2FkZXIoe1xuICAgICAgb3duZXJEb2N1bWVudDogcGFyYW1zLm93bmVyRG9jdW1lbnQsXG4gICAgICBzdHlsZUVsZW1lbnQ6IHBhcmFtcy5zdHlsZUVsZW1lbnRcbiAgICB9KTtcbiAgICB0aGlzLmxvYWRpbmdQYXJhbXMgPSBwYXJhbXMubG9hZGluZ1BhcmFtcztcbiAgICB0aGlzLl9wYXJhbXMgPSBwYXJhbXM7XG4gICAgdGhpcy5jYW52YXNGYWN0b3J5ID0gZmFjdG9yeS5jYW52YXNGYWN0b3J5O1xuICAgIHRoaXMuZmlsdGVyRmFjdG9yeSA9IGZhY3RvcnkuZmlsdGVyRmFjdG9yeTtcbiAgICB0aGlzLmNNYXBSZWFkZXJGYWN0b3J5ID0gZmFjdG9yeS5jTWFwUmVhZGVyRmFjdG9yeTtcbiAgICB0aGlzLnN0YW5kYXJkRm9udERhdGFGYWN0b3J5ID0gZmFjdG9yeS5zdGFuZGFyZEZvbnREYXRhRmFjdG9yeTtcbiAgICB0aGlzLndhc21GYWN0b3J5ID0gZmFjdG9yeS53YXNtRmFjdG9yeTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkgPSBudWxsO1xuICAgIHRoaXMuX25ldHdvcmtTdHJlYW0gPSBuZXR3b3JrU3RyZWFtO1xuICAgIHRoaXMuX2Z1bGxSZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX2xhc3RQcm9ncmVzcyA9IG51bGw7XG4gICAgdGhpcy5kb3dubG9hZEluZm9DYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5lbmFibGVIV0EgPSBlbmFibGVIV0E7XG4gICAgdGhpcy5zZXR1cE1lc3NhZ2VIYW5kbGVyKCk7XG4gIH1cbiAgI2NhY2hlU2ltcGxlTWV0aG9kKG5hbWUsIGRhdGEgPSBudWxsKSB7XG4gICAgY29uc3QgY2FjaGVkUHJvbWlzZSA9IHRoaXMuI21ldGhvZFByb21pc2VzLmdldChuYW1lKTtcbiAgICBpZiAoY2FjaGVkUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIGNhY2hlZFByb21pc2U7XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShuYW1lLCBkYXRhKTtcbiAgICB0aGlzLiNtZXRob2RQcm9taXNlcy5zZXQobmFtZSwgcHJvbWlzZSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgZ2V0IGFubm90YXRpb25TdG9yYWdlKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJhbm5vdGF0aW9uU3RvcmFnZVwiLCBuZXcgQW5ub3RhdGlvblN0b3JhZ2UoKSk7XG4gIH1cbiAgZ2V0UmVuZGVyaW5nSW50ZW50KGludGVudCwgYW5ub3RhdGlvbk1vZGUgPSBBbm5vdGF0aW9uTW9kZS5FTkFCTEUsIHByaW50QW5ub3RhdGlvblN0b3JhZ2UgPSBudWxsLCBpc0VkaXRpbmcgPSBmYWxzZSwgaXNPcExpc3QgPSBmYWxzZSkge1xuICAgIGxldCByZW5kZXJpbmdJbnRlbnQgPSBSZW5kZXJpbmdJbnRlbnRGbGFnLkRJU1BMQVk7XG4gICAgbGV0IGFubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlID0gU2VyaWFsaXphYmxlRW1wdHk7XG4gICAgc3dpdGNoIChpbnRlbnQpIHtcbiAgICAgIGNhc2UgXCJhbnlcIjpcbiAgICAgICAgcmVuZGVyaW5nSW50ZW50ID0gUmVuZGVyaW5nSW50ZW50RmxhZy5BTlk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRpc3BsYXlcIjpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicHJpbnRcIjpcbiAgICAgICAgcmVuZGVyaW5nSW50ZW50ID0gUmVuZGVyaW5nSW50ZW50RmxhZy5QUklOVDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB3YXJuKGBnZXRSZW5kZXJpbmdJbnRlbnQgLSBpbnZhbGlkIGludGVudDogJHtpbnRlbnR9YCk7XG4gICAgfVxuICAgIGNvbnN0IGFubm90YXRpb25TdG9yYWdlID0gcmVuZGVyaW5nSW50ZW50ICYgUmVuZGVyaW5nSW50ZW50RmxhZy5QUklOVCAmJiBwcmludEFubm90YXRpb25TdG9yYWdlIGluc3RhbmNlb2YgUHJpbnRBbm5vdGF0aW9uU3RvcmFnZSA/IHByaW50QW5ub3RhdGlvblN0b3JhZ2UgOiB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIHN3aXRjaCAoYW5ub3RhdGlvbk1vZGUpIHtcbiAgICAgIGNhc2UgQW5ub3RhdGlvbk1vZGUuRElTQUJMRTpcbiAgICAgICAgcmVuZGVyaW5nSW50ZW50ICs9IFJlbmRlcmluZ0ludGVudEZsYWcuQU5OT1RBVElPTlNfRElTQUJMRTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFubm90YXRpb25Nb2RlLkVOQUJMRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFubm90YXRpb25Nb2RlLkVOQUJMRV9GT1JNUzpcbiAgICAgICAgcmVuZGVyaW5nSW50ZW50ICs9IFJlbmRlcmluZ0ludGVudEZsYWcuQU5OT1RBVElPTlNfRk9STVM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uTW9kZS5FTkFCTEVfU1RPUkFHRTpcbiAgICAgICAgcmVuZGVyaW5nSW50ZW50ICs9IFJlbmRlcmluZ0ludGVudEZsYWcuQU5OT1RBVElPTlNfU1RPUkFHRTtcbiAgICAgICAgYW5ub3RhdGlvblN0b3JhZ2VTZXJpYWxpemFibGUgPSBhbm5vdGF0aW9uU3RvcmFnZS5zZXJpYWxpemFibGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgd2FybihgZ2V0UmVuZGVyaW5nSW50ZW50IC0gaW52YWxpZCBhbm5vdGF0aW9uTW9kZTogJHthbm5vdGF0aW9uTW9kZX1gKTtcbiAgICB9XG4gICAgaWYgKGlzRWRpdGluZykge1xuICAgICAgcmVuZGVyaW5nSW50ZW50ICs9IFJlbmRlcmluZ0ludGVudEZsYWcuSVNfRURJVElORztcbiAgICB9XG4gICAgaWYgKGlzT3BMaXN0KSB7XG4gICAgICByZW5kZXJpbmdJbnRlbnQgKz0gUmVuZGVyaW5nSW50ZW50RmxhZy5PUExJU1Q7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGlkczogbW9kaWZpZWRJZHMsXG4gICAgICBoYXNoOiBtb2RpZmllZElkc0hhc2hcbiAgICB9ID0gYW5ub3RhdGlvblN0b3JhZ2UubW9kaWZpZWRJZHM7XG4gICAgY29uc3QgY2FjaGVLZXlCdWYgPSBbcmVuZGVyaW5nSW50ZW50LCBhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZS5oYXNoLCBtb2RpZmllZElkc0hhc2hdO1xuICAgIHJldHVybiB7XG4gICAgICByZW5kZXJpbmdJbnRlbnQsXG4gICAgICBjYWNoZUtleTogY2FjaGVLZXlCdWYuam9pbihcIl9cIiksXG4gICAgICBhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZSxcbiAgICAgIG1vZGlmaWVkSWRzXG4gICAgfTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5KSB7XG4gICAgICByZXR1cm4gdGhpcy5kZXN0cm95Q2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIH1cbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgdGhpcy5kZXN0cm95Q2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuI3Bhc3N3b3JkQ2FwYWJpbGl0eT8ucmVqZWN0KG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkIGR1cmluZyBvblBhc3N3b3JkIGNhbGxiYWNrXCIpKTtcbiAgICBjb25zdCB3YWl0T24gPSBbXTtcbiAgICBmb3IgKGNvbnN0IHBhZ2Ugb2YgdGhpcy4jcGFnZUNhY2hlLnZhbHVlcygpKSB7XG4gICAgICB3YWl0T24ucHVzaChwYWdlLl9kZXN0cm95KCkpO1xuICAgIH1cbiAgICB0aGlzLiNwYWdlQ2FjaGUuY2xlYXIoKTtcbiAgICB0aGlzLiNwYWdlUHJvbWlzZXMuY2xlYXIoKTtcbiAgICB0aGlzLiNwYWdlUmVmQ2FjaGUuY2xlYXIoKTtcbiAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShcImFubm90YXRpb25TdG9yYWdlXCIpKSB7XG4gICAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlLnJlc2V0TW9kaWZpZWQoKTtcbiAgICB9XG4gICAgY29uc3QgdGVybWluYXRlZCA9IHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiVGVybWluYXRlXCIsIG51bGwpO1xuICAgIHdhaXRPbi5wdXNoKHRlcm1pbmF0ZWQpO1xuICAgIFByb21pc2UuYWxsKHdhaXRPbikudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLmNvbW1vbk9ianMuY2xlYXIoKTtcbiAgICAgIHRoaXMuZm9udExvYWRlci5jbGVhcigpO1xuICAgICAgdGhpcy4jbWV0aG9kUHJvbWlzZXMuY2xlYXIoKTtcbiAgICAgIHRoaXMuZmlsdGVyRmFjdG9yeS5kZXN0cm95KCk7XG4gICAgICBUZXh0TGF5ZXIuY2xlYW51cCgpO1xuICAgICAgdGhpcy5fbmV0d29ya1N0cmVhbT8uY2FuY2VsQWxsUmVxdWVzdHMobmV3IEFib3J0RXhjZXB0aW9uKFwiV29ya2VyIHdhcyB0ZXJtaW5hdGVkLlwiKSk7XG4gICAgICB0aGlzLm1lc3NhZ2VIYW5kbGVyPy5kZXN0cm95KCk7XG4gICAgICB0aGlzLm1lc3NhZ2VIYW5kbGVyID0gbnVsbDtcbiAgICAgIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0sIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkucmVqZWN0KTtcbiAgICByZXR1cm4gdGhpcy5kZXN0cm95Q2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIHNldHVwTWVzc2FnZUhhbmRsZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbWVzc2FnZUhhbmRsZXIsXG4gICAgICBsb2FkaW5nVGFza1xuICAgIH0gPSB0aGlzO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiR2V0UmVhZGVyXCIsIChkYXRhLCBzaW5rKSA9PiB7XG4gICAgICBhc3NlcnQodGhpcy5fbmV0d29ya1N0cmVhbSwgXCJHZXRSZWFkZXIgLSBubyBgSVBERlN0cmVhbWAgaW5zdGFuY2UgYXZhaWxhYmxlLlwiKTtcbiAgICAgIHRoaXMuX2Z1bGxSZWFkZXIgPSB0aGlzLl9uZXR3b3JrU3RyZWFtLmdldEZ1bGxSZWFkZXIoKTtcbiAgICAgIHRoaXMuX2Z1bGxSZWFkZXIub25Qcm9ncmVzcyA9IChldnQpID0+IHtcbiAgICAgICAgdGhpcy5fbGFzdFByb2dyZXNzID0ge1xuICAgICAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZCxcbiAgICAgICAgICB0b3RhbDogZXZ0LnRvdGFsXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgc2luay5vblB1bGwgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2Z1bGxSZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24oe1xuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGRvbmVcbiAgICAgICAgfSkge1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICBzaW5rLmNsb3NlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGFzc2VydCh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyLCBcIkdldFJlYWRlciAtIGV4cGVjdGVkIGFuIEFycmF5QnVmZmVyLlwiKTtcbiAgICAgICAgICBzaW5rLmVucXVldWUobmV3IFVpbnQ4QXJyYXkodmFsdWUpLCAxLCBbdmFsdWVdKTtcbiAgICAgICAgfSkuY2F0Y2goKHJlYXNvbikgPT4ge1xuICAgICAgICAgIHNpbmsuZXJyb3IocmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgc2luay5vbkNhbmNlbCA9IChyZWFzb24pID0+IHtcbiAgICAgICAgdGhpcy5fZnVsbFJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICAgICAgc2luay5yZWFkeS5jYXRjaCgocmVhZHlSZWFzb24pID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgcmVhZHlSZWFzb247XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIlJlYWRlckhlYWRlcnNSZWFkeVwiLCBhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5fZnVsbFJlYWRlci5oZWFkZXJzUmVhZHk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGlzU3RyZWFtaW5nU3VwcG9ydGVkLFxuICAgICAgICBpc1JhbmdlU3VwcG9ydGVkLFxuICAgICAgICBjb250ZW50TGVuZ3RoXG4gICAgICB9ID0gdGhpcy5fZnVsbFJlYWRlcjtcbiAgICAgIGlmICghaXNTdHJlYW1pbmdTdXBwb3J0ZWQgfHwgIWlzUmFuZ2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xhc3RQcm9ncmVzcykge1xuICAgICAgICAgIGxvYWRpbmdUYXNrLm9uUHJvZ3Jlc3M/Lih0aGlzLl9sYXN0UHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Z1bGxSZWFkZXIub25Qcm9ncmVzcyA9IChldnQpID0+IHtcbiAgICAgICAgICBsb2FkaW5nVGFzay5vblByb2dyZXNzPy4oe1xuICAgICAgICAgICAgbG9hZGVkOiBldnQubG9hZGVkLFxuICAgICAgICAgICAgdG90YWw6IGV2dC50b3RhbFxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNTdHJlYW1pbmdTdXBwb3J0ZWQsXG4gICAgICAgIGlzUmFuZ2VTdXBwb3J0ZWQsXG4gICAgICAgIGNvbnRlbnRMZW5ndGhcbiAgICAgIH07XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJHZXRSYW5nZVJlYWRlclwiLCAoZGF0YSwgc2luaykgPT4ge1xuICAgICAgYXNzZXJ0KHRoaXMuX25ldHdvcmtTdHJlYW0sIFwiR2V0UmFuZ2VSZWFkZXIgLSBubyBgSVBERlN0cmVhbWAgaW5zdGFuY2UgYXZhaWxhYmxlLlwiKTtcbiAgICAgIGNvbnN0IHJhbmdlUmVhZGVyID0gdGhpcy5fbmV0d29ya1N0cmVhbS5nZXRSYW5nZVJlYWRlcihkYXRhLmJlZ2luLCBkYXRhLmVuZCk7XG4gICAgICBpZiAoIXJhbmdlUmVhZGVyKSB7XG4gICAgICAgIHNpbmsuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2luay5vblB1bGwgPSAoKSA9PiB7XG4gICAgICAgIHJhbmdlUmVhZGVyLnJlYWQoKS50aGVuKGZ1bmN0aW9uKHtcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBkb25lXG4gICAgICAgIH0pIHtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgc2luay5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhc3NlcnQodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciwgXCJHZXRSYW5nZVJlYWRlciAtIGV4cGVjdGVkIGFuIEFycmF5QnVmZmVyLlwiKTtcbiAgICAgICAgICBzaW5rLmVucXVldWUobmV3IFVpbnQ4QXJyYXkodmFsdWUpLCAxLCBbdmFsdWVdKTtcbiAgICAgICAgfSkuY2F0Y2goKHJlYXNvbikgPT4ge1xuICAgICAgICAgIHNpbmsuZXJyb3IocmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgc2luay5vbkNhbmNlbCA9IChyZWFzb24pID0+IHtcbiAgICAgICAgcmFuZ2VSZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgICAgIHNpbmsucmVhZHkuY2F0Y2goKHJlYWR5UmVhc29uKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IHJlYWR5UmVhc29uO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJHZXREb2NcIiwgKHtcbiAgICAgIHBkZkluZm9cbiAgICB9KSA9PiB7XG4gICAgICB0aGlzLl9udW1QYWdlcyA9IHBkZkluZm8ubnVtUGFnZXM7XG4gICAgICB0aGlzLl9odG1sRm9yWGZhID0gcGRmSW5mby5odG1sRm9yWGZhO1xuICAgICAgZGVsZXRlIHBkZkluZm8uaHRtbEZvclhmYTtcbiAgICAgIGxvYWRpbmdUYXNrLl9jYXBhYmlsaXR5LnJlc29sdmUobmV3IFBERkRvY3VtZW50UHJveHkocGRmSW5mbywgdGhpcykpO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiRG9jRXhjZXB0aW9uXCIsIChleCkgPT4ge1xuICAgICAgbG9hZGluZ1Rhc2suX2NhcGFiaWxpdHkucmVqZWN0KHdyYXBSZWFzb24oZXgpKTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIlBhc3N3b3JkUmVxdWVzdFwiLCAoZXgpID0+IHtcbiAgICAgIHRoaXMuI3Bhc3N3b3JkQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFsb2FkaW5nVGFzay5vblBhc3N3b3JkKSB7XG4gICAgICAgICAgdGhyb3cgd3JhcFJlYXNvbihleCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXBkYXRlUGFzc3dvcmQgPSAocGFzc3dvcmQpID0+IHtcbiAgICAgICAgICBpZiAocGFzc3dvcmQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgdGhpcy4jcGFzc3dvcmRDYXBhYmlsaXR5LnJlamVjdChwYXNzd29yZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI3Bhc3N3b3JkQ2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgICAgICAgcGFzc3dvcmRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbG9hZGluZ1Rhc2sub25QYXNzd29yZCh1cGRhdGVQYXNzd29yZCwgZXguY29kZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy4jcGFzc3dvcmRDYXBhYmlsaXR5LnJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuI3Bhc3N3b3JkQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiRGF0YUxvYWRlZFwiLCAoZGF0YSkgPT4ge1xuICAgICAgbG9hZGluZ1Rhc2sub25Qcm9ncmVzcz8uKHtcbiAgICAgICAgbG9hZGVkOiBkYXRhLmxlbmd0aCxcbiAgICAgICAgdG90YWw6IGRhdGEubGVuZ3RoXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZG93bmxvYWRJbmZvQ2FwYWJpbGl0eS5yZXNvbHZlKGRhdGEpO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiU3RhcnRSZW5kZXJQYWdlXCIsIChkYXRhKSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFnZSA9IHRoaXMuI3BhZ2VDYWNoZS5nZXQoZGF0YS5wYWdlSW5kZXgpO1xuICAgICAgcGFnZS5fc3RhcnRSZW5kZXJQYWdlKGRhdGEudHJhbnNwYXJlbmN5LCBkYXRhLmNhY2hlS2V5KTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcImNvbW1vbm9ialwiLCAoW2lkLCB0eXBlLCBleHBvcnRlZERhdGFdKSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb21tb25PYmpzLmhhcyhpZCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcIkZvbnRcIjpcbiAgICAgICAgICBpZiAoXCJlcnJvclwiIGluIGV4cG9ydGVkRGF0YSkge1xuICAgICAgICAgICAgY29uc3QgZXhwb3J0ZWRFcnJvciA9IGV4cG9ydGVkRGF0YS5lcnJvcjtcbiAgICAgICAgICAgIHdhcm4oYEVycm9yIGR1cmluZyBmb250IGxvYWRpbmc6ICR7ZXhwb3J0ZWRFcnJvcn1gKTtcbiAgICAgICAgICAgIHRoaXMuY29tbW9uT2Jqcy5yZXNvbHZlKGlkLCBleHBvcnRlZEVycm9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBmb250RGF0YSA9IG5ldyBGb250SW5mbyhleHBvcnRlZERhdGEpO1xuICAgICAgICAgIGNvbnN0IGluc3BlY3RGb250ID0gdGhpcy5fcGFyYW1zLnBkZkJ1ZyAmJiBnbG9iYWxUaGlzLkZvbnRJbnNwZWN0b3I/LmVuYWJsZWQgPyAoZm9udDIsIHVybCkgPT4gZ2xvYmFsVGhpcy5Gb250SW5zcGVjdG9yLmZvbnRBZGRlZChmb250MiwgdXJsKSA6IG51bGw7XG4gICAgICAgICAgY29uc3QgZm9udCA9IG5ldyBGb250RmFjZU9iamVjdChmb250RGF0YSwgaW5zcGVjdEZvbnQsIGV4cG9ydGVkRGF0YS5leHRyYSwgZXhwb3J0ZWREYXRhLmNoYXJQcm9jT3BlcmF0b3JMaXN0KTtcbiAgICAgICAgICB0aGlzLmZvbnRMb2FkZXIuYmluZChmb250KS5jYXRjaCgoKSA9PiBtZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJGb250RmFsbGJhY2tcIiwge1xuICAgICAgICAgICAgaWRcbiAgICAgICAgICB9KSkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWZvbnQuZm9udEV4dHJhUHJvcGVydGllcyAmJiBmb250LmRhdGEpIHtcbiAgICAgICAgICAgICAgZm9udC5jbGVhckRhdGEoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29tbW9uT2Jqcy5yZXNvbHZlKGlkLCBmb250KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkNvcHlMb2NhbEltYWdlXCI6XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgaW1hZ2VSZWZcbiAgICAgICAgICB9ID0gZXhwb3J0ZWREYXRhO1xuICAgICAgICAgIGFzc2VydChpbWFnZVJlZiwgXCJUaGUgaW1hZ2VSZWYgbXVzdCBiZSBkZWZpbmVkLlwiKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHBhZ2VQcm94eSBvZiB0aGlzLiNwYWdlQ2FjaGUudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgWywgZGF0YV0gb2YgcGFnZVByb3h5Lm9ianMpIHtcbiAgICAgICAgICAgICAgaWYgKGRhdGE/LnJlZiAhPT0gaW1hZ2VSZWYpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWRhdGEuZGF0YUxlbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuY29tbW9uT2Jqcy5yZXNvbHZlKGlkLCBzdHJ1Y3R1cmVkQ2xvbmUoZGF0YSkpO1xuICAgICAgICAgICAgICByZXR1cm4gZGF0YS5kYXRhTGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkZvbnRQYXRoXCI6XG4gICAgICAgIGNhc2UgXCJJbWFnZVwiOlxuICAgICAgICBjYXNlIFwiUGF0dGVyblwiOlxuICAgICAgICAgIHRoaXMuY29tbW9uT2Jqcy5yZXNvbHZlKGlkLCBleHBvcnRlZERhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgR290IHVua25vd24gY29tbW9uIG9iamVjdCB0eXBlICR7dHlwZX1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwib2JqXCIsIChbaWQsIHBhZ2VJbmRleCwgdHlwZSwgaW1hZ2VEYXRhXSkgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhZ2VQcm94eSA9IHRoaXMuI3BhZ2VDYWNoZS5nZXQocGFnZUluZGV4KTtcbiAgICAgIGlmIChwYWdlUHJveHkub2Jqcy5oYXMoaWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChwYWdlUHJveHkuX2ludGVudFN0YXRlcy5zaXplID09PSAwKSB7XG4gICAgICAgIGltYWdlRGF0YT8uYml0bWFwPy5jbG9zZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcIkltYWdlXCI6XG4gICAgICAgIGNhc2UgXCJQYXR0ZXJuXCI6XG4gICAgICAgICAgcGFnZVByb3h5Lm9ianMucmVzb2x2ZShpZCwgaW1hZ2VEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdvdCB1bmtub3duIG9iamVjdCB0eXBlICR7dHlwZX1gKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkRvY1Byb2dyZXNzXCIsIChkYXRhKSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbG9hZGluZ1Rhc2sub25Qcm9ncmVzcz8uKHtcbiAgICAgICAgbG9hZGVkOiBkYXRhLmxvYWRlZCxcbiAgICAgICAgdG90YWw6IGRhdGEudG90YWxcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiRmV0Y2hCaW5hcnlEYXRhXCIsIGFzeW5jIChkYXRhKSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWQuXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgZmFjdG9yeSA9IHRoaXNbZGF0YS50eXBlXTtcbiAgICAgIGlmICghZmFjdG9yeSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZGF0YS50eXBlfSBub3QgaW5pdGlhbGl6ZWQsIHNlZSB0aGUgXFxgdXNlV29ya2VyRmV0Y2hcXGAgcGFyYW1ldGVyLmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhY3RvcnkuZmV0Y2goZGF0YSk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0RGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXREYXRhXCIsIG51bGwpO1xuICB9XG4gIHNhdmVEb2N1bWVudCgpIHtcbiAgICBpZiAodGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zaXplIDw9IDApIHtcbiAgICAgIHdhcm4oXCJzYXZlRG9jdW1lbnQgY2FsbGVkIHdoaWxlIGBhbm5vdGF0aW9uU3RvcmFnZWAgaXMgZW1wdHksIHBsZWFzZSB1c2UgdGhlIGdldERhdGEtbWV0aG9kIGluc3RlYWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBtYXAsXG4gICAgICB0cmFuc2ZlclxuICAgIH0gPSB0aGlzLmFubm90YXRpb25TdG9yYWdlLnNlcmlhbGl6YWJsZTtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJTYXZlRG9jdW1lbnRcIiwge1xuICAgICAgaXNQdXJlWGZhOiAhIXRoaXMuX2h0bWxGb3JYZmEsXG4gICAgICBudW1QYWdlczogdGhpcy5fbnVtUGFnZXMsXG4gICAgICBhbm5vdGF0aW9uU3RvcmFnZTogbWFwLFxuICAgICAgZmlsZW5hbWU6IHRoaXMuX2Z1bGxSZWFkZXI/LmZpbGVuYW1lID8/IG51bGxcbiAgICB9LCB0cmFuc2ZlcikuZmluYWxseSgoKSA9PiB7XG4gICAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlLnJlc2V0TW9kaWZpZWQoKTtcbiAgICB9KTtcbiAgfVxuICBnZXRQYWdlKHBhZ2VOdW1iZXIpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIocGFnZU51bWJlcikgfHwgcGFnZU51bWJlciA8PSAwIHx8IHBhZ2VOdW1iZXIgPiB0aGlzLl9udW1QYWdlcykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkludmFsaWQgcGFnZSByZXF1ZXN0LlwiKSk7XG4gICAgfVxuICAgIGNvbnN0IHBhZ2VJbmRleCA9IHBhZ2VOdW1iZXIgLSAxLCBjYWNoZWRQcm9taXNlID0gdGhpcy4jcGFnZVByb21pc2VzLmdldChwYWdlSW5kZXgpO1xuICAgIGlmIChjYWNoZWRQcm9taXNlKSB7XG4gICAgICByZXR1cm4gY2FjaGVkUHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZVwiLCB7XG4gICAgICBwYWdlSW5kZXhcbiAgICB9KS50aGVuKChwYWdlSW5mbykgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zcG9ydCBkZXN0cm95ZWRcIik7XG4gICAgICB9XG4gICAgICBpZiAocGFnZUluZm8ucmVmU3RyKSB7XG4gICAgICAgIHRoaXMuI3BhZ2VSZWZDYWNoZS5zZXQocGFnZUluZm8ucmVmU3RyLCBwYWdlTnVtYmVyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhZ2UgPSBuZXcgUERGUGFnZVByb3h5KHBhZ2VJbmRleCwgcGFnZUluZm8sIHRoaXMsIHRoaXMuX3BhcmFtcy5wZGZCdWcpO1xuICAgICAgdGhpcy4jcGFnZUNhY2hlLnNldChwYWdlSW5kZXgsIHBhZ2UpO1xuICAgICAgcmV0dXJuIHBhZ2U7XG4gICAgfSk7XG4gICAgdGhpcy4jcGFnZVByb21pc2VzLnNldChwYWdlSW5kZXgsIHByb21pc2UpO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIGdldFBhZ2VJbmRleChyZWYpIHtcbiAgICBpZiAoIWlzUmVmUHJveHkocmVmKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkludmFsaWQgcGFnZUluZGV4IHJlcXVlc3QuXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZUluZGV4XCIsIHtcbiAgICAgIG51bTogcmVmLm51bSxcbiAgICAgIGdlbjogcmVmLmdlblxuICAgIH0pO1xuICB9XG4gIGdldEFubm90YXRpb25zKHBhZ2VJbmRleCwgaW50ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0QW5ub3RhdGlvbnNcIiwge1xuICAgICAgcGFnZUluZGV4LFxuICAgICAgaW50ZW50XG4gICAgfSk7XG4gIH1cbiAgZ2V0RmllbGRPYmplY3RzKCkge1xuICAgIHJldHVybiB0aGlzLiNjYWNoZVNpbXBsZU1ldGhvZChcIkdldEZpZWxkT2JqZWN0c1wiKTtcbiAgfVxuICBoYXNKU0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NhY2hlU2ltcGxlTWV0aG9kKFwiSGFzSlNBY3Rpb25zXCIpO1xuICB9XG4gIGdldENhbGN1bGF0aW9uT3JkZXJJZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0Q2FsY3VsYXRpb25PcmRlcklkc1wiLCBudWxsKTtcbiAgfVxuICBnZXREZXN0aW5hdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0RGVzdGluYXRpb25zXCIsIG51bGwpO1xuICB9XG4gIGdldERlc3RpbmF0aW9uKGlkKSB7XG4gICAgaWYgKHR5cGVvZiBpZCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkludmFsaWQgZGVzdGluYXRpb24gcmVxdWVzdC5cIikpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXREZXN0aW5hdGlvblwiLCB7XG4gICAgICBpZFxuICAgIH0pO1xuICB9XG4gIGdldFBhZ2VMYWJlbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZUxhYmVsc1wiLCBudWxsKTtcbiAgfVxuICBnZXRQYWdlTGF5b3V0KCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBhZ2VMYXlvdXRcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0UGFnZU1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZU1vZGVcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0Vmlld2VyUHJlZmVyZW5jZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0Vmlld2VyUHJlZmVyZW5jZXNcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0T3BlbkFjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRPcGVuQWN0aW9uXCIsIG51bGwpO1xuICB9XG4gIGdldEF0dGFjaG1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldEF0dGFjaG1lbnRzXCIsIG51bGwpO1xuICB9XG4gIGdldEFubm90YXRpb25zQnlUeXBlKHR5cGVzLCBwYWdlSW5kZXhlc1RvU2tpcCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldEFubm90YXRpb25zQnlUeXBlXCIsIHtcbiAgICAgIHR5cGVzLFxuICAgICAgcGFnZUluZGV4ZXNUb1NraXBcbiAgICB9KTtcbiAgfVxuICBnZXREb2NKU0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NhY2hlU2ltcGxlTWV0aG9kKFwiR2V0RG9jSlNBY3Rpb25zXCIpO1xuICB9XG4gIGdldFBhZ2VKU0FjdGlvbnMocGFnZUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZUpTQWN0aW9uc1wiLCB7XG4gICAgICBwYWdlSW5kZXhcbiAgICB9KTtcbiAgfVxuICBnZXRTdHJ1Y3RUcmVlKHBhZ2VJbmRleCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFN0cnVjdFRyZWVcIiwge1xuICAgICAgcGFnZUluZGV4XG4gICAgfSk7XG4gIH1cbiAgZ2V0T3V0bGluZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRPdXRsaW5lXCIsIG51bGwpO1xuICB9XG4gIGdldE9wdGlvbmFsQ29udGVudENvbmZpZyhyZW5kZXJpbmdJbnRlbnQpIHtcbiAgICByZXR1cm4gdGhpcy4jY2FjaGVTaW1wbGVNZXRob2QoXCJHZXRPcHRpb25hbENvbnRlbnRDb25maWdcIikudGhlbigoZGF0YSkgPT4gbmV3IE9wdGlvbmFsQ29udGVudENvbmZpZyhkYXRhLCByZW5kZXJpbmdJbnRlbnQpKTtcbiAgfVxuICBnZXRQZXJtaXNzaW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQZXJtaXNzaW9uc1wiLCBudWxsKTtcbiAgfVxuICBnZXRNZXRhZGF0YSgpIHtcbiAgICBjb25zdCBuYW1lID0gXCJHZXRNZXRhZGF0YVwiLCBjYWNoZWRQcm9taXNlID0gdGhpcy4jbWV0aG9kUHJvbWlzZXMuZ2V0KG5hbWUpO1xuICAgIGlmIChjYWNoZWRQcm9taXNlKSB7XG4gICAgICByZXR1cm4gY2FjaGVkUHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKG5hbWUsIG51bGwpLnRoZW4oKHJlc3VsdHMpID0+ICh7XG4gICAgICBpbmZvOiByZXN1bHRzWzBdLFxuICAgICAgbWV0YWRhdGE6IHJlc3VsdHNbMV0gPyBuZXcgTWV0YWRhdGEocmVzdWx0c1sxXSkgOiBudWxsLFxuICAgICAgY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWU6IHRoaXMuX2Z1bGxSZWFkZXI/LmZpbGVuYW1lID8/IG51bGwsXG4gICAgICBjb250ZW50TGVuZ3RoOiB0aGlzLl9mdWxsUmVhZGVyPy5jb250ZW50TGVuZ3RoID8/IG51bGxcbiAgICB9KSk7XG4gICAgdGhpcy4jbWV0aG9kUHJvbWlzZXMuc2V0KG5hbWUsIHByb21pc2UpO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIGdldE1hcmtJbmZvKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldE1hcmtJbmZvXCIsIG51bGwpO1xuICB9XG4gIGFzeW5jIHN0YXJ0Q2xlYW51cChrZWVwTG9hZGVkRm9udHMgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkNsZWFudXBcIiwgbnVsbCk7XG4gICAgZm9yIChjb25zdCBwYWdlIG9mIHRoaXMuI3BhZ2VDYWNoZS52YWx1ZXMoKSkge1xuICAgICAgY29uc3QgY2xlYW51cFN1Y2Nlc3NmdWwgPSBwYWdlLmNsZWFudXAoKTtcbiAgICAgIGlmICghY2xlYW51cFN1Y2Nlc3NmdWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzdGFydENsZWFudXA6IFBhZ2UgJHtwYWdlLnBhZ2VOdW1iZXJ9IGlzIGN1cnJlbnRseSByZW5kZXJpbmcuYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY29tbW9uT2Jqcy5jbGVhcigpO1xuICAgIGlmICgha2VlcExvYWRlZEZvbnRzKSB7XG4gICAgICB0aGlzLmZvbnRMb2FkZXIuY2xlYXIoKTtcbiAgICB9XG4gICAgdGhpcy4jbWV0aG9kUHJvbWlzZXMuY2xlYXIoKTtcbiAgICB0aGlzLmZpbHRlckZhY3RvcnkuZGVzdHJveSh0cnVlKTtcbiAgICBUZXh0TGF5ZXIuY2xlYW51cCgpO1xuICB9XG4gIGNhY2hlZFBhZ2VOdW1iZXIocmVmKSB7XG4gICAgaWYgKCFpc1JlZlByb3h5KHJlZikpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZWZTdHIgPSByZWYuZ2VuID09PSAwID8gYCR7cmVmLm51bX1SYCA6IGAke3JlZi5udW19UiR7cmVmLmdlbn1gO1xuICAgIHJldHVybiB0aGlzLiNwYWdlUmVmQ2FjaGUuZ2V0KHJlZlN0cikgPz8gbnVsbDtcbiAgfVxufVxuY2xhc3MgUmVuZGVyVGFzayB7XG4gICNpbnRlcm5hbFJlbmRlclRhc2sgPSBudWxsO1xuICBvbkNvbnRpbnVlID0gbnVsbDtcbiAgb25FcnJvciA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKGludGVybmFsUmVuZGVyVGFzaykge1xuICAgIHRoaXMuI2ludGVybmFsUmVuZGVyVGFzayA9IGludGVybmFsUmVuZGVyVGFzaztcbiAgfVxuICBnZXQgcHJvbWlzZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jaW50ZXJuYWxSZW5kZXJUYXNrLmNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjYW5jZWwoZXh0cmFEZWxheSA9IDApIHtcbiAgICB0aGlzLiNpbnRlcm5hbFJlbmRlclRhc2suY2FuY2VsKG51bGwsIGV4dHJhRGVsYXkpO1xuICB9XG4gIGdldCBzZXBhcmF0ZUFubm90cygpIHtcbiAgICBjb25zdCB7XG4gICAgICBzZXBhcmF0ZUFubm90c1xuICAgIH0gPSB0aGlzLiNpbnRlcm5hbFJlbmRlclRhc2sub3BlcmF0b3JMaXN0O1xuICAgIGlmICghc2VwYXJhdGVBbm5vdHMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYW5ub3RhdGlvbkNhbnZhc01hcFxuICAgIH0gPSB0aGlzLiNpbnRlcm5hbFJlbmRlclRhc2s7XG4gICAgcmV0dXJuIHNlcGFyYXRlQW5ub3RzLmZvcm0gfHwgc2VwYXJhdGVBbm5vdHMuY2FudmFzICYmIGFubm90YXRpb25DYW52YXNNYXA/LnNpemUgPiAwO1xuICB9XG59XG5jbGFzcyBJbnRlcm5hbFJlbmRlclRhc2sge1xuICAjckFGID0gbnVsbDtcbiAgc3RhdGljICNjYW52YXNJblVzZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY2FsbGJhY2ssXG4gICAgcGFyYW1zLFxuICAgIG9ianMsXG4gICAgY29tbW9uT2JqcyxcbiAgICBhbm5vdGF0aW9uQ2FudmFzTWFwLFxuICAgIG9wZXJhdG9yTGlzdCxcbiAgICBwYWdlSW5kZXgsXG4gICAgY2FudmFzRmFjdG9yeSxcbiAgICBmaWx0ZXJGYWN0b3J5LFxuICAgIHVzZVJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZhbHNlLFxuICAgIHBkZkJ1ZyA9IGZhbHNlLFxuICAgIHBhZ2VDb2xvcnMgPSBudWxsLFxuICAgIGVuYWJsZUhXQSA9IGZhbHNlLFxuICAgIG9wZXJhdGlvbnNGaWx0ZXIgPSBudWxsXG4gIH0pIHtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgdGhpcy5vYmpzID0gb2JqcztcbiAgICB0aGlzLmNvbW1vbk9ianMgPSBjb21tb25PYmpzO1xuICAgIHRoaXMuYW5ub3RhdGlvbkNhbnZhc01hcCA9IGFubm90YXRpb25DYW52YXNNYXA7XG4gICAgdGhpcy5vcGVyYXRvckxpc3RJZHggPSBudWxsO1xuICAgIHRoaXMub3BlcmF0b3JMaXN0ID0gb3BlcmF0b3JMaXN0O1xuICAgIHRoaXMuX3BhZ2VJbmRleCA9IHBhZ2VJbmRleDtcbiAgICB0aGlzLmNhbnZhc0ZhY3RvcnkgPSBjYW52YXNGYWN0b3J5O1xuICAgIHRoaXMuZmlsdGVyRmFjdG9yeSA9IGZpbHRlckZhY3Rvcnk7XG4gICAgdGhpcy5fcGRmQnVnID0gcGRmQnVnO1xuICAgIHRoaXMucGFnZUNvbG9ycyA9IHBhZ2VDb2xvcnM7XG4gICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5ncmFwaGljc1JlYWR5Q2FsbGJhY2sgPSBudWxsO1xuICAgIHRoaXMuZ3JhcGhpY3NSZWFkeSA9IGZhbHNlO1xuICAgIHRoaXMuX3VzZVJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHVzZVJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gdHJ1ZSAmJiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xuICAgIHRoaXMuY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgdGhpcy5jYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy50YXNrID0gbmV3IFJlbmRlclRhc2sodGhpcyk7XG4gICAgdGhpcy5fY2FuY2VsQm91bmQgPSB0aGlzLmNhbmNlbC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2NvbnRpbnVlQm91bmQgPSB0aGlzLl9jb250aW51ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3NjaGVkdWxlTmV4dEJvdW5kID0gdGhpcy5fc2NoZWR1bGVOZXh0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fbmV4dEJvdW5kID0gdGhpcy5fbmV4dC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2NhbnZhcyA9IHBhcmFtcy5jYW52YXM7XG4gICAgdGhpcy5fY2FudmFzQ29udGV4dCA9IHBhcmFtcy5jYW52YXMgPyBudWxsIDogcGFyYW1zLmNhbnZhc0NvbnRleHQ7XG4gICAgdGhpcy5fZW5hYmxlSFdBID0gZW5hYmxlSFdBO1xuICAgIHRoaXMuX2RlcGVuZGVuY3lUcmFja2VyID0gcGFyYW1zLmRlcGVuZGVuY3lUcmFja2VyO1xuICAgIHRoaXMuX29wZXJhdGlvbnNGaWx0ZXIgPSBvcGVyYXRpb25zRmlsdGVyO1xuICB9XG4gIGdldCBjb21wbGV0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FwYWJpbGl0eS5wcm9taXNlLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgIH0pO1xuICB9XG4gIGluaXRpYWxpemVHcmFwaGljcyh7XG4gICAgdHJhbnNwYXJlbmN5ID0gZmFsc2UsXG4gICAgb3B0aW9uYWxDb250ZW50Q29uZmlnXG4gIH0pIHtcbiAgICBpZiAodGhpcy5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2NhbnZhcykge1xuICAgICAgaWYgKEludGVybmFsUmVuZGVyVGFzay4jY2FudmFzSW5Vc2UuaGFzKHRoaXMuX2NhbnZhcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHVzZSB0aGUgc2FtZSBjYW52YXMgZHVyaW5nIG11bHRpcGxlIHJlbmRlcigpIG9wZXJhdGlvbnMuIFVzZSBkaWZmZXJlbnQgY2FudmFzIG9yIGVuc3VyZSBwcmV2aW91cyBvcGVyYXRpb25zIHdlcmUgY2FuY2VsbGVkIG9yIGNvbXBsZXRlZC5cIik7XG4gICAgICB9XG4gICAgICBJbnRlcm5hbFJlbmRlclRhc2suI2NhbnZhc0luVXNlLmFkZCh0aGlzLl9jYW52YXMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcGRmQnVnICYmIGdsb2JhbFRoaXMuU3RlcHBlck1hbmFnZXI/LmVuYWJsZWQpIHtcbiAgICAgIHRoaXMuc3RlcHBlciA9IGdsb2JhbFRoaXMuU3RlcHBlck1hbmFnZXIuY3JlYXRlKHRoaXMuX3BhZ2VJbmRleCk7XG4gICAgICB0aGlzLnN0ZXBwZXIuaW5pdCh0aGlzLm9wZXJhdG9yTGlzdCk7XG4gICAgICB0aGlzLnN0ZXBwZXIubmV4dEJyZWFrUG9pbnQgPSB0aGlzLnN0ZXBwZXIuZ2V0TmV4dEJyZWFrUG9pbnQoKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgdmlld3BvcnQsXG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICBiYWNrZ3JvdW5kLFxuICAgICAgZGVwZW5kZW5jeVRyYWNrZXJcbiAgICB9ID0gdGhpcy5wYXJhbXM7XG4gICAgY29uc3QgY2FudmFzQ29udGV4dCA9IHRoaXMuX2NhbnZhc0NvbnRleHQgfHwgdGhpcy5fY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICBhbHBoYTogZmFsc2UsXG4gICAgICB3aWxsUmVhZEZyZXF1ZW50bHk6ICF0aGlzLl9lbmFibGVIV0FcbiAgICB9KTtcbiAgICB0aGlzLmdmeCA9IG5ldyBDYW52YXNHcmFwaGljcyhjYW52YXNDb250ZXh0LCB0aGlzLmNvbW1vbk9ianMsIHRoaXMub2JqcywgdGhpcy5jYW52YXNGYWN0b3J5LCB0aGlzLmZpbHRlckZhY3RvcnksIHtcbiAgICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1xuICAgIH0sIHRoaXMuYW5ub3RhdGlvbkNhbnZhc01hcCwgdGhpcy5wYWdlQ29sb3JzLCBkZXBlbmRlbmN5VHJhY2tlcik7XG4gICAgdGhpcy5nZnguYmVnaW5EcmF3aW5nKHtcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgdHJhbnNwYXJlbmN5LFxuICAgICAgYmFja2dyb3VuZFxuICAgIH0pO1xuICAgIHRoaXMub3BlcmF0b3JMaXN0SWR4ID0gMDtcbiAgICB0aGlzLmdyYXBoaWNzUmVhZHkgPSB0cnVlO1xuICAgIHRoaXMuZ3JhcGhpY3NSZWFkeUNhbGxiYWNrPy4oKTtcbiAgfVxuICBjYW5jZWwoZXJyb3IgPSBudWxsLCBleHRyYURlbGF5ID0gMCkge1xuICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICB0aGlzLmdmeD8uZW5kRHJhd2luZygpO1xuICAgIGlmICh0aGlzLiNyQUYpIHtcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLiNyQUYpO1xuICAgICAgdGhpcy4jckFGID0gbnVsbDtcbiAgICB9XG4gICAgSW50ZXJuYWxSZW5kZXJUYXNrLiNjYW52YXNJblVzZS5kZWxldGUodGhpcy5fY2FudmFzKTtcbiAgICBlcnJvciB8fD0gbmV3IFJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbihgUmVuZGVyaW5nIGNhbmNlbGxlZCwgcGFnZSAke3RoaXMuX3BhZ2VJbmRleCArIDF9YCwgZXh0cmFEZWxheSk7XG4gICAgdGhpcy5jYWxsYmFjayhlcnJvcik7XG4gICAgdGhpcy50YXNrLm9uRXJyb3I/LihlcnJvcik7XG4gIH1cbiAgb3BlcmF0b3JMaXN0Q2hhbmdlZCgpIHtcbiAgICBpZiAoIXRoaXMuZ3JhcGhpY3NSZWFkeSkge1xuICAgICAgdGhpcy5ncmFwaGljc1JlYWR5Q2FsbGJhY2sgfHw9IHRoaXMuX2NvbnRpbnVlQm91bmQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZ2Z4LmRlcGVuZGVuY3lUcmFja2VyPy5ncm93T3BlcmF0aW9uc0NvdW50KHRoaXMub3BlcmF0b3JMaXN0LmZuQXJyYXkubGVuZ3RoKTtcbiAgICB0aGlzLnN0ZXBwZXI/LnVwZGF0ZU9wZXJhdG9yTGlzdCh0aGlzLm9wZXJhdG9yTGlzdCk7XG4gICAgaWYgKHRoaXMucnVubmluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9jb250aW51ZSgpO1xuICB9XG4gIF9jb250aW51ZSgpIHtcbiAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuICAgIGlmICh0aGlzLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy50YXNrLm9uQ29udGludWUpIHtcbiAgICAgIHRoaXMudGFzay5vbkNvbnRpbnVlKHRoaXMuX3NjaGVkdWxlTmV4dEJvdW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc2NoZWR1bGVOZXh0KCk7XG4gICAgfVxuICB9XG4gIF9zY2hlZHVsZU5leHQoKSB7XG4gICAgaWYgKHRoaXMuX3VzZVJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgdGhpcy4jckFGID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuI3JBRiA9IG51bGw7XG4gICAgICAgIHRoaXMuX25leHRCb3VuZCgpLmNhdGNoKHRoaXMuX2NhbmNlbEJvdW5kKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKHRoaXMuX25leHRCb3VuZCkuY2F0Y2godGhpcy5fY2FuY2VsQm91bmQpO1xuICAgIH1cbiAgfVxuICBhc3luYyBfbmV4dCgpIHtcbiAgICBpZiAodGhpcy5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5vcGVyYXRvckxpc3RJZHggPSB0aGlzLmdmeC5leGVjdXRlT3BlcmF0b3JMaXN0KHRoaXMub3BlcmF0b3JMaXN0LCB0aGlzLm9wZXJhdG9yTGlzdElkeCwgdGhpcy5fY29udGludWVCb3VuZCwgdGhpcy5zdGVwcGVyLCB0aGlzLl9vcGVyYXRpb25zRmlsdGVyKTtcbiAgICBpZiAodGhpcy5vcGVyYXRvckxpc3RJZHggPT09IHRoaXMub3BlcmF0b3JMaXN0LmFyZ3NBcnJheS5sZW5ndGgpIHtcbiAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMub3BlcmF0b3JMaXN0Lmxhc3RDaHVuaykge1xuICAgICAgICB0aGlzLmdmeC5lbmREcmF3aW5nKCk7XG4gICAgICAgIEludGVybmFsUmVuZGVyVGFzay4jY2FudmFzSW5Vc2UuZGVsZXRlKHRoaXMuX2NhbnZhcyk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmNvbnN0IHZlcnNpb24gPSBcIjUuNC4yOTZcIjtcbmNvbnN0IGJ1aWxkID0gXCJmNTZkYzg2MDFcIjtcbmNsYXNzIENvbG9yUGlja2VyIHtcbiAgI2J1dHRvbiA9IG51bGw7XG4gICNidXR0b25Td2F0Y2ggPSBudWxsO1xuICAjZGVmYXVsdENvbG9yO1xuICAjZHJvcGRvd24gPSBudWxsO1xuICAjZHJvcGRvd25XYXNGcm9tS2V5Ym9hcmQgPSBmYWxzZTtcbiAgI2lzTWFpbkNvbG9yUGlja2VyID0gZmFsc2U7XG4gICNlZGl0b3IgPSBudWxsO1xuICAjZXZlbnRCdXM7XG4gICNvcGVuRHJvcGRvd25BQyA9IG51bGw7XG4gICN1aU1hbmFnZXIgPSBudWxsO1xuICBzdGF0aWMgI2wxMG5Db2xvciA9IG51bGw7XG4gIHN0YXRpYyBnZXQgX2tleWJvYXJkTWFuYWdlcigpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2tleWJvYXJkTWFuYWdlclwiLCBuZXcgS2V5Ym9hcmRNYW5hZ2VyKFtbW1wiRXNjYXBlXCIsIFwibWFjK0VzY2FwZVwiXSwgQ29sb3JQaWNrZXIucHJvdG90eXBlLl9oaWRlRHJvcGRvd25Gcm9tS2V5Ym9hcmRdLCBbW1wiIFwiLCBcIm1hYysgXCJdLCBDb2xvclBpY2tlci5wcm90b3R5cGUuX2NvbG9yU2VsZWN0RnJvbUtleWJvYXJkXSwgW1tcIkFycm93RG93blwiLCBcIkFycm93UmlnaHRcIiwgXCJtYWMrQXJyb3dEb3duXCIsIFwibWFjK0Fycm93UmlnaHRcIl0sIENvbG9yUGlja2VyLnByb3RvdHlwZS5fbW92ZVRvTmV4dF0sIFtbXCJBcnJvd1VwXCIsIFwiQXJyb3dMZWZ0XCIsIFwibWFjK0Fycm93VXBcIiwgXCJtYWMrQXJyb3dMZWZ0XCJdLCBDb2xvclBpY2tlci5wcm90b3R5cGUuX21vdmVUb1ByZXZpb3VzXSwgW1tcIkhvbWVcIiwgXCJtYWMrSG9tZVwiXSwgQ29sb3JQaWNrZXIucHJvdG90eXBlLl9tb3ZlVG9CZWdpbm5pbmddLCBbW1wiRW5kXCIsIFwibWFjK0VuZFwiXSwgQ29sb3JQaWNrZXIucHJvdG90eXBlLl9tb3ZlVG9FbmRdXSkpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBlZGl0b3IgPSBudWxsLFxuICAgIHVpTWFuYWdlciA9IG51bGxcbiAgfSkge1xuICAgIGlmIChlZGl0b3IpIHtcbiAgICAgIHRoaXMuI2lzTWFpbkNvbG9yUGlja2VyID0gZmFsc2U7XG4gICAgICB0aGlzLiNlZGl0b3IgPSBlZGl0b3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2lzTWFpbkNvbG9yUGlja2VyID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy4jdWlNYW5hZ2VyID0gZWRpdG9yPy5fdWlNYW5hZ2VyIHx8IHVpTWFuYWdlcjtcbiAgICB0aGlzLiNldmVudEJ1cyA9IHRoaXMuI3VpTWFuYWdlci5fZXZlbnRCdXM7XG4gICAgdGhpcy4jZGVmYXVsdENvbG9yID0gZWRpdG9yPy5jb2xvcj8udG9VcHBlckNhc2UoKSB8fCB0aGlzLiN1aU1hbmFnZXI/LmhpZ2hsaWdodENvbG9ycy52YWx1ZXMoKS5uZXh0KCkudmFsdWUgfHwgXCIjRkZGRjk4XCI7XG4gICAgQ29sb3JQaWNrZXIuI2wxMG5Db2xvciB8fD0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICBibHVlOiBcInBkZmpzLWVkaXRvci1jb2xvcnBpY2tlci1ibHVlXCIsXG4gICAgICBncmVlbjogXCJwZGZqcy1lZGl0b3ItY29sb3JwaWNrZXItZ3JlZW5cIixcbiAgICAgIHBpbms6IFwicGRmanMtZWRpdG9yLWNvbG9ycGlja2VyLXBpbmtcIixcbiAgICAgIHJlZDogXCJwZGZqcy1lZGl0b3ItY29sb3JwaWNrZXItcmVkXCIsXG4gICAgICB5ZWxsb3c6IFwicGRmanMtZWRpdG9yLWNvbG9ycGlja2VyLXllbGxvd1wiXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyQnV0dG9uKCkge1xuICAgIGNvbnN0IGJ1dHRvbiA9IHRoaXMuI2J1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgYnV0dG9uLmNsYXNzTmFtZSA9IFwiY29sb3JQaWNrZXJcIjtcbiAgICBidXR0b24udGFiSW5kZXggPSBcIjBcIjtcbiAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtZWRpdG9yLWNvbG9ycGlja2VyLWJ1dHRvblwiKTtcbiAgICBidXR0b24uYXJpYUhhc1BvcHVwID0gXCJ0cnVlXCI7XG4gICAgaWYgKHRoaXMuI2VkaXRvcikge1xuICAgICAgYnV0dG9uLmFyaWFDb250cm9scyA9IGAke3RoaXMuI2VkaXRvci5pZH1fY29sb3JwaWNrZXJfZHJvcGRvd25gO1xuICAgIH1cbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLiN1aU1hbmFnZXIuX3NpZ25hbDtcbiAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuI29wZW5Ecm9wZG93bi5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4ja2V5RG93bi5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBjb25zdCBzd2F0Y2ggPSB0aGlzLiNidXR0b25Td2F0Y2ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICBzd2F0Y2guY2xhc3NOYW1lID0gXCJzd2F0Y2hcIjtcbiAgICBzd2F0Y2guYXJpYUhpZGRlbiA9IFwidHJ1ZVwiO1xuICAgIHN3YXRjaC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLiNkZWZhdWx0Q29sb3I7XG4gICAgYnV0dG9uLmFwcGVuZChzd2F0Y2gpO1xuICAgIHJldHVybiBidXR0b247XG4gIH1cbiAgcmVuZGVyTWFpbkRyb3Bkb3duKCkge1xuICAgIGNvbnN0IGRyb3Bkb3duID0gdGhpcy4jZHJvcGRvd24gPSB0aGlzLiNnZXREcm9wZG93blJvb3QoKTtcbiAgICBkcm9wZG93bi5hcmlhT3JpZW50YXRpb24gPSBcImhvcml6b250YWxcIjtcbiAgICBkcm9wZG93bi5hcmlhTGFiZWxsZWRCeSA9IFwiaGlnaGxpZ2h0Q29sb3JQaWNrZXJMYWJlbFwiO1xuICAgIHJldHVybiBkcm9wZG93bjtcbiAgfVxuICAjZ2V0RHJvcGRvd25Sb290KCkge1xuICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBub0NvbnRleHRNZW51LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBkaXYuY2xhc3NOYW1lID0gXCJkcm9wZG93blwiO1xuICAgIGRpdi5yb2xlID0gXCJsaXN0Ym94XCI7XG4gICAgZGl2LmFyaWFNdWx0aVNlbGVjdGFibGUgPSBcImZhbHNlXCI7XG4gICAgZGl2LmFyaWFPcmllbnRhdGlvbiA9IFwidmVydGljYWxcIjtcbiAgICBkaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtZWRpdG9yLWNvbG9ycGlja2VyLWRyb3Bkb3duXCIpO1xuICAgIGlmICh0aGlzLiNlZGl0b3IpIHtcbiAgICAgIGRpdi5pZCA9IGAke3RoaXMuI2VkaXRvci5pZH1fY29sb3JwaWNrZXJfZHJvcGRvd25gO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtuYW1lLCBjb2xvcl0gb2YgdGhpcy4jdWlNYW5hZ2VyLmhpZ2hsaWdodENvbG9ycykge1xuICAgICAgY29uc3QgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICAgIGJ1dHRvbi50YWJJbmRleCA9IFwiMFwiO1xuICAgICAgYnV0dG9uLnJvbGUgPSBcIm9wdGlvblwiO1xuICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImRhdGEtY29sb3JcIiwgY29sb3IpO1xuICAgICAgYnV0dG9uLnRpdGxlID0gbmFtZTtcbiAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgQ29sb3JQaWNrZXIuI2wxMG5Db2xvcltuYW1lXSk7XG4gICAgICBjb25zdCBzd2F0Y2ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIGJ1dHRvbi5hcHBlbmQoc3dhdGNoKTtcbiAgICAgIHN3YXRjaC5jbGFzc05hbWUgPSBcInN3YXRjaFwiO1xuICAgICAgc3dhdGNoLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yO1xuICAgICAgYnV0dG9uLmFyaWFTZWxlY3RlZCA9IGNvbG9yID09PSB0aGlzLiNkZWZhdWx0Q29sb3I7XG4gICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuI2NvbG9yU2VsZWN0LmJpbmQodGhpcywgY29sb3IpLCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICBkaXYuYXBwZW5kKGJ1dHRvbik7XG4gICAgfVxuICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNrZXlEb3duLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHJldHVybiBkaXY7XG4gIH1cbiAgI2NvbG9yU2VsZWN0KGNvbG9yLCBldmVudCkge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHRoaXMuI2V2ZW50QnVzLmRpc3BhdGNoKFwic3dpdGNoYW5ub3RhdGlvbmVkaXRvcnBhcmFtc1wiLCB7XG4gICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICB0eXBlOiBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfQ09MT1IsXG4gICAgICB2YWx1ZTogY29sb3JcbiAgICB9KTtcbiAgICB0aGlzLnVwZGF0ZUNvbG9yKGNvbG9yKTtcbiAgfVxuICBfY29sb3JTZWxlY3RGcm9tS2V5Ym9hcmQoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLiNidXR0b24pIHtcbiAgICAgIHRoaXMuI29wZW5Ecm9wZG93bihldmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbG9yID0gZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtY29sb3JcIik7XG4gICAgaWYgKCFjb2xvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNjb2xvclNlbGVjdChjb2xvciwgZXZlbnQpO1xuICB9XG4gIF9tb3ZlVG9OZXh0KGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLiNpc0Ryb3Bkb3duVmlzaWJsZSkge1xuICAgICAgdGhpcy4jb3BlbkRyb3Bkb3duKGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcy4jYnV0dG9uKSB7XG4gICAgICB0aGlzLiNkcm9wZG93bi5maXJzdENoaWxkPy5mb2N1cygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBldmVudC50YXJnZXQubmV4dFNpYmxpbmc/LmZvY3VzKCk7XG4gIH1cbiAgX21vdmVUb1ByZXZpb3VzKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcy4jZHJvcGRvd24/LmZpcnN0Q2hpbGQgfHwgZXZlbnQudGFyZ2V0ID09PSB0aGlzLiNidXR0b24pIHtcbiAgICAgIGlmICh0aGlzLiNpc0Ryb3Bkb3duVmlzaWJsZSkge1xuICAgICAgICB0aGlzLl9oaWRlRHJvcGRvd25Gcm9tS2V5Ym9hcmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNpc0Ryb3Bkb3duVmlzaWJsZSkge1xuICAgICAgdGhpcy4jb3BlbkRyb3Bkb3duKGV2ZW50KTtcbiAgICB9XG4gICAgZXZlbnQudGFyZ2V0LnByZXZpb3VzU2libGluZz8uZm9jdXMoKTtcbiAgfVxuICBfbW92ZVRvQmVnaW5uaW5nKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLiNpc0Ryb3Bkb3duVmlzaWJsZSkge1xuICAgICAgdGhpcy4jb3BlbkRyb3Bkb3duKGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jZHJvcGRvd24uZmlyc3RDaGlsZD8uZm9jdXMoKTtcbiAgfVxuICBfbW92ZVRvRW5kKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLiNpc0Ryb3Bkb3duVmlzaWJsZSkge1xuICAgICAgdGhpcy4jb3BlbkRyb3Bkb3duKGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jZHJvcGRvd24ubGFzdENoaWxkPy5mb2N1cygpO1xuICB9XG4gICNrZXlEb3duKGV2ZW50KSB7XG4gICAgQ29sb3JQaWNrZXIuX2tleWJvYXJkTWFuYWdlci5leGVjKHRoaXMsIGV2ZW50KTtcbiAgfVxuICAjb3BlbkRyb3Bkb3duKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuI2lzRHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICB0aGlzLmhpZGVEcm9wZG93bigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNkcm9wZG93bldhc0Zyb21LZXlib2FyZCA9IGV2ZW50LmRldGFpbCA9PT0gMDtcbiAgICBpZiAoIXRoaXMuI29wZW5Ecm9wZG93bkFDKSB7XG4gICAgICB0aGlzLiNvcGVuRHJvcGRvd25BQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgdGhpcy4jcG9pbnRlckRvd24uYmluZCh0aGlzKSwge1xuICAgICAgICBzaWduYWw6IHRoaXMuI3VpTWFuYWdlci5jb21iaW5lZFNpZ25hbCh0aGlzLiNvcGVuRHJvcGRvd25BQylcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLiNidXR0b24uYXJpYUV4cGFuZGVkID0gXCJ0cnVlXCI7XG4gICAgaWYgKHRoaXMuI2Ryb3Bkb3duKSB7XG4gICAgICB0aGlzLiNkcm9wZG93bi5jbGFzc0xpc3QucmVtb3ZlKFwiaGlkZGVuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByb290ID0gdGhpcy4jZHJvcGRvd24gPSB0aGlzLiNnZXREcm9wZG93blJvb3QoKTtcbiAgICB0aGlzLiNidXR0b24uYXBwZW5kKHJvb3QpO1xuICB9XG4gICNwb2ludGVyRG93bihldmVudCkge1xuICAgIGlmICh0aGlzLiNkcm9wZG93bj8uY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmhpZGVEcm9wZG93bigpO1xuICB9XG4gIGhpZGVEcm9wZG93bigpIHtcbiAgICB0aGlzLiNkcm9wZG93bj8uY2xhc3NMaXN0LmFkZChcImhpZGRlblwiKTtcbiAgICB0aGlzLiNidXR0b24uYXJpYUV4cGFuZGVkID0gXCJmYWxzZVwiO1xuICAgIHRoaXMuI29wZW5Ecm9wZG93bkFDPy5hYm9ydCgpO1xuICAgIHRoaXMuI29wZW5Ecm9wZG93bkFDID0gbnVsbDtcbiAgfVxuICBnZXQgI2lzRHJvcGRvd25WaXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLiNkcm9wZG93biAmJiAhdGhpcy4jZHJvcGRvd24uY2xhc3NMaXN0LmNvbnRhaW5zKFwiaGlkZGVuXCIpO1xuICB9XG4gIF9oaWRlRHJvcGRvd25Gcm9tS2V5Ym9hcmQoKSB7XG4gICAgaWYgKHRoaXMuI2lzTWFpbkNvbG9yUGlja2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy4jaXNEcm9wZG93blZpc2libGUpIHtcbiAgICAgIHRoaXMuI2VkaXRvcj8udW5zZWxlY3QoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5oaWRlRHJvcGRvd24oKTtcbiAgICB0aGlzLiNidXR0b24uZm9jdXMoe1xuICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZSxcbiAgICAgIGZvY3VzVmlzaWJsZTogdGhpcy4jZHJvcGRvd25XYXNGcm9tS2V5Ym9hcmRcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVDb2xvcihjb2xvcikge1xuICAgIGlmICh0aGlzLiNidXR0b25Td2F0Y2gpIHtcbiAgICAgIHRoaXMuI2J1dHRvblN3YXRjaC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNkcm9wZG93bikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpID0gdGhpcy4jdWlNYW5hZ2VyLmhpZ2hsaWdodENvbG9ycy52YWx1ZXMoKTtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuI2Ryb3Bkb3duLmNoaWxkcmVuKSB7XG4gICAgICBjaGlsZC5hcmlhU2VsZWN0ZWQgPSBpLm5leHQoKS52YWx1ZSA9PT0gY29sb3IudG9VcHBlckNhc2UoKTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiNidXR0b24/LnJlbW92ZSgpO1xuICAgIHRoaXMuI2J1dHRvbiA9IG51bGw7XG4gICAgdGhpcy4jYnV0dG9uU3dhdGNoID0gbnVsbDtcbiAgICB0aGlzLiNkcm9wZG93bj8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jZHJvcGRvd24gPSBudWxsO1xuICB9XG59XG5jbGFzcyBCYXNpY0NvbG9yUGlja2VyIHtcbiAgI2lucHV0ID0gbnVsbDtcbiAgI2VkaXRvciA9IG51bGw7XG4gICN1aU1hbmFnZXIgPSBudWxsO1xuICBzdGF0aWMgI2wxMG5Db2xvciA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKGVkaXRvcikge1xuICAgIHRoaXMuI2VkaXRvciA9IGVkaXRvcjtcbiAgICB0aGlzLiN1aU1hbmFnZXIgPSBlZGl0b3IuX3VpTWFuYWdlcjtcbiAgICBCYXNpY0NvbG9yUGlja2VyLiNsMTBuQ29sb3IgfHw9IE9iamVjdC5mcmVlemUoe1xuICAgICAgZnJlZXRleHQ6IFwicGRmanMtZWRpdG9yLWNvbG9yLXBpY2tlci1mcmVlLXRleHQtaW5wdXRcIixcbiAgICAgIGluazogXCJwZGZqcy1lZGl0b3ItY29sb3ItcGlja2VyLWluay1pbnB1dFwiXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyQnV0dG9uKCkge1xuICAgIGlmICh0aGlzLiNpbnB1dCkge1xuICAgICAgcmV0dXJuIHRoaXMuI2lucHV0O1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBlZGl0b3JUeXBlLFxuICAgICAgY29sb3JUeXBlLFxuICAgICAgY29sb3JWYWx1ZVxuICAgIH0gPSB0aGlzLiNlZGl0b3I7XG4gICAgY29uc3QgaW5wdXQgPSB0aGlzLiNpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICBpbnB1dC50eXBlID0gXCJjb2xvclwiO1xuICAgIGlucHV0LnZhbHVlID0gY29sb3JWYWx1ZSB8fCBcIiMwMDAwMDBcIjtcbiAgICBpbnB1dC5jbGFzc05hbWUgPSBcImJhc2ljQ29sb3JQaWNrZXJcIjtcbiAgICBpbnB1dC50YWJJbmRleCA9IDA7XG4gICAgaW5wdXQuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIEJhc2ljQ29sb3JQaWNrZXIuI2wxMG5Db2xvcltlZGl0b3JUeXBlXSk7XG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsICgpID0+IHtcbiAgICAgIHRoaXMuI3VpTWFuYWdlci51cGRhdGVQYXJhbXMoY29sb3JUeXBlLCBpbnB1dC52YWx1ZSk7XG4gICAgfSwge1xuICAgICAgc2lnbmFsOiB0aGlzLiN1aU1hbmFnZXIuX3NpZ25hbFxuICAgIH0pO1xuICAgIHJldHVybiBpbnB1dDtcbiAgfVxuICB1cGRhdGUodmFsdWUpIHtcbiAgICBpZiAoIXRoaXMuI2lucHV0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2lucHV0LnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiNpbnB1dD8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jaW5wdXQgPSBudWxsO1xuICB9XG4gIGhpZGVEcm9wZG93bigpIHtcbiAgfVxufVxuX193ZWJwYWNrX3JlcXVpcmVfXygxMTYpO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg1MzEpO1xuZnVuY3Rpb24gbWFrZUNvbG9yQ29tcChuKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgubWF4KDAsIE1hdGgubWluKDEsIG4pKSAqIDI1NSkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKTtcbn1cbmZ1bmN0aW9uIHNjYWxlQW5kQ2xhbXAoeCkge1xuICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCAyNTUgKiB4KSk7XG59XG5jbGFzcyBDb2xvckNvbnZlcnRlcnMge1xuICBzdGF0aWMgQ01ZS19HKFtjLCB5LCBtLCBrXSkge1xuICAgIHJldHVybiBbXCJHXCIsIDEgLSBNYXRoLm1pbigxLCAwLjMgKiBjICsgMC41OSAqIG0gKyAwLjExICogeSArIGspXTtcbiAgfVxuICBzdGF0aWMgR19DTVlLKFtnXSkge1xuICAgIHJldHVybiBbXCJDTVlLXCIsIDAsIDAsIDAsIDEgLSBnXTtcbiAgfVxuICBzdGF0aWMgR19SR0IoW2ddKSB7XG4gICAgcmV0dXJuIFtcIlJHQlwiLCBnLCBnLCBnXTtcbiAgfVxuICBzdGF0aWMgR19yZ2IoW2ddKSB7XG4gICAgZyA9IHNjYWxlQW5kQ2xhbXAoZyk7XG4gICAgcmV0dXJuIFtnLCBnLCBnXTtcbiAgfVxuICBzdGF0aWMgR19IVE1MKFtnXSkge1xuICAgIGNvbnN0IEcgPSBtYWtlQ29sb3JDb21wKGcpO1xuICAgIHJldHVybiBgIyR7R30ke0d9JHtHfWA7XG4gIH1cbiAgc3RhdGljIFJHQl9HKFtyLCBnLCBiXSkge1xuICAgIHJldHVybiBbXCJHXCIsIDAuMyAqIHIgKyAwLjU5ICogZyArIDAuMTEgKiBiXTtcbiAgfVxuICBzdGF0aWMgUkdCX3JnYihjb2xvcikge1xuICAgIHJldHVybiBjb2xvci5tYXAoc2NhbGVBbmRDbGFtcCk7XG4gIH1cbiAgc3RhdGljIFJHQl9IVE1MKGNvbG9yKSB7XG4gICAgcmV0dXJuIGAjJHtjb2xvci5tYXAobWFrZUNvbG9yQ29tcCkuam9pbihcIlwiKX1gO1xuICB9XG4gIHN0YXRpYyBUX0hUTUwoKSB7XG4gICAgcmV0dXJuIFwiIzAwMDAwMDAwXCI7XG4gIH1cbiAgc3RhdGljIFRfcmdiKCkge1xuICAgIHJldHVybiBbbnVsbF07XG4gIH1cbiAgc3RhdGljIENNWUtfUkdCKFtjLCB5LCBtLCBrXSkge1xuICAgIHJldHVybiBbXCJSR0JcIiwgMSAtIE1hdGgubWluKDEsIGMgKyBrKSwgMSAtIE1hdGgubWluKDEsIG0gKyBrKSwgMSAtIE1hdGgubWluKDEsIHkgKyBrKV07XG4gIH1cbiAgc3RhdGljIENNWUtfcmdiKFtjLCB5LCBtLCBrXSkge1xuICAgIHJldHVybiBbc2NhbGVBbmRDbGFtcCgxIC0gTWF0aC5taW4oMSwgYyArIGspKSwgc2NhbGVBbmRDbGFtcCgxIC0gTWF0aC5taW4oMSwgbSArIGspKSwgc2NhbGVBbmRDbGFtcCgxIC0gTWF0aC5taW4oMSwgeSArIGspKV07XG4gIH1cbiAgc3RhdGljIENNWUtfSFRNTChjb21wb25lbnRzKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5DTVlLX1JHQihjb21wb25lbnRzKS5zbGljZSgxKTtcbiAgICByZXR1cm4gdGhpcy5SR0JfSFRNTChyZ2IpO1xuICB9XG4gIHN0YXRpYyBSR0JfQ01ZSyhbciwgZywgYl0pIHtcbiAgICBjb25zdCBjID0gMSAtIHI7XG4gICAgY29uc3QgbSA9IDEgLSBnO1xuICAgIGNvbnN0IHkgPSAxIC0gYjtcbiAgICBjb25zdCBrID0gTWF0aC5taW4oYywgbSwgeSk7XG4gICAgcmV0dXJuIFtcIkNNWUtcIiwgYywgbSwgeSwga107XG4gIH1cbn1cbmNsYXNzIEJhc2VTVkdGYWN0b3J5IHtcbiAgY3JlYXRlKHdpZHRoLCBoZWlnaHQsIHNraXBEaW1lbnNpb25zID0gZmFsc2UpIHtcbiAgICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBTVkcgZGltZW5zaW9uc1wiKTtcbiAgICB9XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5fY3JlYXRlU1ZHKFwic3ZnOnN2Z1wiKTtcbiAgICBzdmcuc2V0QXR0cmlidXRlKFwidmVyc2lvblwiLCBcIjEuMVwiKTtcbiAgICBpZiAoIXNraXBEaW1lbnNpb25zKSB7XG4gICAgICBzdmcuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgYCR7d2lkdGh9cHhgKTtcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgYCR7aGVpZ2h0fXB4YCk7XG4gICAgfVxuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJwcmVzZXJ2ZUFzcGVjdFJhdGlvXCIsIFwibm9uZVwiKTtcbiAgICBzdmcuc2V0QXR0cmlidXRlKFwidmlld0JveFwiLCBgMCAwICR7d2lkdGh9ICR7aGVpZ2h0fWApO1xuICAgIHJldHVybiBzdmc7XG4gIH1cbiAgY3JlYXRlRWxlbWVudCh0eXBlKSB7XG4gICAgaWYgKHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFNWRyBlbGVtZW50IHR5cGVcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVTVkcodHlwZSk7XG4gIH1cbiAgX2NyZWF0ZVNWRyh0eXBlKSB7XG4gICAgdW5yZWFjaGFibGUoXCJBYnN0cmFjdCBtZXRob2QgYF9jcmVhdGVTVkdgIGNhbGxlZC5cIik7XG4gIH1cbn1cbmNsYXNzIERPTVNWR0ZhY3RvcnkgZXh0ZW5kcyBCYXNlU1ZHRmFjdG9yeSB7XG4gIF9jcmVhdGVTVkcodHlwZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCB0eXBlKTtcbiAgfVxufVxuY29uc3QgYW5ub3RhdGlvbl9sYXllcl9ERUZBVUxUX0ZPTlRfU0laRSA9IDk7XG5jb25zdCBHZXRFbGVtZW50c0J5TmFtZVNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuY29uc3QgVElNRVpPTkVfT0ZGU0VUID0gKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5nZXRUaW1lem9uZU9mZnNldCgpICogNjAgKiAxZTM7XG5jbGFzcyBBbm5vdGF0aW9uRWxlbWVudEZhY3Rvcnkge1xuICBzdGF0aWMgY3JlYXRlKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBzdWJ0eXBlID0gcGFyYW1ldGVycy5kYXRhLmFubm90YXRpb25UeXBlO1xuICAgIHN3aXRjaCAoc3VidHlwZSkge1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5MSU5LOlxuICAgICAgICByZXR1cm4gbmV3IExpbmtBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuVEVYVDpcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLldJREdFVDpcbiAgICAgICAgY29uc3QgZmllbGRUeXBlID0gcGFyYW1ldGVycy5kYXRhLmZpZWxkVHlwZTtcbiAgICAgICAgc3dpdGNoIChmaWVsZFR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiVHhcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dFdpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICAgIGNhc2UgXCJCdG5cIjpcbiAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJzLmRhdGEucmFkaW9CdXR0b24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSYWRpb0J1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbWV0ZXJzLmRhdGEuY2hlY2tCb3gpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGVja2JveFdpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQdXNoQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICAgICAgY2FzZSBcIkNoXCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IENob2ljZVdpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICAgIGNhc2UgXCJTaWdcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuUE9QVVA6XG4gICAgICAgIHJldHVybiBuZXcgUG9wdXBBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuRlJFRVRFWFQ6XG4gICAgICAgIHJldHVybiBuZXcgRnJlZVRleHRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuTElORTpcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLlNRVUFSRTpcbiAgICAgICAgcmV0dXJuIG5ldyBTcXVhcmVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuQ0lSQ0xFOlxuICAgICAgICByZXR1cm4gbmV3IENpcmNsZUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5QT0xZTElORTpcbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5bGluZUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5DQVJFVDpcbiAgICAgICAgcmV0dXJuIG5ldyBDYXJldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5JTks6XG4gICAgICAgIHJldHVybiBuZXcgSW5rQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLlBPTFlHT046XG4gICAgICAgIHJldHVybiBuZXcgUG9seWdvbkFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5ISUdITElHSFQ6XG4gICAgICAgIHJldHVybiBuZXcgSGlnaGxpZ2h0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLlVOREVSTElORTpcbiAgICAgICAgcmV0dXJuIG5ldyBVbmRlcmxpbmVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuU1FVSUdHTFk6XG4gICAgICAgIHJldHVybiBuZXcgU3F1aWdnbHlBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuU1RSSUtFT1VUOlxuICAgICAgICByZXR1cm4gbmV3IFN0cmlrZU91dEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5TVEFNUDpcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFtcEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5GSUxFQVRUQUNITUVOVDpcbiAgICAgICAgcmV0dXJuIG5ldyBGaWxlQXR0YWNobWVudEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG5ldyBBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI3VwZGF0ZXMgPSBudWxsO1xuICAjaGFzQm9yZGVyID0gZmFsc2U7XG4gICNwb3B1cEVsZW1lbnQgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzLCB7XG4gICAgaXNSZW5kZXJhYmxlID0gZmFsc2UsXG4gICAgaWdub3JlQm9yZGVyID0gZmFsc2UsXG4gICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHMgPSBmYWxzZVxuICB9ID0ge30pIHtcbiAgICB0aGlzLmlzUmVuZGVyYWJsZSA9IGlzUmVuZGVyYWJsZTtcbiAgICB0aGlzLmRhdGEgPSBwYXJhbWV0ZXJzLmRhdGE7XG4gICAgdGhpcy5sYXllciA9IHBhcmFtZXRlcnMubGF5ZXI7XG4gICAgdGhpcy5saW5rU2VydmljZSA9IHBhcmFtZXRlcnMubGlua1NlcnZpY2U7XG4gICAgdGhpcy5kb3dubG9hZE1hbmFnZXIgPSBwYXJhbWV0ZXJzLmRvd25sb2FkTWFuYWdlcjtcbiAgICB0aGlzLmltYWdlUmVzb3VyY2VzUGF0aCA9IHBhcmFtZXRlcnMuaW1hZ2VSZXNvdXJjZXNQYXRoO1xuICAgIHRoaXMucmVuZGVyRm9ybXMgPSBwYXJhbWV0ZXJzLnJlbmRlckZvcm1zO1xuICAgIHRoaXMuc3ZnRmFjdG9yeSA9IHBhcmFtZXRlcnMuc3ZnRmFjdG9yeTtcbiAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlID0gcGFyYW1ldGVycy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICB0aGlzLmVuYWJsZUNvbW1lbnQgPSBwYXJhbWV0ZXJzLmVuYWJsZUNvbW1lbnQ7XG4gICAgdGhpcy5lbmFibGVTY3JpcHRpbmcgPSBwYXJhbWV0ZXJzLmVuYWJsZVNjcmlwdGluZztcbiAgICB0aGlzLmhhc0pTQWN0aW9ucyA9IHBhcmFtZXRlcnMuaGFzSlNBY3Rpb25zO1xuICAgIHRoaXMuX2ZpZWxkT2JqZWN0cyA9IHBhcmFtZXRlcnMuZmllbGRPYmplY3RzO1xuICAgIHRoaXMucGFyZW50ID0gcGFyYW1ldGVycy5wYXJlbnQ7XG4gICAgaWYgKGlzUmVuZGVyYWJsZSkge1xuICAgICAgdGhpcy5jb250YWluZXIgPSB0aGlzLl9jcmVhdGVDb250YWluZXIoaWdub3JlQm9yZGVyKTtcbiAgICB9XG4gICAgaWYgKGNyZWF0ZVF1YWRyaWxhdGVyYWxzKSB7XG4gICAgICB0aGlzLl9jcmVhdGVRdWFkcmlsYXRlcmFscygpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgX2hhc1BvcHVwRGF0YSh7XG4gICAgY29udGVudHNPYmosXG4gICAgcmljaFRleHRcbiAgfSkge1xuICAgIHJldHVybiAhIShjb250ZW50c09iaj8uc3RyIHx8IHJpY2hUZXh0Py5zdHIpO1xuICB9XG4gIGdldCBfaXNFZGl0YWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmlzRWRpdGFibGU7XG4gIH1cbiAgZ2V0IGhhc1BvcHVwRGF0YSgpIHtcbiAgICByZXR1cm4gQW5ub3RhdGlvbkVsZW1lbnQuX2hhc1BvcHVwRGF0YSh0aGlzLmRhdGEpIHx8IHRoaXMuZW5hYmxlQ29tbWVudCAmJiAhIXRoaXMuY29tbWVudFRleHQ7XG4gIH1cbiAgZ2V0IGNvbW1lbnREYXRhKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGFcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlPy5nZXRFZGl0b3IoZGF0YS5pZCk7XG4gICAgaWYgKGVkaXRvcikge1xuICAgICAgcmV0dXJuIGVkaXRvci5nZXREYXRhKCk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIGdldCBoYXNDb21tZW50QnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLmVuYWJsZUNvbW1lbnQgJiYgdGhpcy5oYXNQb3B1cEVsZW1lbnQ7XG4gIH1cbiAgZ2V0IGNvbW1lbnRCdXR0b25Qb3NpdGlvbigpIHtcbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlPy5nZXRFZGl0b3IodGhpcy5kYXRhLmlkKTtcbiAgICBpZiAoZWRpdG9yKSB7XG4gICAgICByZXR1cm4gZWRpdG9yLmNvbW1lbnRCdXR0b25Qb3NpdGlvbkluUGFnZTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcXVhZFBvaW50cyxcbiAgICAgIGlua0xpc3RzLFxuICAgICAgcmVjdFxuICAgIH0gPSB0aGlzLmRhdGE7XG4gICAgbGV0IG1heFggPSAtSW5maW5pdHk7XG4gICAgbGV0IG1heFkgPSAtSW5maW5pdHk7XG4gICAgaWYgKHF1YWRQb2ludHM/Lmxlbmd0aCA+PSA4KSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1YWRQb2ludHMubGVuZ3RoOyBpICs9IDgpIHtcbiAgICAgICAgaWYgKHF1YWRQb2ludHNbaSArIDFdID4gbWF4WSkge1xuICAgICAgICAgIG1heFkgPSBxdWFkUG9pbnRzW2kgKyAxXTtcbiAgICAgICAgICBtYXhYID0gcXVhZFBvaW50c1tpICsgMl07XG4gICAgICAgIH0gZWxzZSBpZiAocXVhZFBvaW50c1tpICsgMV0gPT09IG1heFkpIHtcbiAgICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgcXVhZFBvaW50c1tpICsgMl0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gW21heFgsIG1heFldO1xuICAgIH1cbiAgICBpZiAoaW5rTGlzdHM/Lmxlbmd0aCA+PSAxKSB7XG4gICAgICBmb3IgKGNvbnN0IGlua0xpc3Qgb2YgaW5rTGlzdHMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gaW5rTGlzdC5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICAgICAgaWYgKGlua0xpc3RbaSArIDFdID4gbWF4WSkge1xuICAgICAgICAgICAgbWF4WSA9IGlua0xpc3RbaSArIDFdO1xuICAgICAgICAgICAgbWF4WCA9IGlua0xpc3RbaV07XG4gICAgICAgICAgfSBlbHNlIGlmIChpbmtMaXN0W2kgKyAxXSA9PT0gbWF4WSkge1xuICAgICAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIGlua0xpc3RbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1heFggIT09IEluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiBbbWF4WCwgbWF4WV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZWN0KSB7XG4gICAgICByZXR1cm4gW3JlY3RbMl0sIHJlY3RbM11dO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBfbm9ybWFsaXplUG9pbnQocG9pbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYWdlOiB7XG4gICAgICAgIHZpZXdcbiAgICAgIH0sXG4gICAgICB2aWV3cG9ydDoge1xuICAgICAgICByYXdEaW1zOiB7XG4gICAgICAgICAgcGFnZVdpZHRoLFxuICAgICAgICAgIHBhZ2VIZWlnaHQsXG4gICAgICAgICAgcGFnZVgsXG4gICAgICAgICAgcGFnZVlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gPSB0aGlzLnBhcmVudDtcbiAgICBwb2ludFsxXSA9IHZpZXdbM10gLSBwb2ludFsxXSArIHZpZXdbMV07XG4gICAgcG9pbnRbMF0gPSAxMDAgKiAocG9pbnRbMF0gLSBwYWdlWCkgLyBwYWdlV2lkdGg7XG4gICAgcG9pbnRbMV0gPSAxMDAgKiAocG9pbnRbMV0gLSBwYWdlWSkgLyBwYWdlSGVpZ2h0O1xuICAgIHJldHVybiBwb2ludDtcbiAgfVxuICBnZXQgY29tbWVudFRleHQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YVxuICAgIH0gPSB0aGlzO1xuICAgIHJldHVybiB0aGlzLmFubm90YXRpb25TdG9yYWdlLmdldFJhd1ZhbHVlKGAke0Fubm90YXRpb25FZGl0b3JQcmVmaXh9JHtkYXRhLmlkfWApPy5wb3B1cD8uY29udGVudHMgfHwgZGF0YS5jb250ZW50c09iaj8uc3RyIHx8IFwiXCI7XG4gIH1cbiAgc2V0IGNvbW1lbnRUZXh0KHRleHQpIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgcG9wdXAgPSB7XG4gICAgICBkZWxldGVkOiAhdGV4dCxcbiAgICAgIGNvbnRlbnRzOiB0ZXh0IHx8IFwiXCJcbiAgICB9O1xuICAgIGlmICghdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS51cGRhdGVFZGl0b3IoZGF0YS5pZCwge1xuICAgICAgcG9wdXBcbiAgICB9KSkge1xuICAgICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zZXRWYWx1ZShgJHtBbm5vdGF0aW9uRWRpdG9yUHJlZml4fSR7ZGF0YS5pZH1gLCB7XG4gICAgICAgIGlkOiBkYXRhLmlkLFxuICAgICAgICBhbm5vdGF0aW9uVHlwZTogZGF0YS5hbm5vdGF0aW9uVHlwZSxcbiAgICAgICAgcGFnZUluZGV4OiB0aGlzLnBhcmVudC5wYWdlLl9wYWdlSW5kZXgsXG4gICAgICAgIHBvcHVwLFxuICAgICAgICBwb3B1cFJlZjogZGF0YS5wb3B1cFJlZixcbiAgICAgICAgbW9kaWZpY2F0aW9uRGF0ZTogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIXRleHQpIHtcbiAgICAgIHRoaXMucmVtb3ZlUG9wdXAoKTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlUG9wdXAoKSB7XG4gICAgKHRoaXMuI3BvcHVwRWxlbWVudD8ucG9wdXAgfHwgdGhpcy5wb3B1cCk/LnJlbW92ZSgpO1xuICAgIHRoaXMuI3BvcHVwRWxlbWVudCA9IHRoaXMucG9wdXAgPSBudWxsO1xuICB9XG4gIHVwZGF0ZUVkaXRlZChwYXJhbXMpIHtcbiAgICBpZiAoIXRoaXMuY29udGFpbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwYXJhbXMucmVjdCkge1xuICAgICAgdGhpcy4jdXBkYXRlcyB8fD0ge1xuICAgICAgICByZWN0OiB0aGlzLmRhdGEucmVjdC5zbGljZSgwKVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcmVjdCxcbiAgICAgIHBvcHVwOiBuZXdQb3B1cFxuICAgIH0gPSBwYXJhbXM7XG4gICAgaWYgKHJlY3QpIHtcbiAgICAgIHRoaXMuI3NldFJlY3RFZGl0ZWQocmVjdCk7XG4gICAgfVxuICAgIGxldCBwb3B1cCA9IHRoaXMuI3BvcHVwRWxlbWVudD8ucG9wdXAgfHwgdGhpcy5wb3B1cDtcbiAgICBpZiAoIXBvcHVwICYmIG5ld1BvcHVwPy50ZXh0KSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cChuZXdQb3B1cCk7XG4gICAgICBwb3B1cCA9IHRoaXMuI3BvcHVwRWxlbWVudC5wb3B1cDtcbiAgICB9XG4gICAgaWYgKCFwb3B1cCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwb3B1cC51cGRhdGVFZGl0ZWQocGFyYW1zKTtcbiAgICBpZiAobmV3UG9wdXA/LmRlbGV0ZWQpIHtcbiAgICAgIHBvcHVwLnJlbW92ZSgpO1xuICAgICAgdGhpcy4jcG9wdXBFbGVtZW50ID0gbnVsbDtcbiAgICAgIHRoaXMucG9wdXAgPSBudWxsO1xuICAgIH1cbiAgfVxuICByZXNldEVkaXRlZCgpIHtcbiAgICBpZiAoIXRoaXMuI3VwZGF0ZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jc2V0UmVjdEVkaXRlZCh0aGlzLiN1cGRhdGVzLnJlY3QpO1xuICAgIHRoaXMuI3BvcHVwRWxlbWVudD8ucG9wdXAucmVzZXRFZGl0ZWQoKTtcbiAgICB0aGlzLiN1cGRhdGVzID0gbnVsbDtcbiAgfVxuICAjc2V0UmVjdEVkaXRlZChyZWN0KSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGFpbmVyOiB7XG4gICAgICAgIHN0eWxlXG4gICAgICB9LFxuICAgICAgZGF0YToge1xuICAgICAgICByZWN0OiBjdXJyZW50UmVjdCxcbiAgICAgICAgcm90YXRpb25cbiAgICAgIH0sXG4gICAgICBwYXJlbnQ6IHtcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICByYXdEaW1zOiB7XG4gICAgICAgICAgICBwYWdlV2lkdGgsXG4gICAgICAgICAgICBwYWdlSGVpZ2h0LFxuICAgICAgICAgICAgcGFnZVgsXG4gICAgICAgICAgICBwYWdlWVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIGN1cnJlbnRSZWN0Py5zcGxpY2UoMCwgNCwgLi4ucmVjdCk7XG4gICAgc3R5bGUubGVmdCA9IGAkezEwMCAqIChyZWN0WzBdIC0gcGFnZVgpIC8gcGFnZVdpZHRofSVgO1xuICAgIHN0eWxlLnRvcCA9IGAkezEwMCAqIChwYWdlSGVpZ2h0IC0gcmVjdFszXSArIHBhZ2VZKSAvIHBhZ2VIZWlnaHR9JWA7XG4gICAgaWYgKHJvdGF0aW9uID09PSAwKSB7XG4gICAgICBzdHlsZS53aWR0aCA9IGAkezEwMCAqIChyZWN0WzJdIC0gcmVjdFswXSkgLyBwYWdlV2lkdGh9JWA7XG4gICAgICBzdHlsZS5oZWlnaHQgPSBgJHsxMDAgKiAocmVjdFszXSAtIHJlY3RbMV0pIC8gcGFnZUhlaWdodH0lYDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRSb3RhdGlvbihyb3RhdGlvbik7XG4gICAgfVxuICB9XG4gIF9jcmVhdGVDb250YWluZXIoaWdub3JlQm9yZGVyKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YSxcbiAgICAgIHBhcmVudDoge1xuICAgICAgICBwYWdlLFxuICAgICAgICB2aWV3cG9ydFxuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzZWN0aW9uXCIpO1xuICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJkYXRhLWFubm90YXRpb24taWRcIiwgZGF0YS5pZCk7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFdpZGdldEFubm90YXRpb25FbGVtZW50KSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBMaW5rQW5ub3RhdGlvbkVsZW1lbnQpKSB7XG4gICAgICBjb250YWluZXIudGFiSW5kZXggPSAwO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSBjb250YWluZXI7XG4gICAgc3R5bGUuekluZGV4ID0gdGhpcy5wYXJlbnQuekluZGV4O1xuICAgIHRoaXMucGFyZW50LnpJbmRleCArPSAyO1xuICAgIGlmIChkYXRhLmFsdGVybmF0aXZlVGV4dCkge1xuICAgICAgY29udGFpbmVyLnRpdGxlID0gZGF0YS5hbHRlcm5hdGl2ZVRleHQ7XG4gICAgfVxuICAgIGlmIChkYXRhLm5vUm90YXRlKSB7XG4gICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZChcIm5vcm90YXRlXCIpO1xuICAgIH1cbiAgICBpZiAoIWRhdGEucmVjdCB8fCB0aGlzIGluc3RhbmNlb2YgUG9wdXBBbm5vdGF0aW9uRWxlbWVudCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICByb3RhdGlvbjogcm90YXRpb24yXG4gICAgICB9ID0gZGF0YTtcbiAgICAgIGlmICghZGF0YS5oYXNPd25DYW52YXMgJiYgcm90YXRpb24yICE9PSAwKSB7XG4gICAgICAgIHRoaXMuc2V0Um90YXRpb24ocm90YXRpb24yLCBjb250YWluZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWlnbm9yZUJvcmRlciAmJiBkYXRhLmJvcmRlclN0eWxlLndpZHRoID4gMCkge1xuICAgICAgc3R5bGUuYm9yZGVyV2lkdGggPSBgJHtkYXRhLmJvcmRlclN0eWxlLndpZHRofXB4YDtcbiAgICAgIGNvbnN0IGhvcml6b250YWxSYWRpdXMgPSBkYXRhLmJvcmRlclN0eWxlLmhvcml6b250YWxDb3JuZXJSYWRpdXM7XG4gICAgICBjb25zdCB2ZXJ0aWNhbFJhZGl1cyA9IGRhdGEuYm9yZGVyU3R5bGUudmVydGljYWxDb3JuZXJSYWRpdXM7XG4gICAgICBpZiAoaG9yaXpvbnRhbFJhZGl1cyA+IDAgfHwgdmVydGljYWxSYWRpdXMgPiAwKSB7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IGBjYWxjKCR7aG9yaXpvbnRhbFJhZGl1c31weCAqIHZhcigtLXRvdGFsLXNjYWxlLWZhY3RvcikpIC8gY2FsYygke3ZlcnRpY2FsUmFkaXVzfXB4ICogdmFyKC0tdG90YWwtc2NhbGUtZmFjdG9yKSlgO1xuICAgICAgICBzdHlsZS5ib3JkZXJSYWRpdXMgPSByYWRpdXM7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMgaW5zdGFuY2VvZiBSYWRpb0J1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IGBjYWxjKCR7d2lkdGh9cHggKiB2YXIoLS10b3RhbC1zY2FsZS1mYWN0b3IpKSAvIGNhbGMoJHtoZWlnaHR9cHggKiB2YXIoLS10b3RhbC1zY2FsZS1mYWN0b3IpKWA7XG4gICAgICAgIHN0eWxlLmJvcmRlclJhZGl1cyA9IHJhZGl1cztcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZGF0YS5ib3JkZXJTdHlsZS5zdHlsZSkge1xuICAgICAgICBjYXNlIEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuU09MSUQ6XG4gICAgICAgICAgc3R5bGUuYm9yZGVyU3R5bGUgPSBcInNvbGlkXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5EQVNIRUQ6XG4gICAgICAgICAgc3R5bGUuYm9yZGVyU3R5bGUgPSBcImRhc2hlZFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuQkVWRUxFRDpcbiAgICAgICAgICB3YXJuKFwiVW5pbXBsZW1lbnRlZCBib3JkZXIgc3R5bGU6IGJldmVsZWRcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5JTlNFVDpcbiAgICAgICAgICB3YXJuKFwiVW5pbXBsZW1lbnRlZCBib3JkZXIgc3R5bGU6IGluc2V0XCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuVU5ERVJMSU5FOlxuICAgICAgICAgIHN0eWxlLmJvcmRlckJvdHRvbVN0eWxlID0gXCJzb2xpZFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29uc3QgYm9yZGVyQ29sb3IgPSBkYXRhLmJvcmRlckNvbG9yIHx8IG51bGw7XG4gICAgICBpZiAoYm9yZGVyQ29sb3IpIHtcbiAgICAgICAgdGhpcy4jaGFzQm9yZGVyID0gdHJ1ZTtcbiAgICAgICAgc3R5bGUuYm9yZGVyQ29sb3IgPSBVdGlsLm1ha2VIZXhDb2xvcihib3JkZXJDb2xvclswXSB8IDAsIGJvcmRlckNvbG9yWzFdIHwgMCwgYm9yZGVyQ29sb3JbMl0gfCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlLmJvcmRlcldpZHRoID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVjdCA9IFV0aWwubm9ybWFsaXplUmVjdChbZGF0YS5yZWN0WzBdLCBwYWdlLnZpZXdbM10gLSBkYXRhLnJlY3RbMV0gKyBwYWdlLnZpZXdbMV0sIGRhdGEucmVjdFsyXSwgcGFnZS52aWV3WzNdIC0gZGF0YS5yZWN0WzNdICsgcGFnZS52aWV3WzFdXSk7XG4gICAgY29uc3Qge1xuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodCxcbiAgICAgIHBhZ2VYLFxuICAgICAgcGFnZVlcbiAgICB9ID0gdmlld3BvcnQucmF3RGltcztcbiAgICBzdHlsZS5sZWZ0ID0gYCR7MTAwICogKHJlY3RbMF0gLSBwYWdlWCkgLyBwYWdlV2lkdGh9JWA7XG4gICAgc3R5bGUudG9wID0gYCR7MTAwICogKHJlY3RbMV0gLSBwYWdlWSkgLyBwYWdlSGVpZ2h0fSVgO1xuICAgIGNvbnN0IHtcbiAgICAgIHJvdGF0aW9uXG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKGRhdGEuaGFzT3duQ2FudmFzIHx8IHJvdGF0aW9uID09PSAwKSB7XG4gICAgICBzdHlsZS53aWR0aCA9IGAkezEwMCAqIHdpZHRoIC8gcGFnZVdpZHRofSVgO1xuICAgICAgc3R5bGUuaGVpZ2h0ID0gYCR7MTAwICogaGVpZ2h0IC8gcGFnZUhlaWdodH0lYDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRSb3RhdGlvbihyb3RhdGlvbiwgY29udGFpbmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxuICBzZXRSb3RhdGlvbihhbmdsZSwgY29udGFpbmVyID0gdGhpcy5jb250YWluZXIpIHtcbiAgICBpZiAoIXRoaXMuZGF0YS5yZWN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2VXaWR0aCxcbiAgICAgIHBhZ2VIZWlnaHRcbiAgICB9ID0gdGhpcy5wYXJlbnQudmlld3BvcnQucmF3RGltcztcbiAgICBsZXQge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoYW5nbGUgJSAxODAgIT09IDApIHtcbiAgICAgIFt3aWR0aCwgaGVpZ2h0XSA9IFtoZWlnaHQsIHdpZHRoXTtcbiAgICB9XG4gICAgY29udGFpbmVyLnN0eWxlLndpZHRoID0gYCR7MTAwICogd2lkdGggLyBwYWdlV2lkdGh9JWA7XG4gICAgY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGAkezEwMCAqIGhlaWdodCAvIHBhZ2VIZWlnaHR9JWA7XG4gICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImRhdGEtbWFpbi1yb3RhdGlvblwiLCAoMzYwIC0gYW5nbGUpICUgMzYwKTtcbiAgfVxuICBnZXQgX2NvbW1vbkFjdGlvbnMoKSB7XG4gICAgY29uc3Qgc2V0Q29sb3IgPSAoanNOYW1lLCBzdHlsZU5hbWUsIGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBjb2xvciA9IGV2ZW50LmRldGFpbFtqc05hbWVdO1xuICAgICAgY29uc3QgY29sb3JUeXBlID0gY29sb3JbMF07XG4gICAgICBjb25zdCBjb2xvckFycmF5ID0gY29sb3Iuc2xpY2UoMSk7XG4gICAgICBldmVudC50YXJnZXQuc3R5bGVbc3R5bGVOYW1lXSA9IENvbG9yQ29udmVydGVyc1tgJHtjb2xvclR5cGV9X0hUTUxgXShjb2xvckFycmF5KTtcbiAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgIFtzdHlsZU5hbWVdOiBDb2xvckNvbnZlcnRlcnNbYCR7Y29sb3JUeXBlfV9yZ2JgXShjb2xvckFycmF5KVxuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2NvbW1vbkFjdGlvbnNcIiwge1xuICAgICAgZGlzcGxheTogKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBkaXNwbGF5XG4gICAgICAgIH0gPSBldmVudC5kZXRhaWw7XG4gICAgICAgIGNvbnN0IGhpZGRlbiA9IGRpc3BsYXkgJSAyID09PSAxO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gaGlkZGVuID8gXCJoaWRkZW5cIiA6IFwidmlzaWJsZVwiO1xuICAgICAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlLnNldFZhbHVlKHRoaXMuZGF0YS5pZCwge1xuICAgICAgICAgIG5vVmlldzogaGlkZGVuLFxuICAgICAgICAgIG5vUHJpbnQ6IGRpc3BsYXkgPT09IDEgfHwgZGlzcGxheSA9PT0gMlxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBwcmludDogKGV2ZW50KSA9PiB7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgICAgbm9QcmludDogIWV2ZW50LmRldGFpbC5wcmludFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBoaWRkZW46IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaGlkZGVuXG4gICAgICAgIH0gPSBldmVudC5kZXRhaWw7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSBoaWRkZW4gPyBcImhpZGRlblwiIDogXCJ2aXNpYmxlXCI7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgICAgbm9QcmludDogaGlkZGVuLFxuICAgICAgICAgIG5vVmlldzogaGlkZGVuXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGZvY3VzOiAoZXZlbnQpID0+IHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBldmVudC50YXJnZXQuZm9jdXMoe1xuICAgICAgICAgIHByZXZlbnRTY3JvbGw6IGZhbHNlXG4gICAgICAgIH0pLCAwKTtcbiAgICAgIH0sXG4gICAgICB1c2VyTmFtZTogKGV2ZW50KSA9PiB7XG4gICAgICAgIGV2ZW50LnRhcmdldC50aXRsZSA9IGV2ZW50LmRldGFpbC51c2VyTmFtZTtcbiAgICAgIH0sXG4gICAgICByZWFkb25seTogKGV2ZW50KSA9PiB7XG4gICAgICAgIGV2ZW50LnRhcmdldC5kaXNhYmxlZCA9IGV2ZW50LmRldGFpbC5yZWFkb25seTtcbiAgICAgIH0sXG4gICAgICByZXF1aXJlZDogKGV2ZW50KSA9PiB7XG4gICAgICAgIHRoaXMuX3NldFJlcXVpcmVkKGV2ZW50LnRhcmdldCwgZXZlbnQuZGV0YWlsLnJlcXVpcmVkKTtcbiAgICAgIH0sXG4gICAgICBiZ0NvbG9yOiAoZXZlbnQpID0+IHtcbiAgICAgICAgc2V0Q29sb3IoXCJiZ0NvbG9yXCIsIFwiYmFja2dyb3VuZENvbG9yXCIsIGV2ZW50KTtcbiAgICAgIH0sXG4gICAgICBmaWxsQ29sb3I6IChldmVudCkgPT4ge1xuICAgICAgICBzZXRDb2xvcihcImZpbGxDb2xvclwiLCBcImJhY2tncm91bmRDb2xvclwiLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgZmdDb2xvcjogKGV2ZW50KSA9PiB7XG4gICAgICAgIHNldENvbG9yKFwiZmdDb2xvclwiLCBcImNvbG9yXCIsIGV2ZW50KTtcbiAgICAgIH0sXG4gICAgICB0ZXh0Q29sb3I6IChldmVudCkgPT4ge1xuICAgICAgICBzZXRDb2xvcihcInRleHRDb2xvclwiLCBcImNvbG9yXCIsIGV2ZW50KTtcbiAgICAgIH0sXG4gICAgICBib3JkZXJDb2xvcjogKGV2ZW50KSA9PiB7XG4gICAgICAgIHNldENvbG9yKFwiYm9yZGVyQ29sb3JcIiwgXCJib3JkZXJDb2xvclwiLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgc3Ryb2tlQ29sb3I6IChldmVudCkgPT4ge1xuICAgICAgICBzZXRDb2xvcihcInN0cm9rZUNvbG9yXCIsIFwiYm9yZGVyQ29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIHJvdGF0aW9uOiAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgYW5nbGUgPSBldmVudC5kZXRhaWwucm90YXRpb247XG4gICAgICAgIHRoaXMuc2V0Um90YXRpb24oYW5nbGUpO1xuICAgICAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlLnNldFZhbHVlKHRoaXMuZGF0YS5pZCwge1xuICAgICAgICAgIHJvdGF0aW9uOiBhbmdsZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfZGlzcGF0Y2hFdmVudEZyb21TYW5kYm94KGFjdGlvbnMsIGpzRXZlbnQpIHtcbiAgICBjb25zdCBjb21tb25BY3Rpb25zID0gdGhpcy5fY29tbW9uQWN0aW9ucztcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoanNFdmVudC5kZXRhaWwpKSB7XG4gICAgICBjb25zdCBhY3Rpb24gPSBhY3Rpb25zW25hbWVdIHx8IGNvbW1vbkFjdGlvbnNbbmFtZV07XG4gICAgICBhY3Rpb24/Lihqc0V2ZW50KTtcbiAgICB9XG4gIH1cbiAgX3NldERlZmF1bHRQcm9wZXJ0aWVzRnJvbUpTKGVsZW1lbnQpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlU2NyaXB0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0b3JlZERhdGEgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlLmdldFJhd1ZhbHVlKHRoaXMuZGF0YS5pZCk7XG4gICAgaWYgKCFzdG9yZWREYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbW1vbkFjdGlvbnMgPSB0aGlzLl9jb21tb25BY3Rpb25zO1xuICAgIGZvciAoY29uc3QgW2FjdGlvbk5hbWUsIGRldGFpbF0gb2YgT2JqZWN0LmVudHJpZXMoc3RvcmVkRGF0YSkpIHtcbiAgICAgIGNvbnN0IGFjdGlvbiA9IGNvbW1vbkFjdGlvbnNbYWN0aW9uTmFtZV07XG4gICAgICBpZiAoYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50UHJveHkgPSB7XG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBbYWN0aW9uTmFtZV06IGRldGFpbFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGFyZ2V0OiBlbGVtZW50XG4gICAgICAgIH07XG4gICAgICAgIGFjdGlvbihldmVudFByb3h5KTtcbiAgICAgICAgZGVsZXRlIHN0b3JlZERhdGFbYWN0aW9uTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9jcmVhdGVRdWFkcmlsYXRlcmFscygpIHtcbiAgICBpZiAoIXRoaXMuY29udGFpbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHF1YWRQb2ludHNcbiAgICB9ID0gdGhpcy5kYXRhO1xuICAgIGlmICghcXVhZFBvaW50cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBbcmVjdEJsWCwgcmVjdEJsWSwgcmVjdFRyWCwgcmVjdFRyWV0gPSB0aGlzLmRhdGEucmVjdC5tYXAoKHgpID0+IE1hdGguZnJvdW5kKHgpKTtcbiAgICBpZiAocXVhZFBvaW50cy5sZW5ndGggPT09IDgpIHtcbiAgICAgIGNvbnN0IFt0clgsIHRyWSwgYmxYLCBibFldID0gcXVhZFBvaW50cy5zdWJhcnJheSgyLCA2KTtcbiAgICAgIGlmIChyZWN0VHJYID09PSB0clggJiYgcmVjdFRyWSA9PT0gdHJZICYmIHJlY3RCbFggPT09IGJsWCAmJiByZWN0QmxZID09PSBibFkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSB0aGlzLmNvbnRhaW5lcjtcbiAgICBsZXQgc3ZnQnVmZmVyO1xuICAgIGlmICh0aGlzLiNoYXNCb3JkZXIpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYm9yZGVyQ29sb3IsXG4gICAgICAgIGJvcmRlcldpZHRoXG4gICAgICB9ID0gc3R5bGU7XG4gICAgICBzdHlsZS5ib3JkZXJXaWR0aCA9IDA7XG4gICAgICBzdmdCdWZmZXIgPSBbXCJ1cmwoJ2RhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LFwiLCBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJgLCBgIHByZXNlcnZlQXNwZWN0UmF0aW89XCJub25lXCIgdmlld0JveD1cIjAgMCAxIDFcIj5gLCBgPGcgZmlsbD1cInRyYW5zcGFyZW50XCIgc3Ryb2tlPVwiJHtib3JkZXJDb2xvcn1cIiBzdHJva2Utd2lkdGg9XCIke2JvcmRlcldpZHRofVwiPmBdO1xuICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhhc0JvcmRlclwiKTtcbiAgICB9XG4gICAgY29uc3Qgd2lkdGggPSByZWN0VHJYIC0gcmVjdEJsWDtcbiAgICBjb25zdCBoZWlnaHQgPSByZWN0VHJZIC0gcmVjdEJsWTtcbiAgICBjb25zdCB7XG4gICAgICBzdmdGYWN0b3J5XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc3ZnID0gc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnXCIpO1xuICAgIHN2Zy5jbGFzc0xpc3QuYWRkKFwicXVhZHJpbGF0ZXJhbHNDb250YWluZXJcIik7XG4gICAgc3ZnLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIDApO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgMCk7XG4gICAgc3ZnLnJvbGUgPSBcIm5vbmVcIjtcbiAgICBjb25zdCBkZWZzID0gc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwiZGVmc1wiKTtcbiAgICBzdmcuYXBwZW5kKGRlZnMpO1xuICAgIGNvbnN0IGNsaXBQYXRoID0gc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwiY2xpcFBhdGhcIik7XG4gICAgY29uc3QgaWQgPSBgY2xpcHBhdGhfJHt0aGlzLmRhdGEuaWR9YDtcbiAgICBjbGlwUGF0aC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBpZCk7XG4gICAgY2xpcFBhdGguc2V0QXR0cmlidXRlKFwiY2xpcFBhdGhVbml0c1wiLCBcIm9iamVjdEJvdW5kaW5nQm94XCIpO1xuICAgIGRlZnMuYXBwZW5kKGNsaXBQYXRoKTtcbiAgICBmb3IgKGxldCBpID0gMiwgaWkgPSBxdWFkUG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDgpIHtcbiAgICAgIGNvbnN0IHRyWCA9IHF1YWRQb2ludHNbaV07XG4gICAgICBjb25zdCB0clkgPSBxdWFkUG9pbnRzW2kgKyAxXTtcbiAgICAgIGNvbnN0IGJsWCA9IHF1YWRQb2ludHNbaSArIDJdO1xuICAgICAgY29uc3QgYmxZID0gcXVhZFBvaW50c1tpICsgM107XG4gICAgICBjb25zdCByZWN0ID0gc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwicmVjdFwiKTtcbiAgICAgIGNvbnN0IHggPSAoYmxYIC0gcmVjdEJsWCkgLyB3aWR0aDtcbiAgICAgIGNvbnN0IHkgPSAocmVjdFRyWSAtIHRyWSkgLyBoZWlnaHQ7XG4gICAgICBjb25zdCByZWN0V2lkdGggPSAodHJYIC0gYmxYKSAvIHdpZHRoO1xuICAgICAgY29uc3QgcmVjdEhlaWdodCA9ICh0clkgLSBibFkpIC8gaGVpZ2h0O1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoXCJ4XCIsIHgpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoXCJ5XCIsIHkpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCByZWN0V2lkdGgpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgcmVjdEhlaWdodCk7XG4gICAgICBjbGlwUGF0aC5hcHBlbmQocmVjdCk7XG4gICAgICBzdmdCdWZmZXI/LnB1c2goYDxyZWN0IHZlY3Rvci1lZmZlY3Q9XCJub24tc2NhbGluZy1zdHJva2VcIiB4PVwiJHt4fVwiIHk9XCIke3l9XCIgd2lkdGg9XCIke3JlY3RXaWR0aH1cIiBoZWlnaHQ9XCIke3JlY3RIZWlnaHR9XCIvPmApO1xuICAgIH1cbiAgICBpZiAodGhpcy4jaGFzQm9yZGVyKSB7XG4gICAgICBzdmdCdWZmZXIucHVzaChgPC9nPjwvc3ZnPicpYCk7XG4gICAgICBzdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBzdmdCdWZmZXIuam9pbihcIlwiKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG4gICAgdGhpcy5jb250YWluZXIuc3R5bGUuY2xpcFBhdGggPSBgdXJsKCMke2lkfSlgO1xuICB9XG4gIF9jcmVhdGVQb3B1cChwb3B1cERhdGEgPSBudWxsKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YVxuICAgIH0gPSB0aGlzO1xuICAgIGxldCBjb250ZW50c09iaiwgbW9kaWZpY2F0aW9uRGF0ZTtcbiAgICBpZiAocG9wdXBEYXRhKSB7XG4gICAgICBjb250ZW50c09iaiA9IHtcbiAgICAgICAgc3RyOiBwb3B1cERhdGEudGV4dFxuICAgICAgfTtcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGUgPSBwb3B1cERhdGEuZGF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudHNPYmogPSBkYXRhLmNvbnRlbnRzT2JqO1xuICAgICAgbW9kaWZpY2F0aW9uRGF0ZSA9IGRhdGEubW9kaWZpY2F0aW9uRGF0ZTtcbiAgICB9XG4gICAgY29uc3QgcG9wdXAgPSB0aGlzLiNwb3B1cEVsZW1lbnQgPSBuZXcgUG9wdXBBbm5vdGF0aW9uRWxlbWVudCh7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIGNvbG9yOiBkYXRhLmNvbG9yLFxuICAgICAgICB0aXRsZU9iajogZGF0YS50aXRsZU9iaixcbiAgICAgICAgbW9kaWZpY2F0aW9uRGF0ZSxcbiAgICAgICAgY29udGVudHNPYmosXG4gICAgICAgIHJpY2hUZXh0OiBkYXRhLnJpY2hUZXh0LFxuICAgICAgICBwYXJlbnRSZWN0OiBkYXRhLnJlY3QsXG4gICAgICAgIGJvcmRlclN0eWxlOiAwLFxuICAgICAgICBpZDogYHBvcHVwXyR7ZGF0YS5pZH1gLFxuICAgICAgICByb3RhdGlvbjogZGF0YS5yb3RhdGlvbixcbiAgICAgICAgbm9Sb3RhdGU6IHRydWVcbiAgICAgIH0sXG4gICAgICBsaW5rU2VydmljZTogdGhpcy5saW5rU2VydmljZSxcbiAgICAgIHBhcmVudDogdGhpcy5wYXJlbnQsXG4gICAgICBlbGVtZW50czogW3RoaXNdXG4gICAgfSk7XG4gICAgaWYgKCF0aGlzLnBhcmVudC5fY29tbWVudE1hbmFnZXIpIHtcbiAgICAgIHRoaXMucGFyZW50LmRpdi5hcHBlbmQocG9wdXAucmVuZGVyKCkpO1xuICAgIH1cbiAgfVxuICBnZXQgaGFzUG9wdXBFbGVtZW50KCkge1xuICAgIHJldHVybiAhISh0aGlzLiNwb3B1cEVsZW1lbnQgfHwgdGhpcy5wb3B1cCB8fCB0aGlzLmRhdGEucG9wdXBSZWYpO1xuICB9XG4gIGdldCBleHRyYVBvcHVwRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9wdXBFbGVtZW50O1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB1bnJlYWNoYWJsZShcIkFic3RyYWN0IG1ldGhvZCBgQW5ub3RhdGlvbkVsZW1lbnQucmVuZGVyYCBjYWxsZWRcIik7XG4gIH1cbiAgX2dldEVsZW1lbnRzQnlOYW1lKG5hbWUsIHNraXBJZCA9IG51bGwpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBbXTtcbiAgICBpZiAodGhpcy5fZmllbGRPYmplY3RzKSB7XG4gICAgICBjb25zdCBmaWVsZE9iaiA9IHRoaXMuX2ZpZWxkT2JqZWN0c1tuYW1lXTtcbiAgICAgIGlmIChmaWVsZE9iaikge1xuICAgICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgICBwYWdlLFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIGV4cG9ydFZhbHVlc1xuICAgICAgICB9IG9mIGZpZWxkT2JqKSB7XG4gICAgICAgICAgaWYgKHBhZ2UgPT09IC0xKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlkID09PSBza2lwSWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBleHBvcnRWYWx1ZSA9IHR5cGVvZiBleHBvcnRWYWx1ZXMgPT09IFwic3RyaW5nXCIgPyBleHBvcnRWYWx1ZXMgOiBudWxsO1xuICAgICAgICAgIGNvbnN0IGRvbUVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1lbGVtZW50LWlkPVwiJHtpZH1cIl1gKTtcbiAgICAgICAgICBpZiAoZG9tRWxlbWVudCAmJiAhR2V0RWxlbWVudHNCeU5hbWVTZXQuaGFzKGRvbUVsZW1lbnQpKSB7XG4gICAgICAgICAgICB3YXJuKGBfZ2V0RWxlbWVudHNCeU5hbWUgLSBlbGVtZW50IG5vdCBhbGxvd2VkOiAke2lkfWApO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpZWxkcy5wdXNoKHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgZXhwb3J0VmFsdWUsXG4gICAgICAgICAgICBkb21FbGVtZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmaWVsZHM7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZG9tRWxlbWVudCBvZiBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShuYW1lKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBleHBvcnRWYWx1ZVxuICAgICAgfSA9IGRvbUVsZW1lbnQ7XG4gICAgICBjb25zdCBpZCA9IGRvbUVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIpO1xuICAgICAgaWYgKGlkID09PSBza2lwSWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIUdldEVsZW1lbnRzQnlOYW1lU2V0Lmhhcyhkb21FbGVtZW50KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZpZWxkcy5wdXNoKHtcbiAgICAgICAgaWQsXG4gICAgICAgIGV4cG9ydFZhbHVlLFxuICAgICAgICBkb21FbGVtZW50XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkcztcbiAgfVxuICBzaG93KCkge1xuICAgIGlmICh0aGlzLmNvbnRhaW5lcikge1xuICAgICAgdGhpcy5jb250YWluZXIuaGlkZGVuID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMucG9wdXA/Lm1heWJlU2hvdygpO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgaWYgKHRoaXMuY29udGFpbmVyKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5oaWRkZW4gPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLnBvcHVwPy5mb3JjZUhpZGUoKTtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBhZGRIaWdobGlnaHRBcmVhKCkge1xuICAgIGNvbnN0IHRyaWdnZXJzID0gdGhpcy5nZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodHJpZ2dlcnMpKSB7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdHJpZ2dlcnMpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJpZ2dlcnMuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gICAgfVxuICB9XG4gIF9lZGl0T25Eb3VibGVDbGljaygpIHtcbiAgICBpZiAoIXRoaXMuX2lzRWRpdGFibGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYW5ub3RhdGlvbkVkaXRvclR5cGU6IG1vZGUsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGlkOiBlZGl0SWRcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICB0aGlzLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwiZGJsY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJzd2l0Y2hhbm5vdGF0aW9uZWRpdG9ybW9kZVwiLCB7XG4gICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgZWRpdElkLFxuICAgICAgICBtdXN0RW50ZXJJbkVkaXRNb2RlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5yZWN0WzJdIC0gdGhpcy5kYXRhLnJlY3RbMF07XG4gIH1cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnJlY3RbM10gLSB0aGlzLmRhdGEucmVjdFsxXTtcbiAgfVxufVxuY2xhc3MgRWRpdG9yQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmVkaXRvciA9IHBhcmFtZXRlcnMuZWRpdG9yO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSBcImVkaXRvckFubm90YXRpb25cIjtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgY3JlYXRlT3JVcGRhdGVQb3B1cCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBlZGl0b3JcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWVkaXRvci5oYXNDb21tZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2NyZWF0ZVBvcHVwKGVkaXRvci5jb21tZW50KTtcbiAgICB0aGlzLmV4dHJhUG9wdXBFbGVtZW50LnBvcHVwLnJlbmRlckNvbW1lbnRCdXR0b24oKTtcbiAgfVxuICBnZXQgaGFzQ29tbWVudEJ1dHRvbigpIHtcbiAgICByZXR1cm4gdGhpcy5lbmFibGVDb21tZW50ICYmIHRoaXMuZWRpdG9yLmhhc0NvbW1lbnQ7XG4gIH1cbiAgZ2V0IGNvbW1lbnRCdXR0b25Qb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5lZGl0b3IuY29tbWVudEJ1dHRvblBvc2l0aW9uSW5QYWdlO1xuICB9XG4gIGdldCBjb21tZW50VGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5lZGl0b3IuY29tbWVudC50ZXh0O1xuICB9XG4gIHNldCBjb21tZW50VGV4dCh0ZXh0KSB7XG4gICAgdGhpcy5lZGl0b3IuY29tbWVudCA9IHRleHQ7XG4gICAgaWYgKCF0ZXh0KSB7XG4gICAgICB0aGlzLnJlbW92ZVBvcHVwKCk7XG4gICAgfVxuICB9XG4gIGdldCBjb21tZW50RGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5lZGl0b3IuZ2V0RGF0YSgpO1xuICB9XG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmUoKTtcbiAgICB0aGlzLmNvbnRhaW5lciA9IG51bGw7XG4gICAgdGhpcy5yZW1vdmVQb3B1cCgpO1xuICB9XG59XG5jbGFzcyBMaW5rQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMsIG9wdGlvbnMgPSBudWxsKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiAhIW9wdGlvbnM/Lmlnbm9yZUJvcmRlcixcbiAgICAgIGNyZWF0ZVF1YWRyaWxhdGVyYWxzOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5pc1Rvb2x0aXBPbmx5ID0gcGFyYW1ldGVycy5kYXRhLmlzVG9vbHRpcE9ubHk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICBsaW5rU2VydmljZVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICBsaW5rLnNldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiLCBkYXRhLmlkKTtcbiAgICBsZXQgaXNCb3VuZCA9IGZhbHNlO1xuICAgIGlmIChkYXRhLnVybCkge1xuICAgICAgbGlua1NlcnZpY2UuYWRkTGlua0F0dHJpYnV0ZXMobGluaywgZGF0YS51cmwsIGRhdGEubmV3V2luZG93KTtcbiAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5hY3Rpb24pIHtcbiAgICAgIHRoaXMuX2JpbmROYW1lZEFjdGlvbihsaW5rLCBkYXRhLmFjdGlvbiwgZGF0YS5vdmVybGFpZFRleHQpO1xuICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChkYXRhLmF0dGFjaG1lbnQpIHtcbiAgICAgIHRoaXMuI2JpbmRBdHRhY2htZW50KGxpbmssIGRhdGEuYXR0YWNobWVudCwgZGF0YS5vdmVybGFpZFRleHQsIGRhdGEuYXR0YWNobWVudERlc3QpO1xuICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChkYXRhLnNldE9DR1N0YXRlKSB7XG4gICAgICB0aGlzLiNiaW5kU2V0T0NHU3RhdGUobGluaywgZGF0YS5zZXRPQ0dTdGF0ZSwgZGF0YS5vdmVybGFpZFRleHQpO1xuICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChkYXRhLmRlc3QpIHtcbiAgICAgIHRoaXMuX2JpbmRMaW5rKGxpbmssIGRhdGEuZGVzdCwgZGF0YS5vdmVybGFpZFRleHQpO1xuICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkYXRhLmFjdGlvbnMgJiYgKGRhdGEuYWN0aW9ucy5BY3Rpb24gfHwgZGF0YS5hY3Rpb25zW1wiTW91c2UgVXBcIl0gfHwgZGF0YS5hY3Rpb25zW1wiTW91c2UgRG93blwiXSkgJiYgdGhpcy5lbmFibGVTY3JpcHRpbmcgJiYgdGhpcy5oYXNKU0FjdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fYmluZEpTQWN0aW9uKGxpbmssIGRhdGEpO1xuICAgICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLnJlc2V0Rm9ybSkge1xuICAgICAgICB0aGlzLl9iaW5kUmVzZXRGb3JtQWN0aW9uKGxpbmssIGRhdGEucmVzZXRGb3JtKTtcbiAgICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNUb29sdGlwT25seSAmJiAhaXNCb3VuZCkge1xuICAgICAgICB0aGlzLl9iaW5kTGluayhsaW5rLCBcIlwiKTtcbiAgICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJsaW5rQW5ub3RhdGlvblwiKTtcbiAgICBpZiAoaXNCb3VuZCkge1xuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGxpbmspO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgI3NldEludGVybmFsTGluaygpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJkYXRhLWludGVybmFsLWxpbmtcIiwgXCJcIik7XG4gIH1cbiAgX2JpbmRMaW5rKGxpbmssIGRlc3RpbmF0aW9uLCBvdmVybGFpZFRleHQgPSBcIlwiKSB7XG4gICAgbGluay5ocmVmID0gdGhpcy5saW5rU2VydmljZS5nZXREZXN0aW5hdGlvbkhhc2goZGVzdGluYXRpb24pO1xuICAgIGxpbmsub25jbGljayA9ICgpID0+IHtcbiAgICAgIGlmIChkZXN0aW5hdGlvbikge1xuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmdvVG9EZXN0aW5hdGlvbihkZXN0aW5hdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBpZiAoZGVzdGluYXRpb24gfHwgZGVzdGluYXRpb24gPT09IFwiXCIpIHtcbiAgICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICAgIH1cbiAgICBpZiAob3ZlcmxhaWRUZXh0KSB7XG4gICAgICBsaW5rLnRpdGxlID0gb3ZlcmxhaWRUZXh0O1xuICAgIH1cbiAgfVxuICBfYmluZE5hbWVkQWN0aW9uKGxpbmssIGFjdGlvbiwgb3ZlcmxhaWRUZXh0ID0gXCJcIikge1xuICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0QW5jaG9yVXJsKFwiXCIpO1xuICAgIGxpbmsub25jbGljayA9ICgpID0+IHtcbiAgICAgIHRoaXMubGlua1NlcnZpY2UuZXhlY3V0ZU5hbWVkQWN0aW9uKGFjdGlvbik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBpZiAob3ZlcmxhaWRUZXh0KSB7XG4gICAgICBsaW5rLnRpdGxlID0gb3ZlcmxhaWRUZXh0O1xuICAgIH1cbiAgICB0aGlzLiNzZXRJbnRlcm5hbExpbmsoKTtcbiAgfVxuICAjYmluZEF0dGFjaG1lbnQobGluaywgYXR0YWNobWVudCwgb3ZlcmxhaWRUZXh0ID0gXCJcIiwgZGVzdCA9IG51bGwpIHtcbiAgICBsaW5rLmhyZWYgPSB0aGlzLmxpbmtTZXJ2aWNlLmdldEFuY2hvclVybChcIlwiKTtcbiAgICBpZiAoYXR0YWNobWVudC5kZXNjcmlwdGlvbikge1xuICAgICAgbGluay50aXRsZSA9IGF0dGFjaG1lbnQuZGVzY3JpcHRpb247XG4gICAgfSBlbHNlIGlmIChvdmVybGFpZFRleHQpIHtcbiAgICAgIGxpbmsudGl0bGUgPSBvdmVybGFpZFRleHQ7XG4gICAgfVxuICAgIGxpbmsub25jbGljayA9ICgpID0+IHtcbiAgICAgIHRoaXMuZG93bmxvYWRNYW5hZ2VyPy5vcGVuT3JEb3dubG9hZERhdGEoYXR0YWNobWVudC5jb250ZW50LCBhdHRhY2htZW50LmZpbGVuYW1lLCBkZXN0KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICB9XG4gICNiaW5kU2V0T0NHU3RhdGUobGluaywgYWN0aW9uLCBvdmVybGFpZFRleHQgPSBcIlwiKSB7XG4gICAgbGluay5ocmVmID0gdGhpcy5saW5rU2VydmljZS5nZXRBbmNob3JVcmwoXCJcIik7XG4gICAgbGluay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgdGhpcy5saW5rU2VydmljZS5leGVjdXRlU2V0T0NHU3RhdGUoYWN0aW9uKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGlmIChvdmVybGFpZFRleHQpIHtcbiAgICAgIGxpbmsudGl0bGUgPSBvdmVybGFpZFRleHQ7XG4gICAgfVxuICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICB9XG4gIF9iaW5kSlNBY3Rpb24obGluaywgZGF0YSkge1xuICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0QW5jaG9yVXJsKFwiXCIpO1xuICAgIGNvbnN0IG1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtbXCJBY3Rpb25cIiwgXCJvbmNsaWNrXCJdLCBbXCJNb3VzZSBVcFwiLCBcIm9ubW91c2V1cFwiXSwgW1wiTW91c2UgRG93blwiLCBcIm9ubW91c2Vkb3duXCJdXSk7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKGRhdGEuYWN0aW9ucykpIHtcbiAgICAgIGNvbnN0IGpzTmFtZSA9IG1hcC5nZXQobmFtZSk7XG4gICAgICBpZiAoIWpzTmFtZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxpbmtbanNOYW1lXSA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBpZDogZGF0YS5pZCxcbiAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoZGF0YS5vdmVybGFpZFRleHQpIHtcbiAgICAgIGxpbmsudGl0bGUgPSBkYXRhLm92ZXJsYWlkVGV4dDtcbiAgICB9XG4gICAgaWYgKCFsaW5rLm9uY2xpY2spIHtcbiAgICAgIGxpbmsub25jbGljayA9ICgpID0+IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLiNzZXRJbnRlcm5hbExpbmsoKTtcbiAgfVxuICBfYmluZFJlc2V0Rm9ybUFjdGlvbihsaW5rLCByZXNldEZvcm0pIHtcbiAgICBjb25zdCBvdGhlckNsaWNrQWN0aW9uID0gbGluay5vbmNsaWNrO1xuICAgIGlmICghb3RoZXJDbGlja0FjdGlvbikge1xuICAgICAgbGluay5ocmVmID0gdGhpcy5saW5rU2VydmljZS5nZXRBbmNob3JVcmwoXCJcIik7XG4gICAgfVxuICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICAgIGlmICghdGhpcy5fZmllbGRPYmplY3RzKSB7XG4gICAgICB3YXJuKGBfYmluZFJlc2V0Rm9ybUFjdGlvbiAtIFwicmVzZXRGb3JtXCIgYWN0aW9uIG5vdCBzdXBwb3J0ZWQsIGVuc3VyZSB0aGF0IHRoZSBcXGBmaWVsZE9iamVjdHNcXGAgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLmApO1xuICAgICAgaWYgKCFvdGhlckNsaWNrQWN0aW9uKSB7XG4gICAgICAgIGxpbmsub25jbGljayA9ICgpID0+IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsaW5rLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICBvdGhlckNsaWNrQWN0aW9uPy4oKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZmllbGRzOiByZXNldEZvcm1GaWVsZHMsXG4gICAgICAgIHJlZnM6IHJlc2V0Rm9ybVJlZnMsXG4gICAgICAgIGluY2x1ZGVcbiAgICAgIH0gPSByZXNldEZvcm07XG4gICAgICBjb25zdCBhbGxGaWVsZHMgPSBbXTtcbiAgICAgIGlmIChyZXNldEZvcm1GaWVsZHMubGVuZ3RoICE9PSAwIHx8IHJlc2V0Rm9ybVJlZnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkSWRzID0gbmV3IFNldChyZXNldEZvcm1SZWZzKTtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZE5hbWUgb2YgcmVzZXRGb3JtRmllbGRzKSB7XG4gICAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy5fZmllbGRPYmplY3RzW2ZpZWxkTmFtZV0gfHwgW107XG4gICAgICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgICAgICBpZFxuICAgICAgICAgIH0gb2YgZmllbGRzKSB7XG4gICAgICAgICAgICBmaWVsZElkcy5hZGQoaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkcyBvZiBPYmplY3QudmFsdWVzKHRoaXMuX2ZpZWxkT2JqZWN0cykpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGZpZWxkcykge1xuICAgICAgICAgICAgaWYgKGZpZWxkSWRzLmhhcyhmaWVsZC5pZCkgPT09IGluY2x1ZGUpIHtcbiAgICAgICAgICAgICAgYWxsRmllbGRzLnB1c2goZmllbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZHMgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLl9maWVsZE9iamVjdHMpKSB7XG4gICAgICAgICAgYWxsRmllbGRzLnB1c2goLi4uZmllbGRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgICBjb25zdCBhbGxJZHMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgYWxsRmllbGRzKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBpZFxuICAgICAgICB9ID0gZmllbGQ7XG4gICAgICAgIGFsbElkcy5wdXNoKGlkKTtcbiAgICAgICAgc3dpdGNoIChmaWVsZC50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcInRleHRcIjoge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBmaWVsZC5kZWZhdWx0VmFsdWUgfHwgXCJcIjtcbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJjaGVja2JveFwiOlxuICAgICAgICAgIGNhc2UgXCJyYWRpb2J1dHRvblwiOiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGZpZWxkLmRlZmF1bHRWYWx1ZSA9PT0gZmllbGQuZXhwb3J0VmFsdWVzO1xuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImNvbWJvYm94XCI6XG4gICAgICAgICAgY2FzZSBcImxpc3Rib3hcIjoge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBmaWVsZC5kZWZhdWx0VmFsdWUgfHwgXCJcIjtcbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkb21FbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgW2RhdGEtZWxlbWVudC1pZD1cIiR7aWR9XCJdYCk7XG4gICAgICAgIGlmICghZG9tRWxlbWVudCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKCFHZXRFbGVtZW50c0J5TmFtZVNldC5oYXMoZG9tRWxlbWVudCkpIHtcbiAgICAgICAgICB3YXJuKGBfYmluZFJlc2V0Rm9ybUFjdGlvbiAtIGVsZW1lbnQgbm90IGFsbG93ZWQ6ICR7aWR9YCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZG9tRWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInJlc2V0Zm9ybVwiKSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5lbmFibGVTY3JpcHRpbmcpIHtcbiAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBpZDogXCJhcHBcIixcbiAgICAgICAgICAgIGlkczogYWxsSWRzLFxuICAgICAgICAgICAgbmFtZTogXCJSZXNldEZvcm1cIlxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgfVxufVxuY2xhc3MgVGV4dEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJ0ZXh0QW5ub3RhdGlvblwiKTtcbiAgICBjb25zdCBpbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgaW1hZ2Uuc3JjID0gdGhpcy5pbWFnZVJlc291cmNlc1BhdGggKyBcImFubm90YXRpb24tXCIgKyB0aGlzLmRhdGEubmFtZS50b0xvd2VyQ2FzZSgpICsgXCIuc3ZnXCI7XG4gICAgaW1hZ2Uuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtdGV4dC1hbm5vdGF0aW9uLXR5cGVcIik7XG4gICAgaW1hZ2Uuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWFyZ3NcIiwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgdHlwZTogdGhpcy5kYXRhLm5hbWVcbiAgICB9KSk7XG4gICAgaWYgKCF0aGlzLmRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChpbWFnZSk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBzaG93RWxlbWVudEFuZEhpZGVDYW52YXMoZWxlbWVudCkge1xuICAgIGlmICh0aGlzLmRhdGEuaGFzT3duQ2FudmFzKSB7XG4gICAgICBpZiAoZWxlbWVudC5wcmV2aW91c1NpYmxpbmc/Lm5vZGVOYW1lID09PSBcIkNBTlZBU1wiKSB7XG4gICAgICAgIGVsZW1lbnQucHJldmlvdXNTaWJsaW5nLmhpZGRlbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBlbGVtZW50LmhpZGRlbiA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBfZ2V0S2V5TW9kaWZpZXIoZXZlbnQpIHtcbiAgICByZXR1cm4gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybS5pc01hYyA/IGV2ZW50Lm1ldGFLZXkgOiBldmVudC5jdHJsS2V5O1xuICB9XG4gIF9zZXRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBiYXNlTmFtZSwgZXZlbnROYW1lLCB2YWx1ZUdldHRlcikge1xuICAgIGlmIChiYXNlTmFtZS5pbmNsdWRlcyhcIm1vdXNlXCIpKSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoYmFzZU5hbWUsIChldmVudCkgPT4ge1xuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIGlkOiB0aGlzLmRhdGEuaWQsXG4gICAgICAgICAgICBuYW1lOiBldmVudE5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVHZXR0ZXIoZXZlbnQpLFxuICAgICAgICAgICAgc2hpZnQ6IGV2ZW50LnNoaWZ0S2V5LFxuICAgICAgICAgICAgbW9kaWZpZXI6IHRoaXMuX2dldEtleU1vZGlmaWVyKGV2ZW50KVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGJhc2VOYW1lLCAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGJhc2VOYW1lID09PSBcImJsdXJcIikge1xuICAgICAgICAgIGlmICghZWxlbWVudERhdGEuZm9jdXNlZCB8fCAhZXZlbnQucmVsYXRlZFRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbGVtZW50RGF0YS5mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoYmFzZU5hbWUgPT09IFwiZm9jdXNcIikge1xuICAgICAgICAgIGlmIChlbGVtZW50RGF0YS5mb2N1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnREYXRhLmZvY3VzZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdmFsdWVHZXR0ZXIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBpZDogdGhpcy5kYXRhLmlkLFxuICAgICAgICAgICAgbmFtZTogZXZlbnROYW1lLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlR2V0dGVyKGV2ZW50KVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgX3NldEV2ZW50TGlzdGVuZXJzKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBuYW1lcywgZ2V0dGVyKSB7XG4gICAgZm9yIChjb25zdCBbYmFzZU5hbWUsIGV2ZW50TmFtZV0gb2YgbmFtZXMpIHtcbiAgICAgIGlmIChldmVudE5hbWUgPT09IFwiQWN0aW9uXCIgfHwgdGhpcy5kYXRhLmFjdGlvbnM/LltldmVudE5hbWVdKSB7XG4gICAgICAgIGlmIChldmVudE5hbWUgPT09IFwiRm9jdXNcIiB8fCBldmVudE5hbWUgPT09IFwiQmx1clwiKSB7XG4gICAgICAgICAgZWxlbWVudERhdGEgfHw9IHtcbiAgICAgICAgICAgIGZvY3VzZWQ6IGZhbHNlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBiYXNlTmFtZSwgZXZlbnROYW1lLCBnZXR0ZXIpO1xuICAgICAgICBpZiAoZXZlbnROYW1lID09PSBcIkZvY3VzXCIgJiYgIXRoaXMuZGF0YS5hY3Rpb25zPy5CbHVyKSB7XG4gICAgICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcihlbGVtZW50LCBlbGVtZW50RGF0YSwgXCJibHVyXCIsIFwiQmx1clwiLCBudWxsKTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudE5hbWUgPT09IFwiQmx1clwiICYmICF0aGlzLmRhdGEuYWN0aW9ucz8uRm9jdXMpIHtcbiAgICAgICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBcImZvY3VzXCIsIFwiRm9jdXNcIiwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3NldEJhY2tncm91bmRDb2xvcihlbGVtZW50KSB7XG4gICAgY29uc3QgY29sb3IgPSB0aGlzLmRhdGEuYmFja2dyb3VuZENvbG9yIHx8IG51bGw7XG4gICAgZWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvciA9PT0gbnVsbCA/IFwidHJhbnNwYXJlbnRcIiA6IFV0aWwubWFrZUhleENvbG9yKGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0pO1xuICB9XG4gIF9zZXRUZXh0U3R5bGUoZWxlbWVudCkge1xuICAgIGNvbnN0IFRFWFRfQUxJR05NRU5UID0gW1wibGVmdFwiLCBcImNlbnRlclwiLCBcInJpZ2h0XCJdO1xuICAgIGNvbnN0IHtcbiAgICAgIGZvbnRDb2xvclxuICAgIH0gPSB0aGlzLmRhdGEuZGVmYXVsdEFwcGVhcmFuY2VEYXRhO1xuICAgIGNvbnN0IGZvbnRTaXplID0gdGhpcy5kYXRhLmRlZmF1bHRBcHBlYXJhbmNlRGF0YS5mb250U2l6ZSB8fCBhbm5vdGF0aW9uX2xheWVyX0RFRkFVTFRfRk9OVF9TSVpFO1xuICAgIGNvbnN0IHN0eWxlID0gZWxlbWVudC5zdHlsZTtcbiAgICBsZXQgY29tcHV0ZWRGb250U2l6ZTtcbiAgICBjb25zdCBCT1JERVJfU0laRSA9IDI7XG4gICAgY29uc3Qgcm91bmRUb09uZURlY2ltYWwgPSAoeCkgPT4gTWF0aC5yb3VuZCgxMCAqIHgpIC8gMTA7XG4gICAgaWYgKHRoaXMuZGF0YS5tdWx0aUxpbmUpIHtcbiAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGguYWJzKHRoaXMuZGF0YS5yZWN0WzNdIC0gdGhpcy5kYXRhLnJlY3RbMV0gLSBCT1JERVJfU0laRSk7XG4gICAgICBjb25zdCBudW1iZXJPZkxpbmVzID0gTWF0aC5yb3VuZChoZWlnaHQgLyAoTElORV9GQUNUT1IgKiBmb250U2l6ZSkpIHx8IDE7XG4gICAgICBjb25zdCBsaW5lSGVpZ2h0ID0gaGVpZ2h0IC8gbnVtYmVyT2ZMaW5lcztcbiAgICAgIGNvbXB1dGVkRm9udFNpemUgPSBNYXRoLm1pbihmb250U2l6ZSwgcm91bmRUb09uZURlY2ltYWwobGluZUhlaWdodCAvIExJTkVfRkFDVE9SKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGguYWJzKHRoaXMuZGF0YS5yZWN0WzNdIC0gdGhpcy5kYXRhLnJlY3RbMV0gLSBCT1JERVJfU0laRSk7XG4gICAgICBjb21wdXRlZEZvbnRTaXplID0gTWF0aC5taW4oZm9udFNpemUsIHJvdW5kVG9PbmVEZWNpbWFsKGhlaWdodCAvIExJTkVfRkFDVE9SKSk7XG4gICAgfVxuICAgIHN0eWxlLmZvbnRTaXplID0gYGNhbGMoJHtjb21wdXRlZEZvbnRTaXplfXB4ICogdmFyKC0tdG90YWwtc2NhbGUtZmFjdG9yKSlgO1xuICAgIHN0eWxlLmNvbG9yID0gVXRpbC5tYWtlSGV4Q29sb3IoZm9udENvbG9yWzBdLCBmb250Q29sb3JbMV0sIGZvbnRDb2xvclsyXSk7XG4gICAgaWYgKHRoaXMuZGF0YS50ZXh0QWxpZ25tZW50ICE9PSBudWxsKSB7XG4gICAgICBzdHlsZS50ZXh0QWxpZ24gPSBURVhUX0FMSUdOTUVOVFt0aGlzLmRhdGEudGV4dEFsaWdubWVudF07XG4gICAgfVxuICB9XG4gIF9zZXRSZXF1aXJlZChlbGVtZW50LCBpc1JlcXVpcmVkKSB7XG4gICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwicmVxdWlyZWRcIiwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwicmVxdWlyZWRcIik7XG4gICAgfVxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1yZXF1aXJlZFwiLCBpc1JlcXVpcmVkKTtcbiAgfVxufVxuY2xhc3MgVGV4dFdpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgaXNSZW5kZXJhYmxlID0gcGFyYW1ldGVycy5yZW5kZXJGb3JtcyB8fCBwYXJhbWV0ZXJzLmRhdGEuaGFzT3duQ2FudmFzIHx8ICFwYXJhbWV0ZXJzLmRhdGEuaGFzQXBwZWFyYW5jZSAmJiAhIXBhcmFtZXRlcnMuZGF0YS5maWVsZFZhbHVlO1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZVxuICAgIH0pO1xuICB9XG4gIHNldFByb3BlcnR5T25TaWJsaW5ncyhiYXNlLCBrZXksIHZhbHVlLCBrZXlJblN0b3JhZ2UpIHtcbiAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy5fZ2V0RWxlbWVudHNCeU5hbWUoYmFzZS5uYW1lLCBiYXNlLmlkKSkge1xuICAgICAgaWYgKGVsZW1lbnQuZG9tRWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LmRvbUVsZW1lbnRba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgc3RvcmFnZS5zZXRWYWx1ZShlbGVtZW50LmlkLCB7XG4gICAgICAgIFtrZXlJblN0b3JhZ2VdOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBjb25zdCBpZCA9IHRoaXMuZGF0YS5pZDtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwidGV4dFdpZGdldEFubm90YXRpb25cIik7XG4gICAgbGV0IGVsZW1lbnQgPSBudWxsO1xuICAgIGlmICh0aGlzLnJlbmRlckZvcm1zKSB7XG4gICAgICBjb25zdCBzdG9yZWREYXRhID0gc3RvcmFnZS5nZXRWYWx1ZShpZCwge1xuICAgICAgICB2YWx1ZTogdGhpcy5kYXRhLmZpZWxkVmFsdWVcbiAgICAgIH0pO1xuICAgICAgbGV0IHRleHRDb250ZW50ID0gc3RvcmVkRGF0YS52YWx1ZSB8fCBcIlwiO1xuICAgICAgY29uc3QgbWF4TGVuID0gc3RvcmFnZS5nZXRWYWx1ZShpZCwge1xuICAgICAgICBjaGFyTGltaXQ6IHRoaXMuZGF0YS5tYXhMZW5cbiAgICAgIH0pLmNoYXJMaW1pdDtcbiAgICAgIGlmIChtYXhMZW4gJiYgdGV4dENvbnRlbnQubGVuZ3RoID4gbWF4TGVuKSB7XG4gICAgICAgIHRleHRDb250ZW50ID0gdGV4dENvbnRlbnQuc2xpY2UoMCwgbWF4TGVuKTtcbiAgICAgIH1cbiAgICAgIGxldCBmaWVsZEZvcm1hdHRlZFZhbHVlcyA9IHN0b3JlZERhdGEuZm9ybWF0dGVkVmFsdWUgfHwgdGhpcy5kYXRhLnRleHRDb250ZW50Py5qb2luKFwiXFxuXCIpIHx8IG51bGw7XG4gICAgICBpZiAoZmllbGRGb3JtYXR0ZWRWYWx1ZXMgJiYgdGhpcy5kYXRhLmNvbWIpIHtcbiAgICAgICAgZmllbGRGb3JtYXR0ZWRWYWx1ZXMgPSBmaWVsZEZvcm1hdHRlZFZhbHVlcy5yZXBsYWNlQWxsKC9cXHMrL2csIFwiXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgZWxlbWVudERhdGEgPSB7XG4gICAgICAgIHVzZXJWYWx1ZTogdGV4dENvbnRlbnQsXG4gICAgICAgIGZvcm1hdHRlZFZhbHVlOiBmaWVsZEZvcm1hdHRlZFZhbHVlcyxcbiAgICAgICAgbGFzdENvbW1pdHRlZFZhbHVlOiBudWxsLFxuICAgICAgICBjb21taXRLZXk6IDEsXG4gICAgICAgIGZvY3VzZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuZGF0YS5tdWx0aUxpbmUpIHtcbiAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKTtcbiAgICAgICAgZWxlbWVudC50ZXh0Q29udGVudCA9IGZpZWxkRm9ybWF0dGVkVmFsdWVzID8/IHRleHRDb250ZW50O1xuICAgICAgICBpZiAodGhpcy5kYXRhLmRvTm90U2Nyb2xsKSB7XG4gICAgICAgICAgZWxlbWVudC5zdHlsZS5vdmVyZmxvd1kgPSBcImhpZGRlblwiO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICBlbGVtZW50LnR5cGUgPSB0aGlzLmRhdGEucGFzc3dvcmQgPyBcInBhc3N3b3JkXCIgOiBcInRleHRcIjtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLCBmaWVsZEZvcm1hdHRlZFZhbHVlcyA/PyB0ZXh0Q29udGVudCk7XG4gICAgICAgIGlmICh0aGlzLmRhdGEuZG9Ob3RTY3JvbGwpIHtcbiAgICAgICAgICBlbGVtZW50LnN0eWxlLm92ZXJmbG93WCA9IFwiaGlkZGVuXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmRhdGEuaGFzT3duQ2FudmFzKSB7XG4gICAgICAgIGVsZW1lbnQuaGlkZGVuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIEdldEVsZW1lbnRzQnlOYW1lU2V0LmFkZChlbGVtZW50KTtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIsIGlkKTtcbiAgICAgIGVsZW1lbnQuZGlzYWJsZWQgPSB0aGlzLmRhdGEucmVhZE9ubHk7XG4gICAgICBlbGVtZW50Lm5hbWUgPSB0aGlzLmRhdGEuZmllbGROYW1lO1xuICAgICAgZWxlbWVudC50YWJJbmRleCA9IDA7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGV0aW1lRm9ybWF0LFxuICAgICAgICBkYXRldGltZVR5cGUsXG4gICAgICAgIHRpbWVTdGVwXG4gICAgICB9ID0gdGhpcy5kYXRhO1xuICAgICAgY29uc3QgaGFzRGF0ZU9yVGltZSA9ICEhZGF0ZXRpbWVUeXBlICYmIHRoaXMuZW5hYmxlU2NyaXB0aW5nO1xuICAgICAgaWYgKGRhdGV0aW1lRm9ybWF0KSB7XG4gICAgICAgIGVsZW1lbnQudGl0bGUgPSBkYXRldGltZUZvcm1hdDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NldFJlcXVpcmVkKGVsZW1lbnQsIHRoaXMuZGF0YS5yZXF1aXJlZCk7XG4gICAgICBpZiAobWF4TGVuKSB7XG4gICAgICAgIGVsZW1lbnQubWF4TGVuZ3RoID0gbWF4TGVuO1xuICAgICAgfVxuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICB2YWx1ZTogZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldFByb3BlcnR5T25TaWJsaW5ncyhlbGVtZW50LCBcInZhbHVlXCIsIGV2ZW50LnRhcmdldC52YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICAgICAgZWxlbWVudERhdGEuZm9ybWF0dGVkVmFsdWUgPSBudWxsO1xuICAgICAgfSk7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNldGZvcm1cIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IHRoaXMuZGF0YS5kZWZhdWx0RmllbGRWYWx1ZSA/PyBcIlwiO1xuICAgICAgICBlbGVtZW50LnZhbHVlID0gZWxlbWVudERhdGEudXNlclZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICBlbGVtZW50RGF0YS5mb3JtYXR0ZWRWYWx1ZSA9IG51bGw7XG4gICAgICB9KTtcbiAgICAgIGxldCBibHVyTGlzdGVuZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGZvcm1hdHRlZFZhbHVlXG4gICAgICAgIH0gPSBlbGVtZW50RGF0YTtcbiAgICAgICAgaWYgKGZvcm1hdHRlZFZhbHVlICE9PSBudWxsICYmIGZvcm1hdHRlZFZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBldmVudC50YXJnZXQudmFsdWUgPSBmb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBldmVudC50YXJnZXQuc2Nyb2xsTGVmdCA9IDA7XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zKSB7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIChldmVudCkgPT4ge1xuICAgICAgICAgIGlmIChlbGVtZW50RGF0YS5mb2N1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHRhcmdldFxuICAgICAgICAgIH0gPSBldmVudDtcbiAgICAgICAgICBpZiAoaGFzRGF0ZU9yVGltZSkge1xuICAgICAgICAgICAgdGFyZ2V0LnR5cGUgPSBkYXRldGltZVR5cGU7XG4gICAgICAgICAgICBpZiAodGltZVN0ZXApIHtcbiAgICAgICAgICAgICAgdGFyZ2V0LnN0ZXAgPSB0aW1lU3RlcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsZW1lbnREYXRhLnVzZXJWYWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBlbGVtZW50RGF0YS51c2VyVmFsdWU7XG4gICAgICAgICAgICBpZiAoaGFzRGF0ZU9yVGltZSkge1xuICAgICAgICAgICAgICBpZiAoZGF0ZXRpbWVUeXBlID09PSBcInRpbWVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBbZGF0ZS5nZXRIb3VycygpLCBkYXRlLmdldE1pbnV0ZXMoKSwgZGF0ZS5nZXRTZWNvbmRzKCldO1xuICAgICAgICAgICAgICAgIHRhcmdldC52YWx1ZSA9IHBhcnRzLm1hcCgodikgPT4gdi50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKSkuam9pbihcIjpcIik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnZhbHVlID0gbmV3IERhdGUodmFsdWUgLSBUSU1FWk9ORV9PRkZTRVQpLnRvSVNPU3RyaW5nKCkuc3BsaXQoZGF0ZXRpbWVUeXBlID09PSBcImRhdGVcIiA/IFwiVFwiIDogXCIuXCIsIDEpWzBdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0YXJnZXQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudERhdGEubGFzdENvbW1pdHRlZFZhbHVlID0gdGFyZ2V0LnZhbHVlO1xuICAgICAgICAgIGVsZW1lbnREYXRhLmNvbW1pdEtleSA9IDE7XG4gICAgICAgICAgaWYgKCF0aGlzLmRhdGEuYWN0aW9ucz8uRm9jdXMpIHtcbiAgICAgICAgICAgIGVsZW1lbnREYXRhLmZvY3VzZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInVwZGF0ZWZyb21zYW5kYm94XCIsIChqc0V2ZW50KSA9PiB7XG4gICAgICAgICAgdGhpcy5zaG93RWxlbWVudEFuZEhpZGVDYW52YXMoanNFdmVudC50YXJnZXQpO1xuICAgICAgICAgIGNvbnN0IGFjdGlvbnMgPSB7XG4gICAgICAgICAgICB2YWx1ZShldmVudCkge1xuICAgICAgICAgICAgICBlbGVtZW50RGF0YS51c2VyVmFsdWUgPSBldmVudC5kZXRhaWwudmFsdWUgPz8gXCJcIjtcbiAgICAgICAgICAgICAgaWYgKCFoYXNEYXRlT3JUaW1lKSB7XG4gICAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IGVsZW1lbnREYXRhLnVzZXJWYWx1ZS50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnZhbHVlID0gZWxlbWVudERhdGEudXNlclZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlKGV2ZW50KSB7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZVxuICAgICAgICAgICAgICB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICAgICAgICBlbGVtZW50RGF0YS5mb3JtYXR0ZWRWYWx1ZSA9IGZvcm1hdHRlZFZhbHVlO1xuICAgICAgICAgICAgICBpZiAoZm9ybWF0dGVkVmFsdWUgIT09IG51bGwgJiYgZm9ybWF0dGVkVmFsdWUgIT09IHZvaWQgMCAmJiBldmVudC50YXJnZXQgIT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQudmFsdWUgPSBmb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGlmIChoYXNEYXRlT3JUaW1lKSB7XG4gICAgICAgICAgICAgICAgZGF0YS52YWx1ZSA9IGZvcm1hdHRlZFZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIGRhdGEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlbFJhbmdlKGV2ZW50KSB7XG4gICAgICAgICAgICAgIGV2ZW50LnRhcmdldC5zZXRTZWxlY3Rpb25SYW5nZSguLi5ldmVudC5kZXRhaWwuc2VsUmFuZ2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNoYXJMaW1pdDogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBjaGFyTGltaXRcbiAgICAgICAgICAgICAgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIHRhcmdldFxuICAgICAgICAgICAgICB9ID0gZXZlbnQ7XG4gICAgICAgICAgICAgIGlmIChjaGFyTGltaXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQucmVtb3ZlQXR0cmlidXRlKFwibWF4TGVuZ3RoXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKFwibWF4TGVuZ3RoXCIsIGNoYXJMaW1pdCk7XG4gICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGVsZW1lbnREYXRhLnVzZXJWYWx1ZTtcbiAgICAgICAgICAgICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZS5sZW5ndGggPD0gY2hhckxpbWl0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgY2hhckxpbWl0KTtcbiAgICAgICAgICAgICAgdGFyZ2V0LnZhbHVlID0gZWxlbWVudERhdGEudXNlclZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgIG5hbWU6IFwiS2V5c3Ryb2tlXCIsXG4gICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgIHdpbGxDb21taXQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICBjb21taXRLZXk6IDEsXG4gICAgICAgICAgICAgICAgICBzZWxTdGFydDogdGFyZ2V0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgICAgICAgICAgc2VsRW5kOiB0YXJnZXQuc2VsZWN0aW9uRW5kXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnRGcm9tU2FuZGJveChhY3Rpb25zLCBqc0V2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgZWxlbWVudERhdGEuY29tbWl0S2V5ID0gMTtcbiAgICAgICAgICBsZXQgY29tbWl0S2V5ID0gLTE7XG4gICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCJFc2NhcGVcIikge1xuICAgICAgICAgICAgY29tbWl0S2V5ID0gMDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gXCJFbnRlclwiICYmICF0aGlzLmRhdGEubXVsdGlMaW5lKSB7XG4gICAgICAgICAgICBjb21taXRLZXkgPSAyO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5ID09PSBcIlRhYlwiKSB7XG4gICAgICAgICAgICBlbGVtZW50RGF0YS5jb21taXRLZXkgPSAzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29tbWl0S2V5ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0gPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgaWYgKGVsZW1lbnREYXRhLmxhc3RDb21taXR0ZWRWYWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudERhdGEubGFzdENvbW1pdHRlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgZWxlbWVudERhdGEudXNlclZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIHdpbGxDb21taXQ6IHRydWUsXG4gICAgICAgICAgICAgIGNvbW1pdEtleSxcbiAgICAgICAgICAgICAgc2VsU3RhcnQ6IGV2ZW50LnRhcmdldC5zZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgICAgc2VsRW5kOiBldmVudC50YXJnZXQuc2VsZWN0aW9uRW5kXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBfYmx1ckxpc3RlbmVyID0gYmx1ckxpc3RlbmVyO1xuICAgICAgICBibHVyTGlzdGVuZXIgPSBudWxsO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIChldmVudCkgPT4ge1xuICAgICAgICAgIGlmICghZWxlbWVudERhdGEuZm9jdXNlZCB8fCAhZXZlbnQucmVsYXRlZFRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuZGF0YS5hY3Rpb25zPy5CbHVyKSB7XG4gICAgICAgICAgICBlbGVtZW50RGF0YS5mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHRhcmdldFxuICAgICAgICAgIH0gPSBldmVudDtcbiAgICAgICAgICBsZXQge1xuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9ID0gdGFyZ2V0O1xuICAgICAgICAgIGlmIChoYXNEYXRlT3JUaW1lKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgZGF0ZXRpbWVUeXBlID09PSBcInRpbWVcIikge1xuICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IHZhbHVlLnNwbGl0KFwiOlwiKS5tYXAoKHYpID0+IHBhcnNlSW50KHYsIDEwKSk7XG4gICAgICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUoMmUzLCAwLCAxLCBwYXJ0c1swXSwgcGFydHNbMV0sIHBhcnRzWzJdIHx8IDApLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgdGFyZ2V0LnN0ZXAgPSBcIlwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKCF2YWx1ZS5pbmNsdWRlcyhcIlRcIikpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGAke3ZhbHVlfVQwMDowMGA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZSh2YWx1ZSkudmFsdWVPZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0LnR5cGUgPSBcInRleHRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudERhdGEudXNlclZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgaWYgKGVsZW1lbnREYXRhLmxhc3RDb21taXR0ZWRWYWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB3aWxsQ29tbWl0OiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbW1pdEtleTogZWxlbWVudERhdGEuY29tbWl0S2V5LFxuICAgICAgICAgICAgICAgIHNlbFN0YXJ0OiBldmVudC50YXJnZXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgICAgc2VsRW5kOiBldmVudC50YXJnZXQuc2VsZWN0aW9uRW5kXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfYmx1ckxpc3RlbmVyKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmRhdGEuYWN0aW9ucz8uS2V5c3Ryb2tlKSB7XG4gICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JlaW5wdXRcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBlbGVtZW50RGF0YS5sYXN0Q29tbWl0dGVkVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICB0YXJnZXRcbiAgICAgICAgICAgIH0gPSBldmVudDtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIHNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgICAgICBzZWxlY3Rpb25FbmRcbiAgICAgICAgICAgIH0gPSB0YXJnZXQ7XG4gICAgICAgICAgICBsZXQgc2VsU3RhcnQgPSBzZWxlY3Rpb25TdGFydCwgc2VsRW5kID0gc2VsZWN0aW9uRW5kO1xuICAgICAgICAgICAgc3dpdGNoIChldmVudC5pbnB1dFR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImRlbGV0ZVdvcmRCYWNrd2FyZFwiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB2YWx1ZS5zdWJzdHJpbmcoMCwgc2VsZWN0aW9uU3RhcnQpLm1hdGNoKC9cXHcqW15cXHddKiQvKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgIHNlbFN0YXJ0IC09IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSBcImRlbGV0ZVdvcmRGb3J3YXJkXCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IHZhbHVlLnN1YnN0cmluZyhzZWxlY3Rpb25TdGFydCkubWF0Y2goL15bXlxcd10qXFx3Ki8pO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgc2VsRW5kICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSBcImRlbGV0ZUNvbnRlbnRCYWNrd2FyZFwiOlxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25TdGFydCA9PT0gc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgICAgICAgICAgICBzZWxTdGFydCAtPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImRlbGV0ZUNvbnRlbnRGb3J3YXJkXCI6XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0ID09PSBzZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgICAgICAgICAgIHNlbEVuZCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwiS2V5c3Ryb2tlXCIsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgY2hhbmdlOiBkYXRhIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgd2lsbENvbW1pdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2VsU3RhcnQsXG4gICAgICAgICAgICAgICAgc2VsRW5kXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXJzKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBbW1wiZm9jdXNcIiwgXCJGb2N1c1wiXSwgW1wiYmx1clwiLCBcIkJsdXJcIl0sIFtcIm1vdXNlZG93blwiLCBcIk1vdXNlIERvd25cIl0sIFtcIm1vdXNlZW50ZXJcIiwgXCJNb3VzZSBFbnRlclwiXSwgW1wibW91c2VsZWF2ZVwiLCBcIk1vdXNlIEV4aXRcIl0sIFtcIm1vdXNldXBcIiwgXCJNb3VzZSBVcFwiXV0sIChldmVudCkgPT4gZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChibHVyTGlzdGVuZXIpIHtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBibHVyTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZGF0YS5jb21iKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkV2lkdGggPSB0aGlzLmRhdGEucmVjdFsyXSAtIHRoaXMuZGF0YS5yZWN0WzBdO1xuICAgICAgICBjb25zdCBjb21iV2lkdGggPSBmaWVsZFdpZHRoIC8gbWF4TGVuO1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJjb21iXCIpO1xuICAgICAgICBlbGVtZW50LnN0eWxlLmxldHRlclNwYWNpbmcgPSBgY2FsYygke2NvbWJXaWR0aH1weCAqIHZhcigtLXRvdGFsLXNjYWxlLWZhY3RvcikgLSAxY2gpYDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBlbGVtZW50LnRleHRDb250ZW50ID0gdGhpcy5kYXRhLmZpZWxkVmFsdWU7XG4gICAgICBlbGVtZW50LnN0eWxlLnZlcnRpY2FsQWxpZ24gPSBcIm1pZGRsZVwiO1xuICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJ0YWJsZS1jZWxsXCI7XG4gICAgICBpZiAodGhpcy5kYXRhLmhhc093bkNhbnZhcykge1xuICAgICAgICBlbGVtZW50LmhpZGRlbiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3NldFRleHRTdHlsZShlbGVtZW50KTtcbiAgICB0aGlzLl9zZXRCYWNrZ3JvdW5kQ29sb3IoZWxlbWVudCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoZWxlbWVudCk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGVsZW1lbnQpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgU2lnbmF0dXJlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6ICEhcGFyYW1ldGVycy5kYXRhLmhhc093bkNhbnZhc1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBDaGVja2JveFdpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiBwYXJhbWV0ZXJzLnJlbmRlckZvcm1zXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3QgaWQgPSBkYXRhLmlkO1xuICAgIGxldCB2YWx1ZSA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgIHZhbHVlOiBkYXRhLmV4cG9ydFZhbHVlID09PSBkYXRhLmZpZWxkVmFsdWVcbiAgICB9KS52YWx1ZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlICE9PSBcIk9mZlwiO1xuICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJidXR0b25XaWRnZXRBbm5vdGF0aW9uXCIsIFwiY2hlY2tCb3hcIik7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICBHZXRFbGVtZW50c0J5TmFtZVNldC5hZGQoZWxlbWVudCk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIiwgaWQpO1xuICAgIGVsZW1lbnQuZGlzYWJsZWQgPSBkYXRhLnJlYWRPbmx5O1xuICAgIHRoaXMuX3NldFJlcXVpcmVkKGVsZW1lbnQsIHRoaXMuZGF0YS5yZXF1aXJlZCk7XG4gICAgZWxlbWVudC50eXBlID0gXCJjaGVja2JveFwiO1xuICAgIGVsZW1lbnQubmFtZSA9IGRhdGEuZmllbGROYW1lO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIsIHRydWUpO1xuICAgIH1cbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImV4cG9ydFZhbHVlXCIsIGRhdGEuZXhwb3J0VmFsdWUpO1xuICAgIGVsZW1lbnQudGFiSW5kZXggPSAwO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgY2hlY2tlZFxuICAgICAgfSA9IGV2ZW50LnRhcmdldDtcbiAgICAgIGZvciAoY29uc3QgY2hlY2tib3ggb2YgdGhpcy5fZ2V0RWxlbWVudHNCeU5hbWUobmFtZSwgaWQpKSB7XG4gICAgICAgIGNvbnN0IGN1ckNoZWNrZWQgPSBjaGVja2VkICYmIGNoZWNrYm94LmV4cG9ydFZhbHVlID09PSBkYXRhLmV4cG9ydFZhbHVlO1xuICAgICAgICBpZiAoY2hlY2tib3guZG9tRWxlbWVudCkge1xuICAgICAgICAgIGNoZWNrYm94LmRvbUVsZW1lbnQuY2hlY2tlZCA9IGN1ckNoZWNrZWQ7XG4gICAgICAgIH1cbiAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShjaGVja2JveC5pZCwge1xuICAgICAgICAgIHZhbHVlOiBjdXJDaGVja2VkXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICB2YWx1ZTogY2hlY2tlZFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicmVzZXRmb3JtXCIsIChldmVudCkgPT4ge1xuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gZGF0YS5kZWZhdWx0RmllbGRWYWx1ZSB8fCBcIk9mZlwiO1xuICAgICAgZXZlbnQudGFyZ2V0LmNoZWNrZWQgPSBkZWZhdWx0VmFsdWUgPT09IGRhdGEuZXhwb3J0VmFsdWU7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zKSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVmcm9tc2FuZGJveFwiLCAoanNFdmVudCkgPT4ge1xuICAgICAgICBjb25zdCBhY3Rpb25zID0ge1xuICAgICAgICAgIHZhbHVlKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudC50YXJnZXQuY2hlY2tlZCA9IGV2ZW50LmRldGFpbC52YWx1ZSAhPT0gXCJPZmZcIjtcbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGV2ZW50LnRhcmdldC5jaGVja2VkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnRGcm9tU2FuZGJveChhY3Rpb25zLCBqc0V2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcnMoZWxlbWVudCwgbnVsbCwgW1tcImNoYW5nZVwiLCBcIlZhbGlkYXRlXCJdLCBbXCJjaGFuZ2VcIiwgXCJBY3Rpb25cIl0sIFtcImZvY3VzXCIsIFwiRm9jdXNcIl0sIFtcImJsdXJcIiwgXCJCbHVyXCJdLCBbXCJtb3VzZWRvd25cIiwgXCJNb3VzZSBEb3duXCJdLCBbXCJtb3VzZWVudGVyXCIsIFwiTW91c2UgRW50ZXJcIl0sIFtcIm1vdXNlbGVhdmVcIiwgXCJNb3VzZSBFeGl0XCJdLCBbXCJtb3VzZXVwXCIsIFwiTW91c2UgVXBcIl1dLCAoZXZlbnQpID0+IGV2ZW50LnRhcmdldC5jaGVja2VkKTtcbiAgICB9XG4gICAgdGhpcy5fc2V0QmFja2dyb3VuZENvbG9yKGVsZW1lbnQpO1xuICAgIHRoaXMuX3NldERlZmF1bHRQcm9wZXJ0aWVzRnJvbUpTKGVsZW1lbnQpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChlbGVtZW50KTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFJhZGlvQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHBhcmFtZXRlcnMucmVuZGVyRm9ybXNcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImJ1dHRvbldpZGdldEFubm90YXRpb25cIiwgXCJyYWRpb0J1dHRvblwiKTtcbiAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGNvbnN0IGlkID0gZGF0YS5pZDtcbiAgICBsZXQgdmFsdWUgPSBzdG9yYWdlLmdldFZhbHVlKGlkLCB7XG4gICAgICB2YWx1ZTogZGF0YS5maWVsZFZhbHVlID09PSBkYXRhLmJ1dHRvblZhbHVlXG4gICAgfSkudmFsdWU7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdmFsdWUgPSB2YWx1ZSAhPT0gZGF0YS5idXR0b25WYWx1ZTtcbiAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGZvciAoY29uc3QgcmFkaW8gb2YgdGhpcy5fZ2V0RWxlbWVudHNCeU5hbWUoZGF0YS5maWVsZE5hbWUsIGlkKSkge1xuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKHJhZGlvLmlkLCB7XG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgIEdldEVsZW1lbnRzQnlOYW1lU2V0LmFkZChlbGVtZW50KTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiLCBpZCk7XG4gICAgZWxlbWVudC5kaXNhYmxlZCA9IGRhdGEucmVhZE9ubHk7XG4gICAgdGhpcy5fc2V0UmVxdWlyZWQoZWxlbWVudCwgdGhpcy5kYXRhLnJlcXVpcmVkKTtcbiAgICBlbGVtZW50LnR5cGUgPSBcInJhZGlvXCI7XG4gICAgZWxlbWVudC5uYW1lID0gZGF0YS5maWVsZE5hbWU7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIiwgdHJ1ZSk7XG4gICAgfVxuICAgIGVsZW1lbnQudGFiSW5kZXggPSAwO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgY2hlY2tlZFxuICAgICAgfSA9IGV2ZW50LnRhcmdldDtcbiAgICAgIGZvciAoY29uc3QgcmFkaW8gb2YgdGhpcy5fZ2V0RWxlbWVudHNCeU5hbWUobmFtZSwgaWQpKSB7XG4gICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUocmFkaW8uaWQsIHtcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgIHZhbHVlOiBjaGVja2VkXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNldGZvcm1cIiwgKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBkYXRhLmRlZmF1bHRGaWVsZFZhbHVlO1xuICAgICAgZXZlbnQudGFyZ2V0LmNoZWNrZWQgPSBkZWZhdWx0VmFsdWUgIT09IG51bGwgJiYgZGVmYXVsdFZhbHVlICE9PSB2b2lkIDAgJiYgZGVmYXVsdFZhbHVlID09PSBkYXRhLmJ1dHRvblZhbHVlO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLmVuYWJsZVNjcmlwdGluZyAmJiB0aGlzLmhhc0pTQWN0aW9ucykge1xuICAgICAgY29uc3QgcGRmQnV0dG9uVmFsdWUgPSBkYXRhLmJ1dHRvblZhbHVlO1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZnJvbXNhbmRib3hcIiwgKGpzRXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICAgICAgICB2YWx1ZTogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGVja2VkID0gcGRmQnV0dG9uVmFsdWUgPT09IGV2ZW50LmRldGFpbC52YWx1ZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmFkaW8gb2YgdGhpcy5fZ2V0RWxlbWVudHNCeU5hbWUoZXZlbnQudGFyZ2V0Lm5hbWUpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1ckNoZWNrZWQgPSBjaGVja2VkICYmIHJhZGlvLmlkID09PSBpZDtcbiAgICAgICAgICAgICAgaWYgKHJhZGlvLmRvbUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByYWRpby5kb21FbGVtZW50LmNoZWNrZWQgPSBjdXJDaGVja2VkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUocmFkaW8uaWQsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogY3VyQ2hlY2tlZFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnRGcm9tU2FuZGJveChhY3Rpb25zLCBqc0V2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcnMoZWxlbWVudCwgbnVsbCwgW1tcImNoYW5nZVwiLCBcIlZhbGlkYXRlXCJdLCBbXCJjaGFuZ2VcIiwgXCJBY3Rpb25cIl0sIFtcImZvY3VzXCIsIFwiRm9jdXNcIl0sIFtcImJsdXJcIiwgXCJCbHVyXCJdLCBbXCJtb3VzZWRvd25cIiwgXCJNb3VzZSBEb3duXCJdLCBbXCJtb3VzZWVudGVyXCIsIFwiTW91c2UgRW50ZXJcIl0sIFtcIm1vdXNlbGVhdmVcIiwgXCJNb3VzZSBFeGl0XCJdLCBbXCJtb3VzZXVwXCIsIFwiTW91c2UgVXBcIl1dLCAoZXZlbnQpID0+IGV2ZW50LnRhcmdldC5jaGVja2VkKTtcbiAgICB9XG4gICAgdGhpcy5fc2V0QmFja2dyb3VuZENvbG9yKGVsZW1lbnQpO1xuICAgIHRoaXMuX3NldERlZmF1bHRQcm9wZXJ0aWVzRnJvbUpTKGVsZW1lbnQpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChlbGVtZW50KTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFB1c2hCdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIExpbmtBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpZ25vcmVCb3JkZXI6IHBhcmFtZXRlcnMuZGF0YS5oYXNBcHBlYXJhbmNlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHN1cGVyLnJlbmRlcigpO1xuICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiYnV0dG9uV2lkZ2V0QW5ub3RhdGlvblwiLCBcInB1c2hCdXR0b25cIik7XG4gICAgY29uc3QgbGlua0VsZW1lbnQgPSBjb250YWluZXIubGFzdENoaWxkO1xuICAgIGlmICh0aGlzLmVuYWJsZVNjcmlwdGluZyAmJiB0aGlzLmhhc0pTQWN0aW9ucyAmJiBsaW5rRWxlbWVudCkge1xuICAgICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMobGlua0VsZW1lbnQpO1xuICAgICAgbGlua0VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInVwZGF0ZWZyb21zYW5kYm94XCIsIChqc0V2ZW50KSA9PiB7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnRGcm9tU2FuZGJveCh7fSwganNFdmVudCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgQ2hvaWNlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHBhcmFtZXRlcnMucmVuZGVyRm9ybXNcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImNob2ljZVdpZGdldEFubm90YXRpb25cIik7XG4gICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgY29uc3QgaWQgPSB0aGlzLmRhdGEuaWQ7XG4gICAgY29uc3Qgc3RvcmVkRGF0YSA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgIHZhbHVlOiB0aGlzLmRhdGEuZmllbGRWYWx1ZVxuICAgIH0pO1xuICAgIGNvbnN0IHNlbGVjdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpO1xuICAgIEdldEVsZW1lbnRzQnlOYW1lU2V0LmFkZChzZWxlY3RFbGVtZW50KTtcbiAgICBzZWxlY3RFbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiLCBpZCk7XG4gICAgc2VsZWN0RWxlbWVudC5kaXNhYmxlZCA9IHRoaXMuZGF0YS5yZWFkT25seTtcbiAgICB0aGlzLl9zZXRSZXF1aXJlZChzZWxlY3RFbGVtZW50LCB0aGlzLmRhdGEucmVxdWlyZWQpO1xuICAgIHNlbGVjdEVsZW1lbnQubmFtZSA9IHRoaXMuZGF0YS5maWVsZE5hbWU7XG4gICAgc2VsZWN0RWxlbWVudC50YWJJbmRleCA9IDA7XG4gICAgbGV0IGFkZEFuRW1wdHlFbnRyeSA9IHRoaXMuZGF0YS5jb21ibyAmJiB0aGlzLmRhdGEub3B0aW9ucy5sZW5ndGggPiAwO1xuICAgIGlmICghdGhpcy5kYXRhLmNvbWJvKSB7XG4gICAgICBzZWxlY3RFbGVtZW50LnNpemUgPSB0aGlzLmRhdGEub3B0aW9ucy5sZW5ndGg7XG4gICAgICBpZiAodGhpcy5kYXRhLm11bHRpU2VsZWN0KSB7XG4gICAgICAgIHNlbGVjdEVsZW1lbnQubXVsdGlwbGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBzZWxlY3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNldGZvcm1cIiwgKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSB0aGlzLmRhdGEuZGVmYXVsdEZpZWxkVmFsdWU7XG4gICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBzZWxlY3RFbGVtZW50Lm9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gb3B0aW9uLnZhbHVlID09PSBkZWZhdWx0VmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBvcHRpb24gb2YgdGhpcy5kYXRhLm9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IG9wdGlvbkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgb3B0aW9uRWxlbWVudC50ZXh0Q29udGVudCA9IG9wdGlvbi5kaXNwbGF5VmFsdWU7XG4gICAgICBvcHRpb25FbGVtZW50LnZhbHVlID0gb3B0aW9uLmV4cG9ydFZhbHVlO1xuICAgICAgaWYgKHN0b3JlZERhdGEudmFsdWUuaW5jbHVkZXMob3B0aW9uLmV4cG9ydFZhbHVlKSkge1xuICAgICAgICBvcHRpb25FbGVtZW50LnNldEF0dHJpYnV0ZShcInNlbGVjdGVkXCIsIHRydWUpO1xuICAgICAgICBhZGRBbkVtcHR5RW50cnkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHNlbGVjdEVsZW1lbnQuYXBwZW5kKG9wdGlvbkVsZW1lbnQpO1xuICAgIH1cbiAgICBsZXQgcmVtb3ZlRW1wdHlFbnRyeSA9IG51bGw7XG4gICAgaWYgKGFkZEFuRW1wdHlFbnRyeSkge1xuICAgICAgY29uc3Qgbm9uZU9wdGlvbkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgbm9uZU9wdGlvbkVsZW1lbnQudmFsdWUgPSBcIiBcIjtcbiAgICAgIG5vbmVPcHRpb25FbGVtZW50LnNldEF0dHJpYnV0ZShcImhpZGRlblwiLCB0cnVlKTtcbiAgICAgIG5vbmVPcHRpb25FbGVtZW50LnNldEF0dHJpYnV0ZShcInNlbGVjdGVkXCIsIHRydWUpO1xuICAgICAgc2VsZWN0RWxlbWVudC5wcmVwZW5kKG5vbmVPcHRpb25FbGVtZW50KTtcbiAgICAgIHJlbW92ZUVtcHR5RW50cnkgPSAoKSA9PiB7XG4gICAgICAgIG5vbmVPcHRpb25FbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICBzZWxlY3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCByZW1vdmVFbXB0eUVudHJ5KTtcbiAgICAgICAgcmVtb3ZlRW1wdHlFbnRyeSA9IG51bGw7XG4gICAgICB9O1xuICAgICAgc2VsZWN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgcmVtb3ZlRW1wdHlFbnRyeSk7XG4gICAgfVxuICAgIGNvbnN0IGdldFZhbHVlID0gKGlzRXhwb3J0KSA9PiB7XG4gICAgICBjb25zdCBuYW1lID0gaXNFeHBvcnQgPyBcInZhbHVlXCIgOiBcInRleHRDb250ZW50XCI7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIG11bHRpcGxlXG4gICAgICB9ID0gc2VsZWN0RWxlbWVudDtcbiAgICAgIGlmICghbXVsdGlwbGUpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuc2VsZWN0ZWRJbmRleCA9PT0gLTEgPyBudWxsIDogb3B0aW9uc1tvcHRpb25zLnNlbGVjdGVkSW5kZXhdW25hbWVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbChvcHRpb25zLCAob3B0aW9uKSA9PiBvcHRpb24uc2VsZWN0ZWQpLm1hcCgob3B0aW9uKSA9PiBvcHRpb25bbmFtZV0pO1xuICAgIH07XG4gICAgbGV0IHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgIGNvbnN0IGdldEl0ZW1zID0gKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBvcHRpb25zID0gZXZlbnQudGFyZ2V0Lm9wdGlvbnM7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKG9wdGlvbnMsIChvcHRpb24pID0+ICh7XG4gICAgICAgIGRpc3BsYXlWYWx1ZTogb3B0aW9uLnRleHRDb250ZW50LFxuICAgICAgICBleHBvcnRWYWx1ZTogb3B0aW9uLnZhbHVlXG4gICAgICB9KSk7XG4gICAgfTtcbiAgICBpZiAodGhpcy5lbmFibGVTY3JpcHRpbmcgJiYgdGhpcy5oYXNKU0FjdGlvbnMpIHtcbiAgICAgIHNlbGVjdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInVwZGF0ZWZyb21zYW5kYm94XCIsIChqc0V2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGFjdGlvbnMgPSB7XG4gICAgICAgICAgdmFsdWUoZXZlbnQpIHtcbiAgICAgICAgICAgIHJlbW92ZUVtcHR5RW50cnk/LigpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBldmVudC5kZXRhaWwudmFsdWU7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBuZXcgU2V0KEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIHNlbGVjdEVsZW1lbnQub3B0aW9ucykge1xuICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB2YWx1ZXMuaGFzKG9wdGlvbi52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBnZXRWYWx1ZSh0cnVlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlcyA9IGdldFZhbHVlKGZhbHNlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG11bHRpcGxlU2VsZWN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBzZWxlY3RFbGVtZW50Lm11bHRpcGxlID0gdHJ1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlbW92ZShldmVudCkge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHNlbGVjdEVsZW1lbnQub3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZXZlbnQuZGV0YWlsLnJlbW92ZTtcbiAgICAgICAgICAgIG9wdGlvbnNbaW5kZXhdLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICBzZWxlY3RFbGVtZW50LnJlbW92ZShpbmRleCk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGkgPSBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4LmNhbGwob3B0aW9ucywgKG9wdGlvbikgPT4gb3B0aW9uLnNlbGVjdGVkKTtcbiAgICAgICAgICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uc1swXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpLFxuICAgICAgICAgICAgICBpdGVtczogZ2V0SXRlbXMoZXZlbnQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2xlYXIoZXZlbnQpIHtcbiAgICAgICAgICAgIHdoaWxlIChzZWxlY3RFbGVtZW50Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LnJlbW92ZSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgIGl0ZW1zOiBbXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlcyA9IGdldFZhbHVlKGZhbHNlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGluc2VydChldmVudCkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgZGlzcGxheVZhbHVlLFxuICAgICAgICAgICAgICBleHBvcnRWYWx1ZVxuICAgICAgICAgICAgfSA9IGV2ZW50LmRldGFpbC5pbnNlcnQ7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RDaGlsZCA9IHNlbGVjdEVsZW1lbnQuY2hpbGRyZW5baW5kZXhdO1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICAgICAgICBvcHRpb25FbGVtZW50LnRleHRDb250ZW50ID0gZGlzcGxheVZhbHVlO1xuICAgICAgICAgICAgb3B0aW9uRWxlbWVudC52YWx1ZSA9IGV4cG9ydFZhbHVlO1xuICAgICAgICAgICAgaWYgKHNlbGVjdENoaWxkKSB7XG4gICAgICAgICAgICAgIHNlbGVjdENoaWxkLmJlZm9yZShvcHRpb25FbGVtZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQuYXBwZW5kKG9wdGlvbkVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUodHJ1ZSksXG4gICAgICAgICAgICAgIGl0ZW1zOiBnZXRJdGVtcyhldmVudClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpdGVtcyhldmVudCkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBpdGVtc1xuICAgICAgICAgICAgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgICAgIHdoaWxlIChzZWxlY3RFbGVtZW50Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LnJlbW92ZSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgZGlzcGxheVZhbHVlLFxuICAgICAgICAgICAgICAgIGV4cG9ydFZhbHVlXG4gICAgICAgICAgICAgIH0gPSBpdGVtO1xuICAgICAgICAgICAgICBjb25zdCBvcHRpb25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgICAgICAgICAgb3B0aW9uRWxlbWVudC50ZXh0Q29udGVudCA9IGRpc3BsYXlWYWx1ZTtcbiAgICAgICAgICAgICAgb3B0aW9uRWxlbWVudC52YWx1ZSA9IGV4cG9ydFZhbHVlO1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LmFwcGVuZChvcHRpb25FbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxlY3RFbGVtZW50Lm9wdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50Lm9wdGlvbnNbMF0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUodHJ1ZSksXG4gICAgICAgICAgICAgIGl0ZW1zOiBnZXRJdGVtcyhldmVudClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbmRpY2VzKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBpbmRpY2VzID0gbmV3IFNldChldmVudC5kZXRhaWwuaW5kaWNlcyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBldmVudC50YXJnZXQub3B0aW9ucykge1xuICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBpbmRpY2VzLmhhcyhvcHRpb24uaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUodHJ1ZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlZGl0YWJsZShldmVudCkge1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmRpc2FibGVkID0gIWV2ZW50LmRldGFpbC5lZGl0YWJsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnRGcm9tU2FuZGJveChhY3Rpb25zLCBqc0V2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgc2VsZWN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGV4cG9ydFZhbHVlID0gZ2V0VmFsdWUodHJ1ZSk7XG4gICAgICAgIGNvbnN0IGNoYW5nZSA9IGdldFZhbHVlKGZhbHNlKTtcbiAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgIHZhbHVlOiBleHBvcnRWYWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIG5hbWU6IFwiS2V5c3Ryb2tlXCIsXG4gICAgICAgICAgICB2YWx1ZTogc2VsZWN0ZWRWYWx1ZXMsXG4gICAgICAgICAgICBjaGFuZ2UsXG4gICAgICAgICAgICBjaGFuZ2VFeDogZXhwb3J0VmFsdWUsXG4gICAgICAgICAgICB3aWxsQ29tbWl0OiBmYWxzZSxcbiAgICAgICAgICAgIGNvbW1pdEtleTogMSxcbiAgICAgICAgICAgIGtleURvd246IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcnMoc2VsZWN0RWxlbWVudCwgbnVsbCwgW1tcImZvY3VzXCIsIFwiRm9jdXNcIl0sIFtcImJsdXJcIiwgXCJCbHVyXCJdLCBbXCJtb3VzZWRvd25cIiwgXCJNb3VzZSBEb3duXCJdLCBbXCJtb3VzZWVudGVyXCIsIFwiTW91c2UgRW50ZXJcIl0sIFtcIm1vdXNlbGVhdmVcIiwgXCJNb3VzZSBFeGl0XCJdLCBbXCJtb3VzZXVwXCIsIFwiTW91c2UgVXBcIl0sIFtcImlucHV0XCIsIFwiQWN0aW9uXCJdLCBbXCJpbnB1dFwiLCBcIlZhbGlkYXRlXCJdXSwgKGV2ZW50KSA9PiBldmVudC50YXJnZXQudmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmRhdGEuY29tYm8pIHtcbiAgICAgIHRoaXMuX3NldFRleHRTdHlsZShzZWxlY3RFbGVtZW50KTtcbiAgICB9XG4gICAgdGhpcy5fc2V0QmFja2dyb3VuZENvbG9yKHNlbGVjdEVsZW1lbnQpO1xuICAgIHRoaXMuX3NldERlZmF1bHRQcm9wZXJ0aWVzRnJvbUpTKHNlbGVjdEVsZW1lbnQpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzZWxlY3RFbGVtZW50KTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFBvcHVwQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhLFxuICAgICAgZWxlbWVudHMsXG4gICAgICBwYXJlbnRcbiAgICB9ID0gcGFyYW1ldGVycztcbiAgICBjb25zdCBoYXNDb21tZW50TWFuYWdlciA9ICEhcGFyZW50Ll9jb21tZW50TWFuYWdlcjtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6ICFoYXNDb21tZW50TWFuYWdlciAmJiBBbm5vdGF0aW9uRWxlbWVudC5faGFzUG9wdXBEYXRhKGRhdGEpXG4gICAgfSk7XG4gICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xuICAgIGlmIChoYXNDb21tZW50TWFuYWdlciAmJiBBbm5vdGF0aW9uRWxlbWVudC5faGFzUG9wdXBEYXRhKGRhdGEpKSB7XG4gICAgICBjb25zdCBwb3B1cCA9IHRoaXMucG9wdXAgPSB0aGlzLiNjcmVhdGVQb3B1cCgpO1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIGVsZW1lbnQucG9wdXAgPSBwb3B1cDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wb3B1cCA9IG51bGw7XG4gICAgfVxuICB9XG4gICNjcmVhdGVQb3B1cCgpIHtcbiAgICByZXR1cm4gbmV3IFBvcHVwRWxlbWVudCh7XG4gICAgICBjb250YWluZXI6IHRoaXMuY29udGFpbmVyLFxuICAgICAgY29sb3I6IHRoaXMuZGF0YS5jb2xvcixcbiAgICAgIHRpdGxlT2JqOiB0aGlzLmRhdGEudGl0bGVPYmosXG4gICAgICBtb2RpZmljYXRpb25EYXRlOiB0aGlzLmRhdGEubW9kaWZpY2F0aW9uRGF0ZSB8fCB0aGlzLmRhdGEuY3JlYXRpb25EYXRlLFxuICAgICAgY29udGVudHNPYmo6IHRoaXMuZGF0YS5jb250ZW50c09iaixcbiAgICAgIHJpY2hUZXh0OiB0aGlzLmRhdGEucmljaFRleHQsXG4gICAgICByZWN0OiB0aGlzLmRhdGEucmVjdCxcbiAgICAgIHBhcmVudFJlY3Q6IHRoaXMuZGF0YS5wYXJlbnRSZWN0IHx8IG51bGwsXG4gICAgICBwYXJlbnQ6IHRoaXMucGFyZW50LFxuICAgICAgZWxlbWVudHM6IHRoaXMuZWxlbWVudHMsXG4gICAgICBvcGVuOiB0aGlzLmRhdGEub3BlbixcbiAgICAgIGNvbW1lbnRNYW5hZ2VyOiB0aGlzLnBhcmVudC5fY29tbWVudE1hbmFnZXJcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGFpbmVyXG4gICAgfSA9IHRoaXM7XG4gICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJwb3B1cEFubm90YXRpb25cIik7XG4gICAgY29udGFpbmVyLnJvbGUgPSBcImNvbW1lbnRcIjtcbiAgICBjb25zdCBwb3B1cCA9IHRoaXMucG9wdXAgPSB0aGlzLiNjcmVhdGVQb3B1cCgpO1xuICAgIGNvbnN0IGVsZW1lbnRJZHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy5lbGVtZW50cykge1xuICAgICAgZWxlbWVudC5wb3B1cCA9IHBvcHVwO1xuICAgICAgZWxlbWVudC5jb250YWluZXIuYXJpYUhhc1BvcHVwID0gXCJkaWFsb2dcIjtcbiAgICAgIGVsZW1lbnRJZHMucHVzaChlbGVtZW50LmRhdGEuaWQpO1xuICAgICAgZWxlbWVudC5hZGRIaWdobGlnaHRBcmVhKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImFyaWEtY29udHJvbHNcIiwgZWxlbWVudElkcy5tYXAoKGlkKSA9PiBgJHtBbm5vdGF0aW9uUHJlZml4fSR7aWR9YCkuam9pbihcIixcIikpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgUG9wdXBFbGVtZW50IHtcbiAgI2NvbW1lbnRNYW5hZ2VyID0gbnVsbDtcbiAgI2JvdW5kS2V5RG93biA9IHRoaXMuI2tleURvd24uYmluZCh0aGlzKTtcbiAgI2JvdW5kSGlkZSA9IHRoaXMuI2hpZGUuYmluZCh0aGlzKTtcbiAgI2JvdW5kU2hvdyA9IHRoaXMuI3Nob3cuYmluZCh0aGlzKTtcbiAgI2JvdW5kVG9nZ2xlID0gdGhpcy4jdG9nZ2xlLmJpbmQodGhpcyk7XG4gICNjb2xvciA9IG51bGw7XG4gICNjb250YWluZXIgPSBudWxsO1xuICAjY29udGVudHNPYmogPSBudWxsO1xuICAjZGF0ZU9iaiA9IG51bGw7XG4gICNlbGVtZW50cyA9IG51bGw7XG4gICNwYXJlbnQgPSBudWxsO1xuICAjcGFyZW50UmVjdCA9IG51bGw7XG4gICNwaW5uZWQgPSBmYWxzZTtcbiAgI3BvcHVwID0gbnVsbDtcbiAgI3BvcHVwQWJvcnRDb250cm9sbGVyID0gbnVsbDtcbiAgI3Bvc2l0aW9uID0gbnVsbDtcbiAgI2NvbW1lbnRCdXR0b24gPSBudWxsO1xuICAjY29tbWVudEJ1dHRvblBvc2l0aW9uID0gbnVsbDtcbiAgI3BvcHVwUG9zaXRpb24gPSBudWxsO1xuICAjcmVjdCA9IG51bGw7XG4gICNyaWNoVGV4dCA9IG51bGw7XG4gICN0aXRsZU9iaiA9IG51bGw7XG4gICN1cGRhdGVzID0gbnVsbDtcbiAgI3dhc1Zpc2libGUgPSBmYWxzZTtcbiAgI2ZpcnN0RWxlbWVudCA9IG51bGw7XG4gICNjb21tZW50VGV4dCA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjb250YWluZXIsXG4gICAgY29sb3IsXG4gICAgZWxlbWVudHMsXG4gICAgdGl0bGVPYmosXG4gICAgbW9kaWZpY2F0aW9uRGF0ZSxcbiAgICBjb250ZW50c09iaixcbiAgICByaWNoVGV4dCxcbiAgICBwYXJlbnQsXG4gICAgcmVjdCxcbiAgICBwYXJlbnRSZWN0LFxuICAgIG9wZW4sXG4gICAgY29tbWVudE1hbmFnZXIgPSBudWxsXG4gIH0pIHtcbiAgICB0aGlzLiNjb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy4jdGl0bGVPYmogPSB0aXRsZU9iajtcbiAgICB0aGlzLiNjb250ZW50c09iaiA9IGNvbnRlbnRzT2JqO1xuICAgIHRoaXMuI3JpY2hUZXh0ID0gcmljaFRleHQ7XG4gICAgdGhpcy4jcGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuI2NvbG9yID0gY29sb3I7XG4gICAgdGhpcy4jcmVjdCA9IHJlY3Q7XG4gICAgdGhpcy4jcGFyZW50UmVjdCA9IHBhcmVudFJlY3Q7XG4gICAgdGhpcy4jZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICB0aGlzLiNjb21tZW50TWFuYWdlciA9IGNvbW1lbnRNYW5hZ2VyO1xuICAgIHRoaXMuI2ZpcnN0RWxlbWVudCA9IGVsZW1lbnRzWzBdO1xuICAgIHRoaXMuI2RhdGVPYmogPSBQREZEYXRlU3RyaW5nLnRvRGF0ZU9iamVjdChtb2RpZmljYXRpb25EYXRlKTtcbiAgICB0aGlzLnRyaWdnZXIgPSBlbGVtZW50cy5mbGF0TWFwKChlKSA9PiBlLmdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSk7XG4gICAgaWYgKGNvbW1lbnRNYW5hZ2VyKSB7XG4gICAgICB0aGlzLnJlbmRlckNvbW1lbnRCdXR0b24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5oaWRkZW4gPSB0cnVlO1xuICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgdGhpcy4jdG9nZ2xlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gICNhZGRFdmVudExpc3RlbmVycygpIHtcbiAgICBpZiAodGhpcy4jcG9wdXBBYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jcG9wdXBBYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qge1xuICAgICAgc2lnbmFsXG4gICAgfSA9IHRoaXMuI3BvcHVwQWJvcnRDb250cm9sbGVyO1xuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLnRyaWdnZXIpIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuI2JvdW5kVG9nZ2xlLCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZW50ZXJcIiwgdGhpcy4jYm91bmRTaG93LCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybGVhdmVcIiwgdGhpcy4jYm91bmRIaWRlLCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJwb3B1cFRyaWdnZXJBcmVhXCIpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy4jZWxlbWVudHMpIHtcbiAgICAgIGVsZW1lbnQuY29udGFpbmVyPy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNib3VuZEtleURvd24sIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgI3NldENvbW1lbnRCdXR0b25Qb3NpdGlvbigpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy4jZWxlbWVudHMuZmluZCgoZSkgPT4gZS5oYXNDb21tZW50QnV0dG9uKTtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY29tbWVudEJ1dHRvblBvc2l0aW9uID0gZWxlbWVudC5fbm9ybWFsaXplUG9pbnQoZWxlbWVudC5jb21tZW50QnV0dG9uUG9zaXRpb24pO1xuICB9XG4gIHJlbmRlckNvbW1lbnRCdXR0b24oKSB7XG4gICAgaWYgKHRoaXMuI2NvbW1lbnRCdXR0b24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNjb21tZW50QnV0dG9uUG9zaXRpb24pIHtcbiAgICAgIHRoaXMuI3NldENvbW1lbnRCdXR0b25Qb3NpdGlvbigpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2NvbW1lbnRCdXR0b25Qb3NpdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzaWduYWxcbiAgICB9ID0gdGhpcy4jcG9wdXBBYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3QgaGFzT3duQnV0dG9uID0gISF0aGlzLiNmaXJzdEVsZW1lbnQuZXh0cmFQb3B1cEVsZW1lbnQ7XG4gICAgY29uc3QgdG9nZ2xlUG9wdXAgPSAoKSA9PiB7XG4gICAgICB0aGlzLiNjb21tZW50TWFuYWdlci50b2dnbGVDb21tZW50UG9wdXAodGhpcywgdHJ1ZSwgdm9pZCAwLCAhaGFzT3duQnV0dG9uKTtcbiAgICB9O1xuICAgIGNvbnN0IHNob3dQb3B1cCA9ICgpID0+IHtcbiAgICAgIHRoaXMuI2NvbW1lbnRNYW5hZ2VyLnRvZ2dsZUNvbW1lbnRQb3B1cCh0aGlzLCBmYWxzZSwgdHJ1ZSwgIWhhc093bkJ1dHRvbik7XG4gICAgfTtcbiAgICBjb25zdCBoaWRlUG9wdXAgPSAoKSA9PiB7XG4gICAgICB0aGlzLiNjb21tZW50TWFuYWdlci50b2dnbGVDb21tZW50UG9wdXAodGhpcywgZmFsc2UsIGZhbHNlKTtcbiAgICB9O1xuICAgIGlmICghaGFzT3duQnV0dG9uKSB7XG4gICAgICBjb25zdCBidXR0b24gPSB0aGlzLiNjb21tZW50QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICAgIGJ1dHRvbi5jbGFzc05hbWUgPSBcImFubm90YXRpb25Db21tZW50QnV0dG9uXCI7XG4gICAgICBjb25zdCBwYXJlbnRDb250YWluZXIgPSB0aGlzLiNmaXJzdEVsZW1lbnQuY29udGFpbmVyO1xuICAgICAgYnV0dG9uLnN0eWxlLnpJbmRleCA9IHBhcmVudENvbnRhaW5lci5zdHlsZS56SW5kZXggKyAxO1xuICAgICAgYnV0dG9uLnRhYkluZGV4ID0gMDtcbiAgICAgIGJ1dHRvbi5hcmlhSGFzUG9wdXAgPSBcImRpYWxvZ1wiO1xuICAgICAgYnV0dG9uLmFyaWFDb250cm9scyA9IFwiY29tbWVudFBvcHVwXCI7XG4gICAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtc2hvdy1jb21tZW50LWJ1dHRvblwiKTtcbiAgICAgIHRoaXMuI3VwZGF0ZUNvbG9yKCk7XG4gICAgICB0aGlzLiN1cGRhdGVDb21tZW50QnV0dG9uUG9zaXRpb24oKTtcbiAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNib3VuZEtleURvd24sIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdG9nZ2xlUG9wdXAsIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmVudGVyXCIsIHNob3dQb3B1cCwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybGVhdmVcIiwgaGlkZVBvcHVwLCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICBwYXJlbnRDb250YWluZXIuYWZ0ZXIoYnV0dG9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jY29tbWVudEJ1dHRvbiA9IHRoaXMuI2ZpcnN0RWxlbWVudC5jb250YWluZXI7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy50cmlnZ2VyKSB7XG4gICAgICAgIGVsZW1lbnQuYXJpYUhhc1BvcHVwID0gXCJkaWFsb2dcIjtcbiAgICAgICAgZWxlbWVudC5hcmlhQ29udHJvbHMgPSBcImNvbW1lbnRQb3B1cFwiO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2JvdW5kS2V5RG93biwge1xuICAgICAgICAgIHNpZ25hbFxuICAgICAgICB9KTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdG9nZ2xlUG9wdXAsIHtcbiAgICAgICAgICBzaWduYWxcbiAgICAgICAgfSk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJlbnRlclwiLCBzaG93UG9wdXAsIHtcbiAgICAgICAgICBzaWduYWxcbiAgICAgICAgfSk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJsZWF2ZVwiLCBoaWRlUG9wdXAsIHtcbiAgICAgICAgICBzaWduYWxcbiAgICAgICAgfSk7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcInBvcHVwVHJpZ2dlckFyZWFcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gICN1cGRhdGVDb21tZW50QnV0dG9uUG9zaXRpb24oKSB7XG4gICAgaWYgKHRoaXMuI2ZpcnN0RWxlbWVudC5leHRyYVBvcHVwRWxlbWVudCAmJiAhdGhpcy4jZmlyc3RFbGVtZW50LmVkaXRvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnJlbmRlckNvbW1lbnRCdXR0b24oKTtcbiAgICBjb25zdCBbeCwgeV0gPSB0aGlzLiNjb21tZW50QnV0dG9uUG9zaXRpb247XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gdGhpcy4jY29tbWVudEJ1dHRvbjtcbiAgICBzdHlsZS5sZWZ0ID0gYGNhbGMoJHt4fSUpYDtcbiAgICBzdHlsZS50b3AgPSBgY2FsYygke3l9JSAtIHZhcigtLWNvbW1lbnQtYnV0dG9uLWRpbSkpYDtcbiAgfVxuICAjdXBkYXRlQ29sb3IoKSB7XG4gICAgaWYgKHRoaXMuI2ZpcnN0RWxlbWVudC5leHRyYVBvcHVwRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnJlbmRlckNvbW1lbnRCdXR0b24oKTtcbiAgICB0aGlzLiNjb21tZW50QnV0dG9uLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuY29tbWVudEJ1dHRvbkNvbG9yIHx8IFwiXCI7XG4gIH1cbiAgZ2V0IGNvbW1lbnRCdXR0b25Db2xvcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb2xvcixcbiAgICAgIG9wYWNpdHlcbiAgICB9ID0gdGhpcy4jZmlyc3RFbGVtZW50LmNvbW1lbnREYXRhO1xuICAgIGlmICghY29sb3IpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy4jcGFyZW50Ll9jb21tZW50TWFuYWdlci5tYWtlQ29tbWVudENvbG9yKGNvbG9yLCBvcGFjaXR5KTtcbiAgfVxuICBmb2N1c0NvbW1lbnRCdXR0b24oKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLiNjb21tZW50QnV0dG9uPy5mb2N1cygpO1xuICAgIH0sIDApO1xuICB9XG4gIGdldERhdGEoKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmljaFRleHQsXG4gICAgICBjb2xvcixcbiAgICAgIG9wYWNpdHksXG4gICAgICBjcmVhdGlvbkRhdGUsXG4gICAgICBtb2RpZmljYXRpb25EYXRlXG4gICAgfSA9IHRoaXMuI2ZpcnN0RWxlbWVudC5jb21tZW50RGF0YTtcbiAgICByZXR1cm4ge1xuICAgICAgY29udGVudHNPYmo6IHtcbiAgICAgICAgc3RyOiB0aGlzLmNvbW1lbnRcbiAgICAgIH0sXG4gICAgICByaWNoVGV4dCxcbiAgICAgIGNvbG9yLFxuICAgICAgb3BhY2l0eSxcbiAgICAgIGNyZWF0aW9uRGF0ZSxcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGVcbiAgICB9O1xuICB9XG4gIGdldCBlbGVtZW50QmVmb3JlUG9wdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NvbW1lbnRCdXR0b247XG4gIH1cbiAgZ2V0IGNvbW1lbnQoKSB7XG4gICAgdGhpcy4jY29tbWVudFRleHQgfHw9IHRoaXMuI2ZpcnN0RWxlbWVudC5jb21tZW50VGV4dDtcbiAgICByZXR1cm4gdGhpcy4jY29tbWVudFRleHQ7XG4gIH1cbiAgc2V0IGNvbW1lbnQodGV4dCkge1xuICAgIGlmICh0ZXh0ID09PSB0aGlzLmNvbW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jZmlyc3RFbGVtZW50LmNvbW1lbnRUZXh0ID0gdGhpcy4jY29tbWVudFRleHQgPSB0ZXh0O1xuICB9XG4gIGdldCBwYXJlbnRCb3VuZGluZ0NsaWVudFJlY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ZpcnN0RWxlbWVudC5sYXllci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfVxuICBzZXRDb21tZW50QnV0dG9uU3RhdGVzKHtcbiAgICBzZWxlY3RlZCxcbiAgICBoYXNQb3B1cFxuICB9KSB7XG4gICAgaWYgKCF0aGlzLiNjb21tZW50QnV0dG9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvbW1lbnRCdXR0b24uY2xhc3NMaXN0LnRvZ2dsZShcInNlbGVjdGVkXCIsIHNlbGVjdGVkKTtcbiAgICB0aGlzLiNjb21tZW50QnV0dG9uLmFyaWFFeHBhbmRlZCA9IGhhc1BvcHVwO1xuICB9XG4gIHNldFNlbGVjdGVkQ29tbWVudEJ1dHRvbihzZWxlY3RlZCkge1xuICAgIHRoaXMuI2NvbW1lbnRCdXR0b24uY2xhc3NMaXN0LnRvZ2dsZShcInNlbGVjdGVkXCIsIHNlbGVjdGVkKTtcbiAgfVxuICBnZXQgY29tbWVudFBvcHVwUG9zaXRpb24oKSB7XG4gICAgaWYgKHRoaXMuI3BvcHVwUG9zaXRpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLiNwb3B1cFBvc2l0aW9uO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzLiNjb21tZW50QnV0dG9uLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIHg6IHBhcmVudFgsXG4gICAgICB5OiBwYXJlbnRZLFxuICAgICAgd2lkdGg6IHBhcmVudFdpZHRoLFxuICAgICAgaGVpZ2h0OiBwYXJlbnRIZWlnaHRcbiAgICB9ID0gdGhpcy4jZmlyc3RFbGVtZW50LmxheWVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiBbKHggLSBwYXJlbnRYKSAvIHBhcmVudFdpZHRoLCAoeSArIGhlaWdodCAtIHBhcmVudFkpIC8gcGFyZW50SGVpZ2h0XTtcbiAgfVxuICBzZXQgY29tbWVudFBvcHVwUG9zaXRpb24ocG9zKSB7XG4gICAgdGhpcy4jcG9wdXBQb3NpdGlvbiA9IHBvcztcbiAgfVxuICBoYXNEZWZhdWx0UG9wdXBQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9wdXBQb3NpdGlvbiA9PT0gbnVsbDtcbiAgfVxuICBnZXQgY29tbWVudEJ1dHRvblBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLiNjb21tZW50QnV0dG9uUG9zaXRpb247XG4gIH1cbiAgZ2V0IGNvbW1lbnRCdXR0b25XaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy4jY29tbWVudEJ1dHRvbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAvIHRoaXMucGFyZW50Qm91bmRpbmdDbGllbnRSZWN0LndpZHRoO1xuICB9XG4gIGVkaXRDb21tZW50KG9wdGlvbnMpIHtcbiAgICBjb25zdCBbcG9zWCwgcG9zWV0gPSB0aGlzLiNwb3B1cFBvc2l0aW9uIHx8IHRoaXMuY29tbWVudEJ1dHRvblBvc2l0aW9uLm1hcCgoeCkgPT4geCAvIDEwMCk7XG4gICAgY29uc3QgcGFyZW50RGltZW5zaW9ucyA9IHRoaXMucGFyZW50Qm91bmRpbmdDbGllbnRSZWN0O1xuICAgIGNvbnN0IHtcbiAgICAgIHg6IHBhcmVudFgsXG4gICAgICB5OiBwYXJlbnRZLFxuICAgICAgd2lkdGg6IHBhcmVudFdpZHRoLFxuICAgICAgaGVpZ2h0OiBwYXJlbnRIZWlnaHRcbiAgICB9ID0gcGFyZW50RGltZW5zaW9ucztcbiAgICB0aGlzLiNjb21tZW50TWFuYWdlci5zaG93RGlhbG9nKG51bGwsIHRoaXMsIHBhcmVudFggKyBwb3NYICogcGFyZW50V2lkdGgsIHBhcmVudFkgKyBwb3NZICogcGFyZW50SGVpZ2h0LCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgcGFyZW50RGltZW5zaW9uc1xuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy4jcG9wdXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcG9wdXAgPSB0aGlzLiNwb3B1cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgcG9wdXAuY2xhc3NOYW1lID0gXCJwb3B1cFwiO1xuICAgIGlmICh0aGlzLiNjb2xvcikge1xuICAgICAgY29uc3QgYmFzZUNvbG9yID0gcG9wdXAuc3R5bGUub3V0bGluZUNvbG9yID0gVXRpbC5tYWtlSGV4Q29sb3IoLi4udGhpcy4jY29sb3IpO1xuICAgICAgcG9wdXAuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gYGNvbG9yLW1peChpbiBzcmdiLCAke2Jhc2VDb2xvcn0gMzAlLCB3aGl0ZSlgO1xuICAgIH1cbiAgICBjb25zdCBoZWFkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICBoZWFkZXIuY2xhc3NOYW1lID0gXCJoZWFkZXJcIjtcbiAgICBpZiAodGhpcy4jdGl0bGVPYmo/LnN0cikge1xuICAgICAgY29uc3QgdGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIHRpdGxlLmNsYXNzTmFtZSA9IFwidGl0bGVcIjtcbiAgICAgIGhlYWRlci5hcHBlbmQodGl0bGUpO1xuICAgICAgKHtcbiAgICAgICAgZGlyOiB0aXRsZS5kaXIsXG4gICAgICAgIHN0cjogdGl0bGUudGV4dENvbnRlbnRcbiAgICAgIH0gPSB0aGlzLiN0aXRsZU9iaik7XG4gICAgfVxuICAgIHBvcHVwLmFwcGVuZChoZWFkZXIpO1xuICAgIGlmICh0aGlzLiNkYXRlT2JqKSB7XG4gICAgICBjb25zdCBtb2RpZmljYXRpb25EYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRpbWVcIik7XG4gICAgICBtb2RpZmljYXRpb25EYXRlLmNsYXNzTmFtZSA9IFwicG9wdXBEYXRlXCI7XG4gICAgICBtb2RpZmljYXRpb25EYXRlLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLWFubm90YXRpb24tZGF0ZS10aW1lLXN0cmluZ1wiKTtcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGUuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWFyZ3NcIiwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBkYXRlT2JqOiB0aGlzLiNkYXRlT2JqLnZhbHVlT2YoKVxuICAgICAgfSkpO1xuICAgICAgbW9kaWZpY2F0aW9uRGF0ZS5kYXRlVGltZSA9IHRoaXMuI2RhdGVPYmoudG9JU09TdHJpbmcoKTtcbiAgICAgIGhlYWRlci5hcHBlbmQobW9kaWZpY2F0aW9uRGF0ZSk7XG4gICAgfVxuICAgIHJlbmRlclJpY2hUZXh0KHtcbiAgICAgIGh0bWw6IHRoaXMuI2h0bWwgfHwgdGhpcy4jY29udGVudHNPYmouc3RyLFxuICAgICAgZGlyOiB0aGlzLiNjb250ZW50c09iaj8uZGlyLFxuICAgICAgY2xhc3NOYW1lOiBcInBvcHVwQ29udGVudFwiXG4gICAgfSwgcG9wdXApO1xuICAgIHRoaXMuI2NvbnRhaW5lci5hcHBlbmQocG9wdXApO1xuICB9XG4gIGdldCAjaHRtbCgpIHtcbiAgICBjb25zdCByaWNoVGV4dCA9IHRoaXMuI3JpY2hUZXh0O1xuICAgIGNvbnN0IGNvbnRlbnRzT2JqID0gdGhpcy4jY29udGVudHNPYmo7XG4gICAgaWYgKHJpY2hUZXh0Py5zdHIgJiYgKCFjb250ZW50c09iaj8uc3RyIHx8IGNvbnRlbnRzT2JqLnN0ciA9PT0gcmljaFRleHQuc3RyKSkge1xuICAgICAgcmV0dXJuIHRoaXMuI3JpY2hUZXh0Lmh0bWwgfHwgbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2V0ICNmb250U2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jaHRtbD8uYXR0cmlidXRlcz8uc3R5bGU/LmZvbnRTaXplIHx8IDA7XG4gIH1cbiAgZ2V0ICNmb250Q29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2h0bWw/LmF0dHJpYnV0ZXM/LnN0eWxlPy5jb2xvciB8fCBudWxsO1xuICB9XG4gICNtYWtlUG9wdXBDb250ZW50KHRleHQpIHtcbiAgICBjb25zdCBwb3B1cExpbmVzID0gW107XG4gICAgY29uc3QgcG9wdXBDb250ZW50ID0ge1xuICAgICAgc3RyOiB0ZXh0LFxuICAgICAgaHRtbDoge1xuICAgICAgICBuYW1lOiBcImRpdlwiLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgZGlyOiBcImF1dG9cIlxuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICBuYW1lOiBcInBcIixcbiAgICAgICAgICBjaGlsZHJlbjogcG9wdXBMaW5lc1xuICAgICAgICB9XVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbGluZUF0dHJpYnV0ZXMgPSB7XG4gICAgICBzdHlsZToge1xuICAgICAgICBjb2xvcjogdGhpcy4jZm9udENvbG9yLFxuICAgICAgICBmb250U2l6ZTogdGhpcy4jZm9udFNpemUgPyBgY2FsYygke3RoaXMuI2ZvbnRTaXplfXB4ICogdmFyKC0tdG90YWwtc2NhbGUtZmFjdG9yKSlgIDogXCJcIlxuICAgICAgfVxuICAgIH07XG4gICAgZm9yIChjb25zdCBsaW5lIG9mIHRleHQuc3BsaXQoXCJcXG5cIikpIHtcbiAgICAgIHBvcHVwTGluZXMucHVzaCh7XG4gICAgICAgIG5hbWU6IFwic3BhblwiLFxuICAgICAgICB2YWx1ZTogbGluZSxcbiAgICAgICAgYXR0cmlidXRlczogbGluZUF0dHJpYnV0ZXNcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcG9wdXBDb250ZW50O1xuICB9XG4gICNrZXlEb3duKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmFsdEtleSB8fCBldmVudC5zaGlmdEtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGV2ZW50LmtleSA9PT0gXCJFbnRlclwiIHx8IGV2ZW50LmtleSA9PT0gXCJFc2NhcGVcIiAmJiB0aGlzLiNwaW5uZWQpIHtcbiAgICAgIHRoaXMuI3RvZ2dsZSgpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVFZGl0ZWQoe1xuICAgIHJlY3QsXG4gICAgcG9wdXAsXG4gICAgZGVsZXRlZFxuICB9KSB7XG4gICAgaWYgKHRoaXMuI2NvbW1lbnRNYW5hZ2VyKSB7XG4gICAgICBpZiAoZGVsZXRlZCkge1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLiNjb21tZW50VGV4dCA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHBvcHVwKSB7XG4gICAgICAgIGlmIChwb3B1cC5kZWxldGVkKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLiN1cGRhdGVDb2xvcigpO1xuICAgICAgICAgIHRoaXMuI2NvbW1lbnRUZXh0ID0gcG9wdXAudGV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJlY3QpIHtcbiAgICAgICAgdGhpcy4jY29tbWVudEJ1dHRvblBvc2l0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy4jc2V0Q29tbWVudEJ1dHRvblBvc2l0aW9uKCk7XG4gICAgICAgIHRoaXMuI3VwZGF0ZUNvbW1lbnRCdXR0b25Qb3NpdGlvbigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGVsZXRlZCB8fCBwb3B1cD8uZGVsZXRlZCkge1xuICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLiN1cGRhdGVzIHx8PSB7XG4gICAgICBjb250ZW50c09iajogdGhpcy4jY29udGVudHNPYmosXG4gICAgICByaWNoVGV4dDogdGhpcy4jcmljaFRleHRcbiAgICB9O1xuICAgIGlmIChyZWN0KSB7XG4gICAgICB0aGlzLiNwb3NpdGlvbiA9IG51bGw7XG4gICAgfVxuICAgIGlmIChwb3B1cCAmJiBwb3B1cC50ZXh0KSB7XG4gICAgICB0aGlzLiNyaWNoVGV4dCA9IHRoaXMuI21ha2VQb3B1cENvbnRlbnQocG9wdXAudGV4dCk7XG4gICAgICB0aGlzLiNkYXRlT2JqID0gUERGRGF0ZVN0cmluZy50b0RhdGVPYmplY3QocG9wdXAuZGF0ZSk7XG4gICAgICB0aGlzLiNjb250ZW50c09iaiA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuI3BvcHVwPy5yZW1vdmUoKTtcbiAgICB0aGlzLiNwb3B1cCA9IG51bGw7XG4gIH1cbiAgcmVzZXRFZGl0ZWQoKSB7XG4gICAgaWYgKCF0aGlzLiN1cGRhdGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICh7XG4gICAgICBjb250ZW50c09iajogdGhpcy4jY29udGVudHNPYmosXG4gICAgICByaWNoVGV4dDogdGhpcy4jcmljaFRleHRcbiAgICB9ID0gdGhpcy4jdXBkYXRlcyk7XG4gICAgdGhpcy4jdXBkYXRlcyA9IG51bGw7XG4gICAgdGhpcy4jcG9wdXA/LnJlbW92ZSgpO1xuICAgIHRoaXMuI3BvcHVwID0gbnVsbDtcbiAgICB0aGlzLiNwb3NpdGlvbiA9IG51bGw7XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIHRoaXMuI3BvcHVwQWJvcnRDb250cm9sbGVyPy5hYm9ydCgpO1xuICAgIHRoaXMuI3BvcHVwQWJvcnRDb250cm9sbGVyID0gbnVsbDtcbiAgICB0aGlzLiNwb3B1cD8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jcG9wdXAgPSBudWxsO1xuICAgIHRoaXMuI3dhc1Zpc2libGUgPSBmYWxzZTtcbiAgICB0aGlzLiNwaW5uZWQgPSBmYWxzZTtcbiAgICB0aGlzLiNjb21tZW50QnV0dG9uPy5yZW1vdmUoKTtcbiAgICB0aGlzLiNjb21tZW50QnV0dG9uID0gbnVsbDtcbiAgICBpZiAodGhpcy50cmlnZ2VyKSB7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy50cmlnZ2VyKSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcInBvcHVwVHJpZ2dlckFyZWFcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gICNzZXRQb3NpdGlvbigpIHtcbiAgICBpZiAodGhpcy4jcG9zaXRpb24gIT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcGFnZToge1xuICAgICAgICB2aWV3XG4gICAgICB9LFxuICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgcmF3RGltczoge1xuICAgICAgICAgIHBhZ2VXaWR0aCxcbiAgICAgICAgICBwYWdlSGVpZ2h0LFxuICAgICAgICAgIHBhZ2VYLFxuICAgICAgICAgIHBhZ2VZXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9ID0gdGhpcy4jcGFyZW50O1xuICAgIGxldCB1c2VQYXJlbnRSZWN0ID0gISF0aGlzLiNwYXJlbnRSZWN0O1xuICAgIGxldCByZWN0ID0gdXNlUGFyZW50UmVjdCA/IHRoaXMuI3BhcmVudFJlY3QgOiB0aGlzLiNyZWN0O1xuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLiNlbGVtZW50cykge1xuICAgICAgaWYgKCFyZWN0IHx8IFV0aWwuaW50ZXJzZWN0KGVsZW1lbnQuZGF0YS5yZWN0LCByZWN0KSAhPT0gbnVsbCkge1xuICAgICAgICByZWN0ID0gZWxlbWVudC5kYXRhLnJlY3Q7XG4gICAgICAgIHVzZVBhcmVudFJlY3QgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgbm9ybWFsaXplZFJlY3QgPSBVdGlsLm5vcm1hbGl6ZVJlY3QoW3JlY3RbMF0sIHZpZXdbM10gLSByZWN0WzFdICsgdmlld1sxXSwgcmVjdFsyXSwgdmlld1szXSAtIHJlY3RbM10gKyB2aWV3WzFdXSk7XG4gICAgY29uc3QgSE9SSVpPTlRBTF9TUEFDRV9BRlRFUl9BTk5PVEFUSU9OID0gNTtcbiAgICBjb25zdCBwYXJlbnRXaWR0aCA9IHVzZVBhcmVudFJlY3QgPyByZWN0WzJdIC0gcmVjdFswXSArIEhPUklaT05UQUxfU1BBQ0VfQUZURVJfQU5OT1RBVElPTiA6IDA7XG4gICAgY29uc3QgcG9wdXBMZWZ0ID0gbm9ybWFsaXplZFJlY3RbMF0gKyBwYXJlbnRXaWR0aDtcbiAgICBjb25zdCBwb3B1cFRvcCA9IG5vcm1hbGl6ZWRSZWN0WzFdO1xuICAgIHRoaXMuI3Bvc2l0aW9uID0gWzEwMCAqIChwb3B1cExlZnQgLSBwYWdlWCkgLyBwYWdlV2lkdGgsIDEwMCAqIChwb3B1cFRvcCAtIHBhZ2VZKSAvIHBhZ2VIZWlnaHRdO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IHRoaXMuI2NvbnRhaW5lcjtcbiAgICBzdHlsZS5sZWZ0ID0gYCR7dGhpcy4jcG9zaXRpb25bMF19JWA7XG4gICAgc3R5bGUudG9wID0gYCR7dGhpcy4jcG9zaXRpb25bMV19JWA7XG4gIH1cbiAgI3RvZ2dsZSgpIHtcbiAgICBpZiAodGhpcy4jY29tbWVudE1hbmFnZXIpIHtcbiAgICAgIHRoaXMuI2NvbW1lbnRNYW5hZ2VyLnRvZ2dsZUNvbW1lbnRQb3B1cCh0aGlzLCBmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3Bpbm5lZCA9ICF0aGlzLiNwaW5uZWQ7XG4gICAgaWYgKHRoaXMuI3Bpbm5lZCkge1xuICAgICAgdGhpcy4jc2hvdygpO1xuICAgICAgdGhpcy4jY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLiNib3VuZFRvZ2dsZSk7XG4gICAgICB0aGlzLiNjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4jYm91bmRLZXlEb3duKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jaGlkZSgpO1xuICAgICAgdGhpcy4jY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLiNib3VuZFRvZ2dsZSk7XG4gICAgICB0aGlzLiNjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4jYm91bmRLZXlEb3duKTtcbiAgICB9XG4gIH1cbiAgI3Nob3coKSB7XG4gICAgaWYgKCF0aGlzLiNwb3B1cCkge1xuICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgdGhpcy4jc2V0UG9zaXRpb24oKTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5oaWRkZW4gPSBmYWxzZTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5zdHlsZS56SW5kZXggPSBwYXJzZUludCh0aGlzLiNjb250YWluZXIuc3R5bGUuekluZGV4KSArIDFlMztcbiAgICB9IGVsc2UgaWYgKHRoaXMuI3Bpbm5lZCkge1xuICAgICAgdGhpcy4jY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJmb2N1c2VkXCIpO1xuICAgIH1cbiAgfVxuICAjaGlkZSgpIHtcbiAgICB0aGlzLiNjb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShcImZvY3VzZWRcIik7XG4gICAgaWYgKHRoaXMuI3Bpbm5lZCB8fCAhdGhpcy5pc1Zpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY29udGFpbmVyLmhpZGRlbiA9IHRydWU7XG4gICAgdGhpcy4jY29udGFpbmVyLnN0eWxlLnpJbmRleCA9IHBhcnNlSW50KHRoaXMuI2NvbnRhaW5lci5zdHlsZS56SW5kZXgpIC0gMWUzO1xuICB9XG4gIGZvcmNlSGlkZSgpIHtcbiAgICB0aGlzLiN3YXNWaXNpYmxlID0gdGhpcy5pc1Zpc2libGU7XG4gICAgaWYgKCF0aGlzLiN3YXNWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvbnRhaW5lci5oaWRkZW4gPSB0cnVlO1xuICB9XG4gIG1heWJlU2hvdygpIHtcbiAgICBpZiAodGhpcy4jY29tbWVudE1hbmFnZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICBpZiAoIXRoaXMuI3dhc1Zpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNwb3B1cCkge1xuICAgICAgdGhpcy4jc2hvdygpO1xuICAgIH1cbiAgICB0aGlzLiN3YXNWaXNpYmxlID0gZmFsc2U7XG4gICAgdGhpcy4jY29udGFpbmVyLmhpZGRlbiA9IGZhbHNlO1xuICB9XG4gIGdldCBpc1Zpc2libGUoKSB7XG4gICAgaWYgKHRoaXMuI2NvbW1lbnRNYW5hZ2VyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNjb250YWluZXIuaGlkZGVuID09PSBmYWxzZTtcbiAgfVxufVxuY2xhc3MgRnJlZVRleHRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSBwYXJhbWV0ZXJzLmRhdGEudGV4dENvbnRlbnQ7XG4gICAgdGhpcy50ZXh0UG9zaXRpb24gPSBwYXJhbWV0ZXJzLmRhdGEudGV4dFBvc2l0aW9uO1xuICAgIHRoaXMuYW5ub3RhdGlvbkVkaXRvclR5cGUgPSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5GUkVFVEVYVDtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImZyZWVUZXh0QW5ub3RhdGlvblwiKTtcbiAgICBpZiAodGhpcy50ZXh0Q29udGVudCkge1xuICAgICAgY29uc3QgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoXCJhbm5vdGF0aW9uVGV4dENvbnRlbnRcIik7XG4gICAgICBjb250ZW50LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJjb21tZW50XCIpO1xuICAgICAgZm9yIChjb25zdCBsaW5lIG9mIHRoaXMudGV4dENvbnRlbnQpIHtcbiAgICAgICAgY29uc3QgbGluZVNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgbGluZVNwYW4udGV4dENvbnRlbnQgPSBsaW5lO1xuICAgICAgICBjb250ZW50LmFwcGVuZChsaW5lU3Bhbik7XG4gICAgICB9XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoY29udGVudCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5kYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICB0aGlzLl9lZGl0T25Eb3VibGVDbGljaygpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgTGluZUFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICAjbGluZSA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImxpbmVBbm5vdGF0aW9uXCIpO1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG4gICAgY29uc3QgbGluZSA9IHRoaXMuI2xpbmUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpsaW5lXCIpO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwieDFcIiwgZGF0YS5yZWN0WzJdIC0gZGF0YS5saW5lQ29vcmRpbmF0ZXNbMF0pO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwieTFcIiwgZGF0YS5yZWN0WzNdIC0gZGF0YS5saW5lQ29vcmRpbmF0ZXNbMV0pO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwieDJcIiwgZGF0YS5yZWN0WzJdIC0gZGF0YS5saW5lQ29vcmRpbmF0ZXNbMl0pO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwieTJcIiwgZGF0YS5yZWN0WzNdIC0gZGF0YS5saW5lQ29vcmRpbmF0ZXNbM10pO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIGRhdGEuYm9yZGVyU3R5bGUud2lkdGggfHwgMSk7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBzdmcuYXBwZW5kKGxpbmUpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuICAgIGlmICghZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gIGdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2xpbmU7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgfVxufVxuY2xhc3MgU3F1YXJlQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICNzcXVhcmUgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJzcXVhcmVBbm5vdGF0aW9uXCIpO1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG4gICAgY29uc3QgYm9yZGVyV2lkdGggPSBkYXRhLmJvcmRlclN0eWxlLndpZHRoO1xuICAgIGNvbnN0IHNxdWFyZSA9IHRoaXMuI3NxdWFyZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnJlY3RcIik7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcInhcIiwgYm9yZGVyV2lkdGggLyAyKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwieVwiLCBib3JkZXJXaWR0aCAvIDIpO1xuICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCB3aWR0aCAtIGJvcmRlcldpZHRoKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGhlaWdodCAtIGJvcmRlcldpZHRoKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIGJvcmRlcldpZHRoIHx8IDEpO1xuICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIHN2Zy5hcHBlbmQoc3F1YXJlKTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcbiAgICBpZiAoIWRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLiNzcXVhcmU7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgfVxufVxuY2xhc3MgQ2lyY2xlQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICNjaXJjbGUgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJjaXJjbGVBbm5vdGF0aW9uXCIpO1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG4gICAgY29uc3QgYm9yZGVyV2lkdGggPSBkYXRhLmJvcmRlclN0eWxlLndpZHRoO1xuICAgIGNvbnN0IGNpcmNsZSA9IHRoaXMuI2NpcmNsZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmVsbGlwc2VcIik7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcImN4XCIsIHdpZHRoIC8gMik7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcImN5XCIsIGhlaWdodCAvIDIpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJyeFwiLCB3aWR0aCAvIDIgLSBib3JkZXJXaWR0aCAvIDIpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJyeVwiLCBoZWlnaHQgLyAyIC0gYm9yZGVyV2lkdGggLyAyKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIGJvcmRlcldpZHRoIHx8IDEpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIHN2Zy5hcHBlbmQoY2lyY2xlKTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcbiAgICBpZiAoIWRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLiNjaXJjbGU7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgfVxufVxuY2xhc3MgUG9seWxpbmVBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI3BvbHlsaW5lID0gbnVsbDtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuY29udGFpbmVyQ2xhc3NOYW1lID0gXCJwb2x5bGluZUFubm90YXRpb25cIjtcbiAgICB0aGlzLnN2Z0VsZW1lbnROYW1lID0gXCJzdmc6cG9seWxpbmVcIjtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZCh0aGlzLmNvbnRhaW5lckNsYXNzTmFtZSk7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YToge1xuICAgICAgICByZWN0LFxuICAgICAgICB2ZXJ0aWNlcyxcbiAgICAgICAgYm9yZGVyU3R5bGUsXG4gICAgICAgIHBvcHVwUmVmXG4gICAgICB9LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIXZlcnRpY2VzKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gICAgfVxuICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG4gICAgbGV0IHBvaW50cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IHggPSB2ZXJ0aWNlc1tpXSAtIHJlY3RbMF07XG4gICAgICBjb25zdCB5ID0gcmVjdFszXSAtIHZlcnRpY2VzW2kgKyAxXTtcbiAgICAgIHBvaW50cy5wdXNoKGAke3h9LCR7eX1gKTtcbiAgICB9XG4gICAgcG9pbnRzID0gcG9pbnRzLmpvaW4oXCIgXCIpO1xuICAgIGNvbnN0IHBvbHlsaW5lID0gdGhpcy4jcG9seWxpbmUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudCh0aGlzLnN2Z0VsZW1lbnROYW1lKTtcbiAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJwb2ludHNcIiwgcG9pbnRzKTtcbiAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgYm9yZGVyU3R5bGUud2lkdGggfHwgMSk7XG4gICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIHN2Zy5hcHBlbmQocG9seWxpbmUpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuICAgIGlmICghcG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLiNwb2x5bGluZTtcbiAgfVxuICBhZGRIaWdobGlnaHRBcmVhKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICB9XG59XG5jbGFzcyBQb2x5Z29uQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBQb2x5bGluZUFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xuICAgIHRoaXMuY29udGFpbmVyQ2xhc3NOYW1lID0gXCJwb2x5Z29uQW5ub3RhdGlvblwiO1xuICAgIHRoaXMuc3ZnRWxlbWVudE5hbWUgPSBcInN2Zzpwb2x5Z29uXCI7XG4gIH1cbn1cbmNsYXNzIENhcmV0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImNhcmV0QW5ub3RhdGlvblwiKTtcbiAgICBpZiAoIXRoaXMuZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBJbmtBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI3BvbHlsaW5lc0dyb3VwRWxlbWVudCA9IG51bGw7XG4gICNwb2x5bGluZXMgPSBbXTtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuY29udGFpbmVyQ2xhc3NOYW1lID0gXCJpbmtBbm5vdGF0aW9uXCI7XG4gICAgdGhpcy5zdmdFbGVtZW50TmFtZSA9IFwic3ZnOnBvbHlsaW5lXCI7XG4gICAgdGhpcy5hbm5vdGF0aW9uRWRpdG9yVHlwZSA9IHRoaXMuZGF0YS5pdCA9PT0gXCJJbmtIaWdobGlnaHRcIiA/IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVCA6IEFubm90YXRpb25FZGl0b3JUeXBlLklOSztcbiAgfVxuICAjZ2V0VHJhbnNmb3JtKHJvdGF0aW9uLCByZWN0KSB7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0cmFuc2Zvcm06IGByb3RhdGUoOTApIHRyYW5zbGF0ZSgkey1yZWN0WzBdfSwke3JlY3RbMV19KSBzY2FsZSgxLC0xKWAsXG4gICAgICAgICAgd2lkdGg6IHJlY3RbM10gLSByZWN0WzFdLFxuICAgICAgICAgIGhlaWdodDogcmVjdFsyXSAtIHJlY3RbMF1cbiAgICAgICAgfTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZSgxODApIHRyYW5zbGF0ZSgkey1yZWN0WzJdfSwke3JlY3RbMV19KSBzY2FsZSgxLC0xKWAsXG4gICAgICAgICAgd2lkdGg6IHJlY3RbMl0gLSByZWN0WzBdLFxuICAgICAgICAgIGhlaWdodDogcmVjdFszXSAtIHJlY3RbMV1cbiAgICAgICAgfTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZSgyNzApIHRyYW5zbGF0ZSgkey1yZWN0WzJdfSwke3JlY3RbM119KSBzY2FsZSgxLC0xKWAsXG4gICAgICAgICAgd2lkdGg6IHJlY3RbM10gLSByZWN0WzFdLFxuICAgICAgICAgIGhlaWdodDogcmVjdFsyXSAtIHJlY3RbMF1cbiAgICAgICAgfTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7LXJlY3RbMF19LCR7cmVjdFszXX0pIHNjYWxlKDEsLTEpYCxcbiAgICAgICAgICB3aWR0aDogcmVjdFsyXSAtIHJlY3RbMF0sXG4gICAgICAgICAgaGVpZ2h0OiByZWN0WzNdIC0gcmVjdFsxXVxuICAgICAgICB9O1xuICAgIH1cbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZCh0aGlzLmNvbnRhaW5lckNsYXNzTmFtZSk7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YToge1xuICAgICAgICByZWN0LFxuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgaW5rTGlzdHMsXG4gICAgICAgIGJvcmRlclN0eWxlLFxuICAgICAgICBwb3B1cFJlZlxuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXMuI2dldFRyYW5zZm9ybShyb3RhdGlvbiwgcmVjdCk7XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcbiAgICBjb25zdCBnID0gdGhpcy4jcG9seWxpbmVzR3JvdXBFbGVtZW50ID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6Z1wiKTtcbiAgICBzdmcuYXBwZW5kKGcpO1xuICAgIGcuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIGJvcmRlclN0eWxlLndpZHRoIHx8IDEpO1xuICAgIGcuc2V0QXR0cmlidXRlKFwic3Ryb2tlLWxpbmVjYXBcIiwgXCJyb3VuZFwiKTtcbiAgICBnLnNldEF0dHJpYnV0ZShcInN0cm9rZS1saW5lam9pblwiLCBcInJvdW5kXCIpO1xuICAgIGcuc2V0QXR0cmlidXRlKFwic3Ryb2tlLW1pdGVybGltaXRcIiwgMTApO1xuICAgIGcuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgZy5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgZy5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBpbmtMaXN0cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBjb25zdCBwb2x5bGluZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KHRoaXMuc3ZnRWxlbWVudE5hbWUpO1xuICAgICAgdGhpcy4jcG9seWxpbmVzLnB1c2gocG9seWxpbmUpO1xuICAgICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwicG9pbnRzXCIsIGlua0xpc3RzW2ldLmpvaW4oXCIsXCIpKTtcbiAgICAgIGcuYXBwZW5kKHBvbHlsaW5lKTtcbiAgICB9XG4gICAgaWYgKCFwb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG4gICAgdGhpcy5fZWRpdE9uRG91YmxlQ2xpY2soKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgdXBkYXRlRWRpdGVkKHBhcmFtcykge1xuICAgIHN1cGVyLnVwZGF0ZUVkaXRlZChwYXJhbXMpO1xuICAgIGNvbnN0IHtcbiAgICAgIHRoaWNrbmVzcyxcbiAgICAgIHBvaW50cyxcbiAgICAgIHJlY3RcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IGcgPSB0aGlzLiNwb2x5bGluZXNHcm91cEVsZW1lbnQ7XG4gICAgaWYgKHRoaWNrbmVzcyA+PSAwKSB7XG4gICAgICBnLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCB0aGlja25lc3MgfHwgMSk7XG4gICAgfVxuICAgIGlmIChwb2ludHMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHRoaXMuI3BvbHlsaW5lcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIHRoaXMuI3BvbHlsaW5lc1tpXS5zZXRBdHRyaWJ1dGUoXCJwb2ludHNcIiwgcG9pbnRzW2ldLmpvaW4oXCIsXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlY3QpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9ID0gdGhpcy4jZ2V0VHJhbnNmb3JtKHRoaXMuZGF0YS5yb3RhdGlvbiwgcmVjdCk7XG4gICAgICBjb25zdCByb290ID0gZy5wYXJlbnRFbGVtZW50O1xuICAgICAgcm9vdC5zZXRBdHRyaWJ1dGUoXCJ2aWV3Qm94XCIsIGAwIDAgJHt3aWR0aH0gJHtoZWlnaHR9YCk7XG4gICAgICBnLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0pO1xuICAgIH1cbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLiNwb2x5bGluZXM7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgfVxufVxuY2xhc3MgSGlnaGxpZ2h0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWUsXG4gICAgICBjcmVhdGVRdWFkcmlsYXRlcmFsczogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuYW5ub3RhdGlvbkVkaXRvclR5cGUgPSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQ7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgb3ZlcmxhaWRUZXh0LFxuICAgICAgICBwb3B1cFJlZlxuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghcG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBbm5vdGF0aW9uXCIpO1xuICAgIHRoaXMuX2VkaXRPbkRvdWJsZUNsaWNrKCk7XG4gICAgaWYgKG92ZXJsYWlkVGV4dCkge1xuICAgICAgY29uc3QgbWFyayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJtYXJrXCIpO1xuICAgICAgbWFyay5jbGFzc0xpc3QuYWRkKFwib3ZlcmxhaWRUZXh0XCIpO1xuICAgICAgbWFyay50ZXh0Q29udGVudCA9IG92ZXJsYWlkVGV4dDtcbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChtYXJrKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBVbmRlcmxpbmVBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZSxcbiAgICAgIGNyZWF0ZVF1YWRyaWxhdGVyYWxzOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgb3ZlcmxhaWRUZXh0LFxuICAgICAgICBwb3B1cFJlZlxuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghcG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJ1bmRlcmxpbmVBbm5vdGF0aW9uXCIpO1xuICAgIGlmIChvdmVybGFpZFRleHQpIHtcbiAgICAgIGNvbnN0IHVuZGVybGluZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ1XCIpO1xuICAgICAgdW5kZXJsaW5lLmNsYXNzTGlzdC5hZGQoXCJvdmVybGFpZFRleHRcIik7XG4gICAgICB1bmRlcmxpbmUudGV4dENvbnRlbnQgPSBvdmVybGFpZFRleHQ7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQodW5kZXJsaW5lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBTcXVpZ2dseUFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlLFxuICAgICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHM6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YToge1xuICAgICAgICBvdmVybGFpZFRleHQsXG4gICAgICAgIHBvcHVwUmVmXG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFwb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInNxdWlnZ2x5QW5ub3RhdGlvblwiKTtcbiAgICBpZiAob3ZlcmxhaWRUZXh0KSB7XG4gICAgICBjb25zdCB1bmRlcmxpbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidVwiKTtcbiAgICAgIHVuZGVybGluZS5jbGFzc0xpc3QuYWRkKFwib3ZlcmxhaWRUZXh0XCIpO1xuICAgICAgdW5kZXJsaW5lLnRleHRDb250ZW50ID0gb3ZlcmxhaWRUZXh0O1xuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHVuZGVybGluZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgU3RyaWtlT3V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWUsXG4gICAgICBjcmVhdGVRdWFkcmlsYXRlcmFsczogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIG92ZXJsYWlkVGV4dCxcbiAgICAgICAgcG9wdXBSZWZcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIXBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwic3RyaWtlb3V0QW5ub3RhdGlvblwiKTtcbiAgICBpZiAob3ZlcmxhaWRUZXh0KSB7XG4gICAgICBjb25zdCBzdHJpa2VvdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic1wiKTtcbiAgICAgIHN0cmlrZW91dC5jbGFzc0xpc3QuYWRkKFwib3ZlcmxhaWRUZXh0XCIpO1xuICAgICAgc3RyaWtlb3V0LnRleHRDb250ZW50ID0gb3ZlcmxhaWRUZXh0O1xuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN0cmlrZW91dCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgU3RhbXBBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuYW5ub3RhdGlvbkVkaXRvclR5cGUgPSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5TVEFNUDtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInN0YW1wQW5ub3RhdGlvblwiKTtcbiAgICB0aGlzLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiaW1nXCIpO1xuICAgIGlmICghdGhpcy5kYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICB0aGlzLl9lZGl0T25Eb3VibGVDbGljaygpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgRmlsZUF0dGFjaG1lbnRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI3RyaWdnZXIgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgY29uc3Qge1xuICAgICAgZmlsZVxuICAgIH0gPSB0aGlzLmRhdGE7XG4gICAgdGhpcy5maWxlbmFtZSA9IGZpbGUuZmlsZW5hbWU7XG4gICAgdGhpcy5jb250ZW50ID0gZmlsZS5jb250ZW50O1xuICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZmlsZWF0dGFjaG1lbnRhbm5vdGF0aW9uXCIsIHtcbiAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgIC4uLmZpbGVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImZpbGVBdHRhY2htZW50QW5ub3RhdGlvblwiKTtcbiAgICBjb25zdCB7XG4gICAgICBjb250YWluZXIsXG4gICAgICBkYXRhXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHRyaWdnZXI7XG4gICAgaWYgKGRhdGEuaGFzQXBwZWFyYW5jZSB8fCBkYXRhLmZpbGxBbHBoYSA9PT0gMCkge1xuICAgICAgdHJpZ2dlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyaWdnZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgdHJpZ2dlci5zcmMgPSBgJHt0aGlzLmltYWdlUmVzb3VyY2VzUGF0aH1hbm5vdGF0aW9uLSR7L3BhcGVyY2xpcC9pLnRlc3QoZGF0YS5uYW1lKSA/IFwicGFwZXJjbGlwXCIgOiBcInB1c2hwaW5cIn0uc3ZnYDtcbiAgICAgIGlmIChkYXRhLmZpbGxBbHBoYSAmJiBkYXRhLmZpbGxBbHBoYSA8IDEpIHtcbiAgICAgICAgdHJpZ2dlci5zdHlsZSA9IGBmaWx0ZXI6IG9wYWNpdHkoJHtNYXRoLnJvdW5kKGRhdGEuZmlsbEFscGhhICogMTAwKX0lKTtgO1xuICAgICAgfVxuICAgIH1cbiAgICB0cmlnZ2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJkYmxjbGlja1wiLCB0aGlzLiNkb3dubG9hZC5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLiN0cmlnZ2VyID0gdHJpZ2dlcjtcbiAgICBjb25zdCB7XG4gICAgICBpc01hY1xuICAgIH0gPSB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCAoZXZ0KSA9PiB7XG4gICAgICBpZiAoZXZ0LmtleSA9PT0gXCJFbnRlclwiICYmIChpc01hYyA/IGV2dC5tZXRhS2V5IDogZXZ0LmN0cmxLZXkpKSB7XG4gICAgICAgIHRoaXMuI2Rvd25sb2FkKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFkYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmlnZ2VyLmNsYXNzTGlzdC5hZGQoXCJwb3B1cFRyaWdnZXJBcmVhXCIpO1xuICAgIH1cbiAgICBjb250YWluZXIuYXBwZW5kKHRyaWdnZXIpO1xuICAgIHJldHVybiBjb250YWluZXI7XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy4jdHJpZ2dlcjtcbiAgfVxuICBhZGRIaWdobGlnaHRBcmVhKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICB9XG4gICNkb3dubG9hZCgpIHtcbiAgICB0aGlzLmRvd25sb2FkTWFuYWdlcj8ub3Blbk9yRG93bmxvYWREYXRhKHRoaXMuY29udGVudCwgdGhpcy5maWxlbmFtZSk7XG4gIH1cbn1cbmNsYXNzIEFubm90YXRpb25MYXllciB7XG4gICNhY2Nlc3NpYmlsaXR5TWFuYWdlciA9IG51bGw7XG4gICNhbm5vdGF0aW9uQ2FudmFzTWFwID0gbnVsbDtcbiAgI2Fubm90YXRpb25TdG9yYWdlID0gbnVsbDtcbiAgI2VkaXRhYmxlQW5ub3RhdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAjc3RydWN0VHJlZUxheWVyID0gbnVsbDtcbiAgI2xpbmtTZXJ2aWNlID0gbnVsbDtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGRpdixcbiAgICBhY2Nlc3NpYmlsaXR5TWFuYWdlcixcbiAgICBhbm5vdGF0aW9uQ2FudmFzTWFwLFxuICAgIGFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIsXG4gICAgcGFnZSxcbiAgICB2aWV3cG9ydCxcbiAgICBzdHJ1Y3RUcmVlTGF5ZXIsXG4gICAgY29tbWVudE1hbmFnZXIsXG4gICAgbGlua1NlcnZpY2UsXG4gICAgYW5ub3RhdGlvblN0b3JhZ2VcbiAgfSkge1xuICAgIHRoaXMuZGl2ID0gZGl2O1xuICAgIHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyID0gYWNjZXNzaWJpbGl0eU1hbmFnZXI7XG4gICAgdGhpcy4jYW5ub3RhdGlvbkNhbnZhc01hcCA9IGFubm90YXRpb25DYW52YXNNYXA7XG4gICAgdGhpcy4jc3RydWN0VHJlZUxheWVyID0gc3RydWN0VHJlZUxheWVyIHx8IG51bGw7XG4gICAgdGhpcy4jbGlua1NlcnZpY2UgPSBsaW5rU2VydmljZSB8fCBudWxsO1xuICAgIHRoaXMuI2Fubm90YXRpb25TdG9yYWdlID0gYW5ub3RhdGlvblN0b3JhZ2UgfHwgbmV3IEFubm90YXRpb25TdG9yYWdlKCk7XG4gICAgdGhpcy5wYWdlID0gcGFnZTtcbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgdGhpcy56SW5kZXggPSAwO1xuICAgIHRoaXMuX2Fubm90YXRpb25FZGl0b3JVSU1hbmFnZXIgPSBhbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyO1xuICAgIHRoaXMuX2NvbW1lbnRNYW5hZ2VyID0gY29tbWVudE1hbmFnZXIgfHwgbnVsbDtcbiAgfVxuICBoYXNFZGl0YWJsZUFubm90YXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLiNlZGl0YWJsZUFubm90YXRpb25zLnNpemUgPiAwO1xuICB9XG4gIGFzeW5jICNhcHBlbmRFbGVtZW50KGVsZW1lbnQsIGlkLCBwb3B1cEVsZW1lbnRzKSB7XG4gICAgY29uc3QgY29udGVudEVsZW1lbnQgPSBlbGVtZW50LmZpcnN0Q2hpbGQgfHwgZWxlbWVudDtcbiAgICBjb25zdCBhbm5vdGF0aW9uSWQgPSBjb250ZW50RWxlbWVudC5pZCA9IGAke0Fubm90YXRpb25QcmVmaXh9JHtpZH1gO1xuICAgIGNvbnN0IGFyaWFBdHRyaWJ1dGVzID0gYXdhaXQgdGhpcy4jc3RydWN0VHJlZUxheWVyPy5nZXRBcmlhQXR0cmlidXRlcyhhbm5vdGF0aW9uSWQpO1xuICAgIGlmIChhcmlhQXR0cmlidXRlcykge1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgYXJpYUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgY29udGVudEVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocG9wdXBFbGVtZW50cykge1xuICAgICAgcG9wdXBFbGVtZW50cy5hdCgtMSkuY29udGFpbmVyLmFmdGVyKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpdi5hcHBlbmQoZWxlbWVudCk7XG4gICAgICB0aGlzLiNhY2Nlc3NpYmlsaXR5TWFuYWdlcj8ubW92ZUVsZW1lbnRJbkRPTSh0aGlzLmRpdiwgZWxlbWVudCwgY29udGVudEVsZW1lbnQsIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcmVuZGVyKHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIGFubm90YXRpb25zXG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCBsYXllciA9IHRoaXMuZGl2O1xuICAgIHNldExheWVyRGltZW5zaW9ucyhsYXllciwgdGhpcy52aWV3cG9ydCk7XG4gICAgY29uc3QgcG9wdXBUb0VsZW1lbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBlbGVtZW50UGFyYW1zID0ge1xuICAgICAgZGF0YTogbnVsbCxcbiAgICAgIGxheWVyLFxuICAgICAgbGlua1NlcnZpY2U6IHRoaXMuI2xpbmtTZXJ2aWNlLFxuICAgICAgZG93bmxvYWRNYW5hZ2VyOiBwYXJhbXMuZG93bmxvYWRNYW5hZ2VyLFxuICAgICAgaW1hZ2VSZXNvdXJjZXNQYXRoOiBwYXJhbXMuaW1hZ2VSZXNvdXJjZXNQYXRoIHx8IFwiXCIsXG4gICAgICByZW5kZXJGb3JtczogcGFyYW1zLnJlbmRlckZvcm1zICE9PSBmYWxzZSxcbiAgICAgIHN2Z0ZhY3Rvcnk6IG5ldyBET01TVkdGYWN0b3J5KCksXG4gICAgICBhbm5vdGF0aW9uU3RvcmFnZTogdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2UsXG4gICAgICBlbmFibGVDb21tZW50OiBwYXJhbXMuZW5hYmxlQ29tbWVudCA9PT0gdHJ1ZSxcbiAgICAgIGVuYWJsZVNjcmlwdGluZzogcGFyYW1zLmVuYWJsZVNjcmlwdGluZyA9PT0gdHJ1ZSxcbiAgICAgIGhhc0pTQWN0aW9uczogcGFyYW1zLmhhc0pTQWN0aW9ucyxcbiAgICAgIGZpZWxkT2JqZWN0czogcGFyYW1zLmZpZWxkT2JqZWN0cyxcbiAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgIGVsZW1lbnRzOiBudWxsXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGRhdGEgb2YgYW5ub3RhdGlvbnMpIHtcbiAgICAgIGlmIChkYXRhLm5vSFRNTCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzUG9wdXBBbm5vdGF0aW9uID0gZGF0YS5hbm5vdGF0aW9uVHlwZSA9PT0gQW5ub3RhdGlvblR5cGUuUE9QVVA7XG4gICAgICBpZiAoIWlzUG9wdXBBbm5vdGF0aW9uKSB7XG4gICAgICAgIGlmIChkYXRhLnJlY3RbMl0gPT09IGRhdGEucmVjdFswXSB8fCBkYXRhLnJlY3RbM10gPT09IGRhdGEucmVjdFsxXSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBlbGVtZW50cyA9IHBvcHVwVG9FbGVtZW50cy5nZXQoZGF0YS5pZCk7XG4gICAgICAgIGlmICghZWxlbWVudHMpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50UGFyYW1zLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgICB9XG4gICAgICBlbGVtZW50UGFyYW1zLmRhdGEgPSBkYXRhO1xuICAgICAgY29uc3QgZWxlbWVudCA9IEFubm90YXRpb25FbGVtZW50RmFjdG9yeS5jcmVhdGUoZWxlbWVudFBhcmFtcyk7XG4gICAgICBpZiAoIWVsZW1lbnQuaXNSZW5kZXJhYmxlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFpc1BvcHVwQW5ub3RhdGlvbiAmJiBkYXRhLnBvcHVwUmVmKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gcG9wdXBUb0VsZW1lbnRzLmdldChkYXRhLnBvcHVwUmVmKTtcbiAgICAgICAgaWYgKCFlbGVtZW50cykge1xuICAgICAgICAgIHBvcHVwVG9FbGVtZW50cy5zZXQoZGF0YS5wb3B1cFJlZiwgW2VsZW1lbnRdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCByZW5kZXJlZCA9IGVsZW1lbnQucmVuZGVyKCk7XG4gICAgICBpZiAoZGF0YS5oaWRkZW4pIHtcbiAgICAgICAgcmVuZGVyZWQuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLiNhcHBlbmRFbGVtZW50KHJlbmRlcmVkLCBkYXRhLmlkLCBlbGVtZW50UGFyYW1zLmVsZW1lbnRzKTtcbiAgICAgIGVsZW1lbnQuZXh0cmFQb3B1cEVsZW1lbnQ/LnBvcHVwPy5yZW5kZXJDb21tZW50QnV0dG9uKCk7XG4gICAgICBpZiAoZWxlbWVudC5faXNFZGl0YWJsZSkge1xuICAgICAgICB0aGlzLiNlZGl0YWJsZUFubm90YXRpb25zLnNldChlbGVtZW50LmRhdGEuaWQsIGVsZW1lbnQpO1xuICAgICAgICB0aGlzLl9hbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyPy5yZW5kZXJBbm5vdGF0aW9uRWxlbWVudChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jc2V0QW5ub3RhdGlvbkNhbnZhc01hcCgpO1xuICB9XG4gIGFzeW5jIGFkZExpbmtBbm5vdGF0aW9ucyhhbm5vdGF0aW9ucykge1xuICAgIGNvbnN0IGVsZW1lbnRQYXJhbXMgPSB7XG4gICAgICBkYXRhOiBudWxsLFxuICAgICAgbGF5ZXI6IHRoaXMuZGl2LFxuICAgICAgbGlua1NlcnZpY2U6IHRoaXMuI2xpbmtTZXJ2aWNlLFxuICAgICAgc3ZnRmFjdG9yeTogbmV3IERPTVNWR0ZhY3RvcnkoKSxcbiAgICAgIHBhcmVudDogdGhpc1xuICAgIH07XG4gICAgZm9yIChjb25zdCBkYXRhIG9mIGFubm90YXRpb25zKSB7XG4gICAgICBkYXRhLmJvcmRlclN0eWxlIHx8PSBBbm5vdGF0aW9uTGF5ZXIuX2RlZmF1bHRCb3JkZXJTdHlsZTtcbiAgICAgIGVsZW1lbnRQYXJhbXMuZGF0YSA9IGRhdGE7XG4gICAgICBjb25zdCBlbGVtZW50ID0gQW5ub3RhdGlvbkVsZW1lbnRGYWN0b3J5LmNyZWF0ZShlbGVtZW50UGFyYW1zKTtcbiAgICAgIGlmICghZWxlbWVudC5pc1JlbmRlcmFibGUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCByZW5kZXJlZCA9IGVsZW1lbnQucmVuZGVyKCk7XG4gICAgICBhd2FpdCB0aGlzLiNhcHBlbmRFbGVtZW50KHJlbmRlcmVkLCBkYXRhLmlkLCBudWxsKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlKHtcbiAgICB2aWV3cG9ydFxuICB9KSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmRpdjtcbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgc2V0TGF5ZXJEaW1lbnNpb25zKGxheWVyLCB7XG4gICAgICByb3RhdGlvbjogdmlld3BvcnQucm90YXRpb25cbiAgICB9KTtcbiAgICB0aGlzLiNzZXRBbm5vdGF0aW9uQ2FudmFzTWFwKCk7XG4gICAgbGF5ZXIuaGlkZGVuID0gZmFsc2U7XG4gIH1cbiAgI3NldEFubm90YXRpb25DYW52YXNNYXAoKSB7XG4gICAgaWYgKCF0aGlzLiNhbm5vdGF0aW9uQ2FudmFzTWFwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5kaXY7XG4gICAgZm9yIChjb25zdCBbaWQsIGNhbnZhc10gb2YgdGhpcy4jYW5ub3RhdGlvbkNhbnZhc01hcCkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGxheWVyLnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWFubm90YXRpb24taWQ9XCIke2lkfVwiXWApO1xuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY2FudmFzLmNsYXNzTmFtZSA9IFwiYW5ub3RhdGlvbkNvbnRlbnRcIjtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZmlyc3RDaGlsZFxuICAgICAgfSA9IGVsZW1lbnQ7XG4gICAgICBpZiAoIWZpcnN0Q2hpbGQpIHtcbiAgICAgICAgZWxlbWVudC5hcHBlbmQoY2FudmFzKTtcbiAgICAgIH0gZWxzZSBpZiAoZmlyc3RDaGlsZC5ub2RlTmFtZSA9PT0gXCJDQU5WQVNcIikge1xuICAgICAgICBmaXJzdENoaWxkLnJlcGxhY2VXaXRoKGNhbnZhcyk7XG4gICAgICB9IGVsc2UgaWYgKCFmaXJzdENoaWxkLmNsYXNzTGlzdC5jb250YWlucyhcImFubm90YXRpb25Db250ZW50XCIpKSB7XG4gICAgICAgIGZpcnN0Q2hpbGQuYmVmb3JlKGNhbnZhcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaXJzdENoaWxkLmFmdGVyKGNhbnZhcyk7XG4gICAgICB9XG4gICAgICBjb25zdCBlZGl0YWJsZUFubm90YXRpb24gPSB0aGlzLiNlZGl0YWJsZUFubm90YXRpb25zLmdldChpZCk7XG4gICAgICBpZiAoIWVkaXRhYmxlQW5ub3RhdGlvbikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlZGl0YWJsZUFubm90YXRpb24uX2hhc05vQ2FudmFzKSB7XG4gICAgICAgIHRoaXMuX2Fubm90YXRpb25FZGl0b3JVSU1hbmFnZXI/LnNldE1pc3NpbmdDYW52YXMoaWQsIGVsZW1lbnQuaWQsIGNhbnZhcyk7XG4gICAgICAgIGVkaXRhYmxlQW5ub3RhdGlvbi5faGFzTm9DYW52YXMgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkaXRhYmxlQW5ub3RhdGlvbi5jYW52YXMgPSBjYW52YXM7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2Fubm90YXRpb25DYW52YXNNYXAuY2xlYXIoKTtcbiAgfVxuICBnZXRFZGl0YWJsZUFubm90YXRpb25zKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuI2VkaXRhYmxlQW5ub3RhdGlvbnMudmFsdWVzKCkpO1xuICB9XG4gIGdldEVkaXRhYmxlQW5ub3RhdGlvbihpZCkge1xuICAgIHJldHVybiB0aGlzLiNlZGl0YWJsZUFubm90YXRpb25zLmdldChpZCk7XG4gIH1cbiAgYWRkRmFrZUFubm90YXRpb24oZWRpdG9yKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGl2XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgaWQsXG4gICAgICByb3RhdGlvblxuICAgIH0gPSBlZGl0b3I7XG4gICAgY29uc3QgZWxlbWVudCA9IG5ldyBFZGl0b3JBbm5vdGF0aW9uRWxlbWVudCh7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIGlkLFxuICAgICAgICByZWN0OiBlZGl0b3IuZ2V0UERGUmVjdCgpLFxuICAgICAgICByb3RhdGlvblxuICAgICAgfSxcbiAgICAgIGVkaXRvcixcbiAgICAgIGxheWVyOiBkaXYsXG4gICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICBlbmFibGVDb21tZW50OiAhIXRoaXMuX2NvbW1lbnRNYW5hZ2VyLFxuICAgICAgbGlua1NlcnZpY2U6IHRoaXMuI2xpbmtTZXJ2aWNlLFxuICAgICAgYW5ub3RhdGlvblN0b3JhZ2U6IHRoaXMuI2Fubm90YXRpb25TdG9yYWdlXG4gICAgfSk7XG4gICAgY29uc3QgaHRtbEVsZW1lbnQgPSBlbGVtZW50LnJlbmRlcigpO1xuICAgIGRpdi5hcHBlbmQoaHRtbEVsZW1lbnQpO1xuICAgIHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyPy5tb3ZlRWxlbWVudEluRE9NKGRpdiwgaHRtbEVsZW1lbnQsIGh0bWxFbGVtZW50LCBmYWxzZSk7XG4gICAgZWxlbWVudC5jcmVhdGVPclVwZGF0ZVBvcHVwKCk7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgc3RhdGljIGdldCBfZGVmYXVsdEJvcmRlclN0eWxlKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfZGVmYXVsdEJvcmRlclN0eWxlXCIsIE9iamVjdC5mcmVlemUoe1xuICAgICAgd2lkdGg6IDEsXG4gICAgICByYXdXaWR0aDogMSxcbiAgICAgIHN0eWxlOiBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLlNPTElELFxuICAgICAgZGFzaEFycmF5OiBbM10sXG4gICAgICBob3Jpem9udGFsQ29ybmVyUmFkaXVzOiAwLFxuICAgICAgdmVydGljYWxDb3JuZXJSYWRpdXM6IDBcbiAgICB9KSk7XG4gIH1cbn1cbmNvbnN0IEVPTF9QQVRURVJOID0gL1xcclxcbj98XFxuL2c7XG5jbGFzcyBGcmVlVGV4dEVkaXRvciBleHRlbmRzIEFubm90YXRpb25FZGl0b3Ige1xuICAjY29udGVudCA9IFwiXCI7XG4gICNlZGl0b3JEaXZJZCA9IGAke3RoaXMuaWR9LWVkaXRvcmA7XG4gICNlZGl0TW9kZUFDID0gbnVsbDtcbiAgI2ZvbnRTaXplO1xuICBfY29sb3JQaWNrZXIgPSBudWxsO1xuICBzdGF0aWMgX2ZyZWVUZXh0RGVmYXVsdENvbnRlbnQgPSBcIlwiO1xuICBzdGF0aWMgX2ludGVybmFsUGFkZGluZyA9IDA7XG4gIHN0YXRpYyBfZGVmYXVsdENvbG9yID0gbnVsbDtcbiAgc3RhdGljIF9kZWZhdWx0Rm9udFNpemUgPSAxMDtcbiAgc3RhdGljIGdldCBfa2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIGNvbnN0IHByb3RvID0gRnJlZVRleHRFZGl0b3IucHJvdG90eXBlO1xuICAgIGNvbnN0IGFycm93Q2hlY2tlciA9IChzZWxmMikgPT4gc2VsZjIuaXNFbXB0eSgpO1xuICAgIGNvbnN0IHNtYWxsID0gQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlci5UUkFOU0xBVEVfU01BTEw7XG4gICAgY29uc3QgYmlnID0gQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlci5UUkFOU0xBVEVfQklHO1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfa2V5Ym9hcmRNYW5hZ2VyXCIsIG5ldyBLZXlib2FyZE1hbmFnZXIoW1tbXCJjdHJsK3NcIiwgXCJtYWMrbWV0YStzXCIsIFwiY3RybCtwXCIsIFwibWFjK21ldGErcFwiXSwgcHJvdG8uY29tbWl0T3JSZW1vdmUsIHtcbiAgICAgIGJ1YmJsZXM6IHRydWVcbiAgICB9XSwgW1tcImN0cmwrRW50ZXJcIiwgXCJtYWMrbWV0YStFbnRlclwiLCBcIkVzY2FwZVwiLCBcIm1hYytFc2NhcGVcIl0sIHByb3RvLmNvbW1pdE9yUmVtb3ZlXSwgW1tcIkFycm93TGVmdFwiLCBcIm1hYytBcnJvd0xlZnRcIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogWy1zbWFsbCwgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dMZWZ0XCIsIFwibWFjK3NoaWZ0K0Fycm93TGVmdFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbLWJpZywgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcIkFycm93UmlnaHRcIiwgXCJtYWMrQXJyb3dSaWdodFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbc21hbGwsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93UmlnaHRcIiwgXCJtYWMrc2hpZnQrQXJyb3dSaWdodFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbYmlnLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiQXJyb3dVcFwiLCBcIm1hYytBcnJvd1VwXCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFswLCAtc21hbGxdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93VXBcIiwgXCJtYWMrc2hpZnQrQXJyb3dVcFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbMCwgLWJpZ10sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcIkFycm93RG93blwiLCBcIm1hYytBcnJvd0Rvd25cIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogWzAsIHNtYWxsXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd0Rvd25cIiwgXCJtYWMrc2hpZnQrQXJyb3dEb3duXCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFswLCBiaWddLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV1dKSk7XG4gIH1cbiAgc3RhdGljIF90eXBlID0gXCJmcmVldGV4dFwiO1xuICBzdGF0aWMgX2VkaXRvclR5cGUgPSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5GUkVFVEVYVDtcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ucGFyYW1zLFxuICAgICAgbmFtZTogXCJmcmVlVGV4dEVkaXRvclwiXG4gICAgfSk7XG4gICAgdGhpcy5jb2xvciA9IHBhcmFtcy5jb2xvciB8fCBGcmVlVGV4dEVkaXRvci5fZGVmYXVsdENvbG9yIHx8IEFubm90YXRpb25FZGl0b3IuX2RlZmF1bHRMaW5lQ29sb3I7XG4gICAgdGhpcy4jZm9udFNpemUgPSBwYXJhbXMuZm9udFNpemUgfHwgRnJlZVRleHRFZGl0b3IuX2RlZmF1bHRGb250U2l6ZTtcbiAgICBpZiAoIXRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmExMXlBbGVydChcInBkZmpzLWVkaXRvci1mcmVldGV4dC1hZGRlZC1hbGVydFwiKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKSB7XG4gICAgQW5ub3RhdGlvbkVkaXRvci5pbml0aWFsaXplKGwxMG4sIHVpTWFuYWdlcik7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG4gICAgdGhpcy5faW50ZXJuYWxQYWRkaW5nID0gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiLS1mcmVldGV4dC1wYWRkaW5nXCIpKTtcbiAgfVxuICBzdGF0aWMgdXBkYXRlRGVmYXVsdFBhcmFtcyh0eXBlLCB2YWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9TSVpFOlxuICAgICAgICBGcmVlVGV4dEVkaXRvci5fZGVmYXVsdEZvbnRTaXplID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9DT0xPUjpcbiAgICAgICAgRnJlZVRleHRFZGl0b3IuX2RlZmF1bHRDb2xvciA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdXBkYXRlUGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX1NJWkU6XG4gICAgICAgIHRoaXMuI3VwZGF0ZUZvbnRTaXplKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX0NPTE9SOlxuICAgICAgICB0aGlzLiN1cGRhdGVDb2xvcih2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0IGRlZmF1bHRQcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIFtbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfU0laRSwgRnJlZVRleHRFZGl0b3IuX2RlZmF1bHRGb250U2l6ZV0sIFtBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9DT0xPUiwgRnJlZVRleHRFZGl0b3IuX2RlZmF1bHRDb2xvciB8fCBBbm5vdGF0aW9uRWRpdG9yLl9kZWZhdWx0TGluZUNvbG9yXV07XG4gIH1cbiAgZ2V0IHByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW1tBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9TSVpFLCB0aGlzLiNmb250U2l6ZV0sIFtBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9DT0xPUiwgdGhpcy5jb2xvcl1dO1xuICB9XG4gIGdldCB0b29sYmFyQnV0dG9ucygpIHtcbiAgICB0aGlzLl9jb2xvclBpY2tlciB8fD0gbmV3IEJhc2ljQ29sb3JQaWNrZXIodGhpcyk7XG4gICAgcmV0dXJuIFtbXCJjb2xvclBpY2tlclwiLCB0aGlzLl9jb2xvclBpY2tlcl1dO1xuICB9XG4gIGdldCBjb2xvclR5cGUoKSB7XG4gICAgcmV0dXJuIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX0NPTE9SO1xuICB9XG4gICN1cGRhdGVGb250U2l6ZShmb250U2l6ZSkge1xuICAgIGNvbnN0IHNldEZvbnRzaXplID0gKHNpemUpID0+IHtcbiAgICAgIHRoaXMuZWRpdG9yRGl2LnN0eWxlLmZvbnRTaXplID0gYGNhbGMoJHtzaXplfXB4ICogdmFyKC0tdG90YWwtc2NhbGUtZmFjdG9yKSlgO1xuICAgICAgdGhpcy50cmFuc2xhdGUoMCwgLShzaXplIC0gdGhpcy4jZm9udFNpemUpICogdGhpcy5wYXJlbnRTY2FsZSk7XG4gICAgICB0aGlzLiNmb250U2l6ZSA9IHNpemU7XG4gICAgICB0aGlzLiNzZXRFZGl0b3JEaW1lbnNpb25zKCk7XG4gICAgfTtcbiAgICBjb25zdCBzYXZlZEZvbnRzaXplID0gdGhpcy4jZm9udFNpemU7XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6IHNldEZvbnRzaXplLmJpbmQodGhpcywgZm9udFNpemUpLFxuICAgICAgdW5kbzogc2V0Rm9udHNpemUuYmluZCh0aGlzLCBzYXZlZEZvbnRzaXplKSxcbiAgICAgIHBvc3Q6IHRoaXMuX3VpTWFuYWdlci51cGRhdGVVSS5iaW5kKHRoaXMuX3VpTWFuYWdlciwgdGhpcyksXG4gICAgICBtdXN0RXhlYzogdHJ1ZSxcbiAgICAgIHR5cGU6IEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX1NJWkUsXG4gICAgICBvdmVyd3JpdGVJZlNhbWVUeXBlOiB0cnVlLFxuICAgICAga2VlcFVuZG86IHRydWVcbiAgICB9KTtcbiAgfVxuICBvblVwZGF0ZWRDb2xvcigpIHtcbiAgICB0aGlzLmVkaXRvckRpdi5zdHlsZS5jb2xvciA9IHRoaXMuY29sb3I7XG4gICAgdGhpcy5fY29sb3JQaWNrZXI/LnVwZGF0ZSh0aGlzLmNvbG9yKTtcbiAgICBzdXBlci5vblVwZGF0ZWRDb2xvcigpO1xuICB9XG4gICN1cGRhdGVDb2xvcihjb2xvcikge1xuICAgIGNvbnN0IHNldENvbG9yID0gKGNvbCkgPT4ge1xuICAgICAgdGhpcy5jb2xvciA9IGNvbDtcbiAgICAgIHRoaXMub25VcGRhdGVkQ29sb3IoKTtcbiAgICB9O1xuICAgIGNvbnN0IHNhdmVkQ29sb3IgPSB0aGlzLmNvbG9yO1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiBzZXRDb2xvci5iaW5kKHRoaXMsIGNvbG9yKSxcbiAgICAgIHVuZG86IHNldENvbG9yLmJpbmQodGhpcywgc2F2ZWRDb2xvciksXG4gICAgICBwb3N0OiB0aGlzLl91aU1hbmFnZXIudXBkYXRlVUkuYmluZCh0aGlzLl91aU1hbmFnZXIsIHRoaXMpLFxuICAgICAgbXVzdEV4ZWM6IHRydWUsXG4gICAgICB0eXBlOiBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9DT0xPUixcbiAgICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGU6IHRydWUsXG4gICAgICBrZWVwVW5kbzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIF90cmFuc2xhdGVFbXB0eSh4LCB5KSB7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycyh4LCB5LCB0cnVlKTtcbiAgfVxuICBnZXRJbml0aWFsVHJhbnNsYXRpb24oKSB7XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLnBhcmVudFNjYWxlO1xuICAgIHJldHVybiBbLUZyZWVUZXh0RWRpdG9yLl9pbnRlcm5hbFBhZGRpbmcgKiBzY2FsZSwgLShGcmVlVGV4dEVkaXRvci5faW50ZXJuYWxQYWRkaW5nICsgdGhpcy4jZm9udFNpemUpICogc2NhbGVdO1xuICB9XG4gIHJlYnVpbGQoKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5yZWJ1aWxkKCk7XG4gICAgaWYgKHRoaXMuZGl2ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHRoaXMucGFyZW50LmFkZCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgZW5hYmxlRWRpdE1vZGUoKSB7XG4gICAgaWYgKCFzdXBlci5lbmFibGVFZGl0TW9kZSgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMub3ZlcmxheURpdi5jbGFzc0xpc3QucmVtb3ZlKFwiZW5hYmxlZFwiKTtcbiAgICB0aGlzLmVkaXRvckRpdi5jb250ZW50RWRpdGFibGUgPSB0cnVlO1xuICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5kaXYucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIpO1xuICAgIHRoaXMuI2VkaXRNb2RlQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5fdWlNYW5hZ2VyLmNvbWJpbmVkU2lnbmFsKHRoaXMuI2VkaXRNb2RlQUMpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuZWRpdG9yRGl2S2V5ZG93bi5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLmVkaXRvckRpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy5lZGl0b3JEaXZGb2N1cy5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLmVkaXRvckRpdi5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLmVkaXRvckRpdkJsdXIuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy5lZGl0b3JEaXYuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHRoaXMuZWRpdG9yRGl2SW5wdXQuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy5lZGl0b3JEaXYuYWRkRXZlbnRMaXN0ZW5lcihcInBhc3RlXCIsIHRoaXMuZWRpdG9yRGl2UGFzdGUuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZGlzYWJsZUVkaXRNb2RlKCkge1xuICAgIGlmICghc3VwZXIuZGlzYWJsZUVkaXRNb2RlKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5vdmVybGF5RGl2LmNsYXNzTGlzdC5hZGQoXCJlbmFibGVkXCIpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmNvbnRlbnRFZGl0YWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuZGl2LnNldEF0dHJpYnV0ZShcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiLCB0aGlzLiNlZGl0b3JEaXZJZCk7XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSB0cnVlO1xuICAgIHRoaXMuI2VkaXRNb2RlQUM/LmFib3J0KCk7XG4gICAgdGhpcy4jZWRpdE1vZGVBQyA9IG51bGw7XG4gICAgdGhpcy5kaXYuZm9jdXMoe1xuICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuaXNFZGl0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5wYXJlbnQuZGl2LmNsYXNzTGlzdC5hZGQoXCJmcmVldGV4dEVkaXRpbmdcIik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZm9jdXNpbihldmVudCkge1xuICAgIGlmICghdGhpcy5fZm9jdXNFdmVudHNBbGxvd2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLmZvY3VzaW4oZXZlbnQpO1xuICAgIGlmIChldmVudC50YXJnZXQgIT09IHRoaXMuZWRpdG9yRGl2KSB7XG4gICAgICB0aGlzLmVkaXRvckRpdi5mb2N1cygpO1xuICAgIH1cbiAgfVxuICBvbmNlQWRkZWQoZm9jdXMpIHtcbiAgICBpZiAodGhpcy53aWR0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgaWYgKGZvY3VzKSB7XG4gICAgICB0aGlzLmVkaXRvckRpdi5mb2N1cygpO1xuICAgIH1cbiAgICBpZiAodGhpcy5faW5pdGlhbE9wdGlvbnM/LmlzQ2VudGVyZWQpIHtcbiAgICAgIHRoaXMuY2VudGVyKCk7XG4gICAgfVxuICAgIHRoaXMuX2luaXRpYWxPcHRpb25zID0gbnVsbDtcbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiAhdGhpcy5lZGl0b3JEaXYgfHwgdGhpcy5lZGl0b3JEaXYuaW5uZXJUZXh0LnRyaW0oKSA9PT0gXCJcIjtcbiAgfVxuICByZW1vdmUoKSB7XG4gICAgdGhpcy5pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50LnNldEVkaXRpbmdTdGF0ZSh0cnVlKTtcbiAgICAgIHRoaXMucGFyZW50LmRpdi5jbGFzc0xpc3QuYWRkKFwiZnJlZXRleHRFZGl0aW5nXCIpO1xuICAgIH1cbiAgICBzdXBlci5yZW1vdmUoKTtcbiAgfVxuICAjZXh0cmFjdFRleHQoKSB7XG4gICAgY29uc3QgYnVmZmVyID0gW107XG4gICAgdGhpcy5lZGl0b3JEaXYubm9ybWFsaXplKCk7XG4gICAgbGV0IHByZXZDaGlsZCA9IG51bGw7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmVkaXRvckRpdi5jaGlsZE5vZGVzKSB7XG4gICAgICBpZiAocHJldkNoaWxkPy5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUgJiYgY2hpbGQubm9kZU5hbWUgPT09IFwiQlJcIikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJ1ZmZlci5wdXNoKEZyZWVUZXh0RWRpdG9yLiNnZXROb2RlQ29udGVudChjaGlsZCkpO1xuICAgICAgcHJldkNoaWxkID0gY2hpbGQ7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXIuam9pbihcIlxcblwiKTtcbiAgfVxuICAjc2V0RWRpdG9yRGltZW5zaW9ucygpIHtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgbGV0IHJlY3Q7XG4gICAgaWYgKHRoaXMuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICByZWN0ID0gdGhpcy5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY3VycmVudExheWVyLFxuICAgICAgICBkaXZcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgY29uc3Qgc2F2ZWREaXNwbGF5ID0gZGl2LnN0eWxlLmRpc3BsYXk7XG4gICAgICBjb25zdCBzYXZlZFZpc2liaWxpdHkgPSBkaXYuY2xhc3NMaXN0LmNvbnRhaW5zKFwiaGlkZGVuXCIpO1xuICAgICAgZGl2LmNsYXNzTGlzdC5yZW1vdmUoXCJoaWRkZW5cIik7XG4gICAgICBkaXYuc3R5bGUuZGlzcGxheSA9IFwiaGlkZGVuXCI7XG4gICAgICBjdXJyZW50TGF5ZXIuZGl2LmFwcGVuZCh0aGlzLmRpdik7XG4gICAgICByZWN0ID0gZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgZGl2LnJlbW92ZSgpO1xuICAgICAgZGl2LnN0eWxlLmRpc3BsYXkgPSBzYXZlZERpc3BsYXk7XG4gICAgICBkaXYuY2xhc3NMaXN0LnRvZ2dsZShcImhpZGRlblwiLCBzYXZlZFZpc2liaWxpdHkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5yb3RhdGlvbiAlIDE4MCA9PT0gdGhpcy5wYXJlbnRSb3RhdGlvbiAlIDE4MCkge1xuICAgICAgdGhpcy53aWR0aCA9IHJlY3Qud2lkdGggLyBwYXJlbnRXaWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gcmVjdC5oZWlnaHQgLyBwYXJlbnRIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2lkdGggPSByZWN0LmhlaWdodCAvIHBhcmVudFdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSByZWN0LndpZHRoIC8gcGFyZW50SGVpZ2h0O1xuICAgIH1cbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gIH1cbiAgY29tbWl0KCkge1xuICAgIGlmICghdGhpcy5pc0luRWRpdE1vZGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5jb21taXQoKTtcbiAgICB0aGlzLmRpc2FibGVFZGl0TW9kZSgpO1xuICAgIGNvbnN0IHNhdmVkVGV4dCA9IHRoaXMuI2NvbnRlbnQ7XG4gICAgY29uc3QgbmV3VGV4dCA9IHRoaXMuI2NvbnRlbnQgPSB0aGlzLiNleHRyYWN0VGV4dCgpLnRyaW1FbmQoKTtcbiAgICBpZiAoc2F2ZWRUZXh0ID09PSBuZXdUZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNldFRleHQgPSAodGV4dCkgPT4ge1xuICAgICAgdGhpcy4jY29udGVudCA9IHRleHQ7XG4gICAgICBpZiAoIXRleHQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy4jc2V0Q29udGVudCgpO1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLnJlYnVpbGQodGhpcyk7XG4gICAgICB0aGlzLiNzZXRFZGl0b3JEaW1lbnNpb25zKCk7XG4gICAgfTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogKCkgPT4ge1xuICAgICAgICBzZXRUZXh0KG5ld1RleHQpO1xuICAgICAgfSxcbiAgICAgIHVuZG86ICgpID0+IHtcbiAgICAgICAgc2V0VGV4dChzYXZlZFRleHQpO1xuICAgICAgfSxcbiAgICAgIG11c3RFeGVjOiBmYWxzZVxuICAgIH0pO1xuICAgIHRoaXMuI3NldEVkaXRvckRpbWVuc2lvbnMoKTtcbiAgfVxuICBzaG91bGRHZXRLZXlib2FyZEV2ZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5pc0luRWRpdE1vZGUoKTtcbiAgfVxuICBlbnRlckluRWRpdE1vZGUoKSB7XG4gICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmZvY3VzKCk7XG4gIH1cbiAga2V5ZG93bihldmVudCkge1xuICAgIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMuZGl2ICYmIGV2ZW50LmtleSA9PT0gXCJFbnRlclwiKSB7XG4gICAgICB0aGlzLmVudGVySW5FZGl0TW9kZSgpO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbiAgZWRpdG9yRGl2S2V5ZG93bihldmVudCkge1xuICAgIEZyZWVUZXh0RWRpdG9yLl9rZXlib2FyZE1hbmFnZXIuZXhlYyh0aGlzLCBldmVudCk7XG4gIH1cbiAgZWRpdG9yRGl2Rm9jdXMoZXZlbnQpIHtcbiAgICB0aGlzLmlzRWRpdGluZyA9IHRydWU7XG4gIH1cbiAgZWRpdG9yRGl2Qmx1cihldmVudCkge1xuICAgIHRoaXMuaXNFZGl0aW5nID0gZmFsc2U7XG4gIH1cbiAgZWRpdG9yRGl2SW5wdXQoZXZlbnQpIHtcbiAgICB0aGlzLnBhcmVudC5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImZyZWV0ZXh0RWRpdGluZ1wiLCB0aGlzLmlzRW1wdHkoKSk7XG4gIH1cbiAgZGlzYWJsZUVkaXRpbmcoKSB7XG4gICAgdGhpcy5lZGl0b3JEaXYuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImNvbW1lbnRcIik7XG4gICAgdGhpcy5lZGl0b3JEaXYucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1tdWx0aWxpbmVcIik7XG4gIH1cbiAgZW5hYmxlRWRpdGluZygpIHtcbiAgICB0aGlzLmVkaXRvckRpdi5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwidGV4dGJveFwiKTtcbiAgICB0aGlzLmVkaXRvckRpdi5zZXRBdHRyaWJ1dGUoXCJhcmlhLW11bHRpbGluZVwiLCB0cnVlKTtcbiAgfVxuICBnZXQgY2FuQ2hhbmdlQ29udGVudCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXY7XG4gICAgfVxuICAgIGxldCBiYXNlWCwgYmFzZVk7XG4gICAgaWYgKHRoaXMuX2lzQ29weSB8fCB0aGlzLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIGJhc2VYID0gdGhpcy54O1xuICAgICAgYmFzZVkgPSB0aGlzLnk7XG4gICAgfVxuICAgIHN1cGVyLnJlbmRlcigpO1xuICAgIHRoaXMuZWRpdG9yRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLmVkaXRvckRpdi5jbGFzc05hbWUgPSBcImludGVybmFsXCI7XG4gICAgdGhpcy5lZGl0b3JEaXYuc2V0QXR0cmlidXRlKFwiaWRcIiwgdGhpcy4jZWRpdG9yRGl2SWQpO1xuICAgIHRoaXMuZWRpdG9yRGl2LnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLWZyZWUtdGV4dDJcIik7XG4gICAgdGhpcy5lZGl0b3JEaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWF0dHJzXCIsIFwiZGVmYXVsdC1jb250ZW50XCIpO1xuICAgIHRoaXMuZW5hYmxlRWRpdGluZygpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmNvbnRlbnRFZGl0YWJsZSA9IHRydWU7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gdGhpcy5lZGl0b3JEaXY7XG4gICAgc3R5bGUuZm9udFNpemUgPSBgY2FsYygke3RoaXMuI2ZvbnRTaXplfXB4ICogdmFyKC0tdG90YWwtc2NhbGUtZmFjdG9yKSlgO1xuICAgIHN0eWxlLmNvbG9yID0gdGhpcy5jb2xvcjtcbiAgICB0aGlzLmRpdi5hcHBlbmQodGhpcy5lZGl0b3JEaXYpO1xuICAgIHRoaXMub3ZlcmxheURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5vdmVybGF5RGl2LmNsYXNzTGlzdC5hZGQoXCJvdmVybGF5XCIsIFwiZW5hYmxlZFwiKTtcbiAgICB0aGlzLmRpdi5hcHBlbmQodGhpcy5vdmVybGF5RGl2KTtcbiAgICBpZiAodGhpcy5faXNDb3B5IHx8IHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgICAgaWYgKHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcG9zaXRpb25cbiAgICAgICAgfSA9IHRoaXMuX2luaXRpYWxEYXRhO1xuICAgICAgICBsZXQgW3R4LCB0eV0gPSB0aGlzLmdldEluaXRpYWxUcmFuc2xhdGlvbigpO1xuICAgICAgICBbdHgsIHR5XSA9IHRoaXMucGFnZVRyYW5zbGF0aW9uVG9TY3JlZW4odHgsIHR5KTtcbiAgICAgICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgICAgICBjb25zdCBbcGFnZVgsIHBhZ2VZXSA9IHRoaXMucGFnZVRyYW5zbGF0aW9uO1xuICAgICAgICBsZXQgcG9zWCwgcG9zWTtcbiAgICAgICAgc3dpdGNoICh0aGlzLnJvdGF0aW9uKSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcG9zWCA9IGJhc2VYICsgKHBvc2l0aW9uWzBdIC0gcGFnZVgpIC8gcGFnZVdpZHRoO1xuICAgICAgICAgICAgcG9zWSA9IGJhc2VZICsgdGhpcy5oZWlnaHQgLSAocG9zaXRpb25bMV0gLSBwYWdlWSkgLyBwYWdlSGVpZ2h0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA5MDpcbiAgICAgICAgICAgIHBvc1ggPSBiYXNlWCArIChwb3NpdGlvblswXSAtIHBhZ2VYKSAvIHBhZ2VXaWR0aDtcbiAgICAgICAgICAgIHBvc1kgPSBiYXNlWSAtIChwb3NpdGlvblsxXSAtIHBhZ2VZKSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgICAgICBbdHgsIHR5XSA9IFt0eSwgLXR4XTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTgwOlxuICAgICAgICAgICAgcG9zWCA9IGJhc2VYIC0gdGhpcy53aWR0aCArIChwb3NpdGlvblswXSAtIHBhZ2VYKSAvIHBhZ2VXaWR0aDtcbiAgICAgICAgICAgIHBvc1kgPSBiYXNlWSAtIChwb3NpdGlvblsxXSAtIHBhZ2VZKSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgICAgICBbdHgsIHR5XSA9IFstdHgsIC10eV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI3MDpcbiAgICAgICAgICAgIHBvc1ggPSBiYXNlWCArIChwb3NpdGlvblswXSAtIHBhZ2VYIC0gdGhpcy5oZWlnaHQgKiBwYWdlSGVpZ2h0KSAvIHBhZ2VXaWR0aDtcbiAgICAgICAgICAgIHBvc1kgPSBiYXNlWSArIChwb3NpdGlvblsxXSAtIHBhZ2VZIC0gdGhpcy53aWR0aCAqIHBhZ2VXaWR0aCkgLyBwYWdlSGVpZ2h0O1xuICAgICAgICAgICAgW3R4LCB0eV0gPSBbLXR5LCB0eF07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldEF0KHBvc1ggKiBwYXJlbnRXaWR0aCwgcG9zWSAqIHBhcmVudEhlaWdodCwgdHgsIHR5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX21vdmVBZnRlclBhc3RlKGJhc2VYLCBiYXNlWSk7XG4gICAgICB9XG4gICAgICB0aGlzLiNzZXRDb250ZW50KCk7XG4gICAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IHRydWU7XG4gICAgICB0aGlzLmVkaXRvckRpdi5jb250ZW50RWRpdGFibGUgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faXNEcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZWRpdG9yRGl2LmNvbnRlbnRFZGl0YWJsZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRpdjtcbiAgfVxuICBzdGF0aWMgI2dldE5vZGVDb250ZW50KG5vZGUpIHtcbiAgICByZXR1cm4gKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFID8gbm9kZS5ub2RlVmFsdWUgOiBub2RlLmlubmVyVGV4dCkucmVwbGFjZUFsbChFT0xfUEFUVEVSTiwgXCJcIik7XG4gIH1cbiAgZWRpdG9yRGl2UGFzdGUoZXZlbnQpIHtcbiAgICBjb25zdCBjbGlwYm9hcmREYXRhID0gZXZlbnQuY2xpcGJvYXJkRGF0YSB8fCB3aW5kb3cuY2xpcGJvYXJkRGF0YTtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlc1xuICAgIH0gPSBjbGlwYm9hcmREYXRhO1xuICAgIGlmICh0eXBlcy5sZW5ndGggPT09IDEgJiYgdHlwZXNbMF0gPT09IFwidGV4dC9wbGFpblwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3QgcGFzdGUgPSBGcmVlVGV4dEVkaXRvci4jZGVzZXJpYWxpemVDb250ZW50KGNsaXBib2FyZERhdGEuZ2V0RGF0YShcInRleHRcIikgfHwgXCJcIikucmVwbGFjZUFsbChFT0xfUEFUVEVSTiwgXCJcXG5cIik7XG4gICAgaWYgKCFwYXN0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCFzZWxlY3Rpb24ucmFuZ2VDb3VudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVkaXRvckRpdi5ub3JtYWxpemUoKTtcbiAgICBzZWxlY3Rpb24uZGVsZXRlRnJvbURvY3VtZW50KCk7XG4gICAgY29uc3QgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcbiAgICBpZiAoIXBhc3RlLmluY2x1ZGVzKFwiXFxuXCIpKSB7XG4gICAgICByYW5nZS5pbnNlcnROb2RlKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHBhc3RlKSk7XG4gICAgICB0aGlzLmVkaXRvckRpdi5ub3JtYWxpemUoKTtcbiAgICAgIHNlbGVjdGlvbi5jb2xsYXBzZVRvU3RhcnQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgc3RhcnRDb250YWluZXIsXG4gICAgICBzdGFydE9mZnNldFxuICAgIH0gPSByYW5nZTtcbiAgICBjb25zdCBidWZmZXJCZWZvcmUgPSBbXTtcbiAgICBjb25zdCBidWZmZXJBZnRlciA9IFtdO1xuICAgIGlmIChzdGFydENvbnRhaW5lci5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IHN0YXJ0Q29udGFpbmVyLnBhcmVudEVsZW1lbnQ7XG4gICAgICBidWZmZXJBZnRlci5wdXNoKHN0YXJ0Q29udGFpbmVyLm5vZGVWYWx1ZS5zbGljZShzdGFydE9mZnNldCkucmVwbGFjZUFsbChFT0xfUEFUVEVSTiwgXCJcIikpO1xuICAgICAgaWYgKHBhcmVudCAhPT0gdGhpcy5lZGl0b3JEaXYpIHtcbiAgICAgICAgbGV0IGJ1ZmZlciA9IGJ1ZmZlckJlZm9yZTtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmVkaXRvckRpdi5jaGlsZE5vZGVzKSB7XG4gICAgICAgICAgaWYgKGNoaWxkID09PSBwYXJlbnQpIHtcbiAgICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlckFmdGVyO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJ1ZmZlci5wdXNoKEZyZWVUZXh0RWRpdG9yLiNnZXROb2RlQ29udGVudChjaGlsZCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBidWZmZXJCZWZvcmUucHVzaChzdGFydENvbnRhaW5lci5ub2RlVmFsdWUuc2xpY2UoMCwgc3RhcnRPZmZzZXQpLnJlcGxhY2VBbGwoRU9MX1BBVFRFUk4sIFwiXCIpKTtcbiAgICB9IGVsc2UgaWYgKHN0YXJ0Q29udGFpbmVyID09PSB0aGlzLmVkaXRvckRpdikge1xuICAgICAgbGV0IGJ1ZmZlciA9IGJ1ZmZlckJlZm9yZTtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5lZGl0b3JEaXYuY2hpbGROb2Rlcykge1xuICAgICAgICBpZiAoaSsrID09PSBzdGFydE9mZnNldCkge1xuICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlckFmdGVyO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlci5wdXNoKEZyZWVUZXh0RWRpdG9yLiNnZXROb2RlQ29udGVudChjaGlsZCkpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNjb250ZW50ID0gYCR7YnVmZmVyQmVmb3JlLmpvaW4oXCJcXG5cIil9JHtwYXN0ZX0ke2J1ZmZlckFmdGVyLmpvaW4oXCJcXG5cIil9YDtcbiAgICB0aGlzLiNzZXRDb250ZW50KCk7XG4gICAgY29uc3QgbmV3UmFuZ2UgPSBuZXcgUmFuZ2UoKTtcbiAgICBsZXQgYmVmb3JlTGVuZ3RoID0gTWF0aC5zdW1QcmVjaXNlKGJ1ZmZlckJlZm9yZS5tYXAoKGxpbmUpID0+IGxpbmUubGVuZ3RoKSk7XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBmaXJzdENoaWxkXG4gICAgfSBvZiB0aGlzLmVkaXRvckRpdi5jaGlsZE5vZGVzKSB7XG4gICAgICBpZiAoZmlyc3RDaGlsZC5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZmlyc3RDaGlsZC5ub2RlVmFsdWUubGVuZ3RoO1xuICAgICAgICBpZiAoYmVmb3JlTGVuZ3RoIDw9IGxlbmd0aCkge1xuICAgICAgICAgIG5ld1JhbmdlLnNldFN0YXJ0KGZpcnN0Q2hpbGQsIGJlZm9yZUxlbmd0aCk7XG4gICAgICAgICAgbmV3UmFuZ2Uuc2V0RW5kKGZpcnN0Q2hpbGQsIGJlZm9yZUxlbmd0aCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYmVmb3JlTGVuZ3RoIC09IGxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIHNlbGVjdGlvbi5hZGRSYW5nZShuZXdSYW5nZSk7XG4gIH1cbiAgI3NldENvbnRlbnQoKSB7XG4gICAgdGhpcy5lZGl0b3JEaXYucmVwbGFjZUNoaWxkcmVuKCk7XG4gICAgaWYgKCF0aGlzLiNjb250ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgbGluZSBvZiB0aGlzLiNjb250ZW50LnNwbGl0KFwiXFxuXCIpKSB7XG4gICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgZGl2LmFwcGVuZChsaW5lID8gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGluZSkgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIikpO1xuICAgICAgdGhpcy5lZGl0b3JEaXYuYXBwZW5kKGRpdik7XG4gICAgfVxuICB9XG4gICNzZXJpYWxpemVDb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLiNjb250ZW50LnJlcGxhY2VBbGwoXCLCoFwiLCBcIiBcIik7XG4gIH1cbiAgc3RhdGljICNkZXNlcmlhbGl6ZUNvbnRlbnQoY29udGVudCkge1xuICAgIHJldHVybiBjb250ZW50LnJlcGxhY2VBbGwoXCIgXCIsIFwiwqBcIik7XG4gIH1cbiAgZ2V0IGNvbnRlbnREaXYoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdG9yRGl2O1xuICB9XG4gIGdldFBERlJlY3QoKSB7XG4gICAgY29uc3QgcGFkZGluZyA9IEZyZWVUZXh0RWRpdG9yLl9pbnRlcm5hbFBhZGRpbmcgKiB0aGlzLnBhcmVudFNjYWxlO1xuICAgIHJldHVybiB0aGlzLmdldFJlY3QocGFkZGluZywgcGFkZGluZyk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKSB7XG4gICAgbGV0IGluaXRpYWxEYXRhID0gbnVsbDtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEZyZWVUZXh0QW5ub3RhdGlvbkVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGRlZmF1bHRBcHBlYXJhbmNlRGF0YToge1xuICAgICAgICAgICAgZm9udFNpemUsXG4gICAgICAgICAgICBmb250Q29sb3JcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlY3QsXG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgcG9wdXBSZWYsXG4gICAgICAgICAgcmljaFRleHQsXG4gICAgICAgICAgY29udGVudHNPYmosXG4gICAgICAgICAgY3JlYXRpb25EYXRlLFxuICAgICAgICAgIG1vZGlmaWNhdGlvbkRhdGVcbiAgICAgICAgfSxcbiAgICAgICAgdGV4dENvbnRlbnQsXG4gICAgICAgIHRleHRQb3NpdGlvbixcbiAgICAgICAgcGFyZW50OiB7XG4gICAgICAgICAgcGFnZToge1xuICAgICAgICAgICAgcGFnZU51bWJlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSA9IGRhdGE7XG4gICAgICBpZiAoIXRleHRDb250ZW50IHx8IHRleHRDb250ZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGluaXRpYWxEYXRhID0gZGF0YSA9IHtcbiAgICAgICAgYW5ub3RhdGlvblR5cGU6IEFubm90YXRpb25FZGl0b3JUeXBlLkZSRUVURVhULFxuICAgICAgICBjb2xvcjogQXJyYXkuZnJvbShmb250Q29sb3IpLFxuICAgICAgICBmb250U2l6ZSxcbiAgICAgICAgdmFsdWU6IHRleHRDb250ZW50LmpvaW4oXCJcXG5cIiksXG4gICAgICAgIHBvc2l0aW9uOiB0ZXh0UG9zaXRpb24sXG4gICAgICAgIHBhZ2VJbmRleDogcGFnZU51bWJlciAtIDEsXG4gICAgICAgIHJlY3Q6IHJlY3Quc2xpY2UoMCksXG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICBhbm5vdGF0aW9uRWxlbWVudElkOiBpZCxcbiAgICAgICAgaWQsXG4gICAgICAgIGRlbGV0ZWQ6IGZhbHNlLFxuICAgICAgICBwb3B1cFJlZixcbiAgICAgICAgY29tbWVudDogY29udGVudHNPYmo/LnN0ciB8fCBudWxsLFxuICAgICAgICByaWNoVGV4dCxcbiAgICAgICAgY3JlYXRpb25EYXRlLFxuICAgICAgICBtb2RpZmljYXRpb25EYXRlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBlZGl0b3IgPSBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcik7XG4gICAgZWRpdG9yLiNmb250U2l6ZSA9IGRhdGEuZm9udFNpemU7XG4gICAgZWRpdG9yLmNvbG9yID0gVXRpbC5tYWtlSGV4Q29sb3IoLi4uZGF0YS5jb2xvcik7XG4gICAgZWRpdG9yLiNjb250ZW50ID0gRnJlZVRleHRFZGl0b3IuI2Rlc2VyaWFsaXplQ29udGVudChkYXRhLnZhbHVlKTtcbiAgICBlZGl0b3IuX2luaXRpYWxEYXRhID0gaW5pdGlhbERhdGE7XG4gICAgaWYgKGRhdGEuY29tbWVudCkge1xuICAgICAgZWRpdG9yLnNldENvbW1lbnREYXRhKGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZWRpdG9yO1xuICB9XG4gIHNlcmlhbGl6ZShpc0ZvckNvcHlpbmcgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZURlbGV0ZWQoKTtcbiAgICB9XG4gICAgY29uc3QgY29sb3IgPSBBbm5vdGF0aW9uRWRpdG9yLl9jb2xvck1hbmFnZXIuY29udmVydCh0aGlzLmlzQXR0YWNoZWRUb0RPTSA/IGdldENvbXB1dGVkU3R5bGUodGhpcy5lZGl0b3JEaXYpLmNvbG9yIDogdGhpcy5jb2xvcik7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IE9iamVjdC5hc3NpZ24oc3VwZXIuc2VyaWFsaXplKGlzRm9yQ29weWluZyksIHtcbiAgICAgIGNvbG9yLFxuICAgICAgZm9udFNpemU6IHRoaXMuI2ZvbnRTaXplLFxuICAgICAgdmFsdWU6IHRoaXMuI3NlcmlhbGl6ZUNvbnRlbnQoKVxuICAgIH0pO1xuICAgIHRoaXMuYWRkQ29tbWVudChzZXJpYWxpemVkKTtcbiAgICBpZiAoaXNGb3JDb3B5aW5nKSB7XG4gICAgICBzZXJpYWxpemVkLmlzQ29weSA9IHRydWU7XG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gICAgaWYgKHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCAmJiAhdGhpcy4jaGFzRWxlbWVudENoYW5nZWQoc2VyaWFsaXplZCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzZXJpYWxpemVkLmlkID0gdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkO1xuICAgIHJldHVybiBzZXJpYWxpemVkO1xuICB9XG4gICNoYXNFbGVtZW50Q2hhbmdlZChzZXJpYWxpemVkKSB7XG4gICAgY29uc3Qge1xuICAgICAgdmFsdWUsXG4gICAgICBmb250U2l6ZSxcbiAgICAgIGNvbG9yLFxuICAgICAgcGFnZUluZGV4XG4gICAgfSA9IHRoaXMuX2luaXRpYWxEYXRhO1xuICAgIHJldHVybiB0aGlzLmhhc0VkaXRlZENvbW1lbnQgfHwgdGhpcy5faGFzQmVlbk1vdmVkIHx8IHNlcmlhbGl6ZWQudmFsdWUgIT09IHZhbHVlIHx8IHNlcmlhbGl6ZWQuZm9udFNpemUgIT09IGZvbnRTaXplIHx8IHNlcmlhbGl6ZWQuY29sb3Iuc29tZSgoYywgaSkgPT4gYyAhPT0gY29sb3JbaV0pIHx8IHNlcmlhbGl6ZWQucGFnZUluZGV4ICE9PSBwYWdlSW5kZXg7XG4gIH1cbiAgcmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBzdXBlci5yZW5kZXJBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKTtcbiAgICBpZiAoIWNvbnRlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSBjb250ZW50O1xuICAgIHN0eWxlLmZvbnRTaXplID0gYGNhbGMoJHt0aGlzLiNmb250U2l6ZX1weCAqIHZhcigtLXRvdGFsLXNjYWxlLWZhY3RvcikpYDtcbiAgICBzdHlsZS5jb2xvciA9IHRoaXMuY29sb3I7XG4gICAgY29udGVudC5yZXBsYWNlQ2hpbGRyZW4oKTtcbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgdGhpcy4jY29udGVudC5zcGxpdChcIlxcblwiKSkge1xuICAgICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGRpdi5hcHBlbmQobGluZSA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxpbmUpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpKTtcbiAgICAgIGNvbnRlbnQuYXBwZW5kKGRpdik7XG4gICAgfVxuICAgIGFubm90YXRpb24udXBkYXRlRWRpdGVkKHtcbiAgICAgIHJlY3Q6IHRoaXMuZ2V0UERGUmVjdCgpLFxuICAgICAgcG9wdXA6IHRoaXMuX3VpTWFuYWdlci5oYXNDb21tZW50TWFuYWdlcigpIHx8IHRoaXMuaGFzRWRpdGVkQ29tbWVudCA/IHRoaXMuY29tbWVudCA6IHtcbiAgICAgICAgdGV4dDogdGhpcy4jY29udGVudFxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIHJlc2V0QW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIHN1cGVyLnJlc2V0QW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbik7XG4gICAgYW5ub3RhdGlvbi5yZXNldEVkaXRlZCgpO1xuICB9XG59XG5jbGFzcyBPdXRsaW5lIHtcbiAgc3RhdGljIFBSRUNJU0lPTiA9IDFlLTQ7XG4gIHRvU1ZHUGF0aCgpIHtcbiAgICB1bnJlYWNoYWJsZShcIkFic3RyYWN0IG1ldGhvZCBgdG9TVkdQYXRoYCBtdXN0IGJlIGltcGxlbWVudGVkLlwiKTtcbiAgfVxuICBnZXQgYm94KCkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgZ2V0dGVyIGBib3hgIG11c3QgYmUgaW1wbGVtZW50ZWQuXCIpO1xuICB9XG4gIHNlcmlhbGl6ZShfYmJveCwgX3JvdGF0aW9uKSB7XG4gICAgdW5yZWFjaGFibGUoXCJBYnN0cmFjdCBtZXRob2QgYHNlcmlhbGl6ZWAgbXVzdCBiZSBpbXBsZW1lbnRlZC5cIik7XG4gIH1cbiAgc3RhdGljIF9yZXNjYWxlKHNyYywgdHgsIHR5LCBzeCwgc3ksIGRlc3QpIHtcbiAgICBkZXN0IHx8PSBuZXcgRmxvYXQzMkFycmF5KHNyYy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHNyYy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBkZXN0W2ldID0gdHggKyBzcmNbaV0gKiBzeDtcbiAgICAgIGRlc3RbaSArIDFdID0gdHkgKyBzcmNbaSArIDFdICogc3k7XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xuICB9XG4gIHN0YXRpYyBfcmVzY2FsZUFuZFN3YXAoc3JjLCB0eCwgdHksIHN4LCBzeSwgZGVzdCkge1xuICAgIGRlc3QgfHw9IG5ldyBGbG9hdDMyQXJyYXkoc3JjLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gc3JjLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIGRlc3RbaV0gPSB0eCArIHNyY1tpICsgMV0gKiBzeDtcbiAgICAgIGRlc3RbaSArIDFdID0gdHkgKyBzcmNbaV0gKiBzeTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cbiAgc3RhdGljIF90cmFuc2xhdGUoc3JjLCB0eCwgdHksIGRlc3QpIHtcbiAgICBkZXN0IHx8PSBuZXcgRmxvYXQzMkFycmF5KHNyYy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHNyYy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBkZXN0W2ldID0gdHggKyBzcmNbaV07XG4gICAgICBkZXN0W2kgKyAxXSA9IHR5ICsgc3JjW2kgKyAxXTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cbiAgc3RhdGljIHN2Z1JvdW5kKHgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh4ICogMWU0KTtcbiAgfVxuICBzdGF0aWMgX25vcm1hbGl6ZVBvaW50KHgsIHksIHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQsIHJvdGF0aW9uKSB7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFsxIC0geSAvIHBhcmVudFdpZHRoLCB4IC8gcGFyZW50SGVpZ2h0XTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gWzEgLSB4IC8gcGFyZW50V2lkdGgsIDEgLSB5IC8gcGFyZW50SGVpZ2h0XTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gW3kgLyBwYXJlbnRXaWR0aCwgMSAtIHggLyBwYXJlbnRIZWlnaHRdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFt4IC8gcGFyZW50V2lkdGgsIHkgLyBwYXJlbnRIZWlnaHRdO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgX25vcm1hbGl6ZVBhZ2VQb2ludCh4LCB5LCByb3RhdGlvbikge1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbMSAtIHksIHhdO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbMSAtIHgsIDEgLSB5XTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gW3ksIDEgLSB4XTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBbeCwgeV07XG4gICAgfVxuICB9XG4gIHN0YXRpYyBjcmVhdGVCZXppZXJQb2ludHMoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgIHJldHVybiBbKHgxICsgNSAqIHgyKSAvIDYsICh5MSArIDUgKiB5MikgLyA2LCAoNSAqIHgyICsgeDMpIC8gNiwgKDUgKiB5MiArIHkzKSAvIDYsICh4MiArIHgzKSAvIDIsICh5MiArIHkzKSAvIDJdO1xuICB9XG59XG5jbGFzcyBGcmVlRHJhd091dGxpbmVyIHtcbiAgI2JveDtcbiAgI2JvdHRvbSA9IFtdO1xuICAjaW5uZXJNYXJnaW47XG4gICNpc0xUUjtcbiAgI3RvcCA9IFtdO1xuICAjbGFzdCA9IG5ldyBGbG9hdDMyQXJyYXkoMTgpO1xuICAjbGFzdFg7XG4gICNsYXN0WTtcbiAgI21pbjtcbiAgI21pbl9kaXN0O1xuICAjc2NhbGVGYWN0b3I7XG4gICN0aGlja25lc3M7XG4gICNwb2ludHMgPSBbXTtcbiAgc3RhdGljICNNSU5fRElTVCA9IDg7XG4gIHN0YXRpYyAjTUlOX0RJRkYgPSAyO1xuICBzdGF0aWMgI01JTiA9IEZyZWVEcmF3T3V0bGluZXIuI01JTl9ESVNUICsgRnJlZURyYXdPdXRsaW5lci4jTUlOX0RJRkY7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB4LFxuICAgIHlcbiAgfSwgYm94LCBzY2FsZUZhY3RvciwgdGhpY2tuZXNzLCBpc0xUUiwgaW5uZXJNYXJnaW4gPSAwKSB7XG4gICAgdGhpcy4jYm94ID0gYm94O1xuICAgIHRoaXMuI3RoaWNrbmVzcyA9IHRoaWNrbmVzcyAqIHNjYWxlRmFjdG9yO1xuICAgIHRoaXMuI2lzTFRSID0gaXNMVFI7XG4gICAgdGhpcy4jbGFzdC5zZXQoW05hTiwgTmFOLCBOYU4sIE5hTiwgeCwgeV0sIDYpO1xuICAgIHRoaXMuI2lubmVyTWFyZ2luID0gaW5uZXJNYXJnaW47XG4gICAgdGhpcy4jbWluX2Rpc3QgPSBGcmVlRHJhd091dGxpbmVyLiNNSU5fRElTVCAqIHNjYWxlRmFjdG9yO1xuICAgIHRoaXMuI21pbiA9IEZyZWVEcmF3T3V0bGluZXIuI01JTiAqIHNjYWxlRmFjdG9yO1xuICAgIHRoaXMuI3NjYWxlRmFjdG9yID0gc2NhbGVGYWN0b3I7XG4gICAgdGhpcy4jcG9pbnRzLnB1c2goeCwgeSk7XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gaXNOYU4odGhpcy4jbGFzdFs4XSk7XG4gIH1cbiAgI2dldExhc3RDb29yZHMoKSB7XG4gICAgY29uc3QgbGFzdFRvcCA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoNCwgNik7XG4gICAgY29uc3QgbGFzdEJvdHRvbSA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoMTYsIDE4KTtcbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSB0aGlzLiNib3g7XG4gICAgcmV0dXJuIFsodGhpcy4jbGFzdFggKyAobGFzdFRvcFswXSAtIGxhc3RCb3R0b21bMF0pIC8gMiAtIHgpIC8gd2lkdGgsICh0aGlzLiNsYXN0WSArIChsYXN0VG9wWzFdIC0gbGFzdEJvdHRvbVsxXSkgLyAyIC0geSkgLyBoZWlnaHQsICh0aGlzLiNsYXN0WCArIChsYXN0Qm90dG9tWzBdIC0gbGFzdFRvcFswXSkgLyAyIC0geCkgLyB3aWR0aCwgKHRoaXMuI2xhc3RZICsgKGxhc3RCb3R0b21bMV0gLSBsYXN0VG9wWzFdKSAvIDIgLSB5KSAvIGhlaWdodF07XG4gIH1cbiAgYWRkKHtcbiAgICB4LFxuICAgIHlcbiAgfSkge1xuICAgIHRoaXMuI2xhc3RYID0geDtcbiAgICB0aGlzLiNsYXN0WSA9IHk7XG4gICAgY29uc3QgW2xheWVyWCwgbGF5ZXJZLCBsYXllcldpZHRoLCBsYXllckhlaWdodF0gPSB0aGlzLiNib3g7XG4gICAgbGV0IFt4MSwgeTEsIHgyLCB5Ml0gPSB0aGlzLiNsYXN0LnN1YmFycmF5KDgsIDEyKTtcbiAgICBjb25zdCBkaWZmWCA9IHggLSB4MjtcbiAgICBjb25zdCBkaWZmWSA9IHkgLSB5MjtcbiAgICBjb25zdCBkID0gTWF0aC5oeXBvdChkaWZmWCwgZGlmZlkpO1xuICAgIGlmIChkIDwgdGhpcy4jbWluKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGRpZmZEID0gZCAtIHRoaXMuI21pbl9kaXN0O1xuICAgIGNvbnN0IEsgPSBkaWZmRCAvIGQ7XG4gICAgY29uc3Qgc2hpZnRYID0gSyAqIGRpZmZYO1xuICAgIGNvbnN0IHNoaWZ0WSA9IEsgKiBkaWZmWTtcbiAgICBsZXQgeDAgPSB4MTtcbiAgICBsZXQgeTAgPSB5MTtcbiAgICB4MSA9IHgyO1xuICAgIHkxID0geTI7XG4gICAgeDIgKz0gc2hpZnRYO1xuICAgIHkyICs9IHNoaWZ0WTtcbiAgICB0aGlzLiNwb2ludHM/LnB1c2goeCwgeSk7XG4gICAgY29uc3QgblggPSAtc2hpZnRZIC8gZGlmZkQ7XG4gICAgY29uc3QgblkgPSBzaGlmdFggLyBkaWZmRDtcbiAgICBjb25zdCB0aFggPSBuWCAqIHRoaXMuI3RoaWNrbmVzcztcbiAgICBjb25zdCB0aFkgPSBuWSAqIHRoaXMuI3RoaWNrbmVzcztcbiAgICB0aGlzLiNsYXN0LnNldCh0aGlzLiNsYXN0LnN1YmFycmF5KDIsIDgpLCAwKTtcbiAgICB0aGlzLiNsYXN0LnNldChbeDIgKyB0aFgsIHkyICsgdGhZXSwgNCk7XG4gICAgdGhpcy4jbGFzdC5zZXQodGhpcy4jbGFzdC5zdWJhcnJheSgxNCwgMTgpLCAxMik7XG4gICAgdGhpcy4jbGFzdC5zZXQoW3gyIC0gdGhYLCB5MiAtIHRoWV0sIDE2KTtcbiAgICBpZiAoaXNOYU4odGhpcy4jbGFzdFs2XSkpIHtcbiAgICAgIGlmICh0aGlzLiN0b3AubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuI2xhc3Quc2V0KFt4MSArIHRoWCwgeTEgKyB0aFldLCAyKTtcbiAgICAgICAgdGhpcy4jdG9wLnB1c2goTmFOLCBOYU4sIE5hTiwgTmFOLCAoeDEgKyB0aFggLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKHkxICsgdGhZIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0KTtcbiAgICAgICAgdGhpcy4jbGFzdC5zZXQoW3gxIC0gdGhYLCB5MSAtIHRoWV0sIDE0KTtcbiAgICAgICAgdGhpcy4jYm90dG9tLnB1c2goTmFOLCBOYU4sIE5hTiwgTmFOLCAoeDEgLSB0aFggLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKHkxIC0gdGhZIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI2xhc3Quc2V0KFt4MCwgeTAsIHgxLCB5MSwgeDIsIHkyXSwgNik7XG4gICAgICByZXR1cm4gIXRoaXMuaXNFbXB0eSgpO1xuICAgIH1cbiAgICB0aGlzLiNsYXN0LnNldChbeDAsIHkwLCB4MSwgeTEsIHgyLCB5Ml0sIDYpO1xuICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5hYnMoTWF0aC5hdGFuMih5MCAtIHkxLCB4MCAtIHgxKSAtIE1hdGguYXRhbjIoc2hpZnRZLCBzaGlmdFgpKTtcbiAgICBpZiAoYW5nbGUgPCBNYXRoLlBJIC8gMikge1xuICAgICAgW3gxLCB5MSwgeDIsIHkyXSA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoMiwgNik7XG4gICAgICB0aGlzLiN0b3AucHVzaChOYU4sIE5hTiwgTmFOLCBOYU4sICgoeDEgKyB4MikgLyAyIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsICgoeTEgKyB5MikgLyAyIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0KTtcbiAgICAgIFt4MSwgeTEsIHgwLCB5MF0gPSB0aGlzLiNsYXN0LnN1YmFycmF5KDE0LCAxOCk7XG4gICAgICB0aGlzLiNib3R0b20ucHVzaChOYU4sIE5hTiwgTmFOLCBOYU4sICgoeDAgKyB4MSkgLyAyIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsICgoeTAgKyB5MSkgLyAyIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBbeDAsIHkwLCB4MSwgeTEsIHgyLCB5Ml0gPSB0aGlzLiNsYXN0LnN1YmFycmF5KDAsIDYpO1xuICAgIHRoaXMuI3RvcC5wdXNoKCgoeDAgKyA1ICogeDEpIC8gNiAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAoKHkwICsgNSAqIHkxKSAvIDYgLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQsICgoNSAqIHgxICsgeDIpIC8gNiAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAoKDUgKiB5MSArIHkyKSAvIDYgLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQsICgoeDEgKyB4MikgLyAyIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsICgoeTEgKyB5MikgLyAyIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0KTtcbiAgICBbeDIsIHkyLCB4MSwgeTEsIHgwLCB5MF0gPSB0aGlzLiNsYXN0LnN1YmFycmF5KDEyLCAxOCk7XG4gICAgdGhpcy4jYm90dG9tLnB1c2goKCh4MCArIDUgKiB4MSkgLyA2IC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsICgoeTAgKyA1ICogeTEpIC8gNiAtIGxheWVyWSkgLyBsYXllckhlaWdodCwgKCg1ICogeDEgKyB4MikgLyA2IC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsICgoNSAqIHkxICsgeTIpIC8gNiAtIGxheWVyWSkgLyBsYXllckhlaWdodCwgKCh4MSArIHgyKSAvIDIgLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKCh5MSArIHkyKSAvIDIgLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHRvU1ZHUGF0aCgpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBjb25zdCB0b3AgPSB0aGlzLiN0b3A7XG4gICAgY29uc3QgYm90dG9tID0gdGhpcy4jYm90dG9tO1xuICAgIGlmIChpc05hTih0aGlzLiNsYXN0WzZdKSAmJiAhdGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLiN0b1NWR1BhdGhUd29Qb2ludHMoKTtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVyID0gW107XG4gICAgYnVmZmVyLnB1c2goYE0ke3RvcFs0XX0gJHt0b3BbNV19YCk7XG4gICAgZm9yIChsZXQgaSA9IDY7IGkgPCB0b3AubGVuZ3RoOyBpICs9IDYpIHtcbiAgICAgIGlmIChpc05hTih0b3BbaV0pKSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoKGBMJHt0b3BbaSArIDRdfSAke3RvcFtpICsgNV19YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWZmZXIucHVzaChgQyR7dG9wW2ldfSAke3RvcFtpICsgMV19ICR7dG9wW2kgKyAyXX0gJHt0b3BbaSArIDNdfSAke3RvcFtpICsgNF19ICR7dG9wW2kgKyA1XX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jdG9TVkdQYXRoRW5kKGJ1ZmZlcik7XG4gICAgZm9yIChsZXQgaSA9IGJvdHRvbS5sZW5ndGggLSA2OyBpID49IDY7IGkgLT0gNikge1xuICAgICAgaWYgKGlzTmFOKGJvdHRvbVtpXSkpIHtcbiAgICAgICAgYnVmZmVyLnB1c2goYEwke2JvdHRvbVtpICsgNF19ICR7Ym90dG9tW2kgKyA1XX1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoKGBDJHtib3R0b21baV19ICR7Ym90dG9tW2kgKyAxXX0gJHtib3R0b21baSArIDJdfSAke2JvdHRvbVtpICsgM119ICR7Ym90dG9tW2kgKyA0XX0gJHtib3R0b21baSArIDVdfWApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiN0b1NWR1BhdGhTdGFydChidWZmZXIpO1xuICAgIHJldHVybiBidWZmZXIuam9pbihcIiBcIik7XG4gIH1cbiAgI3RvU1ZHUGF0aFR3b1BvaW50cygpIHtcbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSB0aGlzLiNib3g7XG4gICAgY29uc3QgW2xhc3RUb3BYLCBsYXN0VG9wWSwgbGFzdEJvdHRvbVgsIGxhc3RCb3R0b21ZXSA9IHRoaXMuI2dldExhc3RDb29yZHMoKTtcbiAgICByZXR1cm4gYE0keyh0aGlzLiNsYXN0WzJdIC0geCkgLyB3aWR0aH0gJHsodGhpcy4jbGFzdFszXSAtIHkpIC8gaGVpZ2h0fSBMJHsodGhpcy4jbGFzdFs0XSAtIHgpIC8gd2lkdGh9ICR7KHRoaXMuI2xhc3RbNV0gLSB5KSAvIGhlaWdodH0gTCR7bGFzdFRvcFh9ICR7bGFzdFRvcFl9IEwke2xhc3RCb3R0b21YfSAke2xhc3RCb3R0b21ZfSBMJHsodGhpcy4jbGFzdFsxNl0gLSB4KSAvIHdpZHRofSAkeyh0aGlzLiNsYXN0WzE3XSAtIHkpIC8gaGVpZ2h0fSBMJHsodGhpcy4jbGFzdFsxNF0gLSB4KSAvIHdpZHRofSAkeyh0aGlzLiNsYXN0WzE1XSAtIHkpIC8gaGVpZ2h0fSBaYDtcbiAgfVxuICAjdG9TVkdQYXRoU3RhcnQoYnVmZmVyKSB7XG4gICAgY29uc3QgYm90dG9tID0gdGhpcy4jYm90dG9tO1xuICAgIGJ1ZmZlci5wdXNoKGBMJHtib3R0b21bNF19ICR7Ym90dG9tWzVdfSBaYCk7XG4gIH1cbiAgI3RvU1ZHUGF0aEVuZChidWZmZXIpIHtcbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSB0aGlzLiNib3g7XG4gICAgY29uc3QgbGFzdFRvcCA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoNCwgNik7XG4gICAgY29uc3QgbGFzdEJvdHRvbSA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoMTYsIDE4KTtcbiAgICBjb25zdCBbbGFzdFRvcFgsIGxhc3RUb3BZLCBsYXN0Qm90dG9tWCwgbGFzdEJvdHRvbVldID0gdGhpcy4jZ2V0TGFzdENvb3JkcygpO1xuICAgIGJ1ZmZlci5wdXNoKGBMJHsobGFzdFRvcFswXSAtIHgpIC8gd2lkdGh9ICR7KGxhc3RUb3BbMV0gLSB5KSAvIGhlaWdodH0gTCR7bGFzdFRvcFh9ICR7bGFzdFRvcFl9IEwke2xhc3RCb3R0b21YfSAke2xhc3RCb3R0b21ZfSBMJHsobGFzdEJvdHRvbVswXSAtIHgpIC8gd2lkdGh9ICR7KGxhc3RCb3R0b21bMV0gLSB5KSAvIGhlaWdodH1gKTtcbiAgfVxuICBuZXdGcmVlRHJhd091dGxpbmUob3V0bGluZSwgcG9pbnRzLCBib3gsIHNjYWxlRmFjdG9yLCBpbm5lck1hcmdpbiwgaXNMVFIpIHtcbiAgICByZXR1cm4gbmV3IEZyZWVEcmF3T3V0bGluZShvdXRsaW5lLCBwb2ludHMsIGJveCwgc2NhbGVGYWN0b3IsIGlubmVyTWFyZ2luLCBpc0xUUik7XG4gIH1cbiAgZ2V0T3V0bGluZXMoKSB7XG4gICAgY29uc3QgdG9wID0gdGhpcy4jdG9wO1xuICAgIGNvbnN0IGJvdHRvbSA9IHRoaXMuI2JvdHRvbTtcbiAgICBjb25zdCBsYXN0ID0gdGhpcy4jbGFzdDtcbiAgICBjb25zdCBbbGF5ZXJYLCBsYXllclksIGxheWVyV2lkdGgsIGxheWVySGVpZ2h0XSA9IHRoaXMuI2JveDtcbiAgICBjb25zdCBwb2ludHMgPSBuZXcgRmxvYXQzMkFycmF5KCh0aGlzLiNwb2ludHM/Lmxlbmd0aCA/PyAwKSArIDIpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvaW50cy5sZW5ndGggLSAyOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgcG9pbnRzW2ldID0gKHRoaXMuI3BvaW50c1tpXSAtIGxheWVyWCkgLyBsYXllcldpZHRoO1xuICAgICAgcG9pbnRzW2kgKyAxXSA9ICh0aGlzLiNwb2ludHNbaSArIDFdIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0O1xuICAgIH1cbiAgICBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdID0gKHRoaXMuI2xhc3RYIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGg7XG4gICAgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSA9ICh0aGlzLiNsYXN0WSAtIGxheWVyWSkgLyBsYXllckhlaWdodDtcbiAgICBpZiAoaXNOYU4obGFzdFs2XSkgJiYgIXRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy4jZ2V0T3V0bGluZVR3b1BvaW50cyhwb2ludHMpO1xuICAgIH1cbiAgICBjb25zdCBvdXRsaW5lID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLiN0b3AubGVuZ3RoICsgMjQgKyB0aGlzLiNib3R0b20ubGVuZ3RoKTtcbiAgICBsZXQgTiA9IHRvcC5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyBpICs9IDIpIHtcbiAgICAgIGlmIChpc05hTih0b3BbaV0pKSB7XG4gICAgICAgIG91dGxpbmVbaV0gPSBvdXRsaW5lW2kgKyAxXSA9IE5hTjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBvdXRsaW5lW2ldID0gdG9wW2ldO1xuICAgICAgb3V0bGluZVtpICsgMV0gPSB0b3BbaSArIDFdO1xuICAgIH1cbiAgICBOID0gdGhpcy4jZ2V0T3V0bGluZUVuZChvdXRsaW5lLCBOKTtcbiAgICBmb3IgKGxldCBpID0gYm90dG9tLmxlbmd0aCAtIDY7IGkgPj0gNjsgaSAtPSA2KSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDY7IGogKz0gMikge1xuICAgICAgICBpZiAoaXNOYU4oYm90dG9tW2kgKyBqXSkpIHtcbiAgICAgICAgICBvdXRsaW5lW05dID0gb3V0bGluZVtOICsgMV0gPSBOYU47XG4gICAgICAgICAgTiArPSAyO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG91dGxpbmVbTl0gPSBib3R0b21baSArIGpdO1xuICAgICAgICBvdXRsaW5lW04gKyAxXSA9IGJvdHRvbVtpICsgaiArIDFdO1xuICAgICAgICBOICs9IDI7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2dldE91dGxpbmVTdGFydChvdXRsaW5lLCBOKTtcbiAgICByZXR1cm4gdGhpcy5uZXdGcmVlRHJhd091dGxpbmUob3V0bGluZSwgcG9pbnRzLCB0aGlzLiNib3gsIHRoaXMuI3NjYWxlRmFjdG9yLCB0aGlzLiNpbm5lck1hcmdpbiwgdGhpcy4jaXNMVFIpO1xuICB9XG4gICNnZXRPdXRsaW5lVHdvUG9pbnRzKHBvaW50cykge1xuICAgIGNvbnN0IGxhc3QgPSB0aGlzLiNsYXN0O1xuICAgIGNvbnN0IFtsYXllclgsIGxheWVyWSwgbGF5ZXJXaWR0aCwgbGF5ZXJIZWlnaHRdID0gdGhpcy4jYm94O1xuICAgIGNvbnN0IFtsYXN0VG9wWCwgbGFzdFRvcFksIGxhc3RCb3R0b21YLCBsYXN0Qm90dG9tWV0gPSB0aGlzLiNnZXRMYXN0Q29vcmRzKCk7XG4gICAgY29uc3Qgb3V0bGluZSA9IG5ldyBGbG9hdDMyQXJyYXkoMzYpO1xuICAgIG91dGxpbmUuc2V0KFtOYU4sIE5hTiwgTmFOLCBOYU4sIChsYXN0WzJdIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsIChsYXN0WzNdIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0LCBOYU4sIE5hTiwgTmFOLCBOYU4sIChsYXN0WzRdIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsIChsYXN0WzVdIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0LCBOYU4sIE5hTiwgTmFOLCBOYU4sIGxhc3RUb3BYLCBsYXN0VG9wWSwgTmFOLCBOYU4sIE5hTiwgTmFOLCBsYXN0Qm90dG9tWCwgbGFzdEJvdHRvbVksIE5hTiwgTmFOLCBOYU4sIE5hTiwgKGxhc3RbMTZdIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsIChsYXN0WzE3XSAtIGxheWVyWSkgLyBsYXllckhlaWdodCwgTmFOLCBOYU4sIE5hTiwgTmFOLCAobGFzdFsxNF0gLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKGxhc3RbMTVdIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0XSwgMCk7XG4gICAgcmV0dXJuIHRoaXMubmV3RnJlZURyYXdPdXRsaW5lKG91dGxpbmUsIHBvaW50cywgdGhpcy4jYm94LCB0aGlzLiNzY2FsZUZhY3RvciwgdGhpcy4jaW5uZXJNYXJnaW4sIHRoaXMuI2lzTFRSKTtcbiAgfVxuICAjZ2V0T3V0bGluZVN0YXJ0KG91dGxpbmUsIHBvcykge1xuICAgIGNvbnN0IGJvdHRvbSA9IHRoaXMuI2JvdHRvbTtcbiAgICBvdXRsaW5lLnNldChbTmFOLCBOYU4sIE5hTiwgTmFOLCBib3R0b21bNF0sIGJvdHRvbVs1XV0sIHBvcyk7XG4gICAgcmV0dXJuIHBvcyArPSA2O1xuICB9XG4gICNnZXRPdXRsaW5lRW5kKG91dGxpbmUsIHBvcykge1xuICAgIGNvbnN0IGxhc3RUb3AgPSB0aGlzLiNsYXN0LnN1YmFycmF5KDQsIDYpO1xuICAgIGNvbnN0IGxhc3RCb3R0b20gPSB0aGlzLiNsYXN0LnN1YmFycmF5KDE2LCAxOCk7XG4gICAgY29uc3QgW2xheWVyWCwgbGF5ZXJZLCBsYXllcldpZHRoLCBsYXllckhlaWdodF0gPSB0aGlzLiNib3g7XG4gICAgY29uc3QgW2xhc3RUb3BYLCBsYXN0VG9wWSwgbGFzdEJvdHRvbVgsIGxhc3RCb3R0b21ZXSA9IHRoaXMuI2dldExhc3RDb29yZHMoKTtcbiAgICBvdXRsaW5lLnNldChbTmFOLCBOYU4sIE5hTiwgTmFOLCAobGFzdFRvcFswXSAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAobGFzdFRvcFsxXSAtIGxheWVyWSkgLyBsYXllckhlaWdodCwgTmFOLCBOYU4sIE5hTiwgTmFOLCBsYXN0VG9wWCwgbGFzdFRvcFksIE5hTiwgTmFOLCBOYU4sIE5hTiwgbGFzdEJvdHRvbVgsIGxhc3RCb3R0b21ZLCBOYU4sIE5hTiwgTmFOLCBOYU4sIChsYXN0Qm90dG9tWzBdIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsIChsYXN0Qm90dG9tWzFdIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0XSwgcG9zKTtcbiAgICByZXR1cm4gcG9zICs9IDI0O1xuICB9XG59XG5jbGFzcyBGcmVlRHJhd091dGxpbmUgZXh0ZW5kcyBPdXRsaW5lIHtcbiAgI2JveDtcbiAgI2Jib3ggPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAjaW5uZXJNYXJnaW47XG4gICNpc0xUUjtcbiAgI3BvaW50cztcbiAgI3NjYWxlRmFjdG9yO1xuICAjb3V0bGluZTtcbiAgY29uc3RydWN0b3Iob3V0bGluZSwgcG9pbnRzLCBib3gsIHNjYWxlRmFjdG9yLCBpbm5lck1hcmdpbiwgaXNMVFIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuI291dGxpbmUgPSBvdXRsaW5lO1xuICAgIHRoaXMuI3BvaW50cyA9IHBvaW50cztcbiAgICB0aGlzLiNib3ggPSBib3g7XG4gICAgdGhpcy4jc2NhbGVGYWN0b3IgPSBzY2FsZUZhY3RvcjtcbiAgICB0aGlzLiNpbm5lck1hcmdpbiA9IGlubmVyTWFyZ2luO1xuICAgIHRoaXMuI2lzTFRSID0gaXNMVFI7XG4gICAgdGhpcy5maXJzdFBvaW50ID0gW05hTiwgTmFOXTtcbiAgICB0aGlzLmxhc3RQb2ludCA9IFtOYU4sIE5hTl07XG4gICAgdGhpcy4jY29tcHV0ZU1pbk1heChpc0xUUik7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gdGhpcy4jYmJveDtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBvdXRsaW5lLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIG91dGxpbmVbaV0gPSAob3V0bGluZVtpXSAtIHgpIC8gd2lkdGg7XG4gICAgICBvdXRsaW5lW2kgKyAxXSA9IChvdXRsaW5lW2kgKyAxXSAtIHkpIC8gaGVpZ2h0O1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgcG9pbnRzW2ldID0gKHBvaW50c1tpXSAtIHgpIC8gd2lkdGg7XG4gICAgICBwb2ludHNbaSArIDFdID0gKHBvaW50c1tpICsgMV0gLSB5KSAvIGhlaWdodDtcbiAgICB9XG4gIH1cbiAgdG9TVkdQYXRoKCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IFtgTSR7dGhpcy4jb3V0bGluZVs0XX0gJHt0aGlzLiNvdXRsaW5lWzVdfWBdO1xuICAgIGZvciAobGV0IGkgPSA2LCBpaSA9IHRoaXMuI291dGxpbmUubGVuZ3RoOyBpIDwgaWk7IGkgKz0gNikge1xuICAgICAgaWYgKGlzTmFOKHRoaXMuI291dGxpbmVbaV0pKSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoKGBMJHt0aGlzLiNvdXRsaW5lW2kgKyA0XX0gJHt0aGlzLiNvdXRsaW5lW2kgKyA1XX1gKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBidWZmZXIucHVzaChgQyR7dGhpcy4jb3V0bGluZVtpXX0gJHt0aGlzLiNvdXRsaW5lW2kgKyAxXX0gJHt0aGlzLiNvdXRsaW5lW2kgKyAyXX0gJHt0aGlzLiNvdXRsaW5lW2kgKyAzXX0gJHt0aGlzLiNvdXRsaW5lW2kgKyA0XX0gJHt0aGlzLiNvdXRsaW5lW2kgKyA1XX1gKTtcbiAgICB9XG4gICAgYnVmZmVyLnB1c2goXCJaXCIpO1xuICAgIHJldHVybiBidWZmZXIuam9pbihcIiBcIik7XG4gIH1cbiAgc2VyaWFsaXplKFtibFgsIGJsWSwgdHJYLCB0clldLCByb3RhdGlvbikge1xuICAgIGNvbnN0IHdpZHRoID0gdHJYIC0gYmxYO1xuICAgIGNvbnN0IGhlaWdodCA9IHRyWSAtIGJsWTtcbiAgICBsZXQgb3V0bGluZTtcbiAgICBsZXQgcG9pbnRzO1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgb3V0bGluZSA9IE91dGxpbmUuX3Jlc2NhbGUodGhpcy4jb3V0bGluZSwgYmxYLCB0clksIHdpZHRoLCAtaGVpZ2h0KTtcbiAgICAgICAgcG9pbnRzID0gT3V0bGluZS5fcmVzY2FsZSh0aGlzLiNwb2ludHMsIGJsWCwgdHJZLCB3aWR0aCwgLWhlaWdodCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgb3V0bGluZSA9IE91dGxpbmUuX3Jlc2NhbGVBbmRTd2FwKHRoaXMuI291dGxpbmUsIGJsWCwgYmxZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgcG9pbnRzID0gT3V0bGluZS5fcmVzY2FsZUFuZFN3YXAodGhpcy4jcG9pbnRzLCBibFgsIGJsWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIG91dGxpbmUgPSBPdXRsaW5lLl9yZXNjYWxlKHRoaXMuI291dGxpbmUsIHRyWCwgYmxZLCAtd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHBvaW50cyA9IE91dGxpbmUuX3Jlc2NhbGUodGhpcy4jcG9pbnRzLCB0clgsIGJsWSwgLXdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICBvdXRsaW5lID0gT3V0bGluZS5fcmVzY2FsZUFuZFN3YXAodGhpcy4jb3V0bGluZSwgdHJYLCB0clksIC13aWR0aCwgLWhlaWdodCk7XG4gICAgICAgIHBvaW50cyA9IE91dGxpbmUuX3Jlc2NhbGVBbmRTd2FwKHRoaXMuI3BvaW50cywgdHJYLCB0clksIC13aWR0aCwgLWhlaWdodCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgb3V0bGluZTogQXJyYXkuZnJvbShvdXRsaW5lKSxcbiAgICAgIHBvaW50czogW0FycmF5LmZyb20ocG9pbnRzKV1cbiAgICB9O1xuICB9XG4gICNjb21wdXRlTWluTWF4KGlzTFRSKSB7XG4gICAgY29uc3Qgb3V0bGluZSA9IHRoaXMuI291dGxpbmU7XG4gICAgbGV0IGxhc3RYID0gb3V0bGluZVs0XTtcbiAgICBsZXQgbGFzdFkgPSBvdXRsaW5lWzVdO1xuICAgIGNvbnN0IG1pbk1heCA9IFtsYXN0WCwgbGFzdFksIGxhc3RYLCBsYXN0WV07XG4gICAgbGV0IGZpcnN0UG9pbnRYID0gbGFzdFg7XG4gICAgbGV0IGZpcnN0UG9pbnRZID0gbGFzdFk7XG4gICAgbGV0IGxhc3RQb2ludFggPSBsYXN0WDtcbiAgICBsZXQgbGFzdFBvaW50WSA9IGxhc3RZO1xuICAgIGNvbnN0IGx0ckNhbGxiYWNrID0gaXNMVFIgPyBNYXRoLm1heCA6IE1hdGgubWluO1xuICAgIGNvbnN0IGJlemllckJib3ggPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAgIGZvciAobGV0IGkgPSA2LCBpaSA9IG91dGxpbmUubGVuZ3RoOyBpIDwgaWk7IGkgKz0gNikge1xuICAgICAgY29uc3QgeCA9IG91dGxpbmVbaSArIDRdLCB5ID0gb3V0bGluZVtpICsgNV07XG4gICAgICBpZiAoaXNOYU4ob3V0bGluZVtpXSkpIHtcbiAgICAgICAgVXRpbC5wb2ludEJvdW5kaW5nQm94KHgsIHksIG1pbk1heCk7XG4gICAgICAgIGlmIChmaXJzdFBvaW50WSA+IHkpIHtcbiAgICAgICAgICBmaXJzdFBvaW50WCA9IHg7XG4gICAgICAgICAgZmlyc3RQb2ludFkgPSB5O1xuICAgICAgICB9IGVsc2UgaWYgKGZpcnN0UG9pbnRZID09PSB5KSB7XG4gICAgICAgICAgZmlyc3RQb2ludFggPSBsdHJDYWxsYmFjayhmaXJzdFBvaW50WCwgeCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RQb2ludFkgPCB5KSB7XG4gICAgICAgICAgbGFzdFBvaW50WCA9IHg7XG4gICAgICAgICAgbGFzdFBvaW50WSA9IHk7XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdFBvaW50WSA9PT0geSkge1xuICAgICAgICAgIGxhc3RQb2ludFggPSBsdHJDYWxsYmFjayhsYXN0UG9pbnRYLCB4KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmV6aWVyQmJveFswXSA9IGJlemllckJib3hbMV0gPSBJbmZpbml0eTtcbiAgICAgICAgYmV6aWVyQmJveFsyXSA9IGJlemllckJib3hbM10gPSAtSW5maW5pdHk7XG4gICAgICAgIFV0aWwuYmV6aWVyQm91bmRpbmdCb3gobGFzdFgsIGxhc3RZLCAuLi5vdXRsaW5lLnNsaWNlKGksIGkgKyA2KSwgYmV6aWVyQmJveCk7XG4gICAgICAgIFV0aWwucmVjdEJvdW5kaW5nQm94KGJlemllckJib3hbMF0sIGJlemllckJib3hbMV0sIGJlemllckJib3hbMl0sIGJlemllckJib3hbM10sIG1pbk1heCk7XG4gICAgICAgIGlmIChmaXJzdFBvaW50WSA+IGJlemllckJib3hbMV0pIHtcbiAgICAgICAgICBmaXJzdFBvaW50WCA9IGJlemllckJib3hbMF07XG4gICAgICAgICAgZmlyc3RQb2ludFkgPSBiZXppZXJCYm94WzFdO1xuICAgICAgICB9IGVsc2UgaWYgKGZpcnN0UG9pbnRZID09PSBiZXppZXJCYm94WzFdKSB7XG4gICAgICAgICAgZmlyc3RQb2ludFggPSBsdHJDYWxsYmFjayhmaXJzdFBvaW50WCwgYmV6aWVyQmJveFswXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RQb2ludFkgPCBiZXppZXJCYm94WzNdKSB7XG4gICAgICAgICAgbGFzdFBvaW50WCA9IGJlemllckJib3hbMl07XG4gICAgICAgICAgbGFzdFBvaW50WSA9IGJlemllckJib3hbM107XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdFBvaW50WSA9PT0gYmV6aWVyQmJveFszXSkge1xuICAgICAgICAgIGxhc3RQb2ludFggPSBsdHJDYWxsYmFjayhsYXN0UG9pbnRYLCBiZXppZXJCYm94WzJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGFzdFggPSB4O1xuICAgICAgbGFzdFkgPSB5O1xuICAgIH1cbiAgICBjb25zdCBiYm94ID0gdGhpcy4jYmJveDtcbiAgICBiYm94WzBdID0gbWluTWF4WzBdIC0gdGhpcy4jaW5uZXJNYXJnaW47XG4gICAgYmJveFsxXSA9IG1pbk1heFsxXSAtIHRoaXMuI2lubmVyTWFyZ2luO1xuICAgIGJib3hbMl0gPSBtaW5NYXhbMl0gLSBtaW5NYXhbMF0gKyAyICogdGhpcy4jaW5uZXJNYXJnaW47XG4gICAgYmJveFszXSA9IG1pbk1heFszXSAtIG1pbk1heFsxXSArIDIgKiB0aGlzLiNpbm5lck1hcmdpbjtcbiAgICB0aGlzLmZpcnN0UG9pbnQgPSBbZmlyc3RQb2ludFgsIGZpcnN0UG9pbnRZXTtcbiAgICB0aGlzLmxhc3RQb2ludCA9IFtsYXN0UG9pbnRYLCBsYXN0UG9pbnRZXTtcbiAgfVxuICBnZXQgYm94KCkge1xuICAgIHJldHVybiB0aGlzLiNiYm94O1xuICB9XG4gIG5ld091dGxpbmVyKHBvaW50LCBib3gsIHNjYWxlRmFjdG9yLCB0aGlja25lc3MsIGlzTFRSLCBpbm5lck1hcmdpbiA9IDApIHtcbiAgICByZXR1cm4gbmV3IEZyZWVEcmF3T3V0bGluZXIocG9pbnQsIGJveCwgc2NhbGVGYWN0b3IsIHRoaWNrbmVzcywgaXNMVFIsIGlubmVyTWFyZ2luKTtcbiAgfVxuICBnZXROZXdPdXRsaW5lKHRoaWNrbmVzcywgaW5uZXJNYXJnaW4pIHtcbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSB0aGlzLiNiYm94O1xuICAgIGNvbnN0IFtsYXllclgsIGxheWVyWSwgbGF5ZXJXaWR0aCwgbGF5ZXJIZWlnaHRdID0gdGhpcy4jYm94O1xuICAgIGNvbnN0IHN4ID0gd2lkdGggKiBsYXllcldpZHRoO1xuICAgIGNvbnN0IHN5ID0gaGVpZ2h0ICogbGF5ZXJIZWlnaHQ7XG4gICAgY29uc3QgdHggPSB4ICogbGF5ZXJXaWR0aCArIGxheWVyWDtcbiAgICBjb25zdCB0eSA9IHkgKiBsYXllckhlaWdodCArIGxheWVyWTtcbiAgICBjb25zdCBvdXRsaW5lciA9IHRoaXMubmV3T3V0bGluZXIoe1xuICAgICAgeDogdGhpcy4jcG9pbnRzWzBdICogc3ggKyB0eCxcbiAgICAgIHk6IHRoaXMuI3BvaW50c1sxXSAqIHN5ICsgdHlcbiAgICB9LCB0aGlzLiNib3gsIHRoaXMuI3NjYWxlRmFjdG9yLCB0aGlja25lc3MsIHRoaXMuI2lzTFRSLCBpbm5lck1hcmdpbiA/PyB0aGlzLiNpbm5lck1hcmdpbik7XG4gICAgZm9yIChsZXQgaSA9IDI7IGkgPCB0aGlzLiNwb2ludHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIG91dGxpbmVyLmFkZCh7XG4gICAgICAgIHg6IHRoaXMuI3BvaW50c1tpXSAqIHN4ICsgdHgsXG4gICAgICAgIHk6IHRoaXMuI3BvaW50c1tpICsgMV0gKiBzeSArIHR5XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG91dGxpbmVyLmdldE91dGxpbmVzKCk7XG4gIH1cbn1cbmNsYXNzIEhpZ2hsaWdodE91dGxpbmVyIHtcbiAgI2JveDtcbiAgI2ZpcnN0UG9pbnQ7XG4gICNsYXN0UG9pbnQ7XG4gICN2ZXJ0aWNhbEVkZ2VzID0gW107XG4gICNpbnRlcnZhbHMgPSBbXTtcbiAgY29uc3RydWN0b3IoYm94ZXMsIGJvcmRlcldpZHRoID0gMCwgaW5uZXJNYXJnaW4gPSAwLCBpc0xUUiA9IHRydWUpIHtcbiAgICBjb25zdCBtaW5NYXggPSBbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV07XG4gICAgY29uc3QgRVBTSUxPTiA9IDEwICoqIC00O1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gb2YgYm94ZXMpIHtcbiAgICAgIGNvbnN0IHgxID0gTWF0aC5mbG9vcigoeCAtIGJvcmRlcldpZHRoKSAvIEVQU0lMT04pICogRVBTSUxPTjtcbiAgICAgIGNvbnN0IHgyID0gTWF0aC5jZWlsKCh4ICsgd2lkdGggKyBib3JkZXJXaWR0aCkgLyBFUFNJTE9OKSAqIEVQU0lMT047XG4gICAgICBjb25zdCB5MSA9IE1hdGguZmxvb3IoKHkgLSBib3JkZXJXaWR0aCkgLyBFUFNJTE9OKSAqIEVQU0lMT047XG4gICAgICBjb25zdCB5MiA9IE1hdGguY2VpbCgoeSArIGhlaWdodCArIGJvcmRlcldpZHRoKSAvIEVQU0lMT04pICogRVBTSUxPTjtcbiAgICAgIGNvbnN0IGxlZnQgPSBbeDEsIHkxLCB5MiwgdHJ1ZV07XG4gICAgICBjb25zdCByaWdodCA9IFt4MiwgeTEsIHkyLCBmYWxzZV07XG4gICAgICB0aGlzLiN2ZXJ0aWNhbEVkZ2VzLnB1c2gobGVmdCwgcmlnaHQpO1xuICAgICAgVXRpbC5yZWN0Qm91bmRpbmdCb3goeDEsIHkxLCB4MiwgeTIsIG1pbk1heCk7XG4gICAgfVxuICAgIGNvbnN0IGJib3hXaWR0aCA9IG1pbk1heFsyXSAtIG1pbk1heFswXSArIDIgKiBpbm5lck1hcmdpbjtcbiAgICBjb25zdCBiYm94SGVpZ2h0ID0gbWluTWF4WzNdIC0gbWluTWF4WzFdICsgMiAqIGlubmVyTWFyZ2luO1xuICAgIGNvbnN0IHNoaWZ0ZWRNaW5YID0gbWluTWF4WzBdIC0gaW5uZXJNYXJnaW47XG4gICAgY29uc3Qgc2hpZnRlZE1pblkgPSBtaW5NYXhbMV0gLSBpbm5lck1hcmdpbjtcbiAgICBsZXQgZmlyc3RQb2ludFggPSBpc0xUUiA/IC1JbmZpbml0eSA6IEluZmluaXR5O1xuICAgIGxldCBmaXJzdFBvaW50WSA9IEluZmluaXR5O1xuICAgIGNvbnN0IGxhc3RFZGdlID0gdGhpcy4jdmVydGljYWxFZGdlcy5hdChpc0xUUiA/IC0xIDogLTIpO1xuICAgIGNvbnN0IGxhc3RQb2ludCA9IFtsYXN0RWRnZVswXSwgbGFzdEVkZ2VbMl1dO1xuICAgIGZvciAoY29uc3QgZWRnZSBvZiB0aGlzLiN2ZXJ0aWNhbEVkZ2VzKSB7XG4gICAgICBjb25zdCBbeCwgeTEsIHkyLCBsZWZ0XSA9IGVkZ2U7XG4gICAgICBpZiAoIWxlZnQgJiYgaXNMVFIpIHtcbiAgICAgICAgaWYgKHkxIDwgZmlyc3RQb2ludFkpIHtcbiAgICAgICAgICBmaXJzdFBvaW50WSA9IHkxO1xuICAgICAgICAgIGZpcnN0UG9pbnRYID0geDtcbiAgICAgICAgfSBlbHNlIGlmICh5MSA9PT0gZmlyc3RQb2ludFkpIHtcbiAgICAgICAgICBmaXJzdFBvaW50WCA9IE1hdGgubWF4KGZpcnN0UG9pbnRYLCB4KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsZWZ0ICYmICFpc0xUUikge1xuICAgICAgICBpZiAoeTEgPCBmaXJzdFBvaW50WSkge1xuICAgICAgICAgIGZpcnN0UG9pbnRZID0geTE7XG4gICAgICAgICAgZmlyc3RQb2ludFggPSB4O1xuICAgICAgICB9IGVsc2UgaWYgKHkxID09PSBmaXJzdFBvaW50WSkge1xuICAgICAgICAgIGZpcnN0UG9pbnRYID0gTWF0aC5taW4oZmlyc3RQb2ludFgsIHgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlZGdlWzBdID0gKHggLSBzaGlmdGVkTWluWCkgLyBiYm94V2lkdGg7XG4gICAgICBlZGdlWzFdID0gKHkxIC0gc2hpZnRlZE1pblkpIC8gYmJveEhlaWdodDtcbiAgICAgIGVkZ2VbMl0gPSAoeTIgLSBzaGlmdGVkTWluWSkgLyBiYm94SGVpZ2h0O1xuICAgIH1cbiAgICB0aGlzLiNib3ggPSBuZXcgRmxvYXQzMkFycmF5KFtzaGlmdGVkTWluWCwgc2hpZnRlZE1pblksIGJib3hXaWR0aCwgYmJveEhlaWdodF0pO1xuICAgIHRoaXMuI2ZpcnN0UG9pbnQgPSBbZmlyc3RQb2ludFgsIGZpcnN0UG9pbnRZXTtcbiAgICB0aGlzLiNsYXN0UG9pbnQgPSBsYXN0UG9pbnQ7XG4gIH1cbiAgZ2V0T3V0bGluZXMoKSB7XG4gICAgdGhpcy4jdmVydGljYWxFZGdlcy5zb3J0KChhLCBiKSA9PiBhWzBdIC0gYlswXSB8fCBhWzFdIC0gYlsxXSB8fCBhWzJdIC0gYlsyXSk7XG4gICAgY29uc3Qgb3V0bGluZVZlcnRpY2FsRWRnZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgdGhpcy4jdmVydGljYWxFZGdlcykge1xuICAgICAgaWYgKGVkZ2VbM10pIHtcbiAgICAgICAgb3V0bGluZVZlcnRpY2FsRWRnZXMucHVzaCguLi50aGlzLiNicmVha0VkZ2UoZWRnZSkpO1xuICAgICAgICB0aGlzLiNpbnNlcnQoZWRnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiNyZW1vdmUoZWRnZSk7XG4gICAgICAgIG91dGxpbmVWZXJ0aWNhbEVkZ2VzLnB1c2goLi4udGhpcy4jYnJlYWtFZGdlKGVkZ2UpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI2dldE91dGxpbmVzKG91dGxpbmVWZXJ0aWNhbEVkZ2VzKTtcbiAgfVxuICAjZ2V0T3V0bGluZXMob3V0bGluZVZlcnRpY2FsRWRnZXMpIHtcbiAgICBjb25zdCBlZGdlcyA9IFtdO1xuICAgIGNvbnN0IGFsbEVkZ2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IGVkZ2Ugb2Ygb3V0bGluZVZlcnRpY2FsRWRnZXMpIHtcbiAgICAgIGNvbnN0IFt4LCB5MSwgeTJdID0gZWRnZTtcbiAgICAgIGVkZ2VzLnB1c2goW3gsIHkxLCBlZGdlXSwgW3gsIHkyLCBlZGdlXSk7XG4gICAgfVxuICAgIGVkZ2VzLnNvcnQoKGEsIGIpID0+IGFbMV0gLSBiWzFdIHx8IGFbMF0gLSBiWzBdKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBlZGdlcy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBjb25zdCBlZGdlMSA9IGVkZ2VzW2ldWzJdO1xuICAgICAgY29uc3QgZWRnZTIgPSBlZGdlc1tpICsgMV1bMl07XG4gICAgICBlZGdlMS5wdXNoKGVkZ2UyKTtcbiAgICAgIGVkZ2UyLnB1c2goZWRnZTEpO1xuICAgICAgYWxsRWRnZXMuYWRkKGVkZ2UxKTtcbiAgICAgIGFsbEVkZ2VzLmFkZChlZGdlMik7XG4gICAgfVxuICAgIGNvbnN0IG91dGxpbmVzID0gW107XG4gICAgbGV0IG91dGxpbmU7XG4gICAgd2hpbGUgKGFsbEVkZ2VzLnNpemUgPiAwKSB7XG4gICAgICBjb25zdCBlZGdlID0gYWxsRWRnZXMudmFsdWVzKCkubmV4dCgpLnZhbHVlO1xuICAgICAgbGV0IFt4LCB5MSwgeTIsIGVkZ2UxLCBlZGdlMl0gPSBlZGdlO1xuICAgICAgYWxsRWRnZXMuZGVsZXRlKGVkZ2UpO1xuICAgICAgbGV0IGxhc3RQb2ludFggPSB4O1xuICAgICAgbGV0IGxhc3RQb2ludFkgPSB5MTtcbiAgICAgIG91dGxpbmUgPSBbeCwgeTJdO1xuICAgICAgb3V0bGluZXMucHVzaChvdXRsaW5lKTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxldCBlO1xuICAgICAgICBpZiAoYWxsRWRnZXMuaGFzKGVkZ2UxKSkge1xuICAgICAgICAgIGUgPSBlZGdlMTtcbiAgICAgICAgfSBlbHNlIGlmIChhbGxFZGdlcy5oYXMoZWRnZTIpKSB7XG4gICAgICAgICAgZSA9IGVkZ2UyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGFsbEVkZ2VzLmRlbGV0ZShlKTtcbiAgICAgICAgW3gsIHkxLCB5MiwgZWRnZTEsIGVkZ2UyXSA9IGU7XG4gICAgICAgIGlmIChsYXN0UG9pbnRYICE9PSB4KSB7XG4gICAgICAgICAgb3V0bGluZS5wdXNoKGxhc3RQb2ludFgsIGxhc3RQb2ludFksIHgsIGxhc3RQb2ludFkgPT09IHkxID8geTEgOiB5Mik7XG4gICAgICAgICAgbGFzdFBvaW50WCA9IHg7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFBvaW50WSA9IGxhc3RQb2ludFkgPT09IHkxID8geTIgOiB5MTtcbiAgICAgIH1cbiAgICAgIG91dGxpbmUucHVzaChsYXN0UG9pbnRYLCBsYXN0UG9pbnRZKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBIaWdobGlnaHRPdXRsaW5lKG91dGxpbmVzLCB0aGlzLiNib3gsIHRoaXMuI2ZpcnN0UG9pbnQsIHRoaXMuI2xhc3RQb2ludCk7XG4gIH1cbiAgI2JpbmFyeVNlYXJjaCh5KSB7XG4gICAgY29uc3QgYXJyYXkgPSB0aGlzLiNpbnRlcnZhbHM7XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBsZXQgZW5kID0gYXJyYXkubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoc3RhcnQgPD0gZW5kKSB7XG4gICAgICBjb25zdCBtaWRkbGUgPSBzdGFydCArIGVuZCA+PiAxO1xuICAgICAgY29uc3QgeTEgPSBhcnJheVttaWRkbGVdWzBdO1xuICAgICAgaWYgKHkxID09PSB5KSB7XG4gICAgICAgIHJldHVybiBtaWRkbGU7XG4gICAgICB9XG4gICAgICBpZiAoeTEgPCB5KSB7XG4gICAgICAgIHN0YXJ0ID0gbWlkZGxlICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZCA9IG1pZGRsZSAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbmQgKyAxO1xuICB9XG4gICNpbnNlcnQoWywgeTEsIHkyXSkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy4jYmluYXJ5U2VhcmNoKHkxKTtcbiAgICB0aGlzLiNpbnRlcnZhbHMuc3BsaWNlKGluZGV4LCAwLCBbeTEsIHkyXSk7XG4gIH1cbiAgI3JlbW92ZShbLCB5MSwgeTJdKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLiNiaW5hcnlTZWFyY2goeTEpO1xuICAgIGZvciAobGV0IGkgPSBpbmRleDsgaSA8IHRoaXMuI2ludGVydmFscy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gdGhpcy4jaW50ZXJ2YWxzW2ldO1xuICAgICAgaWYgKHN0YXJ0ICE9PSB5MSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCA9PT0geTEgJiYgZW5kID09PSB5Mikge1xuICAgICAgICB0aGlzLiNpbnRlcnZhbHMuc3BsaWNlKGksIDEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSBpbmRleCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSB0aGlzLiNpbnRlcnZhbHNbaV07XG4gICAgICBpZiAoc3RhcnQgIT09IHkxKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ID09PSB5MSAmJiBlbmQgPT09IHkyKSB7XG4gICAgICAgIHRoaXMuI2ludGVydmFscy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgI2JyZWFrRWRnZShlZGdlKSB7XG4gICAgY29uc3QgW3gsIHkxLCB5Ml0gPSBlZGdlO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbW3gsIHkxLCB5Ml1dO1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy4jYmluYXJ5U2VhcmNoKHkyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4OyBpKyspIHtcbiAgICAgIGNvbnN0IFtzdGFydCwgZW5kXSA9IHRoaXMuI2ludGVydmFsc1tpXTtcbiAgICAgIGZvciAobGV0IGogPSAwLCBqaiA9IHJlc3VsdHMubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICBjb25zdCBbLCB5MywgeTRdID0gcmVzdWx0c1tqXTtcbiAgICAgICAgaWYgKGVuZCA8PSB5MyB8fCB5NCA8PSBzdGFydCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5MyA+PSBzdGFydCkge1xuICAgICAgICAgIGlmICh5NCA+IGVuZCkge1xuICAgICAgICAgICAgcmVzdWx0c1tqXVsxXSA9IGVuZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGpqID09PSAxKSB7XG4gICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdHMuc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgamotLTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0c1tqXVsyXSA9IHN0YXJ0O1xuICAgICAgICBpZiAoeTQgPiBlbmQpIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2goW3gsIGVuZCwgeTRdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxufVxuY2xhc3MgSGlnaGxpZ2h0T3V0bGluZSBleHRlbmRzIE91dGxpbmUge1xuICAjYm94O1xuICAjb3V0bGluZXM7XG4gIGNvbnN0cnVjdG9yKG91dGxpbmVzLCBib3gsIGZpcnN0UG9pbnQsIGxhc3RQb2ludCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy4jb3V0bGluZXMgPSBvdXRsaW5lcztcbiAgICB0aGlzLiNib3ggPSBib3g7XG4gICAgdGhpcy5maXJzdFBvaW50ID0gZmlyc3RQb2ludDtcbiAgICB0aGlzLmxhc3RQb2ludCA9IGxhc3RQb2ludDtcbiAgfVxuICB0b1NWR1BhdGgoKSB7XG4gICAgY29uc3QgYnVmZmVyID0gW107XG4gICAgZm9yIChjb25zdCBwb2x5Z29uIG9mIHRoaXMuI291dGxpbmVzKSB7XG4gICAgICBsZXQgW3ByZXZYLCBwcmV2WV0gPSBwb2x5Z29uO1xuICAgICAgYnVmZmVyLnB1c2goYE0ke3ByZXZYfSAke3ByZXZZfWApO1xuICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCBwb2x5Z29uLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IHggPSBwb2x5Z29uW2ldO1xuICAgICAgICBjb25zdCB5ID0gcG9seWdvbltpICsgMV07XG4gICAgICAgIGlmICh4ID09PSBwcmV2WCkge1xuICAgICAgICAgIGJ1ZmZlci5wdXNoKGBWJHt5fWApO1xuICAgICAgICAgIHByZXZZID0geTtcbiAgICAgICAgfSBlbHNlIGlmICh5ID09PSBwcmV2WSkge1xuICAgICAgICAgIGJ1ZmZlci5wdXNoKGBIJHt4fWApO1xuICAgICAgICAgIHByZXZYID0geDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnVmZmVyLnB1c2goXCJaXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyLmpvaW4oXCIgXCIpO1xuICB9XG4gIHNlcmlhbGl6ZShbYmxYLCBibFksIHRyWCwgdHJZXSwgX3JvdGF0aW9uKSB7XG4gICAgY29uc3Qgb3V0bGluZXMgPSBbXTtcbiAgICBjb25zdCB3aWR0aCA9IHRyWCAtIGJsWDtcbiAgICBjb25zdCBoZWlnaHQgPSB0clkgLSBibFk7XG4gICAgZm9yIChjb25zdCBvdXRsaW5lIG9mIHRoaXMuI291dGxpbmVzKSB7XG4gICAgICBjb25zdCBwb2ludHMgPSBuZXcgQXJyYXkob3V0bGluZS5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRsaW5lLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHBvaW50c1tpXSA9IGJsWCArIG91dGxpbmVbaV0gKiB3aWR0aDtcbiAgICAgICAgcG9pbnRzW2kgKyAxXSA9IHRyWSAtIG91dGxpbmVbaSArIDFdICogaGVpZ2h0O1xuICAgICAgfVxuICAgICAgb3V0bGluZXMucHVzaChwb2ludHMpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0bGluZXM7XG4gIH1cbiAgZ2V0IGJveCgpIHtcbiAgICByZXR1cm4gdGhpcy4jYm94O1xuICB9XG4gIGdldCBjbGFzc05hbWVzRm9yT3V0bGluaW5nKCkge1xuICAgIHJldHVybiBbXCJoaWdobGlnaHRPdXRsaW5lXCJdO1xuICB9XG59XG5jbGFzcyBGcmVlSGlnaGxpZ2h0T3V0bGluZXIgZXh0ZW5kcyBGcmVlRHJhd091dGxpbmVyIHtcbiAgbmV3RnJlZURyYXdPdXRsaW5lKG91dGxpbmUsIHBvaW50cywgYm94LCBzY2FsZUZhY3RvciwgaW5uZXJNYXJnaW4sIGlzTFRSKSB7XG4gICAgcmV0dXJuIG5ldyBGcmVlSGlnaGxpZ2h0T3V0bGluZShvdXRsaW5lLCBwb2ludHMsIGJveCwgc2NhbGVGYWN0b3IsIGlubmVyTWFyZ2luLCBpc0xUUik7XG4gIH1cbn1cbmNsYXNzIEZyZWVIaWdobGlnaHRPdXRsaW5lIGV4dGVuZHMgRnJlZURyYXdPdXRsaW5lIHtcbiAgbmV3T3V0bGluZXIocG9pbnQsIGJveCwgc2NhbGVGYWN0b3IsIHRoaWNrbmVzcywgaXNMVFIsIGlubmVyTWFyZ2luID0gMCkge1xuICAgIHJldHVybiBuZXcgRnJlZUhpZ2hsaWdodE91dGxpbmVyKHBvaW50LCBib3gsIHNjYWxlRmFjdG9yLCB0aGlja25lc3MsIGlzTFRSLCBpbm5lck1hcmdpbik7XG4gIH1cbn1cbmNsYXNzIEhpZ2hsaWdodEVkaXRvciBleHRlbmRzIEFubm90YXRpb25FZGl0b3Ige1xuICAjYW5jaG9yTm9kZSA9IG51bGw7XG4gICNhbmNob3JPZmZzZXQgPSAwO1xuICAjYm94ZXM7XG4gICNjbGlwUGF0aElkID0gbnVsbDtcbiAgI2NvbG9yUGlja2VyID0gbnVsbDtcbiAgI2ZvY3VzT3V0bGluZXMgPSBudWxsO1xuICAjZm9jdXNOb2RlID0gbnVsbDtcbiAgI2ZvY3VzT2Zmc2V0ID0gMDtcbiAgI2hpZ2hsaWdodERpdiA9IG51bGw7XG4gICNoaWdobGlnaHRPdXRsaW5lcyA9IG51bGw7XG4gICNpZCA9IG51bGw7XG4gICNpc0ZyZWVIaWdobGlnaHQgPSBmYWxzZTtcbiAgI2ZpcnN0UG9pbnQgPSBudWxsO1xuICAjbGFzdFBvaW50ID0gbnVsbDtcbiAgI291dGxpbmVJZCA9IG51bGw7XG4gICN0ZXh0ID0gXCJcIjtcbiAgI3RoaWNrbmVzcztcbiAgI21ldGhvZE9mQ3JlYXRpb24gPSBcIlwiO1xuICBzdGF0aWMgX2RlZmF1bHRDb2xvciA9IG51bGw7XG4gIHN0YXRpYyBfZGVmYXVsdE9wYWNpdHkgPSAxO1xuICBzdGF0aWMgX2RlZmF1bHRUaGlja25lc3MgPSAxMjtcbiAgc3RhdGljIF90eXBlID0gXCJoaWdobGlnaHRcIjtcbiAgc3RhdGljIF9lZGl0b3JUeXBlID0gQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hUO1xuICBzdGF0aWMgX2ZyZWVIaWdobGlnaHRJZCA9IC0xO1xuICBzdGF0aWMgX2ZyZWVIaWdobGlnaHQgPSBudWxsO1xuICBzdGF0aWMgX2ZyZWVIaWdobGlnaHRDbGlwSWQgPSBcIlwiO1xuICBzdGF0aWMgZ2V0IF9rZXlib2FyZE1hbmFnZXIoKSB7XG4gICAgY29uc3QgcHJvdG8gPSBIaWdobGlnaHRFZGl0b3IucHJvdG90eXBlO1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfa2V5Ym9hcmRNYW5hZ2VyXCIsIG5ldyBLZXlib2FyZE1hbmFnZXIoW1tbXCJBcnJvd0xlZnRcIiwgXCJtYWMrQXJyb3dMZWZ0XCJdLCBwcm90by5fbW92ZUNhcmV0LCB7XG4gICAgICBhcmdzOiBbMF1cbiAgICB9XSwgW1tcIkFycm93UmlnaHRcIiwgXCJtYWMrQXJyb3dSaWdodFwiXSwgcHJvdG8uX21vdmVDYXJldCwge1xuICAgICAgYXJnczogWzFdXG4gICAgfV0sIFtbXCJBcnJvd1VwXCIsIFwibWFjK0Fycm93VXBcIl0sIHByb3RvLl9tb3ZlQ2FyZXQsIHtcbiAgICAgIGFyZ3M6IFsyXVxuICAgIH1dLCBbW1wiQXJyb3dEb3duXCIsIFwibWFjK0Fycm93RG93blwiXSwgcHJvdG8uX21vdmVDYXJldCwge1xuICAgICAgYXJnczogWzNdXG4gICAgfV1dKSk7XG4gIH1cbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ucGFyYW1zLFxuICAgICAgbmFtZTogXCJoaWdobGlnaHRFZGl0b3JcIlxuICAgIH0pO1xuICAgIHRoaXMuY29sb3IgPSBwYXJhbXMuY29sb3IgfHwgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0Q29sb3I7XG4gICAgdGhpcy4jdGhpY2tuZXNzID0gcGFyYW1zLnRoaWNrbmVzcyB8fCBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRUaGlja25lc3M7XG4gICAgdGhpcy5vcGFjaXR5ID0gcGFyYW1zLm9wYWNpdHkgfHwgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0T3BhY2l0eTtcbiAgICB0aGlzLiNib3hlcyA9IHBhcmFtcy5ib3hlcyB8fCBudWxsO1xuICAgIHRoaXMuI21ldGhvZE9mQ3JlYXRpb24gPSBwYXJhbXMubWV0aG9kT2ZDcmVhdGlvbiB8fCBcIlwiO1xuICAgIHRoaXMuI3RleHQgPSBwYXJhbXMudGV4dCB8fCBcIlwiO1xuICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5kZWZhdWx0TDEwbklkID0gXCJwZGZqcy1lZGl0b3ItaGlnaGxpZ2h0LWVkaXRvclwiO1xuICAgIGlmIChwYXJhbXMuaGlnaGxpZ2h0SWQgPiAtMSkge1xuICAgICAgdGhpcy4jaXNGcmVlSGlnaGxpZ2h0ID0gdHJ1ZTtcbiAgICAgIHRoaXMuI2NyZWF0ZUZyZWVPdXRsaW5lcyhwYXJhbXMpO1xuICAgICAgdGhpcy4jYWRkVG9EcmF3TGF5ZXIoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuI2JveGVzKSB7XG4gICAgICB0aGlzLiNhbmNob3JOb2RlID0gcGFyYW1zLmFuY2hvck5vZGU7XG4gICAgICB0aGlzLiNhbmNob3JPZmZzZXQgPSBwYXJhbXMuYW5jaG9yT2Zmc2V0O1xuICAgICAgdGhpcy4jZm9jdXNOb2RlID0gcGFyYW1zLmZvY3VzTm9kZTtcbiAgICAgIHRoaXMuI2ZvY3VzT2Zmc2V0ID0gcGFyYW1zLmZvY3VzT2Zmc2V0O1xuICAgICAgdGhpcy4jY3JlYXRlT3V0bGluZXMoKTtcbiAgICAgIHRoaXMuI2FkZFRvRHJhd0xheWVyKCk7XG4gICAgICB0aGlzLnJvdGF0ZSh0aGlzLnJvdGF0aW9uKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5hMTF5QWxlcnQoXCJwZGZqcy1lZGl0b3ItaGlnaGxpZ2h0LWFkZGVkLWFsZXJ0XCIpO1xuICAgIH1cbiAgfVxuICBnZXQgdGVsZW1ldHJ5SW5pdGlhbERhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFjdGlvbjogXCJhZGRlZFwiLFxuICAgICAgdHlwZTogdGhpcy4jaXNGcmVlSGlnaGxpZ2h0ID8gXCJmcmVlX2hpZ2hsaWdodFwiIDogXCJoaWdobGlnaHRcIixcbiAgICAgIGNvbG9yOiB0aGlzLl91aU1hbmFnZXIuZ2V0Tm9uSENNQ29sb3JOYW1lKHRoaXMuY29sb3IpLFxuICAgICAgdGhpY2tuZXNzOiB0aGlzLiN0aGlja25lc3MsXG4gICAgICBtZXRob2RPZkNyZWF0aW9uOiB0aGlzLiNtZXRob2RPZkNyZWF0aW9uXG4gICAgfTtcbiAgfVxuICBnZXQgdGVsZW1ldHJ5RmluYWxEYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImhpZ2hsaWdodFwiLFxuICAgICAgY29sb3I6IHRoaXMuX3VpTWFuYWdlci5nZXROb25IQ01Db2xvck5hbWUodGhpcy5jb2xvcilcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBjb21wdXRlVGVsZW1ldHJ5RmluYWxEYXRhKGRhdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbnVtYmVyT2ZDb2xvcnM6IGRhdGEuZ2V0KFwiY29sb3JcIikuc2l6ZVxuICAgIH07XG4gIH1cbiAgI2NyZWF0ZU91dGxpbmVzKCkge1xuICAgIGNvbnN0IG91dGxpbmVyID0gbmV3IEhpZ2hsaWdodE91dGxpbmVyKHRoaXMuI2JveGVzLCAxZS0zKTtcbiAgICB0aGlzLiNoaWdobGlnaHRPdXRsaW5lcyA9IG91dGxpbmVyLmdldE91dGxpbmVzKCk7XG4gICAgW3RoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodF0gPSB0aGlzLiNoaWdobGlnaHRPdXRsaW5lcy5ib3g7XG4gICAgY29uc3Qgb3V0bGluZXJGb3JPdXRsaW5lID0gbmV3IEhpZ2hsaWdodE91dGxpbmVyKHRoaXMuI2JveGVzLCAyNWUtNCwgMWUtMywgdGhpcy5fdWlNYW5hZ2VyLmRpcmVjdGlvbiA9PT0gXCJsdHJcIik7XG4gICAgdGhpcy4jZm9jdXNPdXRsaW5lcyA9IG91dGxpbmVyRm9yT3V0bGluZS5nZXRPdXRsaW5lcygpO1xuICAgIGNvbnN0IHtcbiAgICAgIGZpcnN0UG9pbnRcbiAgICB9ID0gdGhpcy4jaGlnaGxpZ2h0T3V0bGluZXM7XG4gICAgdGhpcy4jZmlyc3RQb2ludCA9IFsoZmlyc3RQb2ludFswXSAtIHRoaXMueCkgLyB0aGlzLndpZHRoLCAoZmlyc3RQb2ludFsxXSAtIHRoaXMueSkgLyB0aGlzLmhlaWdodF07XG4gICAgY29uc3Qge1xuICAgICAgbGFzdFBvaW50XG4gICAgfSA9IHRoaXMuI2ZvY3VzT3V0bGluZXM7XG4gICAgdGhpcy4jbGFzdFBvaW50ID0gWyhsYXN0UG9pbnRbMF0gLSB0aGlzLngpIC8gdGhpcy53aWR0aCwgKGxhc3RQb2ludFsxXSAtIHRoaXMueSkgLyB0aGlzLmhlaWdodF07XG4gIH1cbiAgI2NyZWF0ZUZyZWVPdXRsaW5lcyh7XG4gICAgaGlnaGxpZ2h0T3V0bGluZXMsXG4gICAgaGlnaGxpZ2h0SWQsXG4gICAgY2xpcFBhdGhJZFxuICB9KSB7XG4gICAgdGhpcy4jaGlnaGxpZ2h0T3V0bGluZXMgPSBoaWdobGlnaHRPdXRsaW5lcztcbiAgICBjb25zdCBleHRyYVRoaWNrbmVzcyA9IDEuNTtcbiAgICB0aGlzLiNmb2N1c091dGxpbmVzID0gaGlnaGxpZ2h0T3V0bGluZXMuZ2V0TmV3T3V0bGluZSh0aGlzLiN0aGlja25lc3MgLyAyICsgZXh0cmFUaGlja25lc3MsIDI1ZS00KTtcbiAgICBpZiAoaGlnaGxpZ2h0SWQgPj0gMCkge1xuICAgICAgdGhpcy4jaWQgPSBoaWdobGlnaHRJZDtcbiAgICAgIHRoaXMuI2NsaXBQYXRoSWQgPSBjbGlwUGF0aElkO1xuICAgICAgdGhpcy5wYXJlbnQuZHJhd0xheWVyLmZpbmFsaXplRHJhdyhoaWdobGlnaHRJZCwge1xuICAgICAgICBiYm94OiBoaWdobGlnaHRPdXRsaW5lcy5ib3gsXG4gICAgICAgIHBhdGg6IHtcbiAgICAgICAgICBkOiBoaWdobGlnaHRPdXRsaW5lcy50b1NWR1BhdGgoKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuI291dGxpbmVJZCA9IHRoaXMucGFyZW50LmRyYXdMYXllci5kcmF3T3V0bGluZSh7XG4gICAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICAgIGhpZ2hsaWdodE91dGxpbmU6IHRydWUsXG4gICAgICAgICAgZnJlZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBiYm94OiB0aGlzLiNmb2N1c091dGxpbmVzLmJveCxcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIGQ6IHRoaXMuI2ZvY3VzT3V0bGluZXMudG9TVkdQYXRoKClcbiAgICAgICAgfVxuICAgICAgfSwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgY29uc3QgYW5nbGUgPSB0aGlzLnBhcmVudC52aWV3cG9ydC5yb3RhdGlvbjtcbiAgICAgIHRoaXMucGFyZW50LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuI2lkLCB7XG4gICAgICAgIGJib3g6IEhpZ2hsaWdodEVkaXRvci4jcm90YXRlQmJveCh0aGlzLiNoaWdobGlnaHRPdXRsaW5lcy5ib3gsIChhbmdsZSAtIHRoaXMucm90YXRpb24gKyAzNjApICUgMzYwKSxcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIGQ6IGhpZ2hsaWdodE91dGxpbmVzLnRvU1ZHUGF0aCgpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5wYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy4jb3V0bGluZUlkLCB7XG4gICAgICAgIGJib3g6IEhpZ2hsaWdodEVkaXRvci4jcm90YXRlQmJveCh0aGlzLiNmb2N1c091dGxpbmVzLmJveCwgYW5nbGUpLFxuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgZDogdGhpcy4jZm9jdXNPdXRsaW5lcy50b1NWR1BhdGgoKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gaGlnaGxpZ2h0T3V0bGluZXMuYm94O1xuICAgIHN3aXRjaCAodGhpcy5yb3RhdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgOTA6IHtcbiAgICAgICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgICAgIHRoaXMueCA9IHk7XG4gICAgICAgIHRoaXMueSA9IDEgLSB4O1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGggKiBwYWdlSGVpZ2h0IC8gcGFnZVdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAqIHBhZ2VXaWR0aCAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHRoaXMueCA9IDEgLSB4O1xuICAgICAgICB0aGlzLnkgPSAxIC0geTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI3MDoge1xuICAgICAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICAgICAgdGhpcy54ID0gMSAtIHk7XG4gICAgICAgIHRoaXMueSA9IHg7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aCAqIHBhZ2VIZWlnaHQgLyBwYWdlV2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0ICogcGFnZVdpZHRoIC8gcGFnZUhlaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGZpcnN0UG9pbnRcbiAgICB9ID0gaGlnaGxpZ2h0T3V0bGluZXM7XG4gICAgdGhpcy4jZmlyc3RQb2ludCA9IFsoZmlyc3RQb2ludFswXSAtIHgpIC8gd2lkdGgsIChmaXJzdFBvaW50WzFdIC0geSkgLyBoZWlnaHRdO1xuICAgIGNvbnN0IHtcbiAgICAgIGxhc3RQb2ludFxuICAgIH0gPSB0aGlzLiNmb2N1c091dGxpbmVzO1xuICAgIHRoaXMuI2xhc3RQb2ludCA9IFsobGFzdFBvaW50WzBdIC0geCkgLyB3aWR0aCwgKGxhc3RQb2ludFsxXSAtIHkpIC8gaGVpZ2h0XTtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuLCB1aU1hbmFnZXIpIHtcbiAgICBBbm5vdGF0aW9uRWRpdG9yLmluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKTtcbiAgICBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRDb2xvciB8fD0gdWlNYW5hZ2VyLmhpZ2hsaWdodENvbG9ycz8udmFsdWVzKCkubmV4dCgpLnZhbHVlIHx8IFwiI2ZmZjA2NlwiO1xuICB9XG4gIHN0YXRpYyB1cGRhdGVEZWZhdWx0UGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9DT0xPUjpcbiAgICAgICAgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0Q29sb3IgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9USElDS05FU1M6XG4gICAgICAgIEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdFRoaWNrbmVzcyA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdHJhbnNsYXRlSW5QYWdlKHgsIHkpIHtcbiAgfVxuICBnZXQgdG9vbGJhclBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLiNsYXN0UG9pbnQ7XG4gIH1cbiAgZ2V0IGNvbW1lbnRCdXR0b25Qb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy4jZmlyc3RQb2ludDtcbiAgfVxuICB1cGRhdGVQYXJhbXModHlwZSwgdmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX0NPTE9SOlxuICAgICAgICB0aGlzLiN1cGRhdGVDb2xvcih2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfVEhJQ0tORVNTOlxuICAgICAgICB0aGlzLiN1cGRhdGVUaGlja25lc3ModmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldCBkZWZhdWx0UHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIHJldHVybiBbW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9DT0xPUiwgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0Q29sb3JdLCBbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX1RISUNLTkVTUywgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0VGhpY2tuZXNzXV07XG4gIH1cbiAgZ2V0IHByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW1tBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfQ09MT1IsIHRoaXMuY29sb3IgfHwgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0Q29sb3JdLCBbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX1RISUNLTkVTUywgdGhpcy4jdGhpY2tuZXNzIHx8IEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdFRoaWNrbmVzc10sIFtBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfRlJFRSwgdGhpcy4jaXNGcmVlSGlnaGxpZ2h0XV07XG4gIH1cbiAgb25VcGRhdGVkQ29sb3IoKSB7XG4gICAgdGhpcy5wYXJlbnQ/LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuI2lkLCB7XG4gICAgICByb290OiB7XG4gICAgICAgIGZpbGw6IHRoaXMuY29sb3IsXG4gICAgICAgIFwiZmlsbC1vcGFjaXR5XCI6IHRoaXMub3BhY2l0eVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuI2NvbG9yUGlja2VyPy51cGRhdGVDb2xvcih0aGlzLmNvbG9yKTtcbiAgICBzdXBlci5vblVwZGF0ZWRDb2xvcigpO1xuICB9XG4gICN1cGRhdGVDb2xvcihjb2xvcikge1xuICAgIGNvbnN0IHNldENvbG9yQW5kT3BhY2l0eSA9IChjb2wsIG9wYSkgPT4ge1xuICAgICAgdGhpcy5jb2xvciA9IGNvbDtcbiAgICAgIHRoaXMub3BhY2l0eSA9IG9wYTtcbiAgICAgIHRoaXMub25VcGRhdGVkQ29sb3IoKTtcbiAgICB9O1xuICAgIGNvbnN0IHNhdmVkQ29sb3IgPSB0aGlzLmNvbG9yO1xuICAgIGNvbnN0IHNhdmVkT3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogc2V0Q29sb3JBbmRPcGFjaXR5LmJpbmQodGhpcywgY29sb3IsIEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdE9wYWNpdHkpLFxuICAgICAgdW5kbzogc2V0Q29sb3JBbmRPcGFjaXR5LmJpbmQodGhpcywgc2F2ZWRDb2xvciwgc2F2ZWRPcGFjaXR5KSxcbiAgICAgIHBvc3Q6IHRoaXMuX3VpTWFuYWdlci51cGRhdGVVSS5iaW5kKHRoaXMuX3VpTWFuYWdlciwgdGhpcyksXG4gICAgICBtdXN0RXhlYzogdHJ1ZSxcbiAgICAgIHR5cGU6IEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9DT0xPUixcbiAgICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGU6IHRydWUsXG4gICAgICBrZWVwVW5kbzogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuX3JlcG9ydFRlbGVtZXRyeSh7XG4gICAgICBhY3Rpb246IFwiY29sb3JfY2hhbmdlZFwiLFxuICAgICAgY29sb3I6IHRoaXMuX3VpTWFuYWdlci5nZXROb25IQ01Db2xvck5hbWUoY29sb3IpXG4gICAgfSwgdHJ1ZSk7XG4gIH1cbiAgI3VwZGF0ZVRoaWNrbmVzcyh0aGlja25lc3MpIHtcbiAgICBjb25zdCBzYXZlZFRoaWNrbmVzcyA9IHRoaXMuI3RoaWNrbmVzcztcbiAgICBjb25zdCBzZXRUaGlja25lc3MgPSAodGgpID0+IHtcbiAgICAgIHRoaXMuI3RoaWNrbmVzcyA9IHRoO1xuICAgICAgdGhpcy4jY2hhbmdlVGhpY2tuZXNzKHRoKTtcbiAgICB9O1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiBzZXRUaGlja25lc3MuYmluZCh0aGlzLCB0aGlja25lc3MpLFxuICAgICAgdW5kbzogc2V0VGhpY2tuZXNzLmJpbmQodGhpcywgc2F2ZWRUaGlja25lc3MpLFxuICAgICAgcG9zdDogdGhpcy5fdWlNYW5hZ2VyLnVwZGF0ZVVJLmJpbmQodGhpcy5fdWlNYW5hZ2VyLCB0aGlzKSxcbiAgICAgIG11c3RFeGVjOiB0cnVlLFxuICAgICAgdHlwZTogQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX1RISUNLTkVTUyxcbiAgICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGU6IHRydWUsXG4gICAgICBrZWVwVW5kbzogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuX3JlcG9ydFRlbGVtZXRyeSh7XG4gICAgICBhY3Rpb246IFwidGhpY2tuZXNzX2NoYW5nZWRcIixcbiAgICAgIHRoaWNrbmVzc1xuICAgIH0sIHRydWUpO1xuICB9XG4gIGdldCB0b29sYmFyQnV0dG9ucygpIHtcbiAgICBpZiAodGhpcy5fdWlNYW5hZ2VyLmhpZ2hsaWdodENvbG9ycykge1xuICAgICAgY29uc3QgY29sb3JQaWNrZXIgPSB0aGlzLiNjb2xvclBpY2tlciA9IG5ldyBDb2xvclBpY2tlcih7XG4gICAgICAgIGVkaXRvcjogdGhpc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gW1tcImNvbG9yUGlja2VyXCIsIGNvbG9yUGlja2VyXV07XG4gICAgfVxuICAgIHJldHVybiBzdXBlci50b29sYmFyQnV0dG9ucztcbiAgfVxuICBkaXNhYmxlRWRpdGluZygpIHtcbiAgICBzdXBlci5kaXNhYmxlRWRpdGluZygpO1xuICAgIHRoaXMuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJkaXNhYmxlZFwiLCB0cnVlKTtcbiAgfVxuICBlbmFibGVFZGl0aW5nKCkge1xuICAgIHN1cGVyLmVuYWJsZUVkaXRpbmcoKTtcbiAgICB0aGlzLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiZGlzYWJsZWRcIiwgZmFsc2UpO1xuICB9XG4gIGZpeEFuZFNldFBvc2l0aW9uKCkge1xuICAgIHJldHVybiBzdXBlci5maXhBbmRTZXRQb3NpdGlvbih0aGlzLiNnZXRSb3RhdGlvbigpKTtcbiAgfVxuICBnZXRCYXNlVHJhbnNsYXRpb24oKSB7XG4gICAgcmV0dXJuIFswLCAwXTtcbiAgfVxuICBnZXRSZWN0KHR4LCB0eSkge1xuICAgIHJldHVybiBzdXBlci5nZXRSZWN0KHR4LCB0eSwgdGhpcy4jZ2V0Um90YXRpb24oKSk7XG4gIH1cbiAgb25jZUFkZGVkKGZvY3VzKSB7XG4gICAgaWYgKCF0aGlzLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIHRoaXMucGFyZW50LmFkZFVuZG9hYmxlRWRpdG9yKHRoaXMpO1xuICAgIH1cbiAgICBpZiAoZm9jdXMpIHtcbiAgICAgIHRoaXMuZGl2LmZvY3VzKCk7XG4gICAgfVxuICB9XG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLiNjbGVhbkRyYXdMYXllcigpO1xuICAgIHRoaXMuX3JlcG9ydFRlbGVtZXRyeSh7XG4gICAgICBhY3Rpb246IFwiZGVsZXRlZFwiXG4gICAgfSk7XG4gICAgc3VwZXIucmVtb3ZlKCk7XG4gIH1cbiAgcmVidWlsZCgpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLnJlYnVpbGQoKTtcbiAgICBpZiAodGhpcy5kaXYgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYWRkVG9EcmF3TGF5ZXIoKTtcbiAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICB0aGlzLnBhcmVudC5hZGQodGhpcyk7XG4gICAgfVxuICB9XG4gIHNldFBhcmVudChwYXJlbnQpIHtcbiAgICBsZXQgbXVzdEJlU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5wYXJlbnQgJiYgIXBhcmVudCkge1xuICAgICAgdGhpcy4jY2xlYW5EcmF3TGF5ZXIoKTtcbiAgICB9IGVsc2UgaWYgKHBhcmVudCkge1xuICAgICAgdGhpcy4jYWRkVG9EcmF3TGF5ZXIocGFyZW50KTtcbiAgICAgIG11c3RCZVNlbGVjdGVkID0gIXRoaXMucGFyZW50ICYmIHRoaXMuZGl2Py5jbGFzc0xpc3QuY29udGFpbnMoXCJzZWxlY3RlZEVkaXRvclwiKTtcbiAgICB9XG4gICAgc3VwZXIuc2V0UGFyZW50KHBhcmVudCk7XG4gICAgdGhpcy5zaG93KHRoaXMuX2lzVmlzaWJsZSk7XG4gICAgaWYgKG11c3RCZVNlbGVjdGVkKSB7XG4gICAgICB0aGlzLnNlbGVjdCgpO1xuICAgIH1cbiAgfVxuICAjY2hhbmdlVGhpY2tuZXNzKHRoaWNrbmVzcykge1xuICAgIGlmICghdGhpcy4jaXNGcmVlSGlnaGxpZ2h0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NyZWF0ZUZyZWVPdXRsaW5lcyh7XG4gICAgICBoaWdobGlnaHRPdXRsaW5lczogdGhpcy4jaGlnaGxpZ2h0T3V0bGluZXMuZ2V0TmV3T3V0bGluZSh0aGlja25lc3MgLyAyKVxuICAgIH0pO1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICB0aGlzLnNldERpbXModGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICB9XG4gICNjbGVhbkRyYXdMYXllcigpIHtcbiAgICBpZiAodGhpcy4jaWQgPT09IG51bGwgfHwgIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGFyZW50LmRyYXdMYXllci5yZW1vdmUodGhpcy4jaWQpO1xuICAgIHRoaXMuI2lkID0gbnVsbDtcbiAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIucmVtb3ZlKHRoaXMuI291dGxpbmVJZCk7XG4gICAgdGhpcy4jb3V0bGluZUlkID0gbnVsbDtcbiAgfVxuICAjYWRkVG9EcmF3TGF5ZXIocGFyZW50ID0gdGhpcy5wYXJlbnQpIHtcbiAgICBpZiAodGhpcy4jaWQgIT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgKHtcbiAgICAgIGlkOiB0aGlzLiNpZCxcbiAgICAgIGNsaXBQYXRoSWQ6IHRoaXMuI2NsaXBQYXRoSWRcbiAgICB9ID0gcGFyZW50LmRyYXdMYXllci5kcmF3KHtcbiAgICAgIGJib3g6IHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzLmJveCxcbiAgICAgIHJvb3Q6IHtcbiAgICAgICAgdmlld0JveDogXCIwIDAgMSAxXCIsXG4gICAgICAgIGZpbGw6IHRoaXMuY29sb3IsXG4gICAgICAgIFwiZmlsbC1vcGFjaXR5XCI6IHRoaXMub3BhY2l0eVxuICAgICAgfSxcbiAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICBoaWdobGlnaHQ6IHRydWUsXG4gICAgICAgIGZyZWU6IHRoaXMuI2lzRnJlZUhpZ2hsaWdodFxuICAgICAgfSxcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgZDogdGhpcy4jaGlnaGxpZ2h0T3V0bGluZXMudG9TVkdQYXRoKClcbiAgICAgIH1cbiAgICB9LCBmYWxzZSwgdHJ1ZSkpO1xuICAgIHRoaXMuI291dGxpbmVJZCA9IHBhcmVudC5kcmF3TGF5ZXIuZHJhd091dGxpbmUoe1xuICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgIGhpZ2hsaWdodE91dGxpbmU6IHRydWUsXG4gICAgICAgIGZyZWU6IHRoaXMuI2lzRnJlZUhpZ2hsaWdodFxuICAgICAgfSxcbiAgICAgIGJib3g6IHRoaXMuI2ZvY3VzT3V0bGluZXMuYm94LFxuICAgICAgcGF0aDoge1xuICAgICAgICBkOiB0aGlzLiNmb2N1c091dGxpbmVzLnRvU1ZHUGF0aCgpXG4gICAgICB9XG4gICAgfSwgdGhpcy4jaXNGcmVlSGlnaGxpZ2h0KTtcbiAgICBpZiAodGhpcy4jaGlnaGxpZ2h0RGl2KSB7XG4gICAgICB0aGlzLiNoaWdobGlnaHREaXYuc3R5bGUuY2xpcFBhdGggPSB0aGlzLiNjbGlwUGF0aElkO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgI3JvdGF0ZUJib3goW3gsIHksIHdpZHRoLCBoZWlnaHRdLCBhbmdsZSkge1xuICAgIHN3aXRjaCAoYW5nbGUpIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbMSAtIHkgLSBoZWlnaHQsIHgsIGhlaWdodCwgd2lkdGhdO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbMSAtIHggLSB3aWR0aCwgMSAtIHkgLSBoZWlnaHQsIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbeSwgMSAtIHggLSB3aWR0aCwgaGVpZ2h0LCB3aWR0aF07XG4gICAgfVxuICAgIHJldHVybiBbeCwgeSwgd2lkdGgsIGhlaWdodF07XG4gIH1cbiAgcm90YXRlKGFuZ2xlKSB7XG4gICAgY29uc3Qge1xuICAgICAgZHJhd0xheWVyXG4gICAgfSA9IHRoaXMucGFyZW50O1xuICAgIGxldCBib3g7XG4gICAgaWYgKHRoaXMuI2lzRnJlZUhpZ2hsaWdodCkge1xuICAgICAgYW5nbGUgPSAoYW5nbGUgLSB0aGlzLnJvdGF0aW9uICsgMzYwKSAlIDM2MDtcbiAgICAgIGJveCA9IEhpZ2hsaWdodEVkaXRvci4jcm90YXRlQmJveCh0aGlzLiNoaWdobGlnaHRPdXRsaW5lcy5ib3gsIGFuZ2xlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm94ID0gSGlnaGxpZ2h0RWRpdG9yLiNyb3RhdGVCYm94KFt0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHRdLCBhbmdsZSk7XG4gICAgfVxuICAgIGRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuI2lkLCB7XG4gICAgICBiYm94OiBib3gsXG4gICAgICByb290OiB7XG4gICAgICAgIFwiZGF0YS1tYWluLXJvdGF0aW9uXCI6IGFuZ2xlXG4gICAgICB9XG4gICAgfSk7XG4gICAgZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy4jb3V0bGluZUlkLCB7XG4gICAgICBiYm94OiBIaWdobGlnaHRFZGl0b3IuI3JvdGF0ZUJib3godGhpcy4jZm9jdXNPdXRsaW5lcy5ib3gsIGFuZ2xlKSxcbiAgICAgIHJvb3Q6IHtcbiAgICAgICAgXCJkYXRhLW1haW4tcm90YXRpb25cIjogYW5nbGVcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXY7XG4gICAgfVxuICAgIGNvbnN0IGRpdiA9IHN1cGVyLnJlbmRlcigpO1xuICAgIGlmICh0aGlzLiN0ZXh0KSB7XG4gICAgICBkaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCB0aGlzLiN0ZXh0KTtcbiAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwibWFya1wiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2lzRnJlZUhpZ2hsaWdodCkge1xuICAgICAgZGl2LmNsYXNzTGlzdC5hZGQoXCJmcmVlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNrZXlkb3duLmJpbmQodGhpcyksIHtcbiAgICAgICAgc2lnbmFsOiB0aGlzLl91aU1hbmFnZXIuX3NpZ25hbFxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGhpZ2hsaWdodERpdiA9IHRoaXMuI2hpZ2hsaWdodERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZGl2LmFwcGVuZChoaWdobGlnaHREaXYpO1xuICAgIGhpZ2hsaWdodERpdi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgaGlnaGxpZ2h0RGl2LmNsYXNzTmFtZSA9IFwiaW50ZXJuYWxcIjtcbiAgICBoaWdobGlnaHREaXYuc3R5bGUuY2xpcFBhdGggPSB0aGlzLiNjbGlwUGF0aElkO1xuICAgIHRoaXMuc2V0RGltcyh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgYmluZEV2ZW50cyh0aGlzLCB0aGlzLiNoaWdobGlnaHREaXYsIFtcInBvaW50ZXJvdmVyXCIsIFwicG9pbnRlcmxlYXZlXCJdKTtcbiAgICB0aGlzLmVuYWJsZUVkaXRpbmcoKTtcbiAgICByZXR1cm4gZGl2O1xuICB9XG4gIHBvaW50ZXJvdmVyKCkge1xuICAgIGlmICghdGhpcy5pc1NlbGVjdGVkKSB7XG4gICAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy4jb3V0bGluZUlkLCB7XG4gICAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICAgIGhvdmVyZWQ6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHBvaW50ZXJsZWF2ZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNTZWxlY3RlZCkge1xuICAgICAgdGhpcy5wYXJlbnQ/LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuI291dGxpbmVJZCwge1xuICAgICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgICBob3ZlcmVkOiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgI2tleWRvd24oZXZlbnQpIHtcbiAgICBIaWdobGlnaHRFZGl0b3IuX2tleWJvYXJkTWFuYWdlci5leGVjKHRoaXMsIGV2ZW50KTtcbiAgfVxuICBfbW92ZUNhcmV0KGRpcmVjdGlvbikge1xuICAgIHRoaXMucGFyZW50LnVuc2VsZWN0KHRoaXMpO1xuICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHRoaXMuI3NldENhcmV0KHRydWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgdGhpcy4jc2V0Q2FyZXQoZmFsc2UpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgI3NldENhcmV0KHN0YXJ0KSB7XG4gICAgaWYgKCF0aGlzLiNhbmNob3JOb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgIHNlbGVjdGlvbi5zZXRQb3NpdGlvbih0aGlzLiNhbmNob3JOb2RlLCB0aGlzLiNhbmNob3JPZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3Rpb24uc2V0UG9zaXRpb24odGhpcy4jZm9jdXNOb2RlLCB0aGlzLiNmb2N1c09mZnNldCk7XG4gICAgfVxuICB9XG4gIHNlbGVjdCgpIHtcbiAgICBzdXBlci5zZWxlY3QoKTtcbiAgICBpZiAoIXRoaXMuI291dGxpbmVJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy4jb3V0bGluZUlkLCB7XG4gICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgaG92ZXJlZDogZmFsc2UsXG4gICAgICAgIHNlbGVjdGVkOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgdW5zZWxlY3QoKSB7XG4gICAgc3VwZXIudW5zZWxlY3QoKTtcbiAgICBpZiAoIXRoaXMuI291dGxpbmVJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy4jb3V0bGluZUlkLCB7XG4gICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgc2VsZWN0ZWQ6IGZhbHNlXG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCF0aGlzLiNpc0ZyZWVIaWdobGlnaHQpIHtcbiAgICAgIHRoaXMuI3NldENhcmV0KGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgZ2V0IF9tdXN0Rml4UG9zaXRpb24oKSB7XG4gICAgcmV0dXJuICF0aGlzLiNpc0ZyZWVIaWdobGlnaHQ7XG4gIH1cbiAgc2hvdyh2aXNpYmxlID0gdGhpcy5faXNWaXNpYmxlKSB7XG4gICAgc3VwZXIuc2hvdyh2aXNpYmxlKTtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuI2lkLCB7XG4gICAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICAgIGhpZGRlbjogIXZpc2libGVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLiNvdXRsaW5lSWQsIHtcbiAgICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgICAgaGlkZGVuOiAhdmlzaWJsZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgI2dldFJvdGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLiNpc0ZyZWVIaWdobGlnaHQgPyB0aGlzLnJvdGF0aW9uIDogMDtcbiAgfVxuICAjc2VyaWFsaXplQm94ZXMoKSB7XG4gICAgaWYgKHRoaXMuI2lzRnJlZUhpZ2hsaWdodCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICBjb25zdCBbcGFnZVgsIHBhZ2VZXSA9IHRoaXMucGFnZVRyYW5zbGF0aW9uO1xuICAgIGNvbnN0IGJveGVzID0gdGhpcy4jYm94ZXM7XG4gICAgY29uc3QgcXVhZFBvaW50cyA9IG5ldyBGbG9hdDMyQXJyYXkoYm94ZXMubGVuZ3RoICogOCk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gb2YgYm94ZXMpIHtcbiAgICAgIGNvbnN0IHN4ID0geCAqIHBhZ2VXaWR0aCArIHBhZ2VYO1xuICAgICAgY29uc3Qgc3kgPSAoMSAtIHkpICogcGFnZUhlaWdodCArIHBhZ2VZO1xuICAgICAgcXVhZFBvaW50c1tpXSA9IHF1YWRQb2ludHNbaSArIDRdID0gc3g7XG4gICAgICBxdWFkUG9pbnRzW2kgKyAxXSA9IHF1YWRQb2ludHNbaSArIDNdID0gc3k7XG4gICAgICBxdWFkUG9pbnRzW2kgKyAyXSA9IHF1YWRQb2ludHNbaSArIDZdID0gc3ggKyB3aWR0aCAqIHBhZ2VXaWR0aDtcbiAgICAgIHF1YWRQb2ludHNbaSArIDVdID0gcXVhZFBvaW50c1tpICsgN10gPSBzeSAtIGhlaWdodCAqIHBhZ2VIZWlnaHQ7XG4gICAgICBpICs9IDg7XG4gICAgfVxuICAgIHJldHVybiBxdWFkUG9pbnRzO1xuICB9XG4gICNzZXJpYWxpemVPdXRsaW5lcyhyZWN0KSB7XG4gICAgcmV0dXJuIHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzLnNlcmlhbGl6ZShyZWN0LCB0aGlzLiNnZXRSb3RhdGlvbigpKTtcbiAgfVxuICBzdGF0aWMgc3RhcnRIaWdobGlnaHRpbmcocGFyZW50LCBpc0xUUiwge1xuICAgIHRhcmdldDogdGV4dExheWVyLFxuICAgIHgsXG4gICAgeVxuICB9KSB7XG4gICAgY29uc3Qge1xuICAgICAgeDogbGF5ZXJYLFxuICAgICAgeTogbGF5ZXJZLFxuICAgICAgd2lkdGg6IHBhcmVudFdpZHRoLFxuICAgICAgaGVpZ2h0OiBwYXJlbnRIZWlnaHRcbiAgICB9ID0gdGV4dExheWVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHBhcmVudC5jb21iaW5lZFNpZ25hbChhYyk7XG4gICAgY29uc3QgcG9pbnRlclVwQ2FsbGJhY2sgPSAoZSkgPT4ge1xuICAgICAgYWMuYWJvcnQoKTtcbiAgICAgIHRoaXMuI2VuZEhpZ2hsaWdodChwYXJlbnQsIGUpO1xuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHBvaW50ZXJVcENhbGxiYWNrLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBwb2ludGVyVXBDYWxsYmFjaywge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBzdG9wRXZlbnQsIHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGV4dExheWVyLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCB0aGlzLiNoaWdobGlnaHRNb3ZlLmJpbmQodGhpcywgcGFyZW50KSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy5fZnJlZUhpZ2hsaWdodCA9IG5ldyBGcmVlSGlnaGxpZ2h0T3V0bGluZXIoe1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9LCBbbGF5ZXJYLCBsYXllclksIHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdLCBwYXJlbnQuc2NhbGUsIHRoaXMuX2RlZmF1bHRUaGlja25lc3MgLyAyLCBpc0xUUiwgMWUtMyk7XG4gICAgKHtcbiAgICAgIGlkOiB0aGlzLl9mcmVlSGlnaGxpZ2h0SWQsXG4gICAgICBjbGlwUGF0aElkOiB0aGlzLl9mcmVlSGlnaGxpZ2h0Q2xpcElkXG4gICAgfSA9IHBhcmVudC5kcmF3TGF5ZXIuZHJhdyh7XG4gICAgICBiYm94OiBbMCwgMCwgMSwgMV0sXG4gICAgICByb290OiB7XG4gICAgICAgIHZpZXdCb3g6IFwiMCAwIDEgMVwiLFxuICAgICAgICBmaWxsOiB0aGlzLl9kZWZhdWx0Q29sb3IsXG4gICAgICAgIFwiZmlsbC1vcGFjaXR5XCI6IHRoaXMuX2RlZmF1bHRPcGFjaXR5XG4gICAgICB9LFxuICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgIGhpZ2hsaWdodDogdHJ1ZSxcbiAgICAgICAgZnJlZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgZDogdGhpcy5fZnJlZUhpZ2hsaWdodC50b1NWR1BhdGgoKVxuICAgICAgfVxuICAgIH0sIHRydWUsIHRydWUpKTtcbiAgfVxuICBzdGF0aWMgI2hpZ2hsaWdodE1vdmUocGFyZW50LCBldmVudCkge1xuICAgIGlmICh0aGlzLl9mcmVlSGlnaGxpZ2h0LmFkZChldmVudCkpIHtcbiAgICAgIHBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9mcmVlSGlnaGxpZ2h0SWQsIHtcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIGQ6IHRoaXMuX2ZyZWVIaWdobGlnaHQudG9TVkdQYXRoKClcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyAjZW5kSGlnaGxpZ2h0KHBhcmVudCwgZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX2ZyZWVIaWdobGlnaHQuaXNFbXB0eSgpKSB7XG4gICAgICBwYXJlbnQuY3JlYXRlQW5kQWRkTmV3RWRpdG9yKGV2ZW50LCBmYWxzZSwge1xuICAgICAgICBoaWdobGlnaHRJZDogdGhpcy5fZnJlZUhpZ2hsaWdodElkLFxuICAgICAgICBoaWdobGlnaHRPdXRsaW5lczogdGhpcy5fZnJlZUhpZ2hsaWdodC5nZXRPdXRsaW5lcygpLFxuICAgICAgICBjbGlwUGF0aElkOiB0aGlzLl9mcmVlSGlnaGxpZ2h0Q2xpcElkLFxuICAgICAgICBtZXRob2RPZkNyZWF0aW9uOiBcIm1haW5fdG9vbGJhclwiXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50LmRyYXdMYXllci5yZW1vdmUodGhpcy5fZnJlZUhpZ2hsaWdodElkKTtcbiAgICB9XG4gICAgdGhpcy5fZnJlZUhpZ2hsaWdodElkID0gLTE7XG4gICAgdGhpcy5fZnJlZUhpZ2hsaWdodCA9IG51bGw7XG4gICAgdGhpcy5fZnJlZUhpZ2hsaWdodENsaXBJZCA9IFwiXCI7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKSB7XG4gICAgbGV0IGluaXRpYWxEYXRhID0gbnVsbDtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEhpZ2hsaWdodEFubm90YXRpb25FbGVtZW50KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBxdWFkUG9pbnRzOiBxdWFkUG9pbnRzMixcbiAgICAgICAgICByZWN0LFxuICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIGNvbG9yOiBjb2xvcjIsXG4gICAgICAgICAgb3BhY2l0eTogb3BhY2l0eTIsXG4gICAgICAgICAgcG9wdXBSZWYsXG4gICAgICAgICAgcmljaFRleHQsXG4gICAgICAgICAgY29udGVudHNPYmosXG4gICAgICAgICAgY3JlYXRpb25EYXRlLFxuICAgICAgICAgIG1vZGlmaWNhdGlvbkRhdGVcbiAgICAgICAgfSxcbiAgICAgICAgcGFyZW50OiB7XG4gICAgICAgICAgcGFnZToge1xuICAgICAgICAgICAgcGFnZU51bWJlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSA9IGRhdGE7XG4gICAgICBpbml0aWFsRGF0YSA9IGRhdGEgPSB7XG4gICAgICAgIGFubm90YXRpb25UeXBlOiBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQsXG4gICAgICAgIGNvbG9yOiBBcnJheS5mcm9tKGNvbG9yMiksXG4gICAgICAgIG9wYWNpdHk6IG9wYWNpdHkyLFxuICAgICAgICBxdWFkUG9pbnRzOiBxdWFkUG9pbnRzMixcbiAgICAgICAgYm94ZXM6IG51bGwsXG4gICAgICAgIHBhZ2VJbmRleDogcGFnZU51bWJlciAtIDEsXG4gICAgICAgIHJlY3Q6IHJlY3Quc2xpY2UoMCksXG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICBhbm5vdGF0aW9uRWxlbWVudElkOiBpZCxcbiAgICAgICAgaWQsXG4gICAgICAgIGRlbGV0ZWQ6IGZhbHNlLFxuICAgICAgICBwb3B1cFJlZixcbiAgICAgICAgcmljaFRleHQsXG4gICAgICAgIGNvbW1lbnQ6IGNvbnRlbnRzT2JqPy5zdHIgfHwgbnVsbCxcbiAgICAgICAgY3JlYXRpb25EYXRlLFxuICAgICAgICBtb2RpZmljYXRpb25EYXRlXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIElua0Fubm90YXRpb25FbGVtZW50KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBpbmtMaXN0czogaW5rTGlzdHMyLFxuICAgICAgICAgIHJlY3QsXG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgY29sb3I6IGNvbG9yMixcbiAgICAgICAgICBib3JkZXJTdHlsZToge1xuICAgICAgICAgICAgcmF3V2lkdGg6IHRoaWNrbmVzc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcG9wdXBSZWYsXG4gICAgICAgICAgcmljaFRleHQsXG4gICAgICAgICAgY29udGVudHNPYmosXG4gICAgICAgICAgY3JlYXRpb25EYXRlLFxuICAgICAgICAgIG1vZGlmaWNhdGlvbkRhdGVcbiAgICAgICAgfSxcbiAgICAgICAgcGFyZW50OiB7XG4gICAgICAgICAgcGFnZToge1xuICAgICAgICAgICAgcGFnZU51bWJlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSA9IGRhdGE7XG4gICAgICBpbml0aWFsRGF0YSA9IGRhdGEgPSB7XG4gICAgICAgIGFubm90YXRpb25UeXBlOiBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQsXG4gICAgICAgIGNvbG9yOiBBcnJheS5mcm9tKGNvbG9yMiksXG4gICAgICAgIHRoaWNrbmVzcyxcbiAgICAgICAgaW5rTGlzdHM6IGlua0xpc3RzMixcbiAgICAgICAgYm94ZXM6IG51bGwsXG4gICAgICAgIHBhZ2VJbmRleDogcGFnZU51bWJlciAtIDEsXG4gICAgICAgIHJlY3Q6IHJlY3Quc2xpY2UoMCksXG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICBhbm5vdGF0aW9uRWxlbWVudElkOiBpZCxcbiAgICAgICAgaWQsXG4gICAgICAgIGRlbGV0ZWQ6IGZhbHNlLFxuICAgICAgICBwb3B1cFJlZixcbiAgICAgICAgcmljaFRleHQsXG4gICAgICAgIGNvbW1lbnQ6IGNvbnRlbnRzT2JqPy5zdHIgfHwgbnVsbCxcbiAgICAgICAgY3JlYXRpb25EYXRlLFxuICAgICAgICBtb2RpZmljYXRpb25EYXRlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjb2xvcixcbiAgICAgIHF1YWRQb2ludHMsXG4gICAgICBpbmtMaXN0cyxcbiAgICAgIG9wYWNpdHlcbiAgICB9ID0gZGF0YTtcbiAgICBjb25zdCBlZGl0b3IgPSBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcik7XG4gICAgZWRpdG9yLmNvbG9yID0gVXRpbC5tYWtlSGV4Q29sb3IoLi4uY29sb3IpO1xuICAgIGVkaXRvci5vcGFjaXR5ID0gb3BhY2l0eSB8fCAxO1xuICAgIGlmIChpbmtMaXN0cykge1xuICAgICAgZWRpdG9yLiN0aGlja25lc3MgPSBkYXRhLnRoaWNrbmVzcztcbiAgICB9XG4gICAgZWRpdG9yLl9pbml0aWFsRGF0YSA9IGluaXRpYWxEYXRhO1xuICAgIGlmIChkYXRhLmNvbW1lbnQpIHtcbiAgICAgIGVkaXRvci5zZXRDb21tZW50RGF0YShkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSBlZGl0b3IucGFnZURpbWVuc2lvbnM7XG4gICAgY29uc3QgW3BhZ2VYLCBwYWdlWV0gPSBlZGl0b3IucGFnZVRyYW5zbGF0aW9uO1xuICAgIGlmIChxdWFkUG9pbnRzKSB7XG4gICAgICBjb25zdCBib3hlcyA9IGVkaXRvci4jYm94ZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVhZFBvaW50cy5sZW5ndGg7IGkgKz0gOCkge1xuICAgICAgICBib3hlcy5wdXNoKHtcbiAgICAgICAgICB4OiAocXVhZFBvaW50c1tpXSAtIHBhZ2VYKSAvIHBhZ2VXaWR0aCxcbiAgICAgICAgICB5OiAxIC0gKHF1YWRQb2ludHNbaSArIDFdIC0gcGFnZVkpIC8gcGFnZUhlaWdodCxcbiAgICAgICAgICB3aWR0aDogKHF1YWRQb2ludHNbaSArIDJdIC0gcXVhZFBvaW50c1tpXSkgLyBwYWdlV2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiAocXVhZFBvaW50c1tpICsgMV0gLSBxdWFkUG9pbnRzW2kgKyA1XSkgLyBwYWdlSGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZWRpdG9yLiNjcmVhdGVPdXRsaW5lcygpO1xuICAgICAgZWRpdG9yLiNhZGRUb0RyYXdMYXllcigpO1xuICAgICAgZWRpdG9yLnJvdGF0ZShlZGl0b3Iucm90YXRpb24pO1xuICAgIH0gZWxzZSBpZiAoaW5rTGlzdHMpIHtcbiAgICAgIGVkaXRvci4jaXNGcmVlSGlnaGxpZ2h0ID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHBvaW50cyA9IGlua0xpc3RzWzBdO1xuICAgICAgY29uc3QgcG9pbnQgPSB7XG4gICAgICAgIHg6IHBvaW50c1swXSAtIHBhZ2VYLFxuICAgICAgICB5OiBwYWdlSGVpZ2h0IC0gKHBvaW50c1sxXSAtIHBhZ2VZKVxuICAgICAgfTtcbiAgICAgIGNvbnN0IG91dGxpbmVyID0gbmV3IEZyZWVIaWdobGlnaHRPdXRsaW5lcihwb2ludCwgWzAsIDAsIHBhZ2VXaWR0aCwgcGFnZUhlaWdodF0sIDEsIGVkaXRvci4jdGhpY2tuZXNzIC8gMiwgdHJ1ZSwgMWUtMyk7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgICBwb2ludC54ID0gcG9pbnRzW2ldIC0gcGFnZVg7XG4gICAgICAgIHBvaW50LnkgPSBwYWdlSGVpZ2h0IC0gKHBvaW50c1tpICsgMV0gLSBwYWdlWSk7XG4gICAgICAgIG91dGxpbmVyLmFkZChwb2ludCk7XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIGlkLFxuICAgICAgICBjbGlwUGF0aElkXG4gICAgICB9ID0gcGFyZW50LmRyYXdMYXllci5kcmF3KHtcbiAgICAgICAgYmJveDogWzAsIDAsIDEsIDFdLFxuICAgICAgICByb290OiB7XG4gICAgICAgICAgdmlld0JveDogXCIwIDAgMSAxXCIsXG4gICAgICAgICAgZmlsbDogZWRpdG9yLmNvbG9yLFxuICAgICAgICAgIFwiZmlsbC1vcGFjaXR5XCI6IGVkaXRvci5fZGVmYXVsdE9wYWNpdHlcbiAgICAgICAgfSxcbiAgICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgICAgaGlnaGxpZ2h0OiB0cnVlLFxuICAgICAgICAgIGZyZWU6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIGQ6IG91dGxpbmVyLnRvU1ZHUGF0aCgpXG4gICAgICAgIH1cbiAgICAgIH0sIHRydWUsIHRydWUpO1xuICAgICAgZWRpdG9yLiNjcmVhdGVGcmVlT3V0bGluZXMoe1xuICAgICAgICBoaWdobGlnaHRPdXRsaW5lczogb3V0bGluZXIuZ2V0T3V0bGluZXMoKSxcbiAgICAgICAgaGlnaGxpZ2h0SWQ6IGlkLFxuICAgICAgICBjbGlwUGF0aElkXG4gICAgICB9KTtcbiAgICAgIGVkaXRvci4jYWRkVG9EcmF3TGF5ZXIoKTtcbiAgICAgIGVkaXRvci5yb3RhdGUoZWRpdG9yLnBhcmVudFJvdGF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxuICBzZXJpYWxpemUoaXNGb3JDb3B5aW5nID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkgfHwgaXNGb3JDb3B5aW5nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGVsZXRlZCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplRGVsZXRlZCgpO1xuICAgIH1cbiAgICBjb25zdCBjb2xvciA9IEFubm90YXRpb25FZGl0b3IuX2NvbG9yTWFuYWdlci5jb252ZXJ0KHRoaXMuX3VpTWFuYWdlci5nZXROb25IQ01Db2xvcih0aGlzLmNvbG9yKSk7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHN1cGVyLnNlcmlhbGl6ZShpc0ZvckNvcHlpbmcpO1xuICAgIE9iamVjdC5hc3NpZ24oc2VyaWFsaXplZCwge1xuICAgICAgY29sb3IsXG4gICAgICBvcGFjaXR5OiB0aGlzLm9wYWNpdHksXG4gICAgICB0aGlja25lc3M6IHRoaXMuI3RoaWNrbmVzcyxcbiAgICAgIHF1YWRQb2ludHM6IHRoaXMuI3NlcmlhbGl6ZUJveGVzKCksXG4gICAgICBvdXRsaW5lczogdGhpcy4jc2VyaWFsaXplT3V0bGluZXMoc2VyaWFsaXplZC5yZWN0KVxuICAgIH0pO1xuICAgIHRoaXMuYWRkQ29tbWVudChzZXJpYWxpemVkKTtcbiAgICBpZiAodGhpcy5hbm5vdGF0aW9uRWxlbWVudElkICYmICF0aGlzLiNoYXNFbGVtZW50Q2hhbmdlZChzZXJpYWxpemVkKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHNlcmlhbGl6ZWQuaWQgPSB0aGlzLmFubm90YXRpb25FbGVtZW50SWQ7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gIH1cbiAgI2hhc0VsZW1lbnRDaGFuZ2VkKHNlcmlhbGl6ZWQpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb2xvclxuICAgIH0gPSB0aGlzLl9pbml0aWFsRGF0YTtcbiAgICByZXR1cm4gdGhpcy5oYXNFZGl0ZWRDb21tZW50IHx8IHNlcmlhbGl6ZWQuY29sb3Iuc29tZSgoYywgaSkgPT4gYyAhPT0gY29sb3JbaV0pO1xuICB9XG4gIHJlbmRlckFubm90YXRpb25FbGVtZW50KGFubm90YXRpb24pIHtcbiAgICBpZiAodGhpcy5kZWxldGVkKSB7XG4gICAgICBhbm5vdGF0aW9uLmhpZGUoKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhbm5vdGF0aW9uLnVwZGF0ZUVkaXRlZCh7XG4gICAgICByZWN0OiB0aGlzLmdldFBERlJlY3QoKSxcbiAgICAgIHBvcHVwOiB0aGlzLmNvbW1lbnRcbiAgICB9KTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBzdGF0aWMgY2FuQ3JlYXRlTmV3RW1wdHlFZGl0b3IoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5jbGFzcyBEcmF3aW5nT3B0aW9ucyB7XG4gICNzdmdQcm9wZXJ0aWVzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHVwZGF0ZVByb3BlcnR5KG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpc1tuYW1lXSA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlU1ZHUHJvcGVydHkobmFtZSwgdmFsdWUpO1xuICB9XG4gIHVwZGF0ZVByb3BlcnRpZXMocHJvcGVydGllcykge1xuICAgIGlmICghcHJvcGVydGllcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocHJvcGVydGllcykpIHtcbiAgICAgIGlmICghbmFtZS5zdGFydHNXaXRoKFwiX1wiKSkge1xuICAgICAgICB0aGlzLnVwZGF0ZVByb3BlcnR5KG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdXBkYXRlU1ZHUHJvcGVydHkobmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLiNzdmdQcm9wZXJ0aWVzW25hbWVdID0gdmFsdWU7XG4gIH1cbiAgdG9TVkdQcm9wZXJ0aWVzKCkge1xuICAgIGNvbnN0IHJvb3QgPSB0aGlzLiNzdmdQcm9wZXJ0aWVzO1xuICAgIHRoaXMuI3N2Z1Byb3BlcnRpZXMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICByZXR1cm4ge1xuICAgICAgcm9vdFxuICAgIH07XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy4jc3ZnUHJvcGVydGllcyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIHVwZGF0ZUFsbChvcHRpb25zID0gdGhpcykge1xuICAgIHRoaXMudXBkYXRlUHJvcGVydGllcyhvcHRpb25zKTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICB1bnJlYWNoYWJsZShcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxufVxuY2xhc3MgRHJhd2luZ0VkaXRvciBleHRlbmRzIEFubm90YXRpb25FZGl0b3Ige1xuICAjZHJhd091dGxpbmVzID0gbnVsbDtcbiAgI211c3RCZUNvbW1pdHRlZDtcbiAgX2NvbG9yUGlja2VyID0gbnVsbDtcbiAgX2RyYXdJZCA9IG51bGw7XG4gIHN0YXRpYyBfY3VycmVudERyYXdJZCA9IC0xO1xuICBzdGF0aWMgX2N1cnJlbnRQYXJlbnQgPSBudWxsO1xuICBzdGF0aWMgI2N1cnJlbnREcmF3ID0gbnVsbDtcbiAgc3RhdGljICNjdXJyZW50RHJhd2luZ0FDID0gbnVsbDtcbiAgc3RhdGljICNjdXJyZW50RHJhd2luZ09wdGlvbnMgPSBudWxsO1xuICBzdGF0aWMgI2N1cnJlbnRQb2ludGVySWQgPSBOYU47XG4gIHN0YXRpYyAjY3VycmVudFBvaW50ZXJUeXBlID0gbnVsbDtcbiAgc3RhdGljICNjdXJyZW50UG9pbnRlcklkcyA9IG51bGw7XG4gIHN0YXRpYyAjY3VycmVudE1vdmVUaW1lc3RhbXAgPSBOYU47XG4gIHN0YXRpYyBfSU5ORVJfTUFSR0lOID0gMztcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIocGFyYW1zKTtcbiAgICB0aGlzLiNtdXN0QmVDb21taXR0ZWQgPSBwYXJhbXMubXVzdEJlQ29tbWl0dGVkIHx8IGZhbHNlO1xuICAgIHRoaXMuX2FkZE91dGxpbmVzKHBhcmFtcyk7XG4gIH1cbiAgb25VcGRhdGVkQ29sb3IoKSB7XG4gICAgdGhpcy5fY29sb3JQaWNrZXI/LnVwZGF0ZSh0aGlzLmNvbG9yKTtcbiAgICBzdXBlci5vblVwZGF0ZWRDb2xvcigpO1xuICB9XG4gIF9hZGRPdXRsaW5lcyhwYXJhbXMpIHtcbiAgICBpZiAocGFyYW1zLmRyYXdPdXRsaW5lcykge1xuICAgICAgdGhpcy4jY3JlYXRlRHJhd091dGxpbmVzKHBhcmFtcyk7XG4gICAgICB0aGlzLiNhZGRUb0RyYXdMYXllcigpO1xuICAgIH1cbiAgfVxuICAjY3JlYXRlRHJhd091dGxpbmVzKHtcbiAgICBkcmF3T3V0bGluZXMsXG4gICAgZHJhd0lkLFxuICAgIGRyYXdpbmdPcHRpb25zXG4gIH0pIHtcbiAgICB0aGlzLiNkcmF3T3V0bGluZXMgPSBkcmF3T3V0bGluZXM7XG4gICAgdGhpcy5fZHJhd2luZ09wdGlvbnMgfHw9IGRyYXdpbmdPcHRpb25zO1xuICAgIGlmICghdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuYTExeUFsZXJ0KGBwZGZqcy1lZGl0b3ItJHt0aGlzLmVkaXRvclR5cGV9LWFkZGVkLWFsZXJ0YCk7XG4gICAgfVxuICAgIGlmIChkcmF3SWQgPj0gMCkge1xuICAgICAgdGhpcy5fZHJhd0lkID0gZHJhd0lkO1xuICAgICAgdGhpcy5wYXJlbnQuZHJhd0xheWVyLmZpbmFsaXplRHJhdyhkcmF3SWQsIGRyYXdPdXRsaW5lcy5kZWZhdWx0UHJvcGVydGllcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RyYXdJZCA9IHRoaXMuI2NyZWF0ZURyYXdpbmcoZHJhd091dGxpbmVzLCB0aGlzLnBhcmVudCk7XG4gICAgfVxuICAgIHRoaXMuI3VwZGF0ZUJib3goZHJhd091dGxpbmVzLmJveCk7XG4gIH1cbiAgI2NyZWF0ZURyYXdpbmcoZHJhd091dGxpbmVzLCBwYXJlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBpZFxuICAgIH0gPSBwYXJlbnQuZHJhd0xheWVyLmRyYXcoRHJhd2luZ0VkaXRvci5fbWVyZ2VTVkdQcm9wZXJ0aWVzKHRoaXMuX2RyYXdpbmdPcHRpb25zLnRvU1ZHUHJvcGVydGllcygpLCBkcmF3T3V0bGluZXMuZGVmYXVsdFNWR1Byb3BlcnRpZXMpLCBmYWxzZSwgZmFsc2UpO1xuICAgIHJldHVybiBpZDtcbiAgfVxuICBzdGF0aWMgX21lcmdlU1ZHUHJvcGVydGllcyhwMSwgcDIpIHtcbiAgICBjb25zdCBwMUtleXMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHAxKSk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocDIpKSB7XG4gICAgICBpZiAocDFLZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ocDFba2V5XSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcDFba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcDE7XG4gIH1cbiAgc3RhdGljIGdldERlZmF1bHREcmF3aW5nT3B0aW9ucyhfb3B0aW9ucykge1xuICAgIHVucmVhY2hhYmxlKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZXNNYXAoKSB7XG4gICAgdW5yZWFjaGFibGUoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgc3RhdGljIGdldCBpc0RyYXdlcigpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgZ2V0IHN1cHBvcnRNdWx0aXBsZURyYXdpbmdzKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgdXBkYXRlRGVmYXVsdFBhcmFtcyh0eXBlLCB2YWx1ZSkge1xuICAgIGNvbnN0IHByb3BlcnR5TmFtZSA9IHRoaXMudHlwZXNNYXAuZ2V0KHR5cGUpO1xuICAgIGlmIChwcm9wZXJ0eU5hbWUpIHtcbiAgICAgIHRoaXMuX2RlZmF1bHREcmF3aW5nT3B0aW9ucy51cGRhdGVQcm9wZXJ0eShwcm9wZXJ0eU5hbWUsIHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2N1cnJlbnRQYXJlbnQpIHtcbiAgICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3LnVwZGF0ZVByb3BlcnR5KHByb3BlcnR5TmFtZSwgdmFsdWUpO1xuICAgICAgdGhpcy5fY3VycmVudFBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9jdXJyZW50RHJhd0lkLCB0aGlzLl9kZWZhdWx0RHJhd2luZ09wdGlvbnMudG9TVkdQcm9wZXJ0aWVzKCkpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVQYXJhbXModHlwZSwgdmFsdWUpIHtcbiAgICBjb25zdCBwcm9wZXJ0eU5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLnR5cGVzTWFwLmdldCh0eXBlKTtcbiAgICBpZiAocHJvcGVydHlOYW1lKSB7XG4gICAgICB0aGlzLl91cGRhdGVQcm9wZXJ0eSh0eXBlLCBwcm9wZXJ0eU5hbWUsIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldCBkZWZhdWx0UHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBbXTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fZGVmYXVsdERyYXdpbmdPcHRpb25zO1xuICAgIGZvciAoY29uc3QgW3R5cGUsIG5hbWVdIG9mIHRoaXMudHlwZXNNYXApIHtcbiAgICAgIHByb3BlcnRpZXMucHVzaChbdHlwZSwgb3B0aW9uc1tuYW1lXV0pO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcGVydGllcztcbiAgfVxuICBnZXQgcHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBbXTtcbiAgICBjb25zdCB7XG4gICAgICBfZHJhd2luZ09wdGlvbnNcbiAgICB9ID0gdGhpcztcbiAgICBmb3IgKGNvbnN0IFt0eXBlLCBuYW1lXSBvZiB0aGlzLmNvbnN0cnVjdG9yLnR5cGVzTWFwKSB7XG4gICAgICBwcm9wZXJ0aWVzLnB1c2goW3R5cGUsIF9kcmF3aW5nT3B0aW9uc1tuYW1lXV0pO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcGVydGllcztcbiAgfVxuICBfdXBkYXRlUHJvcGVydHkodHlwZSwgbmFtZSwgdmFsdWUpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fZHJhd2luZ09wdGlvbnM7XG4gICAgY29uc3Qgc2F2ZWRWYWx1ZSA9IG9wdGlvbnNbbmFtZV07XG4gICAgY29uc3Qgc2V0dGVyID0gKHZhbCkgPT4ge1xuICAgICAgb3B0aW9ucy51cGRhdGVQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICAgICAgY29uc3QgYmJveCA9IHRoaXMuI2RyYXdPdXRsaW5lcy51cGRhdGVQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICAgICAgaWYgKGJib3gpIHtcbiAgICAgICAgdGhpcy4jdXBkYXRlQmJveChiYm94KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFyZW50Py5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9kcmF3SWQsIG9wdGlvbnMudG9TVkdQcm9wZXJ0aWVzKCkpO1xuICAgICAgaWYgKHR5cGUgPT09IHRoaXMuY29sb3JUeXBlKSB7XG4gICAgICAgIHRoaXMub25VcGRhdGVkQ29sb3IoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiBzZXR0ZXIuYmluZCh0aGlzLCB2YWx1ZSksXG4gICAgICB1bmRvOiBzZXR0ZXIuYmluZCh0aGlzLCBzYXZlZFZhbHVlKSxcbiAgICAgIHBvc3Q6IHRoaXMuX3VpTWFuYWdlci51cGRhdGVVSS5iaW5kKHRoaXMuX3VpTWFuYWdlciwgdGhpcyksXG4gICAgICBtdXN0RXhlYzogdHJ1ZSxcbiAgICAgIHR5cGUsXG4gICAgICBvdmVyd3JpdGVJZlNhbWVUeXBlOiB0cnVlLFxuICAgICAga2VlcFVuZG86IHRydWVcbiAgICB9KTtcbiAgfVxuICBfb25SZXNpemluZygpIHtcbiAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fZHJhd0lkLCBEcmF3aW5nRWRpdG9yLl9tZXJnZVNWR1Byb3BlcnRpZXModGhpcy4jZHJhd091dGxpbmVzLmdldFBhdGhSZXNpemluZ1NWR1Byb3BlcnRpZXModGhpcy4jY29udmVydFRvRHJhd1NwYWNlKCkpLCB7XG4gICAgICBiYm94OiB0aGlzLiNyb3RhdGVCb3goKVxuICAgIH0pKTtcbiAgfVxuICBfb25SZXNpemVkKCkge1xuICAgIHRoaXMucGFyZW50Py5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9kcmF3SWQsIERyYXdpbmdFZGl0b3IuX21lcmdlU1ZHUHJvcGVydGllcyh0aGlzLiNkcmF3T3V0bGluZXMuZ2V0UGF0aFJlc2l6ZWRTVkdQcm9wZXJ0aWVzKHRoaXMuI2NvbnZlcnRUb0RyYXdTcGFjZSgpKSwge1xuICAgICAgYmJveDogdGhpcy4jcm90YXRlQm94KClcbiAgICB9KSk7XG4gIH1cbiAgX29uVHJhbnNsYXRpbmcoX3gsIF95KSB7XG4gICAgdGhpcy5wYXJlbnQ/LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX2RyYXdJZCwge1xuICAgICAgYmJveDogdGhpcy4jcm90YXRlQm94KClcbiAgICB9KTtcbiAgfVxuICBfb25UcmFuc2xhdGVkKCkge1xuICAgIHRoaXMucGFyZW50Py5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9kcmF3SWQsIERyYXdpbmdFZGl0b3IuX21lcmdlU1ZHUHJvcGVydGllcyh0aGlzLiNkcmF3T3V0bGluZXMuZ2V0UGF0aFRyYW5zbGF0ZWRTVkdQcm9wZXJ0aWVzKHRoaXMuI2NvbnZlcnRUb0RyYXdTcGFjZSgpLCB0aGlzLnBhcmVudERpbWVuc2lvbnMpLCB7XG4gICAgICBiYm94OiB0aGlzLiNyb3RhdGVCb3goKVxuICAgIH0pKTtcbiAgfVxuICBfb25TdGFydERyYWdnaW5nKCkge1xuICAgIHRoaXMucGFyZW50Py5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9kcmF3SWQsIHtcbiAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICBtb3Zpbmc6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfb25TdG9wRHJhZ2dpbmcoKSB7XG4gICAgdGhpcy5wYXJlbnQ/LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX2RyYXdJZCwge1xuICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgIG1vdmluZzogZmFsc2VcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjb21taXQoKSB7XG4gICAgc3VwZXIuY29tbWl0KCk7XG4gICAgdGhpcy5kaXNhYmxlRWRpdE1vZGUoKTtcbiAgICB0aGlzLmRpc2FibGVFZGl0aW5nKCk7XG4gIH1cbiAgZGlzYWJsZUVkaXRpbmcoKSB7XG4gICAgc3VwZXIuZGlzYWJsZUVkaXRpbmcoKTtcbiAgICB0aGlzLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiZGlzYWJsZWRcIiwgdHJ1ZSk7XG4gIH1cbiAgZW5hYmxlRWRpdGluZygpIHtcbiAgICBzdXBlci5lbmFibGVFZGl0aW5nKCk7XG4gICAgdGhpcy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImRpc2FibGVkXCIsIGZhbHNlKTtcbiAgfVxuICBnZXRCYXNlVHJhbnNsYXRpb24oKSB7XG4gICAgcmV0dXJuIFswLCAwXTtcbiAgfVxuICBnZXQgaXNSZXNpemFibGUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgb25jZUFkZGVkKGZvY3VzKSB7XG4gICAgaWYgKCF0aGlzLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIHRoaXMucGFyZW50LmFkZFVuZG9hYmxlRWRpdG9yKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IHRydWU7XG4gICAgaWYgKHRoaXMuI211c3RCZUNvbW1pdHRlZCkge1xuICAgICAgdGhpcy4jbXVzdEJlQ29tbWl0dGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmNvbW1pdCgpO1xuICAgICAgdGhpcy5wYXJlbnQuc2V0U2VsZWN0ZWQodGhpcyk7XG4gICAgICBpZiAoZm9jdXMgJiYgdGhpcy5pc09uU2NyZWVuKSB7XG4gICAgICAgIHRoaXMuZGl2LmZvY3VzKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLiNjbGVhbkRyYXdMYXllcigpO1xuICAgIHN1cGVyLnJlbW92ZSgpO1xuICB9XG4gIHJlYnVpbGQoKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5yZWJ1aWxkKCk7XG4gICAgaWYgKHRoaXMuZGl2ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2FkZFRvRHJhd0xheWVyKCk7XG4gICAgdGhpcy4jdXBkYXRlQmJveCh0aGlzLiNkcmF3T3V0bGluZXMuYm94KTtcbiAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICB0aGlzLnBhcmVudC5hZGQodGhpcyk7XG4gICAgfVxuICB9XG4gIHNldFBhcmVudChwYXJlbnQpIHtcbiAgICBsZXQgbXVzdEJlU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5wYXJlbnQgJiYgIXBhcmVudCkge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLnJlbW92ZVNob3VsZFJlc2NhbGUodGhpcyk7XG4gICAgICB0aGlzLiNjbGVhbkRyYXdMYXllcigpO1xuICAgIH0gZWxzZSBpZiAocGFyZW50KSB7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuYWRkU2hvdWxkUmVzY2FsZSh0aGlzKTtcbiAgICAgIHRoaXMuI2FkZFRvRHJhd0xheWVyKHBhcmVudCk7XG4gICAgICBtdXN0QmVTZWxlY3RlZCA9ICF0aGlzLnBhcmVudCAmJiB0aGlzLmRpdj8uY2xhc3NMaXN0LmNvbnRhaW5zKFwic2VsZWN0ZWRFZGl0b3JcIik7XG4gICAgfVxuICAgIHN1cGVyLnNldFBhcmVudChwYXJlbnQpO1xuICAgIGlmIChtdXN0QmVTZWxlY3RlZCkge1xuICAgICAgdGhpcy5zZWxlY3QoKTtcbiAgICB9XG4gIH1cbiAgI2NsZWFuRHJhd0xheWVyKCkge1xuICAgIGlmICh0aGlzLl9kcmF3SWQgPT09IG51bGwgfHwgIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGFyZW50LmRyYXdMYXllci5yZW1vdmUodGhpcy5fZHJhd0lkKTtcbiAgICB0aGlzLl9kcmF3SWQgPSBudWxsO1xuICAgIHRoaXMuX2RyYXdpbmdPcHRpb25zLnJlc2V0KCk7XG4gIH1cbiAgI2FkZFRvRHJhd0xheWVyKHBhcmVudCA9IHRoaXMucGFyZW50KSB7XG4gICAgaWYgKHRoaXMuX2RyYXdJZCAhPT0gbnVsbCAmJiB0aGlzLnBhcmVudCA9PT0gcGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9kcmF3SWQgIT09IG51bGwpIHtcbiAgICAgIHRoaXMucGFyZW50LmRyYXdMYXllci51cGRhdGVQYXJlbnQodGhpcy5fZHJhd0lkLCBwYXJlbnQuZHJhd0xheWVyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZHJhd2luZ09wdGlvbnMudXBkYXRlQWxsKCk7XG4gICAgdGhpcy5fZHJhd0lkID0gdGhpcy4jY3JlYXRlRHJhd2luZyh0aGlzLiNkcmF3T3V0bGluZXMsIHBhcmVudCk7XG4gIH1cbiAgI2NvbnZlcnRUb1BhcmVudFNwYWNlKFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhcmVudERpbWVuc2lvbnM6IFtwVywgcEhdLFxuICAgICAgcm90YXRpb25cbiAgICB9ID0gdGhpcztcbiAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gW3ksIDEgLSB4LCB3aWR0aCAqIChwSCAvIHBXKSwgaGVpZ2h0ICogKHBXIC8gcEgpXTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gWzEgLSB4LCAxIC0geSwgd2lkdGgsIGhlaWdodF07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcmV0dXJuIFsxIC0geSwgeCwgd2lkdGggKiAocEggLyBwVyksIGhlaWdodCAqIChwVyAvIHBIKV07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gW3gsIHksIHdpZHRoLCBoZWlnaHRdO1xuICAgIH1cbiAgfVxuICAjY29udmVydFRvRHJhd1NwYWNlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBwYXJlbnREaW1lbnNpb25zOiBbcFcsIHBIXSxcbiAgICAgIHJvdGF0aW9uXG4gICAgfSA9IHRoaXM7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFsxIC0geSwgeCwgd2lkdGggKiAocFcgLyBwSCksIGhlaWdodCAqIChwSCAvIHBXKV07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFsxIC0geCwgMSAtIHksIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbeSwgMSAtIHgsIHdpZHRoICogKHBXIC8gcEgpLCBoZWlnaHQgKiAocEggLyBwVyldO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFt4LCB5LCB3aWR0aCwgaGVpZ2h0XTtcbiAgICB9XG4gIH1cbiAgI3VwZGF0ZUJib3goYmJveCkge1xuICAgIFt0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHRdID0gdGhpcy4jY29udmVydFRvUGFyZW50U3BhY2UoYmJveCk7XG4gICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gICAgICB0aGlzLnNldERpbXMoKTtcbiAgICB9XG4gICAgdGhpcy5fb25SZXNpemVkKCk7XG4gIH1cbiAgI3JvdGF0ZUJveCgpIHtcbiAgICBjb25zdCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgcm90YXRpb24sXG4gICAgICBwYXJlbnRSb3RhdGlvbixcbiAgICAgIHBhcmVudERpbWVuc2lvbnM6IFtwVywgcEhdXG4gICAgfSA9IHRoaXM7XG4gICAgc3dpdGNoICgocm90YXRpb24gKiA0ICsgcGFyZW50Um90YXRpb24pIC8gOTApIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIFsxIC0geSAtIGhlaWdodCwgeCwgaGVpZ2h0LCB3aWR0aF07XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiBbMSAtIHggLSB3aWR0aCwgMSAtIHkgLSBoZWlnaHQsIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gW3ksIDEgLSB4IC0gd2lkdGgsIGhlaWdodCwgd2lkdGhdO1xuICAgICAgY2FzZSA0OlxuICAgICAgICByZXR1cm4gW3gsIHkgLSB3aWR0aCAqIChwVyAvIHBIKSwgaGVpZ2h0ICogKHBIIC8gcFcpLCB3aWR0aCAqIChwVyAvIHBIKV07XG4gICAgICBjYXNlIDU6XG4gICAgICAgIHJldHVybiBbMSAtIHksIHgsIHdpZHRoICogKHBXIC8gcEgpLCBoZWlnaHQgKiAocEggLyBwVyldO1xuICAgICAgY2FzZSA2OlxuICAgICAgICByZXR1cm4gWzEgLSB4IC0gaGVpZ2h0ICogKHBIIC8gcFcpLCAxIC0geSwgaGVpZ2h0ICogKHBIIC8gcFcpLCB3aWR0aCAqIChwVyAvIHBIKV07XG4gICAgICBjYXNlIDc6XG4gICAgICAgIHJldHVybiBbeSAtIHdpZHRoICogKHBXIC8gcEgpLCAxIC0geCAtIGhlaWdodCAqIChwSCAvIHBXKSwgd2lkdGggKiAocFcgLyBwSCksIGhlaWdodCAqIChwSCAvIHBXKV07XG4gICAgICBjYXNlIDg6XG4gICAgICAgIHJldHVybiBbeCAtIHdpZHRoLCB5IC0gaGVpZ2h0LCB3aWR0aCwgaGVpZ2h0XTtcbiAgICAgIGNhc2UgOTpcbiAgICAgICAgcmV0dXJuIFsxIC0geSwgeCAtIHdpZHRoLCBoZWlnaHQsIHdpZHRoXTtcbiAgICAgIGNhc2UgMTA6XG4gICAgICAgIHJldHVybiBbMSAtIHgsIDEgLSB5LCB3aWR0aCwgaGVpZ2h0XTtcbiAgICAgIGNhc2UgMTE6XG4gICAgICAgIHJldHVybiBbeSAtIGhlaWdodCwgMSAtIHgsIGhlaWdodCwgd2lkdGhdO1xuICAgICAgY2FzZSAxMjpcbiAgICAgICAgcmV0dXJuIFt4IC0gaGVpZ2h0ICogKHBIIC8gcFcpLCB5LCBoZWlnaHQgKiAocEggLyBwVyksIHdpZHRoICogKHBXIC8gcEgpXTtcbiAgICAgIGNhc2UgMTM6XG4gICAgICAgIHJldHVybiBbMSAtIHkgLSB3aWR0aCAqIChwVyAvIHBIKSwgeCAtIGhlaWdodCAqIChwSCAvIHBXKSwgd2lkdGggKiAocFcgLyBwSCksIGhlaWdodCAqIChwSCAvIHBXKV07XG4gICAgICBjYXNlIDE0OlxuICAgICAgICByZXR1cm4gWzEgLSB4LCAxIC0geSAtIHdpZHRoICogKHBXIC8gcEgpLCBoZWlnaHQgKiAocEggLyBwVyksIHdpZHRoICogKHBXIC8gcEgpXTtcbiAgICAgIGNhc2UgMTU6XG4gICAgICAgIHJldHVybiBbeSwgMSAtIHgsIHdpZHRoICogKHBXIC8gcEgpLCBoZWlnaHQgKiAocEggLyBwVyldO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFt4LCB5LCB3aWR0aCwgaGVpZ2h0XTtcbiAgICB9XG4gIH1cbiAgcm90YXRlKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fZHJhd0lkLCBEcmF3aW5nRWRpdG9yLl9tZXJnZVNWR1Byb3BlcnRpZXMoe1xuICAgICAgYmJveDogdGhpcy4jcm90YXRlQm94KClcbiAgICB9LCB0aGlzLiNkcmF3T3V0bGluZXMudXBkYXRlUm90YXRpb24oKHRoaXMucGFyZW50Um90YXRpb24gLSB0aGlzLnJvdGF0aW9uICsgMzYwKSAlIDM2MCkpKTtcbiAgfVxuICBvblNjYWxlQ2hhbmdpbmcoKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiN1cGRhdGVCYm94KHRoaXMuI2RyYXdPdXRsaW5lcy51cGRhdGVQYXJlbnREaW1lbnNpb25zKHRoaXMucGFyZW50RGltZW5zaW9ucywgdGhpcy5wYXJlbnQuc2NhbGUpKTtcbiAgfVxuICBzdGF0aWMgb25TY2FsZUNoYW5naW5nV2hlbkRyYXdpbmcoKSB7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgcmV0dXJuIHRoaXMuZGl2O1xuICAgIH1cbiAgICBsZXQgYmFzZVgsIGJhc2VZO1xuICAgIGlmICh0aGlzLl9pc0NvcHkpIHtcbiAgICAgIGJhc2VYID0gdGhpcy54O1xuICAgICAgYmFzZVkgPSB0aGlzLnk7XG4gICAgfVxuICAgIGNvbnN0IGRpdiA9IHN1cGVyLnJlbmRlcigpO1xuICAgIGRpdi5jbGFzc0xpc3QuYWRkKFwiZHJhd1wiKTtcbiAgICBjb25zdCBkcmF3RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkaXYuYXBwZW5kKGRyYXdEaXYpO1xuICAgIGRyYXdEaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgIGRyYXdEaXYuY2xhc3NOYW1lID0gXCJpbnRlcm5hbFwiO1xuICAgIHRoaXMuc2V0RGltcygpO1xuICAgIHRoaXMuX3VpTWFuYWdlci5hZGRTaG91bGRSZXNjYWxlKHRoaXMpO1xuICAgIHRoaXMuZGlzYWJsZUVkaXRpbmcoKTtcbiAgICBpZiAodGhpcy5faXNDb3B5KSB7XG4gICAgICB0aGlzLl9tb3ZlQWZ0ZXJQYXN0ZShiYXNlWCwgYmFzZVkpO1xuICAgIH1cbiAgICByZXR1cm4gZGl2O1xuICB9XG4gIHN0YXRpYyBjcmVhdGVEcmF3ZXJJbnN0YW5jZShfeCwgX3ksIF9wYXJlbnRXaWR0aCwgX3BhcmVudEhlaWdodCwgX3JvdGF0aW9uKSB7XG4gICAgdW5yZWFjaGFibGUoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgc3RhdGljIHN0YXJ0RHJhd2luZyhwYXJlbnQsIHVpTWFuYWdlciwgX2lzTFRSLCBldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHRhcmdldCxcbiAgICAgIG9mZnNldFg6IHgsXG4gICAgICBvZmZzZXRZOiB5LFxuICAgICAgcG9pbnRlcklkLFxuICAgICAgcG9pbnRlclR5cGVcbiAgICB9ID0gZXZlbnQ7XG4gICAgaWYgKERyYXdpbmdFZGl0b3IuI2N1cnJlbnRQb2ludGVyVHlwZSAmJiBEcmF3aW5nRWRpdG9yLiNjdXJyZW50UG9pbnRlclR5cGUgIT09IHBvaW50ZXJUeXBlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgIHJvdGF0aW9uXG4gICAgICB9XG4gICAgfSA9IHBhcmVudDtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aDogcGFyZW50V2lkdGgsXG4gICAgICBoZWlnaHQ6IHBhcmVudEhlaWdodFxuICAgIH0gPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgYWMgPSBEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhd2luZ0FDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHBhcmVudC5jb21iaW5lZFNpZ25hbChhYyk7XG4gICAgRHJhd2luZ0VkaXRvci4jY3VycmVudFBvaW50ZXJJZCB8fD0gcG9pbnRlcklkO1xuICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnRQb2ludGVyVHlwZSA/Pz0gcG9pbnRlclR5cGU7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgKGUpID0+IHtcbiAgICAgIGlmIChEcmF3aW5nRWRpdG9yLiNjdXJyZW50UG9pbnRlcklkID09PSBlLnBvaW50ZXJJZCkge1xuICAgICAgICB0aGlzLl9lbmREcmF3KGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgRHJhd2luZ0VkaXRvci4jY3VycmVudFBvaW50ZXJJZHM/LmRlbGV0ZShlLnBvaW50ZXJJZCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyY2FuY2VsXCIsIChlKSA9PiB7XG4gICAgICBpZiAoRHJhd2luZ0VkaXRvci4jY3VycmVudFBvaW50ZXJJZCA9PT0gZS5wb2ludGVySWQpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudFBhcmVudC5lbmREcmF3aW5nU2Vzc2lvbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgRHJhd2luZ0VkaXRvci4jY3VycmVudFBvaW50ZXJJZHM/LmRlbGV0ZShlLnBvaW50ZXJJZCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCAoZSkgPT4ge1xuICAgICAgaWYgKERyYXdpbmdFZGl0b3IuI2N1cnJlbnRQb2ludGVyVHlwZSAhPT0gZS5wb2ludGVyVHlwZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAoRHJhd2luZ0VkaXRvci4jY3VycmVudFBvaW50ZXJJZHMgfHw9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpLmFkZChlLnBvaW50ZXJJZCk7XG4gICAgICBpZiAoRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcuaXNDYW5jZWxsYWJsZSgpKSB7XG4gICAgICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3LnJlbW92ZUxhc3RFbGVtZW50KCk7XG4gICAgICAgIGlmIChEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhdy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICB0aGlzLl9jdXJyZW50UGFyZW50LmVuZERyYXdpbmdTZXNzaW9uKHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2VuZERyYXcobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG5vQ29udGV4dE1lbnUsIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgdGhpcy5fZHJhd01vdmUuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgKGUpID0+IHtcbiAgICAgIGlmIChlLnRpbWVTdGFtcCA9PT0gRHJhd2luZ0VkaXRvci4jY3VycmVudE1vdmVUaW1lc3RhbXApIHtcbiAgICAgICAgc3RvcEV2ZW50KGUpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHBhcmVudC50b2dnbGVEcmF3aW5nKCk7XG4gICAgdWlNYW5hZ2VyLl9lZGl0b3JVbmRvQmFyPy5oaWRlKCk7XG4gICAgaWYgKERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3KSB7XG4gICAgICBwYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fY3VycmVudERyYXdJZCwgRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcuc3RhcnROZXcoeCwgeSwgcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodCwgcm90YXRpb24pKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdWlNYW5hZ2VyLnVwZGF0ZVVJRm9yRGVmYXVsdFByb3BlcnRpZXModGhpcyk7XG4gICAgRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcgPSB0aGlzLmNyZWF0ZURyYXdlckluc3RhbmNlKHgsIHksIHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQsIHJvdGF0aW9uKTtcbiAgICBEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhd2luZ09wdGlvbnMgPSB0aGlzLmdldERlZmF1bHREcmF3aW5nT3B0aW9ucygpO1xuICAgIHRoaXMuX2N1cnJlbnRQYXJlbnQgPSBwYXJlbnQ7XG4gICAgKHtcbiAgICAgIGlkOiB0aGlzLl9jdXJyZW50RHJhd0lkXG4gICAgfSA9IHBhcmVudC5kcmF3TGF5ZXIuZHJhdyh0aGlzLl9tZXJnZVNWR1Byb3BlcnRpZXMoRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXdpbmdPcHRpb25zLnRvU1ZHUHJvcGVydGllcygpLCBEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhdy5kZWZhdWx0U1ZHUHJvcGVydGllcyksIHRydWUsIGZhbHNlKSk7XG4gIH1cbiAgc3RhdGljIF9kcmF3TW92ZShldmVudCkge1xuICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnRNb3ZlVGltZXN0YW1wID0gLTE7XG4gICAgaWYgKCFEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhdykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBvZmZzZXRYLFxuICAgICAgb2Zmc2V0WSxcbiAgICAgIHBvaW50ZXJJZFxuICAgIH0gPSBldmVudDtcbiAgICBpZiAoRHJhd2luZ0VkaXRvci4jY3VycmVudFBvaW50ZXJJZCAhPT0gcG9pbnRlcklkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChEcmF3aW5nRWRpdG9yLiNjdXJyZW50UG9pbnRlcklkcz8uc2l6ZSA+PSAxKSB7XG4gICAgICB0aGlzLl9lbmREcmF3KGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY3VycmVudFBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9jdXJyZW50RHJhd0lkLCBEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhdy5hZGQob2Zmc2V0WCwgb2Zmc2V0WSkpO1xuICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnRNb3ZlVGltZXN0YW1wID0gZXZlbnQudGltZVN0YW1wO1xuICAgIHN0b3BFdmVudChldmVudCk7XG4gIH1cbiAgc3RhdGljIF9jbGVhbnVwKGFsbCkge1xuICAgIGlmIChhbGwpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnREcmF3SWQgPSAtMTtcbiAgICAgIHRoaXMuX2N1cnJlbnRQYXJlbnQgPSBudWxsO1xuICAgICAgRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcgPSBudWxsO1xuICAgICAgRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXdpbmdPcHRpb25zID0gbnVsbDtcbiAgICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnRQb2ludGVyVHlwZSA9IG51bGw7XG4gICAgICBEcmF3aW5nRWRpdG9yLiNjdXJyZW50TW92ZVRpbWVzdGFtcCA9IE5hTjtcbiAgICB9XG4gICAgaWYgKERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3aW5nQUMpIHtcbiAgICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3aW5nQUMuYWJvcnQoKTtcbiAgICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3aW5nQUMgPSBudWxsO1xuICAgICAgRHJhd2luZ0VkaXRvci4jY3VycmVudFBvaW50ZXJJZCA9IE5hTjtcbiAgICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnRQb2ludGVySWRzID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgc3RhdGljIF9lbmREcmF3KGV2ZW50KSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5fY3VycmVudFBhcmVudDtcbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwYXJlbnQudG9nZ2xlRHJhd2luZyh0cnVlKTtcbiAgICB0aGlzLl9jbGVhbnVwKGZhbHNlKTtcbiAgICBpZiAoZXZlbnQ/LnRhcmdldCA9PT0gcGFyZW50LmRpdikge1xuICAgICAgcGFyZW50LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX2N1cnJlbnREcmF3SWQsIERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3LmVuZChldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnN1cHBvcnRNdWx0aXBsZURyYXdpbmdzKSB7XG4gICAgICBjb25zdCBkcmF3ID0gRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXc7XG4gICAgICBjb25zdCBkcmF3SWQgPSB0aGlzLl9jdXJyZW50RHJhd0lkO1xuICAgICAgY29uc3QgbGFzdEVsZW1lbnQgPSBkcmF3LmdldExhc3RFbGVtZW50KCk7XG4gICAgICBwYXJlbnQuYWRkQ29tbWFuZHMoe1xuICAgICAgICBjbWQ6ICgpID0+IHtcbiAgICAgICAgICBwYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXMoZHJhd0lkLCBkcmF3LnNldExhc3RFbGVtZW50KGxhc3RFbGVtZW50KSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVuZG86ICgpID0+IHtcbiAgICAgICAgICBwYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXMoZHJhd0lkLCBkcmF3LnJlbW92ZUxhc3RFbGVtZW50KCkpO1xuICAgICAgICB9LFxuICAgICAgICBtdXN0RXhlYzogZmFsc2UsXG4gICAgICAgIHR5cGU6IEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkRSQVdfU1RFUFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZW5kRHJhd2luZyhmYWxzZSk7XG4gIH1cbiAgc3RhdGljIGVuZERyYXdpbmcoaXNBYm9ydGVkKSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5fY3VycmVudFBhcmVudDtcbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHBhcmVudC50b2dnbGVEcmF3aW5nKHRydWUpO1xuICAgIHBhcmVudC5jbGVhblVuZG9TdGFjayhBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5EUkFXX1NURVApO1xuICAgIGlmICghRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcuaXNFbXB0eSgpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhZ2VEaW1lbnNpb25zOiBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSxcbiAgICAgICAgc2NhbGVcbiAgICAgIH0gPSBwYXJlbnQ7XG4gICAgICBjb25zdCBlZGl0b3IgPSBwYXJlbnQuY3JlYXRlQW5kQWRkTmV3RWRpdG9yKHtcbiAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgb2Zmc2V0WTogMFxuICAgICAgfSwgZmFsc2UsIHtcbiAgICAgICAgZHJhd0lkOiB0aGlzLl9jdXJyZW50RHJhd0lkLFxuICAgICAgICBkcmF3T3V0bGluZXM6IERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3LmdldE91dGxpbmVzKHBhZ2VXaWR0aCAqIHNjYWxlLCBwYWdlSGVpZ2h0ICogc2NhbGUsIHNjYWxlLCB0aGlzLl9JTk5FUl9NQVJHSU4pLFxuICAgICAgICBkcmF3aW5nT3B0aW9uczogRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXdpbmdPcHRpb25zLFxuICAgICAgICBtdXN0QmVDb21taXR0ZWQ6ICFpc0Fib3J0ZWRcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fY2xlYW51cCh0cnVlKTtcbiAgICAgIHJldHVybiBlZGl0b3I7XG4gICAgfVxuICAgIHBhcmVudC5kcmF3TGF5ZXIucmVtb3ZlKHRoaXMuX2N1cnJlbnREcmF3SWQpO1xuICAgIHRoaXMuX2NsZWFudXAodHJ1ZSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY3JlYXRlRHJhd2luZ09wdGlvbnMoX2RhdGEpIHtcbiAgfVxuICBzdGF0aWMgZGVzZXJpYWxpemVEcmF3KF9wYWdlWCwgX3BhZ2VZLCBfcGFnZVdpZHRoLCBfcGFnZUhlaWdodCwgX2lubmVyV2lkdGgsIF9kYXRhKSB7XG4gICAgdW5yZWFjaGFibGUoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmF3RGltczoge1xuICAgICAgICBwYWdlV2lkdGgsXG4gICAgICAgIHBhZ2VIZWlnaHQsXG4gICAgICAgIHBhZ2VYLFxuICAgICAgICBwYWdlWVxuICAgICAgfVxuICAgIH0gPSBwYXJlbnQudmlld3BvcnQ7XG4gICAgY29uc3QgZHJhd091dGxpbmVzID0gdGhpcy5kZXNlcmlhbGl6ZURyYXcocGFnZVgsIHBhZ2VZLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHQsIHRoaXMuX0lOTkVSX01BUkdJTiwgZGF0YSk7XG4gICAgY29uc3QgZWRpdG9yID0gYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpO1xuICAgIGVkaXRvci5jcmVhdGVEcmF3aW5nT3B0aW9ucyhkYXRhKTtcbiAgICBlZGl0b3IuI2NyZWF0ZURyYXdPdXRsaW5lcyh7XG4gICAgICBkcmF3T3V0bGluZXNcbiAgICB9KTtcbiAgICBlZGl0b3IuI2FkZFRvRHJhd0xheWVyKCk7XG4gICAgZWRpdG9yLm9uU2NhbGVDaGFuZ2luZygpO1xuICAgIGVkaXRvci5yb3RhdGUoKTtcbiAgICByZXR1cm4gZWRpdG9yO1xuICB9XG4gIHNlcmlhbGl6ZURyYXcoaXNGb3JDb3B5aW5nKSB7XG4gICAgY29uc3QgW3BhZ2VYLCBwYWdlWV0gPSB0aGlzLnBhZ2VUcmFuc2xhdGlvbjtcbiAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgcmV0dXJuIHRoaXMuI2RyYXdPdXRsaW5lcy5zZXJpYWxpemUoW3BhZ2VYLCBwYWdlWSwgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSwgaXNGb3JDb3B5aW5nKTtcbiAgfVxuICByZW5kZXJBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKSB7XG4gICAgYW5ub3RhdGlvbi51cGRhdGVFZGl0ZWQoe1xuICAgICAgcmVjdDogdGhpcy5nZXRQREZSZWN0KClcbiAgICB9KTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBzdGF0aWMgY2FuQ3JlYXRlTmV3RW1wdHlFZGl0b3IoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5jbGFzcyBJbmtEcmF3T3V0bGluZXIge1xuICAjbGFzdCA9IG5ldyBGbG9hdDY0QXJyYXkoNik7XG4gICNsaW5lO1xuICAjbGluZXM7XG4gICNyb3RhdGlvbjtcbiAgI3RoaWNrbmVzcztcbiAgI3BvaW50cztcbiAgI2xhc3RTVkdQYXRoID0gXCJcIjtcbiAgI2xhc3RJbmRleCA9IDA7XG4gICNvdXRsaW5lcyA9IG5ldyBJbmtEcmF3T3V0bGluZSgpO1xuICAjcGFyZW50V2lkdGg7XG4gICNwYXJlbnRIZWlnaHQ7XG4gIGNvbnN0cnVjdG9yKHgsIHksIHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQsIHJvdGF0aW9uLCB0aGlja25lc3MpIHtcbiAgICB0aGlzLiNwYXJlbnRXaWR0aCA9IHBhcmVudFdpZHRoO1xuICAgIHRoaXMuI3BhcmVudEhlaWdodCA9IHBhcmVudEhlaWdodDtcbiAgICB0aGlzLiNyb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHRoaXMuI3RoaWNrbmVzcyA9IHRoaWNrbmVzcztcbiAgICBbeCwgeV0gPSB0aGlzLiNub3JtYWxpemVQb2ludCh4LCB5KTtcbiAgICBjb25zdCBsaW5lID0gdGhpcy4jbGluZSA9IFtOYU4sIE5hTiwgTmFOLCBOYU4sIHgsIHldO1xuICAgIHRoaXMuI3BvaW50cyA9IFt4LCB5XTtcbiAgICB0aGlzLiNsaW5lcyA9IFt7XG4gICAgICBsaW5lLFxuICAgICAgcG9pbnRzOiB0aGlzLiNwb2ludHNcbiAgICB9XTtcbiAgICB0aGlzLiNsYXN0LnNldChsaW5lLCAwKTtcbiAgfVxuICB1cGRhdGVQcm9wZXJ0eShuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChuYW1lID09PSBcInN0cm9rZS13aWR0aFwiKSB7XG4gICAgICB0aGlzLiN0aGlja25lc3MgPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgI25vcm1hbGl6ZVBvaW50KHgsIHkpIHtcbiAgICByZXR1cm4gT3V0bGluZS5fbm9ybWFsaXplUG9pbnQoeCwgeSwgdGhpcy4jcGFyZW50V2lkdGgsIHRoaXMuI3BhcmVudEhlaWdodCwgdGhpcy4jcm90YXRpb24pO1xuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuICF0aGlzLiNsaW5lcyB8fCB0aGlzLiNsaW5lcy5sZW5ndGggPT09IDA7XG4gIH1cbiAgaXNDYW5jZWxsYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9pbnRzLmxlbmd0aCA8PSAxMDtcbiAgfVxuICBhZGQoeCwgeSkge1xuICAgIFt4LCB5XSA9IHRoaXMuI25vcm1hbGl6ZVBvaW50KHgsIHkpO1xuICAgIGNvbnN0IFt4MSwgeTEsIHgyLCB5Ml0gPSB0aGlzLiNsYXN0LnN1YmFycmF5KDIsIDYpO1xuICAgIGNvbnN0IGRpZmZYID0geCAtIHgyO1xuICAgIGNvbnN0IGRpZmZZID0geSAtIHkyO1xuICAgIGNvbnN0IGQgPSBNYXRoLmh5cG90KHRoaXMuI3BhcmVudFdpZHRoICogZGlmZlgsIHRoaXMuI3BhcmVudEhlaWdodCAqIGRpZmZZKTtcbiAgICBpZiAoZCA8PSAyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdGhpcy4jcG9pbnRzLnB1c2goeCwgeSk7XG4gICAgaWYgKGlzTmFOKHgxKSkge1xuICAgICAgdGhpcy4jbGFzdC5zZXQoW3gyLCB5MiwgeCwgeV0sIDIpO1xuICAgICAgdGhpcy4jbGluZS5wdXNoKE5hTiwgTmFOLCBOYU4sIE5hTiwgeCwgeSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgZDogdGhpcy50b1NWR1BhdGgoKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoaXNOYU4odGhpcy4jbGFzdFswXSkpIHtcbiAgICAgIHRoaXMuI2xpbmUuc3BsaWNlKDYsIDYpO1xuICAgIH1cbiAgICB0aGlzLiNsYXN0LnNldChbeDEsIHkxLCB4MiwgeTIsIHgsIHldLCAwKTtcbiAgICB0aGlzLiNsaW5lLnB1c2goLi4uT3V0bGluZS5jcmVhdGVCZXppZXJQb2ludHMoeDEsIHkxLCB4MiwgeTIsIHgsIHkpKTtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDoge1xuICAgICAgICBkOiB0aGlzLnRvU1ZHUGF0aCgpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBlbmQoeCwgeSkge1xuICAgIGNvbnN0IGNoYW5nZSA9IHRoaXMuYWRkKHgsIHkpO1xuICAgIGlmIChjaGFuZ2UpIHtcbiAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgfVxuICAgIGlmICh0aGlzLiNwb2ludHMubGVuZ3RoID09PSAyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgZDogdGhpcy50b1NWR1BhdGgoKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBzdGFydE5ldyh4LCB5LCBwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0LCByb3RhdGlvbikge1xuICAgIHRoaXMuI3BhcmVudFdpZHRoID0gcGFyZW50V2lkdGg7XG4gICAgdGhpcy4jcGFyZW50SGVpZ2h0ID0gcGFyZW50SGVpZ2h0O1xuICAgIHRoaXMuI3JvdGF0aW9uID0gcm90YXRpb247XG4gICAgW3gsIHldID0gdGhpcy4jbm9ybWFsaXplUG9pbnQoeCwgeSk7XG4gICAgY29uc3QgbGluZSA9IHRoaXMuI2xpbmUgPSBbTmFOLCBOYU4sIE5hTiwgTmFOLCB4LCB5XTtcbiAgICB0aGlzLiNwb2ludHMgPSBbeCwgeV07XG4gICAgY29uc3QgbGFzdCA9IHRoaXMuI2xpbmVzLmF0KC0xKTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5saW5lID0gbmV3IEZsb2F0MzJBcnJheShsYXN0LmxpbmUpO1xuICAgICAgbGFzdC5wb2ludHMgPSBuZXcgRmxvYXQzMkFycmF5KGxhc3QucG9pbnRzKTtcbiAgICB9XG4gICAgdGhpcy4jbGluZXMucHVzaCh7XG4gICAgICBsaW5lLFxuICAgICAgcG9pbnRzOiB0aGlzLiNwb2ludHNcbiAgICB9KTtcbiAgICB0aGlzLiNsYXN0LnNldChsaW5lLCAwKTtcbiAgICB0aGlzLiNsYXN0SW5kZXggPSAwO1xuICAgIHRoaXMudG9TVkdQYXRoKCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2V0TGFzdEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2xpbmVzLmF0KC0xKTtcbiAgfVxuICBzZXRMYXN0RWxlbWVudChlbGVtZW50KSB7XG4gICAgaWYgKCF0aGlzLiNsaW5lcykge1xuICAgICAgcmV0dXJuIHRoaXMuI291dGxpbmVzLnNldExhc3RFbGVtZW50KGVsZW1lbnQpO1xuICAgIH1cbiAgICB0aGlzLiNsaW5lcy5wdXNoKGVsZW1lbnQpO1xuICAgIHRoaXMuI2xpbmUgPSBlbGVtZW50LmxpbmU7XG4gICAgdGhpcy4jcG9pbnRzID0gZWxlbWVudC5wb2ludHM7XG4gICAgdGhpcy4jbGFzdEluZGV4ID0gMDtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDoge1xuICAgICAgICBkOiB0aGlzLnRvU1ZHUGF0aCgpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICByZW1vdmVMYXN0RWxlbWVudCgpIHtcbiAgICBpZiAoIXRoaXMuI2xpbmVzKSB7XG4gICAgICByZXR1cm4gdGhpcy4jb3V0bGluZXMucmVtb3ZlTGFzdEVsZW1lbnQoKTtcbiAgICB9XG4gICAgdGhpcy4jbGluZXMucG9wKCk7XG4gICAgdGhpcy4jbGFzdFNWR1BhdGggPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHRoaXMuI2xpbmVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGluZSxcbiAgICAgICAgcG9pbnRzXG4gICAgICB9ID0gdGhpcy4jbGluZXNbaV07XG4gICAgICB0aGlzLiNsaW5lID0gbGluZTtcbiAgICAgIHRoaXMuI3BvaW50cyA9IHBvaW50cztcbiAgICAgIHRoaXMuI2xhc3RJbmRleCA9IDA7XG4gICAgICB0aGlzLnRvU1ZHUGF0aCgpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDoge1xuICAgICAgICBkOiB0aGlzLiNsYXN0U1ZHUGF0aFxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgdG9TVkdQYXRoKCkge1xuICAgIGNvbnN0IGZpcnN0WCA9IE91dGxpbmUuc3ZnUm91bmQodGhpcy4jbGluZVs0XSk7XG4gICAgY29uc3QgZmlyc3RZID0gT3V0bGluZS5zdmdSb3VuZCh0aGlzLiNsaW5lWzVdKTtcbiAgICBpZiAodGhpcy4jcG9pbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdGhpcy4jbGFzdFNWR1BhdGggPSBgJHt0aGlzLiNsYXN0U1ZHUGF0aH0gTSAke2ZpcnN0WH0gJHtmaXJzdFl9IFpgO1xuICAgICAgcmV0dXJuIHRoaXMuI2xhc3RTVkdQYXRoO1xuICAgIH1cbiAgICBpZiAodGhpcy4jcG9pbnRzLmxlbmd0aCA8PSA2KSB7XG4gICAgICBjb25zdCBpID0gdGhpcy4jbGFzdFNWR1BhdGgubGFzdEluZGV4T2YoXCJNXCIpO1xuICAgICAgdGhpcy4jbGFzdFNWR1BhdGggPSBgJHt0aGlzLiNsYXN0U1ZHUGF0aC5zbGljZSgwLCBpKX0gTSAke2ZpcnN0WH0gJHtmaXJzdFl9YDtcbiAgICAgIHRoaXMuI2xhc3RJbmRleCA9IDY7XG4gICAgfVxuICAgIGlmICh0aGlzLiNwb2ludHMubGVuZ3RoID09PSA0KSB7XG4gICAgICBjb25zdCBzZWNvbmRYID0gT3V0bGluZS5zdmdSb3VuZCh0aGlzLiNsaW5lWzEwXSk7XG4gICAgICBjb25zdCBzZWNvbmRZID0gT3V0bGluZS5zdmdSb3VuZCh0aGlzLiNsaW5lWzExXSk7XG4gICAgICB0aGlzLiNsYXN0U1ZHUGF0aCA9IGAke3RoaXMuI2xhc3RTVkdQYXRofSBMICR7c2Vjb25kWH0gJHtzZWNvbmRZfWA7XG4gICAgICB0aGlzLiNsYXN0SW5kZXggPSAxMjtcbiAgICAgIHJldHVybiB0aGlzLiNsYXN0U1ZHUGF0aDtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVyID0gW107XG4gICAgaWYgKHRoaXMuI2xhc3RJbmRleCA9PT0gMCkge1xuICAgICAgYnVmZmVyLnB1c2goYE0gJHtmaXJzdFh9ICR7Zmlyc3RZfWApO1xuICAgICAgdGhpcy4jbGFzdEluZGV4ID0gNjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IHRoaXMuI2xhc3RJbmRleCwgaWkgPSB0aGlzLiNsaW5lLmxlbmd0aDsgaSA8IGlpOyBpICs9IDYpIHtcbiAgICAgIGNvbnN0IFtjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHldID0gdGhpcy4jbGluZS5zbGljZShpLCBpICsgNikubWFwKE91dGxpbmUuc3ZnUm91bmQpO1xuICAgICAgYnVmZmVyLnB1c2goYEMke2MxeH0gJHtjMXl9ICR7YzJ4fSAke2MyeX0gJHt4fSAke3l9YCk7XG4gICAgfVxuICAgIHRoaXMuI2xhc3RTVkdQYXRoICs9IGJ1ZmZlci5qb2luKFwiIFwiKTtcbiAgICB0aGlzLiNsYXN0SW5kZXggPSB0aGlzLiNsaW5lLmxlbmd0aDtcbiAgICByZXR1cm4gdGhpcy4jbGFzdFNWR1BhdGg7XG4gIH1cbiAgZ2V0T3V0bGluZXMocGFyZW50V2lkdGgsIHBhcmVudEhlaWdodCwgc2NhbGUsIGlubmVyTWFyZ2luKSB7XG4gICAgY29uc3QgbGFzdCA9IHRoaXMuI2xpbmVzLmF0KC0xKTtcbiAgICBsYXN0LmxpbmUgPSBuZXcgRmxvYXQzMkFycmF5KGxhc3QubGluZSk7XG4gICAgbGFzdC5wb2ludHMgPSBuZXcgRmxvYXQzMkFycmF5KGxhc3QucG9pbnRzKTtcbiAgICB0aGlzLiNvdXRsaW5lcy5idWlsZCh0aGlzLiNsaW5lcywgcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodCwgc2NhbGUsIHRoaXMuI3JvdGF0aW9uLCB0aGlzLiN0aGlja25lc3MsIGlubmVyTWFyZ2luKTtcbiAgICB0aGlzLiNsYXN0ID0gbnVsbDtcbiAgICB0aGlzLiNsaW5lID0gbnVsbDtcbiAgICB0aGlzLiNsaW5lcyA9IG51bGw7XG4gICAgdGhpcy4jbGFzdFNWR1BhdGggPSBudWxsO1xuICAgIHJldHVybiB0aGlzLiNvdXRsaW5lcztcbiAgfVxuICBnZXQgZGVmYXVsdFNWR1Byb3BlcnRpZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb3Q6IHtcbiAgICAgICAgdmlld0JveDogXCIwIDAgMTAwMDAgMTAwMDBcIlxuICAgICAgfSxcbiAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICBkcmF3OiB0cnVlXG4gICAgICB9LFxuICAgICAgYmJveDogWzAsIDAsIDEsIDFdXG4gICAgfTtcbiAgfVxufVxuY2xhc3MgSW5rRHJhd091dGxpbmUgZXh0ZW5kcyBPdXRsaW5lIHtcbiAgI2Jib3g7XG4gICNjdXJyZW50Um90YXRpb24gPSAwO1xuICAjaW5uZXJNYXJnaW47XG4gICNsaW5lcztcbiAgI3BhcmVudFdpZHRoO1xuICAjcGFyZW50SGVpZ2h0O1xuICAjcGFyZW50U2NhbGU7XG4gICNyb3RhdGlvbjtcbiAgI3RoaWNrbmVzcztcbiAgYnVpbGQobGluZXMsIHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQsIHBhcmVudFNjYWxlLCByb3RhdGlvbiwgdGhpY2tuZXNzLCBpbm5lck1hcmdpbikge1xuICAgIHRoaXMuI3BhcmVudFdpZHRoID0gcGFyZW50V2lkdGg7XG4gICAgdGhpcy4jcGFyZW50SGVpZ2h0ID0gcGFyZW50SGVpZ2h0O1xuICAgIHRoaXMuI3BhcmVudFNjYWxlID0gcGFyZW50U2NhbGU7XG4gICAgdGhpcy4jcm90YXRpb24gPSByb3RhdGlvbjtcbiAgICB0aGlzLiN0aGlja25lc3MgPSB0aGlja25lc3M7XG4gICAgdGhpcy4jaW5uZXJNYXJnaW4gPSBpbm5lck1hcmdpbiA/PyAwO1xuICAgIHRoaXMuI2xpbmVzID0gbGluZXM7XG4gICAgdGhpcy4jY29tcHV0ZUJib3goKTtcbiAgfVxuICBnZXQgdGhpY2tuZXNzKCkge1xuICAgIHJldHVybiB0aGlzLiN0aGlja25lc3M7XG4gIH1cbiAgc2V0TGFzdEVsZW1lbnQoZWxlbWVudCkge1xuICAgIHRoaXMuI2xpbmVzLnB1c2goZWxlbWVudCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgZDogdGhpcy50b1NWR1BhdGgoKVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmVtb3ZlTGFzdEVsZW1lbnQoKSB7XG4gICAgdGhpcy4jbGluZXMucG9wKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgZDogdGhpcy50b1NWR1BhdGgoKVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgdG9TVkdQYXRoKCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IFtdO1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgbGluZVxuICAgIH0gb2YgdGhpcy4jbGluZXMpIHtcbiAgICAgIGJ1ZmZlci5wdXNoKGBNJHtPdXRsaW5lLnN2Z1JvdW5kKGxpbmVbNF0pfSAke091dGxpbmUuc3ZnUm91bmQobGluZVs1XSl9YCk7XG4gICAgICBpZiAobGluZS5sZW5ndGggPT09IDYpIHtcbiAgICAgICAgYnVmZmVyLnB1c2goXCJaXCIpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lLmxlbmd0aCA9PT0gMTIgJiYgaXNOYU4obGluZVs2XSkpIHtcbiAgICAgICAgYnVmZmVyLnB1c2goYEwke091dGxpbmUuc3ZnUm91bmQobGluZVsxMF0pfSAke091dGxpbmUuc3ZnUm91bmQobGluZVsxMV0pfWApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSA2LCBpaSA9IGxpbmUubGVuZ3RoOyBpIDwgaWk7IGkgKz0gNikge1xuICAgICAgICBjb25zdCBbYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5XSA9IGxpbmUuc3ViYXJyYXkoaSwgaSArIDYpLm1hcChPdXRsaW5lLnN2Z1JvdW5kKTtcbiAgICAgICAgYnVmZmVyLnB1c2goYEMke2MxeH0gJHtjMXl9ICR7YzJ4fSAke2MyeX0gJHt4fSAke3l9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBidWZmZXIuam9pbihcIlwiKTtcbiAgfVxuICBzZXJpYWxpemUoW3BhZ2VYLCBwYWdlWSwgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSwgaXNGb3JDb3B5aW5nKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZExpbmVzID0gW107XG4gICAgY29uc3Qgc2VyaWFsaXplZFBvaW50cyA9IFtdO1xuICAgIGNvbnN0IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSA9IHRoaXMuI2dldEJCb3hXaXRoTm9NYXJnaW4oKTtcbiAgICBsZXQgdHgsIHR5LCBzeCwgc3ksIHgxLCB5MSwgeDIsIHkyLCByZXNjYWxlRm47XG4gICAgc3dpdGNoICh0aGlzLiNyb3RhdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXNjYWxlRm4gPSBPdXRsaW5lLl9yZXNjYWxlO1xuICAgICAgICB0eCA9IHBhZ2VYO1xuICAgICAgICB0eSA9IHBhZ2VZICsgcGFnZUhlaWdodDtcbiAgICAgICAgc3ggPSBwYWdlV2lkdGg7XG4gICAgICAgIHN5ID0gLXBhZ2VIZWlnaHQ7XG4gICAgICAgIHgxID0gcGFnZVggKyB4ICogcGFnZVdpZHRoO1xuICAgICAgICB5MSA9IHBhZ2VZICsgKDEgLSB5IC0gaGVpZ2h0KSAqIHBhZ2VIZWlnaHQ7XG4gICAgICAgIHgyID0gcGFnZVggKyAoeCArIHdpZHRoKSAqIHBhZ2VXaWR0aDtcbiAgICAgICAgeTIgPSBwYWdlWSArICgxIC0geSkgKiBwYWdlSGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJlc2NhbGVGbiA9IE91dGxpbmUuX3Jlc2NhbGVBbmRTd2FwO1xuICAgICAgICB0eCA9IHBhZ2VYO1xuICAgICAgICB0eSA9IHBhZ2VZO1xuICAgICAgICBzeCA9IHBhZ2VXaWR0aDtcbiAgICAgICAgc3kgPSBwYWdlSGVpZ2h0O1xuICAgICAgICB4MSA9IHBhZ2VYICsgeSAqIHBhZ2VXaWR0aDtcbiAgICAgICAgeTEgPSBwYWdlWSArIHggKiBwYWdlSGVpZ2h0O1xuICAgICAgICB4MiA9IHBhZ2VYICsgKHkgKyBoZWlnaHQpICogcGFnZVdpZHRoO1xuICAgICAgICB5MiA9IHBhZ2VZICsgKHggKyB3aWR0aCkgKiBwYWdlSGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXNjYWxlRm4gPSBPdXRsaW5lLl9yZXNjYWxlO1xuICAgICAgICB0eCA9IHBhZ2VYICsgcGFnZVdpZHRoO1xuICAgICAgICB0eSA9IHBhZ2VZO1xuICAgICAgICBzeCA9IC1wYWdlV2lkdGg7XG4gICAgICAgIHN5ID0gcGFnZUhlaWdodDtcbiAgICAgICAgeDEgPSBwYWdlWCArICgxIC0geCAtIHdpZHRoKSAqIHBhZ2VXaWR0aDtcbiAgICAgICAgeTEgPSBwYWdlWSArIHkgKiBwYWdlSGVpZ2h0O1xuICAgICAgICB4MiA9IHBhZ2VYICsgKDEgLSB4KSAqIHBhZ2VXaWR0aDtcbiAgICAgICAgeTIgPSBwYWdlWSArICh5ICsgaGVpZ2h0KSAqIHBhZ2VIZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJlc2NhbGVGbiA9IE91dGxpbmUuX3Jlc2NhbGVBbmRTd2FwO1xuICAgICAgICB0eCA9IHBhZ2VYICsgcGFnZVdpZHRoO1xuICAgICAgICB0eSA9IHBhZ2VZICsgcGFnZUhlaWdodDtcbiAgICAgICAgc3ggPSAtcGFnZVdpZHRoO1xuICAgICAgICBzeSA9IC1wYWdlSGVpZ2h0O1xuICAgICAgICB4MSA9IHBhZ2VYICsgKDEgLSB5IC0gaGVpZ2h0KSAqIHBhZ2VXaWR0aDtcbiAgICAgICAgeTEgPSBwYWdlWSArICgxIC0geCAtIHdpZHRoKSAqIHBhZ2VIZWlnaHQ7XG4gICAgICAgIHgyID0gcGFnZVggKyAoMSAtIHkpICogcGFnZVdpZHRoO1xuICAgICAgICB5MiA9IHBhZ2VZICsgKDEgLSB4KSAqIHBhZ2VIZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIGxpbmUsXG4gICAgICBwb2ludHNcbiAgICB9IG9mIHRoaXMuI2xpbmVzKSB7XG4gICAgICBzZXJpYWxpemVkTGluZXMucHVzaChyZXNjYWxlRm4obGluZSwgdHgsIHR5LCBzeCwgc3ksIGlzRm9yQ29weWluZyA/IG5ldyBBcnJheShsaW5lLmxlbmd0aCkgOiBudWxsKSk7XG4gICAgICBzZXJpYWxpemVkUG9pbnRzLnB1c2gocmVzY2FsZUZuKHBvaW50cywgdHgsIHR5LCBzeCwgc3ksIGlzRm9yQ29weWluZyA/IG5ldyBBcnJheShwb2ludHMubGVuZ3RoKSA6IG51bGwpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmVzOiBzZXJpYWxpemVkTGluZXMsXG4gICAgICBwb2ludHM6IHNlcmlhbGl6ZWRQb2ludHMsXG4gICAgICByZWN0OiBbeDEsIHkxLCB4MiwgeTJdXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgZGVzZXJpYWxpemUocGFnZVgsIHBhZ2VZLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHQsIGlubmVyTWFyZ2luLCB7XG4gICAgcGF0aHM6IHtcbiAgICAgIGxpbmVzLFxuICAgICAgcG9pbnRzXG4gICAgfSxcbiAgICByb3RhdGlvbixcbiAgICB0aGlja25lc3NcbiAgfSkge1xuICAgIGNvbnN0IG5ld0xpbmVzID0gW107XG4gICAgbGV0IHR4LCB0eSwgc3gsIHN5LCByZXNjYWxlRm47XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXNjYWxlRm4gPSBPdXRsaW5lLl9yZXNjYWxlO1xuICAgICAgICB0eCA9IC1wYWdlWCAvIHBhZ2VXaWR0aDtcbiAgICAgICAgdHkgPSBwYWdlWSAvIHBhZ2VIZWlnaHQgKyAxO1xuICAgICAgICBzeCA9IDEgLyBwYWdlV2lkdGg7XG4gICAgICAgIHN5ID0gLTEgLyBwYWdlSGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJlc2NhbGVGbiA9IE91dGxpbmUuX3Jlc2NhbGVBbmRTd2FwO1xuICAgICAgICB0eCA9IC1wYWdlWSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgIHR5ID0gLXBhZ2VYIC8gcGFnZVdpZHRoO1xuICAgICAgICBzeCA9IDEgLyBwYWdlSGVpZ2h0O1xuICAgICAgICBzeSA9IDEgLyBwYWdlV2lkdGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJlc2NhbGVGbiA9IE91dGxpbmUuX3Jlc2NhbGU7XG4gICAgICAgIHR4ID0gcGFnZVggLyBwYWdlV2lkdGggKyAxO1xuICAgICAgICB0eSA9IC1wYWdlWSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgIHN4ID0gLTEgLyBwYWdlV2lkdGg7XG4gICAgICAgIHN5ID0gMSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJlc2NhbGVGbiA9IE91dGxpbmUuX3Jlc2NhbGVBbmRTd2FwO1xuICAgICAgICB0eCA9IHBhZ2VZIC8gcGFnZUhlaWdodCArIDE7XG4gICAgICAgIHR5ID0gcGFnZVggLyBwYWdlV2lkdGggKyAxO1xuICAgICAgICBzeCA9IC0xIC8gcGFnZUhlaWdodDtcbiAgICAgICAgc3kgPSAtMSAvIHBhZ2VXaWR0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICghbGluZXMpIHtcbiAgICAgIGxpbmVzID0gW107XG4gICAgICBmb3IgKGNvbnN0IHBvaW50IG9mIHBvaW50cykge1xuICAgICAgICBjb25zdCBsZW4gPSBwb2ludC5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPT09IDIpIHtcbiAgICAgICAgICBsaW5lcy5wdXNoKG5ldyBGbG9hdDMyQXJyYXkoW05hTiwgTmFOLCBOYU4sIE5hTiwgcG9pbnRbMF0sIHBvaW50WzFdXSkpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW4gPT09IDQpIHtcbiAgICAgICAgICBsaW5lcy5wdXNoKG5ldyBGbG9hdDMyQXJyYXkoW05hTiwgTmFOLCBOYU4sIE5hTiwgcG9pbnRbMF0sIHBvaW50WzFdLCBOYU4sIE5hTiwgTmFOLCBOYU4sIHBvaW50WzJdLCBwb2ludFszXV0pKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaW5lID0gbmV3IEZsb2F0MzJBcnJheSgzICogKGxlbiAtIDIpKTtcbiAgICAgICAgbGluZXMucHVzaChsaW5lKTtcbiAgICAgICAgbGV0IFt4MSwgeTEsIHgyLCB5Ml0gPSBwb2ludC5zdWJhcnJheSgwLCA0KTtcbiAgICAgICAgbGluZS5zZXQoW05hTiwgTmFOLCBOYU4sIE5hTiwgeDEsIHkxXSwgMCk7XG4gICAgICAgIGZvciAobGV0IGkgPSA0OyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICAgICAgICBjb25zdCB4ID0gcG9pbnRbaV07XG4gICAgICAgICAgY29uc3QgeSA9IHBvaW50W2kgKyAxXTtcbiAgICAgICAgICBsaW5lLnNldChPdXRsaW5lLmNyZWF0ZUJlemllclBvaW50cyh4MSwgeTEsIHgyLCB5MiwgeCwgeSksIChpIC0gMikgKiAzKTtcbiAgICAgICAgICBbeDEsIHkxLCB4MiwgeTJdID0gW3gyLCB5MiwgeCwgeV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gbGluZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgbmV3TGluZXMucHVzaCh7XG4gICAgICAgIGxpbmU6IHJlc2NhbGVGbihsaW5lc1tpXS5tYXAoKHgpID0+IHggPz8gTmFOKSwgdHgsIHR5LCBzeCwgc3kpLFxuICAgICAgICBwb2ludHM6IHJlc2NhbGVGbihwb2ludHNbaV0ubWFwKCh4KSA9PiB4ID8/IE5hTiksIHR4LCB0eSwgc3gsIHN5KVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG91dGxpbmVzID0gbmV3IHRoaXMucHJvdG90eXBlLmNvbnN0cnVjdG9yKCk7XG4gICAgb3V0bGluZXMuYnVpbGQobmV3TGluZXMsIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgMSwgcm90YXRpb24sIHRoaWNrbmVzcywgaW5uZXJNYXJnaW4pO1xuICAgIHJldHVybiBvdXRsaW5lcztcbiAgfVxuICAjZ2V0TWFyZ2luQ29tcG9uZW50cyh0aGlja25lc3MgPSB0aGlzLiN0aGlja25lc3MpIHtcbiAgICBjb25zdCBtYXJnaW4gPSB0aGlzLiNpbm5lck1hcmdpbiArIHRoaWNrbmVzcyAvIDIgKiB0aGlzLiNwYXJlbnRTY2FsZTtcbiAgICByZXR1cm4gdGhpcy4jcm90YXRpb24gJSAxODAgPT09IDAgPyBbbWFyZ2luIC8gdGhpcy4jcGFyZW50V2lkdGgsIG1hcmdpbiAvIHRoaXMuI3BhcmVudEhlaWdodF0gOiBbbWFyZ2luIC8gdGhpcy4jcGFyZW50SGVpZ2h0LCBtYXJnaW4gLyB0aGlzLiNwYXJlbnRXaWR0aF07XG4gIH1cbiAgI2dldEJCb3hXaXRoTm9NYXJnaW4oKSB7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gdGhpcy4jYmJveDtcbiAgICBjb25zdCBbbWFyZ2luWCwgbWFyZ2luWV0gPSB0aGlzLiNnZXRNYXJnaW5Db21wb25lbnRzKDApO1xuICAgIHJldHVybiBbeCArIG1hcmdpblgsIHkgKyBtYXJnaW5ZLCB3aWR0aCAtIDIgKiBtYXJnaW5YLCBoZWlnaHQgLSAyICogbWFyZ2luWV07XG4gIH1cbiAgI2NvbXB1dGVCYm94KCkge1xuICAgIGNvbnN0IGJib3ggPSB0aGlzLiNiYm94ID0gbmV3IEZsb2F0MzJBcnJheShbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV0pO1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgbGluZVxuICAgIH0gb2YgdGhpcy4jbGluZXMpIHtcbiAgICAgIGlmIChsaW5lLmxlbmd0aCA8PSAxMikge1xuICAgICAgICBmb3IgKGxldCBpID0gNCwgaWkgPSBsaW5lLmxlbmd0aDsgaSA8IGlpOyBpICs9IDYpIHtcbiAgICAgICAgICBVdGlsLnBvaW50Qm91bmRpbmdCb3gobGluZVtpXSwgbGluZVtpICsgMV0sIGJib3gpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGV0IGxhc3RYID0gbGluZVs0XSwgbGFzdFkgPSBsaW5lWzVdO1xuICAgICAgZm9yIChsZXQgaSA9IDYsIGlpID0gbGluZS5sZW5ndGg7IGkgPCBpaTsgaSArPSA2KSB7XG4gICAgICAgIGNvbnN0IFtjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHldID0gbGluZS5zdWJhcnJheShpLCBpICsgNik7XG4gICAgICAgIFV0aWwuYmV6aWVyQm91bmRpbmdCb3gobGFzdFgsIGxhc3RZLCBjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHksIGJib3gpO1xuICAgICAgICBsYXN0WCA9IHg7XG4gICAgICAgIGxhc3RZID0geTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgW21hcmdpblgsIG1hcmdpblldID0gdGhpcy4jZ2V0TWFyZ2luQ29tcG9uZW50cygpO1xuICAgIGJib3hbMF0gPSBNYXRoQ2xhbXAoYmJveFswXSAtIG1hcmdpblgsIDAsIDEpO1xuICAgIGJib3hbMV0gPSBNYXRoQ2xhbXAoYmJveFsxXSAtIG1hcmdpblksIDAsIDEpO1xuICAgIGJib3hbMl0gPSBNYXRoQ2xhbXAoYmJveFsyXSArIG1hcmdpblgsIDAsIDEpO1xuICAgIGJib3hbM10gPSBNYXRoQ2xhbXAoYmJveFszXSArIG1hcmdpblksIDAsIDEpO1xuICAgIGJib3hbMl0gLT0gYmJveFswXTtcbiAgICBiYm94WzNdIC09IGJib3hbMV07XG4gIH1cbiAgZ2V0IGJveCgpIHtcbiAgICByZXR1cm4gdGhpcy4jYmJveDtcbiAgfVxuICB1cGRhdGVQcm9wZXJ0eShuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChuYW1lID09PSBcInN0cm9rZS13aWR0aFwiKSB7XG4gICAgICByZXR1cm4gdGhpcy4jdXBkYXRlVGhpY2tuZXNzKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgI3VwZGF0ZVRoaWNrbmVzcyh0aGlja25lc3MpIHtcbiAgICBjb25zdCBbb2xkTWFyZ2luWCwgb2xkTWFyZ2luWV0gPSB0aGlzLiNnZXRNYXJnaW5Db21wb25lbnRzKCk7XG4gICAgdGhpcy4jdGhpY2tuZXNzID0gdGhpY2tuZXNzO1xuICAgIGNvbnN0IFtuZXdNYXJnaW5YLCBuZXdNYXJnaW5ZXSA9IHRoaXMuI2dldE1hcmdpbkNvbXBvbmVudHMoKTtcbiAgICBjb25zdCBbZGlmZk1hcmdpblgsIGRpZmZNYXJnaW5ZXSA9IFtuZXdNYXJnaW5YIC0gb2xkTWFyZ2luWCwgbmV3TWFyZ2luWSAtIG9sZE1hcmdpblldO1xuICAgIGNvbnN0IGJib3ggPSB0aGlzLiNiYm94O1xuICAgIGJib3hbMF0gLT0gZGlmZk1hcmdpblg7XG4gICAgYmJveFsxXSAtPSBkaWZmTWFyZ2luWTtcbiAgICBiYm94WzJdICs9IDIgKiBkaWZmTWFyZ2luWDtcbiAgICBiYm94WzNdICs9IDIgKiBkaWZmTWFyZ2luWTtcbiAgICByZXR1cm4gYmJveDtcbiAgfVxuICB1cGRhdGVQYXJlbnREaW1lbnNpb25zKFt3aWR0aCwgaGVpZ2h0XSwgc2NhbGUpIHtcbiAgICBjb25zdCBbb2xkTWFyZ2luWCwgb2xkTWFyZ2luWV0gPSB0aGlzLiNnZXRNYXJnaW5Db21wb25lbnRzKCk7XG4gICAgdGhpcy4jcGFyZW50V2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLiNwYXJlbnRIZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy4jcGFyZW50U2NhbGUgPSBzY2FsZTtcbiAgICBjb25zdCBbbmV3TWFyZ2luWCwgbmV3TWFyZ2luWV0gPSB0aGlzLiNnZXRNYXJnaW5Db21wb25lbnRzKCk7XG4gICAgY29uc3QgZGlmZk1hcmdpblggPSBuZXdNYXJnaW5YIC0gb2xkTWFyZ2luWDtcbiAgICBjb25zdCBkaWZmTWFyZ2luWSA9IG5ld01hcmdpblkgLSBvbGRNYXJnaW5ZO1xuICAgIGNvbnN0IGJib3ggPSB0aGlzLiNiYm94O1xuICAgIGJib3hbMF0gLT0gZGlmZk1hcmdpblg7XG4gICAgYmJveFsxXSAtPSBkaWZmTWFyZ2luWTtcbiAgICBiYm94WzJdICs9IDIgKiBkaWZmTWFyZ2luWDtcbiAgICBiYm94WzNdICs9IDIgKiBkaWZmTWFyZ2luWTtcbiAgICByZXR1cm4gYmJveDtcbiAgfVxuICB1cGRhdGVSb3RhdGlvbihyb3RhdGlvbikge1xuICAgIHRoaXMuI2N1cnJlbnRSb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiB7XG4gICAgICAgIHRyYW5zZm9ybTogdGhpcy5yb3RhdGlvblRyYW5zZm9ybVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZ2V0IHZpZXdCb3goKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Jib3gubWFwKE91dGxpbmUuc3ZnUm91bmQpLmpvaW4oXCIgXCIpO1xuICB9XG4gIGdldCBkZWZhdWx0UHJvcGVydGllcygpIHtcbiAgICBjb25zdCBbeCwgeV0gPSB0aGlzLiNiYm94O1xuICAgIHJldHVybiB7XG4gICAgICByb290OiB7XG4gICAgICAgIHZpZXdCb3g6IHRoaXMudmlld0JveFxuICAgICAgfSxcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgXCJ0cmFuc2Zvcm0tb3JpZ2luXCI6IGAke091dGxpbmUuc3ZnUm91bmQoeCl9ICR7T3V0bGluZS5zdmdSb3VuZCh5KX1gXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBnZXQgcm90YXRpb25UcmFuc2Zvcm0oKSB7XG4gICAgY29uc3QgWywgLCB3aWR0aCwgaGVpZ2h0XSA9IHRoaXMuI2Jib3g7XG4gICAgbGV0IGEgPSAwLCBiID0gMCwgYyA9IDAsIGQgPSAwLCBlID0gMCwgZiA9IDA7XG4gICAgc3dpdGNoICh0aGlzLiNjdXJyZW50Um90YXRpb24pIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIGIgPSBoZWlnaHQgLyB3aWR0aDtcbiAgICAgICAgYyA9IC13aWR0aCAvIGhlaWdodDtcbiAgICAgICAgZSA9IHdpZHRoO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICBhID0gLTE7XG4gICAgICAgIGQgPSAtMTtcbiAgICAgICAgZSA9IHdpZHRoO1xuICAgICAgICBmID0gaGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICBiID0gLWhlaWdodCAvIHdpZHRoO1xuICAgICAgICBjID0gd2lkdGggLyBoZWlnaHQ7XG4gICAgICAgIGYgPSBoZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHJldHVybiBgbWF0cml4KCR7YX0gJHtifSAke2N9ICR7ZH0gJHtPdXRsaW5lLnN2Z1JvdW5kKGUpfSAke091dGxpbmUuc3ZnUm91bmQoZil9KWA7XG4gIH1cbiAgZ2V0UGF0aFJlc2l6aW5nU1ZHUHJvcGVydGllcyhbbmV3WCwgbmV3WSwgbmV3V2lkdGgsIG5ld0hlaWdodF0pIHtcbiAgICBjb25zdCBbbWFyZ2luWCwgbWFyZ2luWV0gPSB0aGlzLiNnZXRNYXJnaW5Db21wb25lbnRzKCk7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gdGhpcy4jYmJveDtcbiAgICBpZiAoTWF0aC5hYnMod2lkdGggLSBtYXJnaW5YKSA8PSBPdXRsaW5lLlBSRUNJU0lPTiB8fCBNYXRoLmFicyhoZWlnaHQgLSBtYXJnaW5ZKSA8PSBPdXRsaW5lLlBSRUNJU0lPTikge1xuICAgICAgY29uc3QgdHggPSBuZXdYICsgbmV3V2lkdGggLyAyIC0gKHggKyB3aWR0aCAvIDIpO1xuICAgICAgY29uc3QgdHkgPSBuZXdZICsgbmV3SGVpZ2h0IC8gMiAtICh5ICsgaGVpZ2h0IC8gMik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgXCJ0cmFuc2Zvcm0tb3JpZ2luXCI6IGAke091dGxpbmUuc3ZnUm91bmQobmV3WCl9ICR7T3V0bGluZS5zdmdSb3VuZChuZXdZKX1gLFxuICAgICAgICAgIHRyYW5zZm9ybTogYCR7dGhpcy5yb3RhdGlvblRyYW5zZm9ybX0gdHJhbnNsYXRlKCR7dHh9ICR7dHl9KWBcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgczF4ID0gKG5ld1dpZHRoIC0gMiAqIG1hcmdpblgpIC8gKHdpZHRoIC0gMiAqIG1hcmdpblgpO1xuICAgIGNvbnN0IHMxeSA9IChuZXdIZWlnaHQgLSAyICogbWFyZ2luWSkgLyAoaGVpZ2h0IC0gMiAqIG1hcmdpblkpO1xuICAgIGNvbnN0IHMyeCA9IHdpZHRoIC8gbmV3V2lkdGg7XG4gICAgY29uc3QgczJ5ID0gaGVpZ2h0IC8gbmV3SGVpZ2h0O1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiB7XG4gICAgICAgIFwidHJhbnNmb3JtLW9yaWdpblwiOiBgJHtPdXRsaW5lLnN2Z1JvdW5kKHgpfSAke091dGxpbmUuc3ZnUm91bmQoeSl9YCxcbiAgICAgICAgdHJhbnNmb3JtOiBgJHt0aGlzLnJvdGF0aW9uVHJhbnNmb3JtfSBzY2FsZSgke3MyeH0gJHtzMnl9KSB0cmFuc2xhdGUoJHtPdXRsaW5lLnN2Z1JvdW5kKG1hcmdpblgpfSAke091dGxpbmUuc3ZnUm91bmQobWFyZ2luWSl9KSBzY2FsZSgke3MxeH0gJHtzMXl9KSB0cmFuc2xhdGUoJHtPdXRsaW5lLnN2Z1JvdW5kKC1tYXJnaW5YKX0gJHtPdXRsaW5lLnN2Z1JvdW5kKC1tYXJnaW5ZKX0pYFxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZ2V0UGF0aFJlc2l6ZWRTVkdQcm9wZXJ0aWVzKFtuZXdYLCBuZXdZLCBuZXdXaWR0aCwgbmV3SGVpZ2h0XSkge1xuICAgIGNvbnN0IFttYXJnaW5YLCBtYXJnaW5ZXSA9IHRoaXMuI2dldE1hcmdpbkNvbXBvbmVudHMoKTtcbiAgICBjb25zdCBiYm94ID0gdGhpcy4jYmJveDtcbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSBiYm94O1xuICAgIGJib3hbMF0gPSBuZXdYO1xuICAgIGJib3hbMV0gPSBuZXdZO1xuICAgIGJib3hbMl0gPSBuZXdXaWR0aDtcbiAgICBiYm94WzNdID0gbmV3SGVpZ2h0O1xuICAgIGlmIChNYXRoLmFicyh3aWR0aCAtIG1hcmdpblgpIDw9IE91dGxpbmUuUFJFQ0lTSU9OIHx8IE1hdGguYWJzKGhlaWdodCAtIG1hcmdpblkpIDw9IE91dGxpbmUuUFJFQ0lTSU9OKSB7XG4gICAgICBjb25zdCB0eDIgPSBuZXdYICsgbmV3V2lkdGggLyAyIC0gKHggKyB3aWR0aCAvIDIpO1xuICAgICAgY29uc3QgdHkyID0gbmV3WSArIG5ld0hlaWdodCAvIDIgLSAoeSArIGhlaWdodCAvIDIpO1xuICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgIGxpbmUsXG4gICAgICAgIHBvaW50c1xuICAgICAgfSBvZiB0aGlzLiNsaW5lcykge1xuICAgICAgICBPdXRsaW5lLl90cmFuc2xhdGUobGluZSwgdHgyLCB0eTIsIGxpbmUpO1xuICAgICAgICBPdXRsaW5lLl90cmFuc2xhdGUocG9pbnRzLCB0eDIsIHR5MiwgcG9pbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICB2aWV3Qm94OiB0aGlzLnZpZXdCb3hcbiAgICAgICAgfSxcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIFwidHJhbnNmb3JtLW9yaWdpblwiOiBgJHtPdXRsaW5lLnN2Z1JvdW5kKG5ld1gpfSAke091dGxpbmUuc3ZnUm91bmQobmV3WSl9YCxcbiAgICAgICAgICB0cmFuc2Zvcm06IHRoaXMucm90YXRpb25UcmFuc2Zvcm0gfHwgbnVsbCxcbiAgICAgICAgICBkOiB0aGlzLnRvU1ZHUGF0aCgpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHMxeCA9IChuZXdXaWR0aCAtIDIgKiBtYXJnaW5YKSAvICh3aWR0aCAtIDIgKiBtYXJnaW5YKTtcbiAgICBjb25zdCBzMXkgPSAobmV3SGVpZ2h0IC0gMiAqIG1hcmdpblkpIC8gKGhlaWdodCAtIDIgKiBtYXJnaW5ZKTtcbiAgICBjb25zdCB0eCA9IC1zMXggKiAoeCArIG1hcmdpblgpICsgbmV3WCArIG1hcmdpblg7XG4gICAgY29uc3QgdHkgPSAtczF5ICogKHkgKyBtYXJnaW5ZKSArIG5ld1kgKyBtYXJnaW5ZO1xuICAgIGlmIChzMXggIT09IDEgfHwgczF5ICE9PSAxIHx8IHR4ICE9PSAwIHx8IHR5ICE9PSAwKSB7XG4gICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgbGluZSxcbiAgICAgICAgcG9pbnRzXG4gICAgICB9IG9mIHRoaXMuI2xpbmVzKSB7XG4gICAgICAgIE91dGxpbmUuX3Jlc2NhbGUobGluZSwgdHgsIHR5LCBzMXgsIHMxeSwgbGluZSk7XG4gICAgICAgIE91dGxpbmUuX3Jlc2NhbGUocG9pbnRzLCB0eCwgdHksIHMxeCwgczF5LCBwb2ludHMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcm9vdDoge1xuICAgICAgICB2aWV3Qm94OiB0aGlzLnZpZXdCb3hcbiAgICAgIH0sXG4gICAgICBwYXRoOiB7XG4gICAgICAgIFwidHJhbnNmb3JtLW9yaWdpblwiOiBgJHtPdXRsaW5lLnN2Z1JvdW5kKG5ld1gpfSAke091dGxpbmUuc3ZnUm91bmQobmV3WSl9YCxcbiAgICAgICAgdHJhbnNmb3JtOiB0aGlzLnJvdGF0aW9uVHJhbnNmb3JtIHx8IG51bGwsXG4gICAgICAgIGQ6IHRoaXMudG9TVkdQYXRoKClcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGdldFBhdGhUcmFuc2xhdGVkU1ZHUHJvcGVydGllcyhbbmV3WCwgbmV3WV0sIHBhcmVudERpbWVuc2lvbnMpIHtcbiAgICBjb25zdCBbbmV3UGFyZW50V2lkdGgsIG5ld1BhcmVudEhlaWdodF0gPSBwYXJlbnREaW1lbnNpb25zO1xuICAgIGNvbnN0IGJib3ggPSB0aGlzLiNiYm94O1xuICAgIGNvbnN0IHR4ID0gbmV3WCAtIGJib3hbMF07XG4gICAgY29uc3QgdHkgPSBuZXdZIC0gYmJveFsxXTtcbiAgICBpZiAodGhpcy4jcGFyZW50V2lkdGggPT09IG5ld1BhcmVudFdpZHRoICYmIHRoaXMuI3BhcmVudEhlaWdodCA9PT0gbmV3UGFyZW50SGVpZ2h0KSB7XG4gICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgbGluZSxcbiAgICAgICAgcG9pbnRzXG4gICAgICB9IG9mIHRoaXMuI2xpbmVzKSB7XG4gICAgICAgIE91dGxpbmUuX3RyYW5zbGF0ZShsaW5lLCB0eCwgdHksIGxpbmUpO1xuICAgICAgICBPdXRsaW5lLl90cmFuc2xhdGUocG9pbnRzLCB0eCwgdHksIHBvaW50cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN4ID0gdGhpcy4jcGFyZW50V2lkdGggLyBuZXdQYXJlbnRXaWR0aDtcbiAgICAgIGNvbnN0IHN5ID0gdGhpcy4jcGFyZW50SGVpZ2h0IC8gbmV3UGFyZW50SGVpZ2h0O1xuICAgICAgdGhpcy4jcGFyZW50V2lkdGggPSBuZXdQYXJlbnRXaWR0aDtcbiAgICAgIHRoaXMuI3BhcmVudEhlaWdodCA9IG5ld1BhcmVudEhlaWdodDtcbiAgICAgIGZvciAoY29uc3Qge1xuICAgICAgICBsaW5lLFxuICAgICAgICBwb2ludHNcbiAgICAgIH0gb2YgdGhpcy4jbGluZXMpIHtcbiAgICAgICAgT3V0bGluZS5fcmVzY2FsZShsaW5lLCB0eCwgdHksIHN4LCBzeSwgbGluZSk7XG4gICAgICAgIE91dGxpbmUuX3Jlc2NhbGUocG9pbnRzLCB0eCwgdHksIHN4LCBzeSwgcG9pbnRzKTtcbiAgICAgIH1cbiAgICAgIGJib3hbMl0gKj0gc3g7XG4gICAgICBiYm94WzNdICo9IHN5O1xuICAgIH1cbiAgICBiYm94WzBdID0gbmV3WDtcbiAgICBiYm94WzFdID0gbmV3WTtcbiAgICByZXR1cm4ge1xuICAgICAgcm9vdDoge1xuICAgICAgICB2aWV3Qm94OiB0aGlzLnZpZXdCb3hcbiAgICAgIH0sXG4gICAgICBwYXRoOiB7XG4gICAgICAgIGQ6IHRoaXMudG9TVkdQYXRoKCksXG4gICAgICAgIFwidHJhbnNmb3JtLW9yaWdpblwiOiBgJHtPdXRsaW5lLnN2Z1JvdW5kKG5ld1gpfSAke091dGxpbmUuc3ZnUm91bmQobmV3WSl9YFxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZ2V0IGRlZmF1bHRTVkdQcm9wZXJ0aWVzKCkge1xuICAgIGNvbnN0IGJib3ggPSB0aGlzLiNiYm94O1xuICAgIHJldHVybiB7XG4gICAgICByb290OiB7XG4gICAgICAgIHZpZXdCb3g6IHRoaXMudmlld0JveFxuICAgICAgfSxcbiAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICBkcmF3OiB0cnVlXG4gICAgICB9LFxuICAgICAgcGF0aDoge1xuICAgICAgICBkOiB0aGlzLnRvU1ZHUGF0aCgpLFxuICAgICAgICBcInRyYW5zZm9ybS1vcmlnaW5cIjogYCR7T3V0bGluZS5zdmdSb3VuZChiYm94WzBdKX0gJHtPdXRsaW5lLnN2Z1JvdW5kKGJib3hbMV0pfWAsXG4gICAgICAgIHRyYW5zZm9ybTogdGhpcy5yb3RhdGlvblRyYW5zZm9ybSB8fCBudWxsXG4gICAgICB9LFxuICAgICAgYmJveFxuICAgIH07XG4gIH1cbn1cbmNsYXNzIElua0RyYXdpbmdPcHRpb25zIGV4dGVuZHMgRHJhd2luZ09wdGlvbnMge1xuICBjb25zdHJ1Y3Rvcih2aWV3ZXJQYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl92aWV3UGFyYW1ldGVycyA9IHZpZXdlclBhcmFtZXRlcnM7XG4gICAgc3VwZXIudXBkYXRlUHJvcGVydGllcyh7XG4gICAgICBmaWxsOiBcIm5vbmVcIixcbiAgICAgIHN0cm9rZTogQW5ub3RhdGlvbkVkaXRvci5fZGVmYXVsdExpbmVDb2xvcixcbiAgICAgIFwic3Ryb2tlLW9wYWNpdHlcIjogMSxcbiAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IDEsXG4gICAgICBcInN0cm9rZS1saW5lY2FwXCI6IFwicm91bmRcIixcbiAgICAgIFwic3Ryb2tlLWxpbmVqb2luXCI6IFwicm91bmRcIixcbiAgICAgIFwic3Ryb2tlLW1pdGVybGltaXRcIjogMTBcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVTVkdQcm9wZXJ0eShuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChuYW1lID09PSBcInN0cm9rZS13aWR0aFwiKSB7XG4gICAgICB2YWx1ZSA/Pz0gdGhpc1tcInN0cm9rZS13aWR0aFwiXTtcbiAgICAgIHZhbHVlICo9IHRoaXMuX3ZpZXdQYXJhbWV0ZXJzLnJlYWxTY2FsZTtcbiAgICB9XG4gICAgc3VwZXIudXBkYXRlU1ZHUHJvcGVydHkobmFtZSwgdmFsdWUpO1xuICB9XG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGNsb25lID0gbmV3IElua0RyYXdpbmdPcHRpb25zKHRoaXMuX3ZpZXdQYXJhbWV0ZXJzKTtcbiAgICBjbG9uZS51cGRhdGVBbGwodGhpcyk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG59XG5jbGFzcyBJbmtFZGl0b3IgZXh0ZW5kcyBEcmF3aW5nRWRpdG9yIHtcbiAgc3RhdGljIF90eXBlID0gXCJpbmtcIjtcbiAgc3RhdGljIF9lZGl0b3JUeXBlID0gQW5ub3RhdGlvbkVkaXRvclR5cGUuSU5LO1xuICBzdGF0aWMgX2RlZmF1bHREcmF3aW5nT3B0aW9ucyA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLnBhcmFtcyxcbiAgICAgIG5hbWU6IFwiaW5rRWRpdG9yXCJcbiAgICB9KTtcbiAgICB0aGlzLl93aWxsS2VlcEFzcGVjdFJhdGlvID0gdHJ1ZTtcbiAgICB0aGlzLmRlZmF1bHRMMTBuSWQgPSBcInBkZmpzLWVkaXRvci1pbmstZWRpdG9yXCI7XG4gIH1cbiAgc3RhdGljIGluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKSB7XG4gICAgQW5ub3RhdGlvbkVkaXRvci5pbml0aWFsaXplKGwxMG4sIHVpTWFuYWdlcik7XG4gICAgdGhpcy5fZGVmYXVsdERyYXdpbmdPcHRpb25zID0gbmV3IElua0RyYXdpbmdPcHRpb25zKHVpTWFuYWdlci52aWV3UGFyYW1ldGVycyk7XG4gIH1cbiAgc3RhdGljIGdldERlZmF1bHREcmF3aW5nT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgY29uc3QgY2xvbmUgPSB0aGlzLl9kZWZhdWx0RHJhd2luZ09wdGlvbnMuY2xvbmUoKTtcbiAgICBjbG9uZS51cGRhdGVQcm9wZXJ0aWVzKG9wdGlvbnMpO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuICBzdGF0aWMgZ2V0IHN1cHBvcnRNdWx0aXBsZURyYXdpbmdzKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZXNNYXAoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcInR5cGVzTWFwXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX1RISUNLTkVTUywgXCJzdHJva2Utd2lkdGhcIl0sIFtBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfQ09MT1IsIFwic3Ryb2tlXCJdLCBbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX09QQUNJVFksIFwic3Ryb2tlLW9wYWNpdHlcIl1dKSk7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZURyYXdlckluc3RhbmNlKHgsIHksIHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQsIHJvdGF0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBJbmtEcmF3T3V0bGluZXIoeCwgeSwgcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodCwgcm90YXRpb24sIHRoaXMuX2RlZmF1bHREcmF3aW5nT3B0aW9uc1tcInN0cm9rZS13aWR0aFwiXSk7XG4gIH1cbiAgc3RhdGljIGRlc2VyaWFsaXplRHJhdyhwYWdlWCwgcGFnZVksIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgaW5uZXJNYXJnaW4sIGRhdGEpIHtcbiAgICByZXR1cm4gSW5rRHJhd091dGxpbmUuZGVzZXJpYWxpemUocGFnZVgsIHBhZ2VZLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHQsIGlubmVyTWFyZ2luLCBkYXRhKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpIHtcbiAgICBsZXQgaW5pdGlhbERhdGEgPSBudWxsO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgSW5rQW5ub3RhdGlvbkVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGlua0xpc3RzLFxuICAgICAgICAgIHJlY3QsXG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgY29sb3IsXG4gICAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgICBib3JkZXJTdHlsZToge1xuICAgICAgICAgICAgcmF3V2lkdGg6IHRoaWNrbmVzc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcG9wdXBSZWYsXG4gICAgICAgICAgcmljaFRleHQsXG4gICAgICAgICAgY29udGVudHNPYmosXG4gICAgICAgICAgY3JlYXRpb25EYXRlLFxuICAgICAgICAgIG1vZGlmaWNhdGlvbkRhdGVcbiAgICAgICAgfSxcbiAgICAgICAgcGFyZW50OiB7XG4gICAgICAgICAgcGFnZToge1xuICAgICAgICAgICAgcGFnZU51bWJlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSA9IGRhdGE7XG4gICAgICBpbml0aWFsRGF0YSA9IGRhdGEgPSB7XG4gICAgICAgIGFubm90YXRpb25UeXBlOiBBbm5vdGF0aW9uRWRpdG9yVHlwZS5JTkssXG4gICAgICAgIGNvbG9yOiBBcnJheS5mcm9tKGNvbG9yKSxcbiAgICAgICAgdGhpY2tuZXNzLFxuICAgICAgICBvcGFjaXR5LFxuICAgICAgICBwYXRoczoge1xuICAgICAgICAgIHBvaW50czogaW5rTGlzdHNcbiAgICAgICAgfSxcbiAgICAgICAgYm94ZXM6IG51bGwsXG4gICAgICAgIHBhZ2VJbmRleDogcGFnZU51bWJlciAtIDEsXG4gICAgICAgIHJlY3Q6IHJlY3Quc2xpY2UoMCksXG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICBhbm5vdGF0aW9uRWxlbWVudElkOiBpZCxcbiAgICAgICAgaWQsXG4gICAgICAgIGRlbGV0ZWQ6IGZhbHNlLFxuICAgICAgICBwb3B1cFJlZixcbiAgICAgICAgcmljaFRleHQsXG4gICAgICAgIGNvbW1lbnQ6IGNvbnRlbnRzT2JqPy5zdHIgfHwgbnVsbCxcbiAgICAgICAgY3JlYXRpb25EYXRlLFxuICAgICAgICBtb2RpZmljYXRpb25EYXRlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBlZGl0b3IgPSBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcik7XG4gICAgZWRpdG9yLl9pbml0aWFsRGF0YSA9IGluaXRpYWxEYXRhO1xuICAgIGlmIChkYXRhLmNvbW1lbnQpIHtcbiAgICAgIGVkaXRvci5zZXRDb21tZW50RGF0YShkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxuICBnZXQgdG9vbGJhckJ1dHRvbnMoKSB7XG4gICAgdGhpcy5fY29sb3JQaWNrZXIgfHw9IG5ldyBCYXNpY0NvbG9yUGlja2VyKHRoaXMpO1xuICAgIHJldHVybiBbW1wiY29sb3JQaWNrZXJcIiwgdGhpcy5fY29sb3JQaWNrZXJdXTtcbiAgfVxuICBnZXQgY29sb3JUeXBlKCkge1xuICAgIHJldHVybiBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfQ09MT1I7XG4gIH1cbiAgZ2V0IGNvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9kcmF3aW5nT3B0aW9ucy5zdHJva2U7XG4gIH1cbiAgZ2V0IG9wYWNpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RyYXdpbmdPcHRpb25zW1wic3Ryb2tlLW9wYWNpdHlcIl07XG4gIH1cbiAgb25TY2FsZUNoYW5naW5nKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIub25TY2FsZUNoYW5naW5nKCk7XG4gICAgY29uc3Qge1xuICAgICAgX2RyYXdJZCxcbiAgICAgIF9kcmF3aW5nT3B0aW9ucyxcbiAgICAgIHBhcmVudFxuICAgIH0gPSB0aGlzO1xuICAgIF9kcmF3aW5nT3B0aW9ucy51cGRhdGVTVkdQcm9wZXJ0eShcInN0cm9rZS13aWR0aFwiKTtcbiAgICBwYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXMoX2RyYXdJZCwgX2RyYXdpbmdPcHRpb25zLnRvU1ZHUHJvcGVydGllcygpKTtcbiAgfVxuICBzdGF0aWMgb25TY2FsZUNoYW5naW5nV2hlbkRyYXdpbmcoKSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5fY3VycmVudFBhcmVudDtcbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5vblNjYWxlQ2hhbmdpbmdXaGVuRHJhd2luZygpO1xuICAgIHRoaXMuX2RlZmF1bHREcmF3aW5nT3B0aW9ucy51cGRhdGVTVkdQcm9wZXJ0eShcInN0cm9rZS13aWR0aFwiKTtcbiAgICBwYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fY3VycmVudERyYXdJZCwgdGhpcy5fZGVmYXVsdERyYXdpbmdPcHRpb25zLnRvU1ZHUHJvcGVydGllcygpKTtcbiAgfVxuICBjcmVhdGVEcmF3aW5nT3B0aW9ucyh7XG4gICAgY29sb3IsXG4gICAgdGhpY2tuZXNzLFxuICAgIG9wYWNpdHlcbiAgfSkge1xuICAgIHRoaXMuX2RyYXdpbmdPcHRpb25zID0gSW5rRWRpdG9yLmdldERlZmF1bHREcmF3aW5nT3B0aW9ucyh7XG4gICAgICBzdHJva2U6IFV0aWwubWFrZUhleENvbG9yKC4uLmNvbG9yKSxcbiAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IHRoaWNrbmVzcyxcbiAgICAgIFwic3Ryb2tlLW9wYWNpdHlcIjogb3BhY2l0eVxuICAgIH0pO1xuICB9XG4gIHNlcmlhbGl6ZShpc0ZvckNvcHlpbmcgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZURlbGV0ZWQoKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgbGluZXMsXG4gICAgICBwb2ludHNcbiAgICB9ID0gdGhpcy5zZXJpYWxpemVEcmF3KGlzRm9yQ29weWluZyk7XG4gICAgY29uc3Qge1xuICAgICAgX2RyYXdpbmdPcHRpb25zOiB7XG4gICAgICAgIHN0cm9rZSxcbiAgICAgICAgXCJzdHJva2Utb3BhY2l0eVwiOiBvcGFjaXR5LFxuICAgICAgICBcInN0cm9rZS13aWR0aFwiOiB0aGlja25lc3NcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBzZXJpYWxpemVkID0gT2JqZWN0LmFzc2lnbihzdXBlci5zZXJpYWxpemUoaXNGb3JDb3B5aW5nKSwge1xuICAgICAgY29sb3I6IEFubm90YXRpb25FZGl0b3IuX2NvbG9yTWFuYWdlci5jb252ZXJ0KHN0cm9rZSksXG4gICAgICBvcGFjaXR5LFxuICAgICAgdGhpY2tuZXNzLFxuICAgICAgcGF0aHM6IHtcbiAgICAgICAgbGluZXMsXG4gICAgICAgIHBvaW50c1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuYWRkQ29tbWVudChzZXJpYWxpemVkKTtcbiAgICBpZiAoaXNGb3JDb3B5aW5nKSB7XG4gICAgICBzZXJpYWxpemVkLmlzQ29weSA9IHRydWU7XG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gICAgaWYgKHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCAmJiAhdGhpcy4jaGFzRWxlbWVudENoYW5nZWQoc2VyaWFsaXplZCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzZXJpYWxpemVkLmlkID0gdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkO1xuICAgIHJldHVybiBzZXJpYWxpemVkO1xuICB9XG4gICNoYXNFbGVtZW50Q2hhbmdlZChzZXJpYWxpemVkKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29sb3IsXG4gICAgICB0aGlja25lc3MsXG4gICAgICBvcGFjaXR5LFxuICAgICAgcGFnZUluZGV4XG4gICAgfSA9IHRoaXMuX2luaXRpYWxEYXRhO1xuICAgIHJldHVybiB0aGlzLmhhc0VkaXRlZENvbW1lbnQgfHwgdGhpcy5faGFzQmVlbk1vdmVkIHx8IHRoaXMuX2hhc0JlZW5SZXNpemVkIHx8IHNlcmlhbGl6ZWQuY29sb3Iuc29tZSgoYywgaSkgPT4gYyAhPT0gY29sb3JbaV0pIHx8IHNlcmlhbGl6ZWQudGhpY2tuZXNzICE9PSB0aGlja25lc3MgfHwgc2VyaWFsaXplZC5vcGFjaXR5ICE9PSBvcGFjaXR5IHx8IHNlcmlhbGl6ZWQucGFnZUluZGV4ICE9PSBwYWdlSW5kZXg7XG4gIH1cbiAgcmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIGlmICh0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIGFubm90YXRpb24uaGlkZSgpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHBvaW50cyxcbiAgICAgIHJlY3RcbiAgICB9ID0gdGhpcy5zZXJpYWxpemVEcmF3KGZhbHNlKTtcbiAgICBhbm5vdGF0aW9uLnVwZGF0ZUVkaXRlZCh7XG4gICAgICByZWN0LFxuICAgICAgdGhpY2tuZXNzOiB0aGlzLl9kcmF3aW5nT3B0aW9uc1tcInN0cm9rZS13aWR0aFwiXSxcbiAgICAgIHBvaW50cyxcbiAgICAgIHBvcHVwOiB0aGlzLmNvbW1lbnRcbiAgICB9KTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuY2xhc3MgQ29udG91ckRyYXdPdXRsaW5lIGV4dGVuZHMgSW5rRHJhd091dGxpbmUge1xuICB0b1NWR1BhdGgoKSB7XG4gICAgbGV0IHBhdGggPSBzdXBlci50b1NWR1BhdGgoKTtcbiAgICBpZiAoIXBhdGguZW5kc1dpdGgoXCJaXCIpKSB7XG4gICAgICBwYXRoICs9IFwiWlwiO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbiAgfVxufVxuY29uc3QgQkFTRV9IRUFERVJfTEVOR1RIID0gODtcbmNvbnN0IFBPSU5UU19QUk9QRVJUSUVTX05VTUJFUiA9IDM7XG5jbGFzcyBTaWduYXR1cmVFeHRyYWN0b3Ige1xuICBzdGF0aWMgI1BBUkFNRVRFUlMgPSB7XG4gICAgbWF4RGltOiA1MTIsXG4gICAgc2lnbWFTRmFjdG9yOiAwLjAyLFxuICAgIHNpZ21hUjogMjUsXG4gICAga2VybmVsU2l6ZTogMTZcbiAgfTtcbiAgc3RhdGljICNuZWlnaGJvckluZGV4VG9JZChpMCwgajAsIGksIGopIHtcbiAgICBpIC09IGkwO1xuICAgIGogLT0gajA7XG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIHJldHVybiBqID4gMCA/IDAgOiA0O1xuICAgIH1cbiAgICBpZiAoaSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGogKyA2O1xuICAgIH1cbiAgICByZXR1cm4gMiAtIGo7XG4gIH1cbiAgc3RhdGljICNuZWlnaGJvcklkVG9JbmRleCA9IG5ldyBJbnQzMkFycmF5KFswLCAxLCAtMSwgMSwgLTEsIDAsIC0xLCAtMSwgMCwgLTEsIDEsIC0xLCAxLCAwLCAxLCAxXSk7XG4gIHN0YXRpYyAjY2xvY2t3aXNlTm9uWmVybyhidWYsIHdpZHRoLCBpMCwgajAsIGksIGosIG9mZnNldCkge1xuICAgIGNvbnN0IGlkID0gdGhpcy4jbmVpZ2hib3JJbmRleFRvSWQoaTAsIGowLCBpLCBqKTtcbiAgICBmb3IgKGxldCBrID0gMDsgayA8IDg7IGsrKykge1xuICAgICAgY29uc3Qga2sgPSAoLWsgKyBpZCAtIG9mZnNldCArIDE2KSAlIDg7XG4gICAgICBjb25zdCBzaGlmdEkgPSB0aGlzLiNuZWlnaGJvcklkVG9JbmRleFsyICoga2tdO1xuICAgICAgY29uc3Qgc2hpZnRKID0gdGhpcy4jbmVpZ2hib3JJZFRvSW5kZXhbMiAqIGtrICsgMV07XG4gICAgICBpZiAoYnVmWyhpMCArIHNoaWZ0SSkgKiB3aWR0aCArIChqMCArIHNoaWZ0SildICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBraztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHN0YXRpYyAjY291bnRlckNsb2Nrd2lzZU5vblplcm8oYnVmLCB3aWR0aCwgaTAsIGowLCBpLCBqLCBvZmZzZXQpIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuI25laWdoYm9ySW5kZXhUb0lkKGkwLCBqMCwgaSwgaik7XG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCA4OyBrKyspIHtcbiAgICAgIGNvbnN0IGtrID0gKGsgKyBpZCArIG9mZnNldCArIDE2KSAlIDg7XG4gICAgICBjb25zdCBzaGlmdEkgPSB0aGlzLiNuZWlnaGJvcklkVG9JbmRleFsyICoga2tdO1xuICAgICAgY29uc3Qgc2hpZnRKID0gdGhpcy4jbmVpZ2hib3JJZFRvSW5kZXhbMiAqIGtrICsgMV07XG4gICAgICBpZiAoYnVmWyhpMCArIHNoaWZ0SSkgKiB3aWR0aCArIChqMCArIHNoaWZ0SildICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBraztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHN0YXRpYyAjZmluZENvbnRvdXJzKGJ1Ziwgd2lkdGgsIGhlaWdodCwgdGhyZXNob2xkKSB7XG4gICAgY29uc3QgTiA9IGJ1Zi5sZW5ndGg7XG4gICAgY29uc3QgdHlwZXMgPSBuZXcgSW50MzJBcnJheShOKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgdHlwZXNbaV0gPSBidWZbaV0gPD0gdGhyZXNob2xkID8gMSA6IDA7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaGVpZ2h0IC0gMTsgaSsrKSB7XG4gICAgICB0eXBlc1tpICogd2lkdGhdID0gdHlwZXNbaSAqIHdpZHRoICsgd2lkdGggLSAxXSA9IDA7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xuICAgICAgdHlwZXNbaV0gPSB0eXBlc1t3aWR0aCAqIGhlaWdodCAtIDEgLSBpXSA9IDA7XG4gICAgfVxuICAgIGxldCBuYmQgPSAxO1xuICAgIGxldCBsbmJkO1xuICAgIGNvbnN0IGNvbnRvdXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBoZWlnaHQgLSAxOyBpKyspIHtcbiAgICAgIGxuYmQgPSAxO1xuICAgICAgZm9yIChsZXQgaiA9IDE7IGogPCB3aWR0aCAtIDE7IGorKykge1xuICAgICAgICBjb25zdCBpaiA9IGkgKiB3aWR0aCArIGo7XG4gICAgICAgIGNvbnN0IHBpeCA9IHR5cGVzW2lqXTtcbiAgICAgICAgaWYgKHBpeCA9PT0gMCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpMiA9IGk7XG4gICAgICAgIGxldCBqMiA9IGo7XG4gICAgICAgIGlmIChwaXggPT09IDEgJiYgdHlwZXNbaWogLSAxXSA9PT0gMCkge1xuICAgICAgICAgIG5iZCArPSAxO1xuICAgICAgICAgIGoyIC09IDE7XG4gICAgICAgIH0gZWxzZSBpZiAocGl4ID49IDEgJiYgdHlwZXNbaWogKyAxXSA9PT0gMCkge1xuICAgICAgICAgIG5iZCArPSAxO1xuICAgICAgICAgIGoyICs9IDE7XG4gICAgICAgICAgaWYgKHBpeCA+IDEpIHtcbiAgICAgICAgICAgIGxuYmQgPSBwaXg7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChwaXggIT09IDEpIHtcbiAgICAgICAgICAgIGxuYmQgPSBNYXRoLmFicyhwaXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb2ludHMgPSBbaiwgaV07XG4gICAgICAgIGNvbnN0IGlzSG9sZSA9IGoyID09PSBqICsgMTtcbiAgICAgICAgY29uc3QgY29udG91ciA9IHtcbiAgICAgICAgICBpc0hvbGUsXG4gICAgICAgICAgcG9pbnRzLFxuICAgICAgICAgIGlkOiBuYmQsXG4gICAgICAgICAgcGFyZW50OiAwXG4gICAgICAgIH07XG4gICAgICAgIGNvbnRvdXJzLnB1c2goY29udG91cik7XG4gICAgICAgIGxldCBjb250b3VyMDtcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIGNvbnRvdXJzKSB7XG4gICAgICAgICAgaWYgKGMuaWQgPT09IGxuYmQpIHtcbiAgICAgICAgICAgIGNvbnRvdXIwID0gYztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbnRvdXIwKSB7XG4gICAgICAgICAgY29udG91ci5wYXJlbnQgPSBpc0hvbGUgPyBsbmJkIDogMDtcbiAgICAgICAgfSBlbHNlIGlmIChjb250b3VyMC5pc0hvbGUpIHtcbiAgICAgICAgICBjb250b3VyLnBhcmVudCA9IGlzSG9sZSA/IGNvbnRvdXIwLnBhcmVudCA6IGxuYmQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udG91ci5wYXJlbnQgPSBpc0hvbGUgPyBsbmJkIDogY29udG91cjAucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGsgPSB0aGlzLiNjbG9ja3dpc2VOb25aZXJvKHR5cGVzLCB3aWR0aCwgaSwgaiwgaTIsIGoyLCAwKTtcbiAgICAgICAgaWYgKGsgPT09IC0xKSB7XG4gICAgICAgICAgdHlwZXNbaWpdID0gLW5iZDtcbiAgICAgICAgICBpZiAodHlwZXNbaWpdICE9PSAxKSB7XG4gICAgICAgICAgICBsbmJkID0gTWF0aC5hYnModHlwZXNbaWpdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNoaWZ0SSA9IHRoaXMuI25laWdoYm9ySWRUb0luZGV4WzIgKiBrXTtcbiAgICAgICAgbGV0IHNoaWZ0SiA9IHRoaXMuI25laWdoYm9ySWRUb0luZGV4WzIgKiBrICsgMV07XG4gICAgICAgIGNvbnN0IGkxID0gaSArIHNoaWZ0STtcbiAgICAgICAgY29uc3QgajEgPSBqICsgc2hpZnRKO1xuICAgICAgICBpMiA9IGkxO1xuICAgICAgICBqMiA9IGoxO1xuICAgICAgICBsZXQgaTMgPSBpO1xuICAgICAgICBsZXQgajMgPSBqO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGNvbnN0IGtrID0gdGhpcy4jY291bnRlckNsb2Nrd2lzZU5vblplcm8odHlwZXMsIHdpZHRoLCBpMywgajMsIGkyLCBqMiwgMSk7XG4gICAgICAgICAgc2hpZnRJID0gdGhpcy4jbmVpZ2hib3JJZFRvSW5kZXhbMiAqIGtrXTtcbiAgICAgICAgICBzaGlmdEogPSB0aGlzLiNuZWlnaGJvcklkVG9JbmRleFsyICoga2sgKyAxXTtcbiAgICAgICAgICBjb25zdCBpNCA9IGkzICsgc2hpZnRJO1xuICAgICAgICAgIGNvbnN0IGo0ID0gajMgKyBzaGlmdEo7XG4gICAgICAgICAgcG9pbnRzLnB1c2goajQsIGk0KTtcbiAgICAgICAgICBjb25zdCBpajMgPSBpMyAqIHdpZHRoICsgajM7XG4gICAgICAgICAgaWYgKHR5cGVzW2lqMyArIDFdID09PSAwKSB7XG4gICAgICAgICAgICB0eXBlc1tpajNdID0gLW5iZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVzW2lqM10gPT09IDEpIHtcbiAgICAgICAgICAgIHR5cGVzW2lqM10gPSBuYmQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpNCA9PT0gaSAmJiBqNCA9PT0gaiAmJiBpMyA9PT0gaTEgJiYgajMgPT09IGoxKSB7XG4gICAgICAgICAgICBpZiAodHlwZXNbaWpdICE9PSAxKSB7XG4gICAgICAgICAgICAgIGxuYmQgPSBNYXRoLmFicyh0eXBlc1tpal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGkyID0gaTM7XG4gICAgICAgICAgICBqMiA9IGozO1xuICAgICAgICAgICAgaTMgPSBpNDtcbiAgICAgICAgICAgIGozID0gajQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb250b3VycztcbiAgfVxuICBzdGF0aWMgI2RvdWdsYXNQZXVja2VySGVscGVyKHBvaW50cywgc3RhcnQsIGVuZCwgb3V0cHV0KSB7XG4gICAgaWYgKGVuZCAtIHN0YXJ0IDw9IDQpIHtcbiAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZCAtIDI7IGkgKz0gMikge1xuICAgICAgICBvdXRwdXQucHVzaChwb2ludHNbaV0sIHBvaW50c1tpICsgMV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBheCA9IHBvaW50c1tzdGFydF07XG4gICAgY29uc3QgYXkgPSBwb2ludHNbc3RhcnQgKyAxXTtcbiAgICBjb25zdCBhYnggPSBwb2ludHNbZW5kIC0gNF0gLSBheDtcbiAgICBjb25zdCBhYnkgPSBwb2ludHNbZW5kIC0gM10gLSBheTtcbiAgICBjb25zdCBkaXN0ID0gTWF0aC5oeXBvdChhYngsIGFieSk7XG4gICAgY29uc3QgbmFieCA9IGFieCAvIGRpc3Q7XG4gICAgY29uc3QgbmFieSA9IGFieSAvIGRpc3Q7XG4gICAgY29uc3QgYWEgPSBuYWJ4ICogYXkgLSBuYWJ5ICogYXg7XG4gICAgY29uc3QgbSA9IGFieSAvIGFieDtcbiAgICBjb25zdCBpbnZTID0gMSAvIGRpc3Q7XG4gICAgY29uc3QgcGhpID0gTWF0aC5hdGFuKG0pO1xuICAgIGNvbnN0IGNvc1BoaSA9IE1hdGguY29zKHBoaSk7XG4gICAgY29uc3Qgc2luUGhpID0gTWF0aC5zaW4ocGhpKTtcbiAgICBjb25zdCB0bWF4ID0gaW52UyAqIChNYXRoLmFicyhjb3NQaGkpICsgTWF0aC5hYnMoc2luUGhpKSk7XG4gICAgY29uc3QgcG9seSA9IGludlMgKiAoMSAtIHRtYXggKyB0bWF4ICoqIDIpO1xuICAgIGNvbnN0IHBhcnRpYWxQaGkgPSBNYXRoLm1heChNYXRoLmF0YW4oTWF0aC5hYnMoc2luUGhpICsgY29zUGhpKSAqIHBvbHkpLCBNYXRoLmF0YW4oTWF0aC5hYnMoc2luUGhpIC0gY29zUGhpKSAqIHBvbHkpKTtcbiAgICBsZXQgZG1heCA9IDA7XG4gICAgbGV0IGluZGV4ID0gc3RhcnQ7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0ICsgMjsgaSA8IGVuZCAtIDI7IGkgKz0gMikge1xuICAgICAgY29uc3QgZCA9IE1hdGguYWJzKGFhIC0gbmFieCAqIHBvaW50c1tpICsgMV0gKyBuYWJ5ICogcG9pbnRzW2ldKTtcbiAgICAgIGlmIChkID4gZG1heCkge1xuICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgIGRtYXggPSBkO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZG1heCA+IChkaXN0ICogcGFydGlhbFBoaSkgKiogMikge1xuICAgICAgdGhpcy4jZG91Z2xhc1BldWNrZXJIZWxwZXIocG9pbnRzLCBzdGFydCwgaW5kZXggKyAyLCBvdXRwdXQpO1xuICAgICAgdGhpcy4jZG91Z2xhc1BldWNrZXJIZWxwZXIocG9pbnRzLCBpbmRleCwgZW5kLCBvdXRwdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaChheCwgYXkpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgI2RvdWdsYXNQZXVja2VyKHBvaW50cykge1xuICAgIGNvbnN0IG91dHB1dCA9IFtdO1xuICAgIGNvbnN0IGxlbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgdGhpcy4jZG91Z2xhc1BldWNrZXJIZWxwZXIocG9pbnRzLCAwLCBsZW4sIG91dHB1dCk7XG4gICAgb3V0cHV0LnB1c2gocG9pbnRzW2xlbiAtIDJdLCBwb2ludHNbbGVuIC0gMV0pO1xuICAgIHJldHVybiBvdXRwdXQubGVuZ3RoIDw9IDQgPyBudWxsIDogb3V0cHV0O1xuICB9XG4gIHN0YXRpYyAjYmlsYXRlcmFsRmlsdGVyKGJ1Ziwgd2lkdGgsIGhlaWdodCwgc2lnbWFTLCBzaWdtYVIsIGtlcm5lbFNpemUpIHtcbiAgICBjb25zdCBrZXJuZWwgPSBuZXcgRmxvYXQzMkFycmF5KGtlcm5lbFNpemUgKiogMik7XG4gICAgY29uc3Qgc2lnbWFTMiA9IC0yICogc2lnbWFTICoqIDI7XG4gICAgY29uc3QgaGFsZlNpemUgPSBrZXJuZWxTaXplID4+IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXJuZWxTaXplOyBpKyspIHtcbiAgICAgIGNvbnN0IHggPSAoaSAtIGhhbGZTaXplKSAqKiAyO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBrZXJuZWxTaXplOyBqKyspIHtcbiAgICAgICAga2VybmVsW2kgKiBrZXJuZWxTaXplICsgal0gPSBNYXRoLmV4cCgoeCArIChqIC0gaGFsZlNpemUpICoqIDIpIC8gc2lnbWFTMik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJhbmdlVmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSgyNTYpO1xuICAgIGNvbnN0IHNpZ21hUjIgPSAtMiAqIHNpZ21hUiAqKiAyO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgIHJhbmdlVmFsdWVzW2ldID0gTWF0aC5leHAoaSAqKiAyIC8gc2lnbWFSMik7XG4gICAgfVxuICAgIGNvbnN0IE4gPSBidWYubGVuZ3RoO1xuICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KE4pO1xuICAgIGNvbnN0IGhpc3RvZ3JhbSA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVpZ2h0OyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgd2lkdGg7IGorKykge1xuICAgICAgICBjb25zdCBpaiA9IGkgKiB3aWR0aCArIGo7XG4gICAgICAgIGNvbnN0IGNlbnRlciA9IGJ1Zltpal07XG4gICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICBsZXQgbm9ybSA9IDA7XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwga2VybmVsU2l6ZTsgaysrKSB7XG4gICAgICAgICAgY29uc3QgeSA9IGkgKyBrIC0gaGFsZlNpemU7XG4gICAgICAgICAgaWYgKHkgPCAwIHx8IHkgPj0gaGVpZ2h0KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChsZXQgbCA9IDA7IGwgPCBrZXJuZWxTaXplOyBsKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSBqICsgbCAtIGhhbGZTaXplO1xuICAgICAgICAgICAgaWYgKHggPCAwIHx8IHggPj0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZWlnaGJvdXIgPSBidWZbeSAqIHdpZHRoICsgeF07XG4gICAgICAgICAgICBjb25zdCB3ID0ga2VybmVsW2sgKiBrZXJuZWxTaXplICsgbF0gKiByYW5nZVZhbHVlc1tNYXRoLmFicyhuZWlnaGJvdXIgLSBjZW50ZXIpXTtcbiAgICAgICAgICAgIHN1bSArPSBuZWlnaGJvdXIgKiB3O1xuICAgICAgICAgICAgbm9ybSArPSB3O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwaXggPSBvdXRbaWpdID0gTWF0aC5yb3VuZChzdW0gLyBub3JtKTtcbiAgICAgICAgaGlzdG9ncmFtW3BpeF0rKztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtvdXQsIGhpc3RvZ3JhbV07XG4gIH1cbiAgc3RhdGljICNnZXRIaXN0b2dyYW0oYnVmKSB7XG4gICAgY29uc3QgaGlzdG9ncmFtID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gICAgZm9yIChjb25zdCBnIG9mIGJ1Zikge1xuICAgICAgaGlzdG9ncmFtW2ddKys7XG4gICAgfVxuICAgIHJldHVybiBoaXN0b2dyYW07XG4gIH1cbiAgc3RhdGljICN0b1VpbnQ4KGJ1Zikge1xuICAgIGNvbnN0IE4gPSBidWYubGVuZ3RoO1xuICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OENsYW1wZWRBcnJheShOID4+IDIpO1xuICAgIGxldCBtYXggPSAtSW5maW5pdHk7XG4gICAgbGV0IG1pbiA9IEluZmluaXR5O1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IG91dC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBjb25zdCBwaXggPSBvdXRbaV0gPSBidWZbaSA8PCAyXTtcbiAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgcGl4KTtcbiAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgcGl4KTtcbiAgICB9XG4gICAgY29uc3QgcmF0aW8gPSAyNTUgLyAobWF4IC0gbWluKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBvdXQubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgb3V0W2ldID0gKG91dFtpXSAtIG1pbikgKiByYXRpbztcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICBzdGF0aWMgI2d1ZXNzVGhyZXNob2xkKGhpc3RvZ3JhbSkge1xuICAgIGxldCBpO1xuICAgIGxldCBNID0gLUluZmluaXR5O1xuICAgIGxldCBMID0gLUluZmluaXR5O1xuICAgIGNvbnN0IG1pbiA9IGhpc3RvZ3JhbS5maW5kSW5kZXgoKHYpID0+IHYgIT09IDApO1xuICAgIGxldCBwb3MgPSBtaW47XG4gICAgbGV0IHNwb3MgPSBtaW47XG4gICAgZm9yIChpID0gbWluOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgIGNvbnN0IHYgPSBoaXN0b2dyYW1baV07XG4gICAgICBpZiAodiA+IE0pIHtcbiAgICAgICAgaWYgKGkgLSBwb3MgPiBMKSB7XG4gICAgICAgICAgTCA9IGkgLSBwb3M7XG4gICAgICAgICAgc3BvcyA9IGkgLSAxO1xuICAgICAgICB9XG4gICAgICAgIE0gPSB2O1xuICAgICAgICBwb3MgPSBpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGkgPSBzcG9zIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmIChoaXN0b2dyYW1baV0gPiBoaXN0b2dyYW1baSArIDFdKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfVxuICBzdGF0aWMgI2dldEdyYXlQaXhlbHMoYml0bWFwKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxCaXRtYXAgPSBiaXRtYXA7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gYml0bWFwO1xuICAgIGNvbnN0IHtcbiAgICAgIG1heERpbVxuICAgIH0gPSB0aGlzLiNQQVJBTUVURVJTO1xuICAgIGxldCBuZXdXaWR0aCA9IHdpZHRoO1xuICAgIGxldCBuZXdIZWlnaHQgPSBoZWlnaHQ7XG4gICAgaWYgKHdpZHRoID4gbWF4RGltIHx8IGhlaWdodCA+IG1heERpbSkge1xuICAgICAgbGV0IHByZXZXaWR0aCA9IHdpZHRoO1xuICAgICAgbGV0IHByZXZIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICBsZXQgc3RlcHMgPSBNYXRoLmxvZzIoTWF0aC5tYXgod2lkdGgsIGhlaWdodCkgLyBtYXhEaW0pO1xuICAgICAgY29uc3QgaXN0ZXBzID0gTWF0aC5mbG9vcihzdGVwcyk7XG4gICAgICBzdGVwcyA9IHN0ZXBzID09PSBpc3RlcHMgPyBpc3RlcHMgLSAxIDogaXN0ZXBzO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGVwczsgaSsrKSB7XG4gICAgICAgIG5ld1dpZHRoID0gTWF0aC5jZWlsKHByZXZXaWR0aCAvIDIpO1xuICAgICAgICBuZXdIZWlnaHQgPSBNYXRoLmNlaWwocHJldkhlaWdodCAvIDIpO1xuICAgICAgICBjb25zdCBvZmZzY3JlZW4yID0gbmV3IE9mZnNjcmVlbkNhbnZhcyhuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICAgICAgY29uc3QgY3R4MiA9IG9mZnNjcmVlbjIuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICBjdHgyLmRyYXdJbWFnZShiaXRtYXAsIDAsIDAsIHByZXZXaWR0aCwgcHJldkhlaWdodCwgMCwgMCwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICAgIHByZXZXaWR0aCA9IG5ld1dpZHRoO1xuICAgICAgICBwcmV2SGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgICBpZiAoYml0bWFwICE9PSBvcmlnaW5hbEJpdG1hcCkge1xuICAgICAgICAgIGJpdG1hcC5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGJpdG1hcCA9IG9mZnNjcmVlbjIudHJhbnNmZXJUb0ltYWdlQml0bWFwKCk7XG4gICAgICB9XG4gICAgICBjb25zdCByYXRpbyA9IE1hdGgubWluKG1heERpbSAvIG5ld1dpZHRoLCBtYXhEaW0gLyBuZXdIZWlnaHQpO1xuICAgICAgbmV3V2lkdGggPSBNYXRoLnJvdW5kKG5ld1dpZHRoICogcmF0aW8pO1xuICAgICAgbmV3SGVpZ2h0ID0gTWF0aC5yb3VuZChuZXdIZWlnaHQgKiByYXRpbyk7XG4gICAgfVxuICAgIGNvbnN0IG9mZnNjcmVlbiA9IG5ldyBPZmZzY3JlZW5DYW52YXMobmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgY29uc3QgY3R4ID0gb2Zmc2NyZWVuLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICB3aWxsUmVhZEZyZXF1ZW50bHk6IHRydWVcbiAgICB9KTtcbiAgICBjdHguZmlsbFN0eWxlID0gXCJ3aGl0ZVwiO1xuICAgIGN0eC5maWxsUmVjdCgwLCAwLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICBjdHguZmlsdGVyID0gXCJncmF5c2NhbGUoMSlcIjtcbiAgICBjdHguZHJhd0ltYWdlKGJpdG1hcCwgMCwgMCwgYml0bWFwLndpZHRoLCBiaXRtYXAuaGVpZ2h0LCAwLCAwLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICBjb25zdCBncmF5SW1hZ2UgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIG5ld1dpZHRoLCBuZXdIZWlnaHQpLmRhdGE7XG4gICAgY29uc3QgdWludDhCdWYgPSB0aGlzLiN0b1VpbnQ4KGdyYXlJbWFnZSk7XG4gICAgcmV0dXJuIFt1aW50OEJ1ZiwgbmV3V2lkdGgsIG5ld0hlaWdodF07XG4gIH1cbiAgc3RhdGljIGV4dHJhY3RDb250b3Vyc0Zyb21UZXh0KHRleHQsIHtcbiAgICBmb250RmFtaWx5LFxuICAgIGZvbnRTdHlsZSxcbiAgICBmb250V2VpZ2h0XG4gIH0sIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgcm90YXRpb24sIGlubmVyTWFyZ2luKSB7XG4gICAgbGV0IGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMoMSwgMSk7XG4gICAgbGV0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwge1xuICAgICAgYWxwaGE6IGZhbHNlXG4gICAgfSk7XG4gICAgY29uc3QgZm9udFNpemUgPSAyMDA7XG4gICAgY29uc3QgZm9udCA9IGN0eC5mb250ID0gYCR7Zm9udFN0eWxlfSAke2ZvbnRXZWlnaHR9ICR7Zm9udFNpemV9cHggJHtmb250RmFtaWx5fWA7XG4gICAgY29uc3Qge1xuICAgICAgYWN0dWFsQm91bmRpbmdCb3hMZWZ0LFxuICAgICAgYWN0dWFsQm91bmRpbmdCb3hSaWdodCxcbiAgICAgIGFjdHVhbEJvdW5kaW5nQm94QXNjZW50LFxuICAgICAgYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50LFxuICAgICAgZm9udEJvdW5kaW5nQm94QXNjZW50LFxuICAgICAgZm9udEJvdW5kaW5nQm94RGVzY2VudCxcbiAgICAgIHdpZHRoXG4gICAgfSA9IGN0eC5tZWFzdXJlVGV4dCh0ZXh0KTtcbiAgICBjb25zdCBTQ0FMRSA9IDEuNTtcbiAgICBjb25zdCBjYW52YXNXaWR0aCA9IE1hdGguY2VpbChNYXRoLm1heChNYXRoLmFicyhhY3R1YWxCb3VuZGluZ0JveExlZnQpICsgTWF0aC5hYnMoYWN0dWFsQm91bmRpbmdCb3hSaWdodCkgfHwgMCwgd2lkdGgpICogU0NBTEUpO1xuICAgIGNvbnN0IGNhbnZhc0hlaWdodCA9IE1hdGguY2VpbChNYXRoLm1heChNYXRoLmFicyhhY3R1YWxCb3VuZGluZ0JveEFzY2VudCkgKyBNYXRoLmFicyhhY3R1YWxCb3VuZGluZ0JveERlc2NlbnQpIHx8IGZvbnRTaXplLCBNYXRoLmFicyhmb250Qm91bmRpbmdCb3hBc2NlbnQpICsgTWF0aC5hYnMoZm9udEJvdW5kaW5nQm94RGVzY2VudCkgfHwgZm9udFNpemUpICogU0NBTEUpO1xuICAgIGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMoY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICBhbHBoYTogdHJ1ZSxcbiAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZVxuICAgIH0pO1xuICAgIGN0eC5mb250ID0gZm9udDtcbiAgICBjdHguZmlsdGVyID0gXCJncmF5c2NhbGUoMSlcIjtcbiAgICBjdHguZmlsbFN0eWxlID0gXCJ3aGl0ZVwiO1xuICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcbiAgICBjdHguZmlsbFN0eWxlID0gXCJibGFja1wiO1xuICAgIGN0eC5maWxsVGV4dCh0ZXh0LCBjYW52YXNXaWR0aCAqIChTQ0FMRSAtIDEpIC8gMiwgY2FudmFzSGVpZ2h0ICogKDMgLSBTQ0FMRSkgLyAyKTtcbiAgICBjb25zdCB1aW50OEJ1ZiA9IHRoaXMuI3RvVWludDgoY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KS5kYXRhKTtcbiAgICBjb25zdCBoaXN0b2dyYW0gPSB0aGlzLiNnZXRIaXN0b2dyYW0odWludDhCdWYpO1xuICAgIGNvbnN0IHRocmVzaG9sZCA9IHRoaXMuI2d1ZXNzVGhyZXNob2xkKGhpc3RvZ3JhbSk7XG4gICAgY29uc3QgY29udG91ckxpc3QgPSB0aGlzLiNmaW5kQ29udG91cnModWludDhCdWYsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQsIHRocmVzaG9sZCk7XG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc0RyYXduTGluZXMoe1xuICAgICAgbGluZXM6IHtcbiAgICAgICAgY3VydmVzOiBjb250b3VyTGlzdCxcbiAgICAgICAgd2lkdGg6IGNhbnZhc1dpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNhbnZhc0hlaWdodFxuICAgICAgfSxcbiAgICAgIHBhZ2VXaWR0aCxcbiAgICAgIHBhZ2VIZWlnaHQsXG4gICAgICByb3RhdGlvbixcbiAgICAgIGlubmVyTWFyZ2luLFxuICAgICAgbXVzdFNtb290aDogdHJ1ZSxcbiAgICAgIGFyZUNvbnRvdXJzOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIHByb2Nlc3MoYml0bWFwLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHQsIHJvdGF0aW9uLCBpbm5lck1hcmdpbikge1xuICAgIGNvbnN0IFt1aW50OEJ1Ziwgd2lkdGgsIGhlaWdodF0gPSB0aGlzLiNnZXRHcmF5UGl4ZWxzKGJpdG1hcCk7XG4gICAgY29uc3QgW2J1ZmZlciwgaGlzdG9ncmFtXSA9IHRoaXMuI2JpbGF0ZXJhbEZpbHRlcih1aW50OEJ1Ziwgd2lkdGgsIGhlaWdodCwgTWF0aC5oeXBvdCh3aWR0aCwgaGVpZ2h0KSAqIHRoaXMuI1BBUkFNRVRFUlMuc2lnbWFTRmFjdG9yLCB0aGlzLiNQQVJBTUVURVJTLnNpZ21hUiwgdGhpcy4jUEFSQU1FVEVSUy5rZXJuZWxTaXplKTtcbiAgICBjb25zdCB0aHJlc2hvbGQgPSB0aGlzLiNndWVzc1RocmVzaG9sZChoaXN0b2dyYW0pO1xuICAgIGNvbnN0IGNvbnRvdXJMaXN0ID0gdGhpcy4jZmluZENvbnRvdXJzKGJ1ZmZlciwgd2lkdGgsIGhlaWdodCwgdGhyZXNob2xkKTtcbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzRHJhd25MaW5lcyh7XG4gICAgICBsaW5lczoge1xuICAgICAgICBjdXJ2ZXM6IGNvbnRvdXJMaXN0LFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9LFxuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodCxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgaW5uZXJNYXJnaW4sXG4gICAgICBtdXN0U21vb3RoOiB0cnVlLFxuICAgICAgYXJlQ29udG91cnM6IHRydWVcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgcHJvY2Vzc0RyYXduTGluZXMoe1xuICAgIGxpbmVzLFxuICAgIHBhZ2VXaWR0aCxcbiAgICBwYWdlSGVpZ2h0LFxuICAgIHJvdGF0aW9uLFxuICAgIGlubmVyTWFyZ2luLFxuICAgIG11c3RTbW9vdGgsXG4gICAgYXJlQ29udG91cnNcbiAgfSkge1xuICAgIGlmIChyb3RhdGlvbiAlIDE4MCAhPT0gMCkge1xuICAgICAgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSBbcGFnZUhlaWdodCwgcGFnZVdpZHRoXTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY3VydmVzLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gbGluZXM7XG4gICAgY29uc3QgdGhpY2tuZXNzID0gbGluZXMudGhpY2tuZXNzID8/IDA7XG4gICAgY29uc3QgbGluZXNBbmRQb2ludHMgPSBbXTtcbiAgICBjb25zdCByYXRpbyA9IE1hdGgubWluKHBhZ2VXaWR0aCAvIHdpZHRoLCBwYWdlSGVpZ2h0IC8gaGVpZ2h0KTtcbiAgICBjb25zdCB4U2NhbGUgPSByYXRpbyAvIHBhZ2VXaWR0aDtcbiAgICBjb25zdCB5U2NhbGUgPSByYXRpbyAvIHBhZ2VIZWlnaHQ7XG4gICAgY29uc3QgbmV3Q3VydmVzID0gW107XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBwb2ludHNcbiAgICB9IG9mIGN1cnZlcykge1xuICAgICAgY29uc3QgcmVkdWNlZFBvaW50cyA9IG11c3RTbW9vdGggPyB0aGlzLiNkb3VnbGFzUGV1Y2tlcihwb2ludHMpIDogcG9pbnRzO1xuICAgICAgaWYgKCFyZWR1Y2VkUG9pbnRzKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbmV3Q3VydmVzLnB1c2gocmVkdWNlZFBvaW50cyk7XG4gICAgICBjb25zdCBsZW4gPSByZWR1Y2VkUG9pbnRzLmxlbmd0aDtcbiAgICAgIGNvbnN0IG5ld1BvaW50cyA9IG5ldyBGbG9hdDMyQXJyYXkobGVuKTtcbiAgICAgIGNvbnN0IGxpbmUgPSBuZXcgRmxvYXQzMkFycmF5KDMgKiAobGVuID09PSAyID8gMiA6IGxlbiAtIDIpKTtcbiAgICAgIGxpbmVzQW5kUG9pbnRzLnB1c2goe1xuICAgICAgICBsaW5lLFxuICAgICAgICBwb2ludHM6IG5ld1BvaW50c1xuICAgICAgfSk7XG4gICAgICBpZiAobGVuID09PSAyKSB7XG4gICAgICAgIG5ld1BvaW50c1swXSA9IHJlZHVjZWRQb2ludHNbMF0gKiB4U2NhbGU7XG4gICAgICAgIG5ld1BvaW50c1sxXSA9IHJlZHVjZWRQb2ludHNbMV0gKiB5U2NhbGU7XG4gICAgICAgIGxpbmUuc2V0KFtOYU4sIE5hTiwgTmFOLCBOYU4sIG5ld1BvaW50c1swXSwgbmV3UG9pbnRzWzFdXSwgMCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGV0IFt4MSwgeTEsIHgyLCB5Ml0gPSByZWR1Y2VkUG9pbnRzO1xuICAgICAgeDEgKj0geFNjYWxlO1xuICAgICAgeTEgKj0geVNjYWxlO1xuICAgICAgeDIgKj0geFNjYWxlO1xuICAgICAgeTIgKj0geVNjYWxlO1xuICAgICAgbmV3UG9pbnRzLnNldChbeDEsIHkxLCB4MiwgeTJdLCAwKTtcbiAgICAgIGxpbmUuc2V0KFtOYU4sIE5hTiwgTmFOLCBOYU4sIHgxLCB5MV0sIDApO1xuICAgICAgZm9yIChsZXQgaSA9IDQ7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgICBjb25zdCB4ID0gbmV3UG9pbnRzW2ldID0gcmVkdWNlZFBvaW50c1tpXSAqIHhTY2FsZTtcbiAgICAgICAgY29uc3QgeSA9IG5ld1BvaW50c1tpICsgMV0gPSByZWR1Y2VkUG9pbnRzW2kgKyAxXSAqIHlTY2FsZTtcbiAgICAgICAgbGluZS5zZXQoT3V0bGluZS5jcmVhdGVCZXppZXJQb2ludHMoeDEsIHkxLCB4MiwgeTIsIHgsIHkpLCAoaSAtIDIpICogMyk7XG4gICAgICAgIFt4MSwgeTEsIHgyLCB5Ml0gPSBbeDIsIHkyLCB4LCB5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxpbmVzQW5kUG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG91dGxpbmUgPSBhcmVDb250b3VycyA/IG5ldyBDb250b3VyRHJhd091dGxpbmUoKSA6IG5ldyBJbmtEcmF3T3V0bGluZSgpO1xuICAgIG91dGxpbmUuYnVpbGQobGluZXNBbmRQb2ludHMsIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgMSwgcm90YXRpb24sIGFyZUNvbnRvdXJzID8gMCA6IHRoaWNrbmVzcywgaW5uZXJNYXJnaW4pO1xuICAgIHJldHVybiB7XG4gICAgICBvdXRsaW5lLFxuICAgICAgbmV3Q3VydmVzLFxuICAgICAgYXJlQ29udG91cnMsXG4gICAgICB0aGlja25lc3MsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH07XG4gIH1cbiAgc3RhdGljIGFzeW5jIGNvbXByZXNzU2lnbmF0dXJlKHtcbiAgICBvdXRsaW5lcyxcbiAgICBhcmVDb250b3VycyxcbiAgICB0aGlja25lc3MsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH0pIHtcbiAgICBsZXQgbWluRGlmZiA9IEluZmluaXR5O1xuICAgIGxldCBtYXhEaWZmID0gLUluZmluaXR5O1xuICAgIGxldCBvdXRsaW5lc0xlbmd0aCA9IDA7XG4gICAgZm9yIChjb25zdCBwb2ludHMgb2Ygb3V0bGluZXMpIHtcbiAgICAgIG91dGxpbmVzTGVuZ3RoICs9IHBvaW50cy5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMiwgaWkgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBjb25zdCBkeCA9IHBvaW50c1tpXSAtIHBvaW50c1tpIC0gMl07XG4gICAgICAgIG1pbkRpZmYgPSBNYXRoLm1pbihtaW5EaWZmLCBkeCk7XG4gICAgICAgIG1heERpZmYgPSBNYXRoLm1heChtYXhEaWZmLCBkeCk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBidWZmZXJUeXBlO1xuICAgIGlmIChtaW5EaWZmID49IC0xMjggJiYgbWF4RGlmZiA8PSAxMjcpIHtcbiAgICAgIGJ1ZmZlclR5cGUgPSBJbnQ4QXJyYXk7XG4gICAgfSBlbHNlIGlmIChtaW5EaWZmID49IC0zMjc2OCAmJiBtYXhEaWZmIDw9IDMyNzY3KSB7XG4gICAgICBidWZmZXJUeXBlID0gSW50MTZBcnJheTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmZmVyVHlwZSA9IEludDMyQXJyYXk7XG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IG91dGxpbmVzLmxlbmd0aDtcbiAgICBjb25zdCBoZWFkZXJMZW5ndGggPSBCQVNFX0hFQURFUl9MRU5HVEggKyBQT0lOVFNfUFJPUEVSVElFU19OVU1CRVIgKiBsZW47XG4gICAgY29uc3QgaGVhZGVyID0gbmV3IFVpbnQzMkFycmF5KGhlYWRlckxlbmd0aCk7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgaGVhZGVyW29mZnNldCsrXSA9IGhlYWRlckxlbmd0aCAqIFVpbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UICsgKG91dGxpbmVzTGVuZ3RoIC0gMiAqIGxlbikgKiBidWZmZXJUeXBlLkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgIGhlYWRlcltvZmZzZXQrK10gPSAwO1xuICAgIGhlYWRlcltvZmZzZXQrK10gPSB3aWR0aDtcbiAgICBoZWFkZXJbb2Zmc2V0KytdID0gaGVpZ2h0O1xuICAgIGhlYWRlcltvZmZzZXQrK10gPSBhcmVDb250b3VycyA/IDAgOiAxO1xuICAgIGhlYWRlcltvZmZzZXQrK10gPSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKHRoaWNrbmVzcyA/PyAwKSk7XG4gICAgaGVhZGVyW29mZnNldCsrXSA9IGxlbjtcbiAgICBoZWFkZXJbb2Zmc2V0KytdID0gYnVmZmVyVHlwZS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICBmb3IgKGNvbnN0IHBvaW50cyBvZiBvdXRsaW5lcykge1xuICAgICAgaGVhZGVyW29mZnNldCsrXSA9IHBvaW50cy5sZW5ndGggLSAyO1xuICAgICAgaGVhZGVyW29mZnNldCsrXSA9IHBvaW50c1swXTtcbiAgICAgIGhlYWRlcltvZmZzZXQrK10gPSBwb2ludHNbMV07XG4gICAgfVxuICAgIGNvbnN0IGNzID0gbmV3IENvbXByZXNzaW9uU3RyZWFtKFwiZGVmbGF0ZS1yYXdcIik7XG4gICAgY29uc3Qgd3JpdGVyID0gY3Mud3JpdGFibGUuZ2V0V3JpdGVyKCk7XG4gICAgYXdhaXQgd3JpdGVyLnJlYWR5O1xuICAgIHdyaXRlci53cml0ZShoZWFkZXIpO1xuICAgIGNvbnN0IEJ1ZmZlckN0b3IgPSBidWZmZXJUeXBlLnByb3RvdHlwZS5jb25zdHJ1Y3RvcjtcbiAgICBmb3IgKGNvbnN0IHBvaW50cyBvZiBvdXRsaW5lcykge1xuICAgICAgY29uc3QgZGlmZnMgPSBuZXcgQnVmZmVyQ3Rvcihwb2ludHMubGVuZ3RoIC0gMik7XG4gICAgICBmb3IgKGxldCBpID0gMiwgaWkgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBkaWZmc1tpIC0gMl0gPSBwb2ludHNbaV0gLSBwb2ludHNbaSAtIDJdO1xuICAgICAgfVxuICAgICAgd3JpdGVyLndyaXRlKGRpZmZzKTtcbiAgICB9XG4gICAgd3JpdGVyLmNsb3NlKCk7XG4gICAgY29uc3QgYnVmID0gYXdhaXQgbmV3IFJlc3BvbnNlKGNzLnJlYWRhYmxlKS5hcnJheUJ1ZmZlcigpO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnVmKTtcbiAgICByZXR1cm4gdG9CYXNlNjRVdGlsKGJ5dGVzKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZGVjb21wcmVzc1NpZ25hdHVyZShzaWduYXR1cmVEYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGJ5dGVzID0gZnJvbUJhc2U2NFV0aWwoc2lnbmF0dXJlRGF0YSk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlYWRhYmxlLFxuICAgICAgICB3cml0YWJsZVxuICAgICAgfSA9IG5ldyBEZWNvbXByZXNzaW9uU3RyZWFtKFwiZGVmbGF0ZS1yYXdcIik7XG4gICAgICBjb25zdCB3cml0ZXIgPSB3cml0YWJsZS5nZXRXcml0ZXIoKTtcbiAgICAgIGF3YWl0IHdyaXRlci5yZWFkeTtcbiAgICAgIHdyaXRlci53cml0ZShieXRlcykudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IHdyaXRlci5yZWFkeTtcbiAgICAgICAgYXdhaXQgd3JpdGVyLmNsb3NlKCk7XG4gICAgICB9KS5jYXRjaCgoKSA9PiB7XG4gICAgICB9KTtcbiAgICAgIGxldCBkYXRhID0gbnVsbDtcbiAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiByZWFkYWJsZSkge1xuICAgICAgICBkYXRhIHx8PSBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoY2h1bmsuYnVmZmVyLCAwLCA0KVswXSk7XG4gICAgICAgIGRhdGEuc2V0KGNodW5rLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgfVxuICAgICAgY29uc3QgaGVhZGVyID0gbmV3IFVpbnQzMkFycmF5KGRhdGEuYnVmZmVyLCAwLCBkYXRhLmxlbmd0aCA+PiAyKTtcbiAgICAgIGNvbnN0IHZlcnNpb24yID0gaGVhZGVyWzFdO1xuICAgICAgaWYgKHZlcnNpb24yICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2ZXJzaW9uOiAke3ZlcnNpb24yfWApO1xuICAgICAgfVxuICAgICAgY29uc3Qgd2lkdGggPSBoZWFkZXJbMl07XG4gICAgICBjb25zdCBoZWlnaHQgPSBoZWFkZXJbM107XG4gICAgICBjb25zdCBhcmVDb250b3VycyA9IGhlYWRlcls0XSA9PT0gMDtcbiAgICAgIGNvbnN0IHRoaWNrbmVzcyA9IGhlYWRlcls1XTtcbiAgICAgIGNvbnN0IG51bWJlck9mRHJhd2luZ3MgPSBoZWFkZXJbNl07XG4gICAgICBjb25zdCBidWZmZXJUeXBlID0gaGVhZGVyWzddO1xuICAgICAgY29uc3Qgb3V0bGluZXMgPSBbXTtcbiAgICAgIGNvbnN0IGRpZmZzT2Zmc2V0ID0gKEJBU0VfSEVBREVSX0xFTkdUSCArIFBPSU5UU19QUk9QRVJUSUVTX05VTUJFUiAqIG51bWJlck9mRHJhd2luZ3MpICogVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgICBsZXQgZGlmZnM7XG4gICAgICBzd2l0Y2ggKGJ1ZmZlclR5cGUpIHtcbiAgICAgICAgY2FzZSBJbnQ4QXJyYXkuQllURVNfUEVSX0VMRU1FTlQ6XG4gICAgICAgICAgZGlmZnMgPSBuZXcgSW50OEFycmF5KGRhdGEuYnVmZmVyLCBkaWZmc09mZnNldCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSW50MTZBcnJheS5CWVRFU19QRVJfRUxFTUVOVDpcbiAgICAgICAgICBkaWZmcyA9IG5ldyBJbnQxNkFycmF5KGRhdGEuYnVmZmVyLCBkaWZmc09mZnNldCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDpcbiAgICAgICAgICBkaWZmcyA9IG5ldyBJbnQzMkFycmF5KGRhdGEuYnVmZmVyLCBkaWZmc09mZnNldCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBvZmZzZXQgPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZkRyYXdpbmdzOyBpKyspIHtcbiAgICAgICAgY29uc3QgbGVuID0gaGVhZGVyW1BPSU5UU19QUk9QRVJUSUVTX05VTUJFUiAqIGkgKyBCQVNFX0hFQURFUl9MRU5HVEhdO1xuICAgICAgICBjb25zdCBwb2ludHMgPSBuZXcgRmxvYXQzMkFycmF5KGxlbiArIDIpO1xuICAgICAgICBvdXRsaW5lcy5wdXNoKHBvaW50cyk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgUE9JTlRTX1BST1BFUlRJRVNfTlVNQkVSIC0gMTsgaisrKSB7XG4gICAgICAgICAgcG9pbnRzW2pdID0gaGVhZGVyW1BPSU5UU19QUk9QRVJUSUVTX05VTUJFUiAqIGkgKyBCQVNFX0hFQURFUl9MRU5HVEggKyBqICsgMV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsZW47IGorKykge1xuICAgICAgICAgIHBvaW50c1tqICsgMl0gPSBwb2ludHNbal0gKyBkaWZmc1tvZmZzZXQrK107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFyZUNvbnRvdXJzLFxuICAgICAgICB0aGlja25lc3MsXG4gICAgICAgIG91dGxpbmVzLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHdhcm4oYGRlY29tcHJlc3NTaWduYXR1cmU6ICR7ZX1gKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgU2lnbmF0dXJlT3B0aW9ucyBleHRlbmRzIERyYXdpbmdPcHRpb25zIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICBzdXBlci51cGRhdGVQcm9wZXJ0aWVzKHtcbiAgICAgIGZpbGw6IEFubm90YXRpb25FZGl0b3IuX2RlZmF1bHRMaW5lQ29sb3IsXG4gICAgICBcInN0cm9rZS13aWR0aFwiOiAwXG4gICAgfSk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgU2lnbmF0dXJlT3B0aW9ucygpO1xuICAgIGNsb25lLnVwZGF0ZUFsbCh0aGlzKTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbn1cbmNsYXNzIERyYXduU2lnbmF0dXJlT3B0aW9ucyBleHRlbmRzIElua0RyYXdpbmdPcHRpb25zIHtcbiAgY29uc3RydWN0b3Iodmlld2VyUGFyYW1ldGVycykge1xuICAgIHN1cGVyKHZpZXdlclBhcmFtZXRlcnMpO1xuICAgIHN1cGVyLnVwZGF0ZVByb3BlcnRpZXMoe1xuICAgICAgc3Ryb2tlOiBBbm5vdGF0aW9uRWRpdG9yLl9kZWZhdWx0TGluZUNvbG9yLFxuICAgICAgXCJzdHJva2Utd2lkdGhcIjogMVxuICAgIH0pO1xuICB9XG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGNsb25lID0gbmV3IERyYXduU2lnbmF0dXJlT3B0aW9ucyh0aGlzLl92aWV3UGFyYW1ldGVycyk7XG4gICAgY2xvbmUudXBkYXRlQWxsKHRoaXMpO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxufVxuY2xhc3MgU2lnbmF0dXJlRWRpdG9yIGV4dGVuZHMgRHJhd2luZ0VkaXRvciB7XG4gICNpc0V4dHJhY3RlZCA9IGZhbHNlO1xuICAjZGVzY3JpcHRpb24gPSBudWxsO1xuICAjc2lnbmF0dXJlRGF0YSA9IG51bGw7XG4gICNzaWduYXR1cmVVVUlEID0gbnVsbDtcbiAgc3RhdGljIF90eXBlID0gXCJzaWduYXR1cmVcIjtcbiAgc3RhdGljIF9lZGl0b3JUeXBlID0gQW5ub3RhdGlvbkVkaXRvclR5cGUuU0lHTkFUVVJFO1xuICBzdGF0aWMgX2RlZmF1bHREcmF3aW5nT3B0aW9ucyA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLnBhcmFtcyxcbiAgICAgIG11c3RCZUNvbW1pdHRlZDogdHJ1ZSxcbiAgICAgIG5hbWU6IFwic2lnbmF0dXJlRWRpdG9yXCJcbiAgICB9KTtcbiAgICB0aGlzLl93aWxsS2VlcEFzcGVjdFJhdGlvID0gdHJ1ZTtcbiAgICB0aGlzLiNzaWduYXR1cmVEYXRhID0gcGFyYW1zLnNpZ25hdHVyZURhdGEgfHwgbnVsbDtcbiAgICB0aGlzLiNkZXNjcmlwdGlvbiA9IG51bGw7XG4gICAgdGhpcy5kZWZhdWx0TDEwbklkID0gXCJwZGZqcy1lZGl0b3Itc2lnbmF0dXJlLWVkaXRvcjFcIjtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuLCB1aU1hbmFnZXIpIHtcbiAgICBBbm5vdGF0aW9uRWRpdG9yLmluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKTtcbiAgICB0aGlzLl9kZWZhdWx0RHJhd2luZ09wdGlvbnMgPSBuZXcgU2lnbmF0dXJlT3B0aW9ucygpO1xuICAgIHRoaXMuX2RlZmF1bHREcmF3blNpZ25hdHVyZU9wdGlvbnMgPSBuZXcgRHJhd25TaWduYXR1cmVPcHRpb25zKHVpTWFuYWdlci52aWV3UGFyYW1ldGVycyk7XG4gIH1cbiAgc3RhdGljIGdldERlZmF1bHREcmF3aW5nT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgY29uc3QgY2xvbmUgPSB0aGlzLl9kZWZhdWx0RHJhd2luZ09wdGlvbnMuY2xvbmUoKTtcbiAgICBjbG9uZS51cGRhdGVQcm9wZXJ0aWVzKG9wdGlvbnMpO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuICBzdGF0aWMgZ2V0IHN1cHBvcnRNdWx0aXBsZURyYXdpbmdzKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGVzTWFwKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJ0eXBlc01hcFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgfVxuICBzdGF0aWMgZ2V0IGlzRHJhd2VyKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBnZXQgdGVsZW1ldHJ5RmluYWxEYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInNpZ25hdHVyZVwiLFxuICAgICAgaGFzRGVzY3JpcHRpb246ICEhdGhpcy4jZGVzY3JpcHRpb25cbiAgICB9O1xuICB9XG4gIHN0YXRpYyBjb21wdXRlVGVsZW1ldHJ5RmluYWxEYXRhKGRhdGEpIHtcbiAgICBjb25zdCBoYXNEZXNjcmlwdGlvblN0YXRzID0gZGF0YS5nZXQoXCJoYXNEZXNjcmlwdGlvblwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgaGFzQWx0VGV4dDogaGFzRGVzY3JpcHRpb25TdGF0cy5nZXQodHJ1ZSkgPz8gMCxcbiAgICAgIGhhc05vQWx0VGV4dDogaGFzRGVzY3JpcHRpb25TdGF0cy5nZXQoZmFsc2UpID8/IDBcbiAgICB9O1xuICB9XG4gIGdldCBpc1Jlc2l6YWJsZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBvblNjYWxlQ2hhbmdpbmcoKSB7XG4gICAgaWYgKHRoaXMuX2RyYXdJZCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5vblNjYWxlQ2hhbmdpbmcoKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXY7XG4gICAgfVxuICAgIGxldCBiYXNlWCwgYmFzZVk7XG4gICAgY29uc3Qge1xuICAgICAgX2lzQ29weVxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChfaXNDb3B5KSB7XG4gICAgICB0aGlzLl9pc0NvcHkgPSBmYWxzZTtcbiAgICAgIGJhc2VYID0gdGhpcy54O1xuICAgICAgYmFzZVkgPSB0aGlzLnk7XG4gICAgfVxuICAgIHN1cGVyLnJlbmRlcigpO1xuICAgIGlmICh0aGlzLl9kcmF3SWQgPT09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLiNzaWduYXR1cmVEYXRhKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBsaW5lcyxcbiAgICAgICAgICBtdXN0U21vb3RoLFxuICAgICAgICAgIGFyZUNvbnRvdXJzLFxuICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgIHV1aWQsXG4gICAgICAgICAgaGVpZ2h0SW5QYWdlXG4gICAgICAgIH0gPSB0aGlzLiNzaWduYXR1cmVEYXRhO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcmF3RGltczoge1xuICAgICAgICAgICAgcGFnZVdpZHRoLFxuICAgICAgICAgICAgcGFnZUhlaWdodFxuICAgICAgICAgIH0sXG4gICAgICAgICAgcm90YXRpb25cbiAgICAgICAgfSA9IHRoaXMucGFyZW50LnZpZXdwb3J0O1xuICAgICAgICBjb25zdCBvdXRsaW5lID0gU2lnbmF0dXJlRXh0cmFjdG9yLnByb2Nlc3NEcmF3bkxpbmVzKHtcbiAgICAgICAgICBsaW5lcyxcbiAgICAgICAgICBwYWdlV2lkdGgsXG4gICAgICAgICAgcGFnZUhlaWdodCxcbiAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICBpbm5lck1hcmdpbjogU2lnbmF0dXJlRWRpdG9yLl9JTk5FUl9NQVJHSU4sXG4gICAgICAgICAgbXVzdFNtb290aCxcbiAgICAgICAgICBhcmVDb250b3Vyc1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hZGRTaWduYXR1cmUob3V0bGluZSwgaGVpZ2h0SW5QYWdlLCBkZXNjcmlwdGlvbiwgdXVpZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4tYXJnc1wiLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiXCJcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLmRpdi5oaWRkZW4gPSB0cnVlO1xuICAgICAgICB0aGlzLl91aU1hbmFnZXIuZ2V0U2lnbmF0dXJlKHRoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4tYXJnc1wiLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLiNkZXNjcmlwdGlvbiB8fCBcIlwiXG4gICAgICB9KSk7XG4gICAgfVxuICAgIGlmIChfaXNDb3B5KSB7XG4gICAgICB0aGlzLl9pc0NvcHkgPSB0cnVlO1xuICAgICAgdGhpcy5fbW92ZUFmdGVyUGFzdGUoYmFzZVgsIGJhc2VZKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZGl2O1xuICB9XG4gIHNldFV1aWQodXVpZCkge1xuICAgIHRoaXMuI3NpZ25hdHVyZVVVSUQgPSB1dWlkO1xuICAgIHRoaXMuYWRkRWRpdFRvb2xiYXIoKTtcbiAgfVxuICBnZXRVdWlkKCkge1xuICAgIHJldHVybiB0aGlzLiNzaWduYXR1cmVVVUlEO1xuICB9XG4gIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy4jZGVzY3JpcHRpb247XG4gIH1cbiAgc2V0IGRlc2NyaXB0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgdGhpcy4jZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICBpZiAoIXRoaXMuZGl2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZGl2LnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1hcmdzXCIsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIGRlc2NyaXB0aW9uXG4gICAgfSkpO1xuICAgIHN1cGVyLmFkZEVkaXRUb29sYmFyKCkudGhlbigodG9vbGJhcikgPT4ge1xuICAgICAgdG9vbGJhcj8udXBkYXRlRWRpdFNpZ25hdHVyZUJ1dHRvbihkZXNjcmlwdGlvbik7XG4gICAgfSk7XG4gIH1cbiAgZ2V0U2lnbmF0dXJlUHJldmlldygpIHtcbiAgICBjb25zdCB7XG4gICAgICBuZXdDdXJ2ZXMsXG4gICAgICBhcmVDb250b3VycyxcbiAgICAgIHRoaWNrbmVzcyxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXMuI3NpZ25hdHVyZURhdGE7XG4gICAgY29uc3QgbWF4RGltID0gTWF0aC5tYXgod2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3Qgb3V0bGluZURhdGEgPSBTaWduYXR1cmVFeHRyYWN0b3IucHJvY2Vzc0RyYXduTGluZXMoe1xuICAgICAgbGluZXM6IHtcbiAgICAgICAgY3VydmVzOiBuZXdDdXJ2ZXMubWFwKChwb2ludHMpID0+ICh7XG4gICAgICAgICAgcG9pbnRzXG4gICAgICAgIH0pKSxcbiAgICAgICAgdGhpY2tuZXNzLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9LFxuICAgICAgcGFnZVdpZHRoOiBtYXhEaW0sXG4gICAgICBwYWdlSGVpZ2h0OiBtYXhEaW0sXG4gICAgICByb3RhdGlvbjogMCxcbiAgICAgIGlubmVyTWFyZ2luOiAwLFxuICAgICAgbXVzdFNtb290aDogZmFsc2UsXG4gICAgICBhcmVDb250b3Vyc1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBhcmVDb250b3VycyxcbiAgICAgIG91dGxpbmU6IG91dGxpbmVEYXRhLm91dGxpbmVcbiAgICB9O1xuICB9XG4gIGdldCB0b29sYmFyQnV0dG9ucygpIHtcbiAgICBpZiAodGhpcy5fdWlNYW5hZ2VyLnNpZ25hdHVyZU1hbmFnZXIpIHtcbiAgICAgIHJldHVybiBbW1wiZWRpdFNpZ25hdHVyZVwiLCB0aGlzLl91aU1hbmFnZXIuc2lnbmF0dXJlTWFuYWdlcl1dO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIudG9vbGJhckJ1dHRvbnM7XG4gIH1cbiAgYWRkU2lnbmF0dXJlKGRhdGEsIGhlaWdodEluUGFnZSwgZGVzY3JpcHRpb24sIHV1aWQpIHtcbiAgICBjb25zdCB7XG4gICAgICB4OiBzYXZlZFgsXG4gICAgICB5OiBzYXZlZFlcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBvdXRsaW5lXG4gICAgfSA9IHRoaXMuI3NpZ25hdHVyZURhdGEgPSBkYXRhO1xuICAgIHRoaXMuI2lzRXh0cmFjdGVkID0gb3V0bGluZSBpbnN0YW5jZW9mIENvbnRvdXJEcmF3T3V0bGluZTtcbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgbGV0IGRyYXdpbmdPcHRpb25zO1xuICAgIGlmICh0aGlzLiNpc0V4dHJhY3RlZCkge1xuICAgICAgZHJhd2luZ09wdGlvbnMgPSBTaWduYXR1cmVFZGl0b3IuZ2V0RGVmYXVsdERyYXdpbmdPcHRpb25zKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRyYXdpbmdPcHRpb25zID0gU2lnbmF0dXJlRWRpdG9yLl9kZWZhdWx0RHJhd25TaWduYXR1cmVPcHRpb25zLmNsb25lKCk7XG4gICAgICBkcmF3aW5nT3B0aW9ucy51cGRhdGVQcm9wZXJ0aWVzKHtcbiAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogb3V0bGluZS50aGlja25lc3NcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9hZGRPdXRsaW5lcyh7XG4gICAgICBkcmF3T3V0bGluZXM6IG91dGxpbmUsXG4gICAgICBkcmF3aW5nT3B0aW9uc1xuICAgIH0pO1xuICAgIGNvbnN0IFssIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICBsZXQgbmV3SGVpZ2h0ID0gaGVpZ2h0SW5QYWdlIC8gcGFnZUhlaWdodDtcbiAgICBuZXdIZWlnaHQgPSBuZXdIZWlnaHQgPj0gMSA/IDAuNSA6IG5ld0hlaWdodDtcbiAgICB0aGlzLndpZHRoICo9IG5ld0hlaWdodCAvIHRoaXMuaGVpZ2h0O1xuICAgIGlmICh0aGlzLndpZHRoID49IDEpIHtcbiAgICAgIG5ld0hlaWdodCAqPSAwLjkgLyB0aGlzLndpZHRoO1xuICAgICAgdGhpcy53aWR0aCA9IDAuOTtcbiAgICB9XG4gICAgdGhpcy5oZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgdGhpcy5zZXREaW1zKCk7XG4gICAgdGhpcy54ID0gc2F2ZWRYO1xuICAgIHRoaXMueSA9IHNhdmVkWTtcbiAgICB0aGlzLmNlbnRlcigpO1xuICAgIHRoaXMuX29uUmVzaXplZCgpO1xuICAgIHRoaXMub25TY2FsZUNoYW5naW5nKCk7XG4gICAgdGhpcy5yb3RhdGUoKTtcbiAgICB0aGlzLl91aU1hbmFnZXIuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZSh0aGlzKTtcbiAgICB0aGlzLnNldFV1aWQodXVpZCk7XG4gICAgdGhpcy5fcmVwb3J0VGVsZW1ldHJ5KHtcbiAgICAgIGFjdGlvbjogXCJwZGZqcy5zaWduYXR1cmUuaW5zZXJ0ZWRcIixcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgaGFzQmVlblNhdmVkOiAhIXV1aWQsXG4gICAgICAgIGhhc0Rlc2NyaXB0aW9uOiAhIWRlc2NyaXB0aW9uXG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5kaXYuaGlkZGVuID0gZmFsc2U7XG4gIH1cbiAgZ2V0RnJvbUltYWdlKGJpdG1hcCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHJhd0RpbXM6IHtcbiAgICAgICAgcGFnZVdpZHRoLFxuICAgICAgICBwYWdlSGVpZ2h0XG4gICAgICB9LFxuICAgICAgcm90YXRpb25cbiAgICB9ID0gdGhpcy5wYXJlbnQudmlld3BvcnQ7XG4gICAgcmV0dXJuIFNpZ25hdHVyZUV4dHJhY3Rvci5wcm9jZXNzKGJpdG1hcCwgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0LCByb3RhdGlvbiwgU2lnbmF0dXJlRWRpdG9yLl9JTk5FUl9NQVJHSU4pO1xuICB9XG4gIGdldEZyb21UZXh0KHRleHQsIGZvbnRJbmZvKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmF3RGltczoge1xuICAgICAgICBwYWdlV2lkdGgsXG4gICAgICAgIHBhZ2VIZWlnaHRcbiAgICAgIH0sXG4gICAgICByb3RhdGlvblxuICAgIH0gPSB0aGlzLnBhcmVudC52aWV3cG9ydDtcbiAgICByZXR1cm4gU2lnbmF0dXJlRXh0cmFjdG9yLmV4dHJhY3RDb250b3Vyc0Zyb21UZXh0KHRleHQsIGZvbnRJbmZvLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHQsIHJvdGF0aW9uLCBTaWduYXR1cmVFZGl0b3IuX0lOTkVSX01BUkdJTik7XG4gIH1cbiAgZ2V0RHJhd25TaWduYXR1cmUoY3VydmVzKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmF3RGltczoge1xuICAgICAgICBwYWdlV2lkdGgsXG4gICAgICAgIHBhZ2VIZWlnaHRcbiAgICAgIH0sXG4gICAgICByb3RhdGlvblxuICAgIH0gPSB0aGlzLnBhcmVudC52aWV3cG9ydDtcbiAgICByZXR1cm4gU2lnbmF0dXJlRXh0cmFjdG9yLnByb2Nlc3NEcmF3bkxpbmVzKHtcbiAgICAgIGxpbmVzOiBjdXJ2ZXMsXG4gICAgICBwYWdlV2lkdGgsXG4gICAgICBwYWdlSGVpZ2h0LFxuICAgICAgcm90YXRpb24sXG4gICAgICBpbm5lck1hcmdpbjogU2lnbmF0dXJlRWRpdG9yLl9JTk5FUl9NQVJHSU4sXG4gICAgICBtdXN0U21vb3RoOiBmYWxzZSxcbiAgICAgIGFyZUNvbnRvdXJzOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIGNyZWF0ZURyYXdpbmdPcHRpb25zKHtcbiAgICBhcmVDb250b3VycyxcbiAgICB0aGlja25lc3NcbiAgfSkge1xuICAgIGlmIChhcmVDb250b3Vycykge1xuICAgICAgdGhpcy5fZHJhd2luZ09wdGlvbnMgPSBTaWduYXR1cmVFZGl0b3IuZ2V0RGVmYXVsdERyYXdpbmdPcHRpb25zKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RyYXdpbmdPcHRpb25zID0gU2lnbmF0dXJlRWRpdG9yLl9kZWZhdWx0RHJhd25TaWduYXR1cmVPcHRpb25zLmNsb25lKCk7XG4gICAgICB0aGlzLl9kcmF3aW5nT3B0aW9ucy51cGRhdGVQcm9wZXJ0aWVzKHtcbiAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogdGhpY2tuZXNzXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgc2VyaWFsaXplKGlzRm9yQ29weWluZyA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgbGluZXMsXG4gICAgICBwb2ludHNcbiAgICB9ID0gdGhpcy5zZXJpYWxpemVEcmF3KGlzRm9yQ29weWluZyk7XG4gICAgY29uc3Qge1xuICAgICAgX2RyYXdpbmdPcHRpb25zOiB7XG4gICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IHRoaWNrbmVzc1xuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBPYmplY3QuYXNzaWduKHN1cGVyLnNlcmlhbGl6ZShpc0ZvckNvcHlpbmcpLCB7XG4gICAgICBpc1NpZ25hdHVyZTogdHJ1ZSxcbiAgICAgIGFyZUNvbnRvdXJzOiB0aGlzLiNpc0V4dHJhY3RlZCxcbiAgICAgIGNvbG9yOiBbMCwgMCwgMF0sXG4gICAgICB0aGlja25lc3M6IHRoaXMuI2lzRXh0cmFjdGVkID8gMCA6IHRoaWNrbmVzc1xuICAgIH0pO1xuICAgIHRoaXMuYWRkQ29tbWVudChzZXJpYWxpemVkKTtcbiAgICBpZiAoaXNGb3JDb3B5aW5nKSB7XG4gICAgICBzZXJpYWxpemVkLnBhdGhzID0ge1xuICAgICAgICBsaW5lcyxcbiAgICAgICAgcG9pbnRzXG4gICAgICB9O1xuICAgICAgc2VyaWFsaXplZC51dWlkID0gdGhpcy4jc2lnbmF0dXJlVVVJRDtcbiAgICAgIHNlcmlhbGl6ZWQuaXNDb3B5ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VyaWFsaXplZC5saW5lcyA9IGxpbmVzO1xuICAgIH1cbiAgICBpZiAodGhpcy4jZGVzY3JpcHRpb24pIHtcbiAgICAgIHNlcmlhbGl6ZWQuYWNjZXNzaWJpbGl0eURhdGEgPSB7XG4gICAgICAgIHR5cGU6IFwiRmlndXJlXCIsXG4gICAgICAgIGFsdDogdGhpcy4jZGVzY3JpcHRpb25cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkO1xuICB9XG4gIHN0YXRpYyBkZXNlcmlhbGl6ZURyYXcocGFnZVgsIHBhZ2VZLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHQsIGlubmVyTWFyZ2luLCBkYXRhKSB7XG4gICAgaWYgKGRhdGEuYXJlQ29udG91cnMpIHtcbiAgICAgIHJldHVybiBDb250b3VyRHJhd091dGxpbmUuZGVzZXJpYWxpemUocGFnZVgsIHBhZ2VZLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHQsIGlubmVyTWFyZ2luLCBkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIElua0RyYXdPdXRsaW5lLmRlc2VyaWFsaXplKHBhZ2VYLCBwYWdlWSwgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0LCBpbm5lck1hcmdpbiwgZGF0YSk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKSB7XG4gICAgY29uc3QgZWRpdG9yID0gYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpO1xuICAgIGVkaXRvci4jaXNFeHRyYWN0ZWQgPSBkYXRhLmFyZUNvbnRvdXJzO1xuICAgIGVkaXRvci5kZXNjcmlwdGlvbiA9IGRhdGEuYWNjZXNzaWJpbGl0eURhdGE/LmFsdCB8fCBcIlwiO1xuICAgIGVkaXRvci4jc2lnbmF0dXJlVVVJRCA9IGRhdGEudXVpZDtcbiAgICByZXR1cm4gZWRpdG9yO1xuICB9XG59XG5jbGFzcyBTdGFtcEVkaXRvciBleHRlbmRzIEFubm90YXRpb25FZGl0b3Ige1xuICAjYml0bWFwID0gbnVsbDtcbiAgI2JpdG1hcElkID0gbnVsbDtcbiAgI2JpdG1hcFByb21pc2UgPSBudWxsO1xuICAjYml0bWFwVXJsID0gbnVsbDtcbiAgI2JpdG1hcEZpbGUgPSBudWxsO1xuICAjYml0bWFwRmlsZU5hbWUgPSBcIlwiO1xuICAjY2FudmFzID0gbnVsbDtcbiAgI21pc3NpbmdDYW52YXMgPSBmYWxzZTtcbiAgI3Jlc2l6ZVRpbWVvdXRJZCA9IG51bGw7XG4gICNpc1N2ZyA9IGZhbHNlO1xuICAjaGFzQmVlbkFkZGVkSW5VbmRvU3RhY2sgPSBmYWxzZTtcbiAgc3RhdGljIF90eXBlID0gXCJzdGFtcFwiO1xuICBzdGF0aWMgX2VkaXRvclR5cGUgPSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5TVEFNUDtcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ucGFyYW1zLFxuICAgICAgbmFtZTogXCJzdGFtcEVkaXRvclwiXG4gICAgfSk7XG4gICAgdGhpcy4jYml0bWFwVXJsID0gcGFyYW1zLmJpdG1hcFVybDtcbiAgICB0aGlzLiNiaXRtYXBGaWxlID0gcGFyYW1zLmJpdG1hcEZpbGU7XG4gICAgdGhpcy5kZWZhdWx0TDEwbklkID0gXCJwZGZqcy1lZGl0b3Itc3RhbXAtZWRpdG9yXCI7XG4gIH1cbiAgc3RhdGljIGluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKSB7XG4gICAgQW5ub3RhdGlvbkVkaXRvci5pbml0aWFsaXplKGwxMG4sIHVpTWFuYWdlcik7XG4gIH1cbiAgc3RhdGljIGlzSGFuZGxpbmdNaW1lRm9yUGFzdGluZyhtaW1lKSB7XG4gICAgcmV0dXJuIFN1cHBvcnRlZEltYWdlTWltZVR5cGVzLmluY2x1ZGVzKG1pbWUpO1xuICB9XG4gIHN0YXRpYyBwYXN0ZShpdGVtLCBwYXJlbnQpIHtcbiAgICBwYXJlbnQucGFzdGVFZGl0b3Ioe1xuICAgICAgbW9kZTogQW5ub3RhdGlvbkVkaXRvclR5cGUuU1RBTVBcbiAgICB9LCB7XG4gICAgICBiaXRtYXBGaWxlOiBpdGVtLmdldEFzRmlsZSgpXG4gICAgfSk7XG4gIH1cbiAgYWx0VGV4dEZpbmlzaCgpIHtcbiAgICBpZiAodGhpcy5fdWlNYW5hZ2VyLnVzZU5ld0FsdFRleHRGbG93KSB7XG4gICAgICB0aGlzLmRpdi5oaWRkZW4gPSBmYWxzZTtcbiAgICB9XG4gICAgc3VwZXIuYWx0VGV4dEZpbmlzaCgpO1xuICB9XG4gIGdldCB0ZWxlbWV0cnlGaW5hbERhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwic3RhbXBcIixcbiAgICAgIGhhc0FsdFRleHQ6ICEhdGhpcy5hbHRUZXh0RGF0YT8uYWx0VGV4dFxuICAgIH07XG4gIH1cbiAgc3RhdGljIGNvbXB1dGVUZWxlbWV0cnlGaW5hbERhdGEoZGF0YSkge1xuICAgIGNvbnN0IGhhc0FsdFRleHRTdGF0cyA9IGRhdGEuZ2V0KFwiaGFzQWx0VGV4dFwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgaGFzQWx0VGV4dDogaGFzQWx0VGV4dFN0YXRzLmdldCh0cnVlKSA/PyAwLFxuICAgICAgaGFzTm9BbHRUZXh0OiBoYXNBbHRUZXh0U3RhdHMuZ2V0KGZhbHNlKSA/PyAwXG4gICAgfTtcbiAgfVxuICAjZ2V0Qml0bWFwRmV0Y2hlZChkYXRhLCBmcm9tSWQgPSBmYWxzZSkge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYml0bWFwID0gZGF0YS5iaXRtYXA7XG4gICAgaWYgKCFmcm9tSWQpIHtcbiAgICAgIHRoaXMuI2JpdG1hcElkID0gZGF0YS5pZDtcbiAgICAgIHRoaXMuI2lzU3ZnID0gZGF0YS5pc1N2ZztcbiAgICB9XG4gICAgaWYgKGRhdGEuZmlsZSkge1xuICAgICAgdGhpcy4jYml0bWFwRmlsZU5hbWUgPSBkYXRhLmZpbGUubmFtZTtcbiAgICB9XG4gICAgdGhpcy4jY3JlYXRlQ2FudmFzKCk7XG4gIH1cbiAgI2dldEJpdG1hcERvbmUoKSB7XG4gICAgdGhpcy4jYml0bWFwUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLmVuYWJsZVdhaXRpbmcoZmFsc2UpO1xuICAgIGlmICghdGhpcy4jY2FudmFzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl91aU1hbmFnZXIudXNlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSAmJiB0aGlzLl91aU1hbmFnZXIudXNlTmV3QWx0VGV4dEZsb3cgJiYgdGhpcy4jYml0bWFwKSB7XG4gICAgICB0aGlzLmFkZEVkaXRUb29sYmFyKCkudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuX2VkaXRUb29sYmFyLmhpZGUoKTtcbiAgICAgICAgdGhpcy5fdWlNYW5hZ2VyLmVkaXRBbHRUZXh0KHRoaXMsIHRydWUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5fdWlNYW5hZ2VyLnVzZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2UgJiYgdGhpcy5fdWlNYW5hZ2VyLnVzZU5ld0FsdFRleHRGbG93ICYmIHRoaXMuI2JpdG1hcCkge1xuICAgICAgdGhpcy5fcmVwb3J0VGVsZW1ldHJ5KHtcbiAgICAgICAgYWN0aW9uOiBcInBkZmpzLmltYWdlLmltYWdlX2FkZGVkXCIsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBhbHRfdGV4dF9tb2RhbDogZmFsc2UsXG4gICAgICAgICAgYWx0X3RleHRfdHlwZTogXCJlbXB0eVwiXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5tbEd1ZXNzQWx0VGV4dCgpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZGl2LmZvY3VzKCk7XG4gIH1cbiAgYXN5bmMgbWxHdWVzc0FsdFRleHQoaW1hZ2VEYXRhID0gbnVsbCwgdXBkYXRlQWx0VGV4dERhdGEgPSB0cnVlKSB7XG4gICAgaWYgKHRoaXMuaGFzQWx0VGV4dERhdGEoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIG1sTWFuYWdlclxuICAgIH0gPSB0aGlzLl91aU1hbmFnZXI7XG4gICAgaWYgKCFtbE1hbmFnZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIE1MLlwiKTtcbiAgICB9XG4gICAgaWYgKCFhd2FpdCBtbE1hbmFnZXIuaXNFbmFibGVkRm9yKFwiYWx0VGV4dFwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTUwgaXNuJ3QgZW5hYmxlZCBmb3IgYWx0IHRleHQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBkYXRhLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gaW1hZ2VEYXRhIHx8IHRoaXMuY29weUNhbnZhcyhudWxsLCBudWxsLCB0cnVlKS5pbWFnZURhdGE7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBtbE1hbmFnZXIuZ3Vlc3Moe1xuICAgICAgbmFtZTogXCJhbHRUZXh0XCIsXG4gICAgICByZXF1ZXN0OiB7XG4gICAgICAgIGRhdGEsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIGNoYW5uZWxzOiBkYXRhLmxlbmd0aCAvICh3aWR0aCAqIGhlaWdodClcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyByZXNwb25zZSBmcm9tIHRoZSBBSSBzZXJ2aWNlLlwiKTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBmcm9tIHRoZSBBSSBzZXJ2aWNlLlwiKTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLmNhbmNlbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2Uub3V0cHV0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB2YWxpZCByZXNwb25zZSBmcm9tIHRoZSBBSSBzZXJ2aWNlLlwiKTtcbiAgICB9XG4gICAgY29uc3QgYWx0VGV4dCA9IHJlc3BvbnNlLm91dHB1dDtcbiAgICBhd2FpdCB0aGlzLnNldEd1ZXNzZWRBbHRUZXh0KGFsdFRleHQpO1xuICAgIGlmICh1cGRhdGVBbHRUZXh0RGF0YSAmJiAhdGhpcy5oYXNBbHRUZXh0RGF0YSgpKSB7XG4gICAgICB0aGlzLmFsdFRleHREYXRhID0ge1xuICAgICAgICBhbHQ6IGFsdFRleHQsXG4gICAgICAgIGRlY29yYXRpdmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gYWx0VGV4dDtcbiAgfVxuICAjZ2V0Qml0bWFwKCkge1xuICAgIGlmICh0aGlzLiNiaXRtYXBJZCkge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmVuYWJsZVdhaXRpbmcodHJ1ZSk7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmdldEZyb21JZCh0aGlzLiNiaXRtYXBJZCkudGhlbigoZGF0YSkgPT4gdGhpcy4jZ2V0Qml0bWFwRmV0Y2hlZChkYXRhLCB0cnVlKSkuZmluYWxseSgoKSA9PiB0aGlzLiNnZXRCaXRtYXBEb25lKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jYml0bWFwVXJsKSB7XG4gICAgICBjb25zdCB1cmwgPSB0aGlzLiNiaXRtYXBVcmw7XG4gICAgICB0aGlzLiNiaXRtYXBVcmwgPSBudWxsO1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmVuYWJsZVdhaXRpbmcodHJ1ZSk7XG4gICAgICB0aGlzLiNiaXRtYXBQcm9taXNlID0gdGhpcy5fdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5nZXRGcm9tVXJsKHVybCkudGhlbigoZGF0YSkgPT4gdGhpcy4jZ2V0Qml0bWFwRmV0Y2hlZChkYXRhKSkuZmluYWxseSgoKSA9PiB0aGlzLiNnZXRCaXRtYXBEb25lKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jYml0bWFwRmlsZSkge1xuICAgICAgY29uc3QgZmlsZSA9IHRoaXMuI2JpdG1hcEZpbGU7XG4gICAgICB0aGlzLiNiaXRtYXBGaWxlID0gbnVsbDtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5lbmFibGVXYWl0aW5nKHRydWUpO1xuICAgICAgdGhpcy4jYml0bWFwUHJvbWlzZSA9IHRoaXMuX3VpTWFuYWdlci5pbWFnZU1hbmFnZXIuZ2V0RnJvbUZpbGUoZmlsZSkudGhlbigoZGF0YSkgPT4gdGhpcy4jZ2V0Qml0bWFwRmV0Y2hlZChkYXRhKSkuZmluYWxseSgoKSA9PiB0aGlzLiNnZXRCaXRtYXBEb25lKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICBpbnB1dC50eXBlID0gXCJmaWxlXCI7XG4gICAgaW5wdXQuYWNjZXB0ID0gU3VwcG9ydGVkSW1hZ2VNaW1lVHlwZXMuam9pbihcIixcIik7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5fdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgdGhpcy4jYml0bWFwUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKCFpbnB1dC5maWxlcyB8fCBpbnB1dC5maWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3VpTWFuYWdlci5lbmFibGVXYWl0aW5nKHRydWUpO1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmdldEZyb21GaWxlKGlucHV0LmZpbGVzWzBdKTtcbiAgICAgICAgICB0aGlzLl9yZXBvcnRUZWxlbWV0cnkoe1xuICAgICAgICAgICAgYWN0aW9uOiBcInBkZmpzLmltYWdlLmltYWdlX3NlbGVjdGVkXCIsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIGFsdF90ZXh0X21vZGFsOiB0aGlzLl91aU1hbmFnZXIudXNlTmV3QWx0VGV4dEZsb3dcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLiNnZXRCaXRtYXBGZXRjaGVkKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0sIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJjYW5jZWxcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9LCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgfSkuZmluYWxseSgoKSA9PiB0aGlzLiNnZXRCaXRtYXBEb25lKCkpO1xuICAgIGlucHV0LmNsaWNrKCk7XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIGlmICh0aGlzLiNiaXRtYXBJZCkge1xuICAgICAgdGhpcy4jYml0bWFwID0gbnVsbDtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5pbWFnZU1hbmFnZXIuZGVsZXRlSWQodGhpcy4jYml0bWFwSWQpO1xuICAgICAgdGhpcy4jY2FudmFzPy5yZW1vdmUoKTtcbiAgICAgIHRoaXMuI2NhbnZhcyA9IG51bGw7XG4gICAgICBpZiAodGhpcy4jcmVzaXplVGltZW91dElkKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNyZXNpemVUaW1lb3V0SWQpO1xuICAgICAgICB0aGlzLiNyZXNpemVUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBzdXBlci5yZW1vdmUoKTtcbiAgfVxuICByZWJ1aWxkKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIGlmICh0aGlzLiNiaXRtYXBJZCkge1xuICAgICAgICB0aGlzLiNnZXRCaXRtYXAoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIucmVidWlsZCgpO1xuICAgIGlmICh0aGlzLmRpdiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jYml0bWFwSWQgJiYgdGhpcy4jY2FudmFzID09PSBudWxsKSB7XG4gICAgICB0aGlzLiNnZXRCaXRtYXAoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgdGhpcy5wYXJlbnQuYWRkKHRoaXMpO1xuICAgIH1cbiAgfVxuICBvbmNlQWRkZWQoZm9jdXMpIHtcbiAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IHRydWU7XG4gICAgaWYgKGZvY3VzKSB7XG4gICAgICB0aGlzLmRpdi5mb2N1cygpO1xuICAgIH1cbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiAhKHRoaXMuI2JpdG1hcFByb21pc2UgfHwgdGhpcy4jYml0bWFwIHx8IHRoaXMuI2JpdG1hcFVybCB8fCB0aGlzLiNiaXRtYXBGaWxlIHx8IHRoaXMuI2JpdG1hcElkIHx8IHRoaXMuI21pc3NpbmdDYW52YXMpO1xuICB9XG4gIGdldCB0b29sYmFyQnV0dG9ucygpIHtcbiAgICByZXR1cm4gW1tcImFsdFRleHRcIiwgdGhpcy5jcmVhdGVBbHRUZXh0KCldXTtcbiAgfVxuICBnZXQgaXNSZXNpemFibGUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgcmV0dXJuIHRoaXMuZGl2O1xuICAgIH1cbiAgICBsZXQgYmFzZVgsIGJhc2VZO1xuICAgIGlmICh0aGlzLl9pc0NvcHkpIHtcbiAgICAgIGJhc2VYID0gdGhpcy54O1xuICAgICAgYmFzZVkgPSB0aGlzLnk7XG4gICAgfVxuICAgIHN1cGVyLnJlbmRlcigpO1xuICAgIHRoaXMuZGl2LmhpZGRlbiA9IHRydWU7XG4gICAgdGhpcy5jcmVhdGVBbHRUZXh0KCk7XG4gICAgaWYgKCF0aGlzLiNtaXNzaW5nQ2FudmFzKSB7XG4gICAgICBpZiAodGhpcy4jYml0bWFwKSB7XG4gICAgICAgIHRoaXMuI2NyZWF0ZUNhbnZhcygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4jZ2V0Qml0bWFwKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLl9pc0NvcHkpIHtcbiAgICAgIHRoaXMuX21vdmVBZnRlclBhc3RlKGJhc2VYLCBiYXNlWSk7XG4gICAgfVxuICAgIHRoaXMuX3VpTWFuYWdlci5hZGRTaG91bGRSZXNjYWxlKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLmRpdjtcbiAgfVxuICBzZXRDYW52YXMoYW5ub3RhdGlvbkVsZW1lbnRJZCwgY2FudmFzKSB7XG4gICAgY29uc3Qge1xuICAgICAgaWQ6IGJpdG1hcElkLFxuICAgICAgYml0bWFwXG4gICAgfSA9IHRoaXMuX3VpTWFuYWdlci5pbWFnZU1hbmFnZXIuZ2V0RnJvbUNhbnZhcyhhbm5vdGF0aW9uRWxlbWVudElkLCBjYW52YXMpO1xuICAgIGNhbnZhcy5yZW1vdmUoKTtcbiAgICBpZiAoYml0bWFwSWQgJiYgdGhpcy5fdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5pc1ZhbGlkSWQoYml0bWFwSWQpKSB7XG4gICAgICB0aGlzLiNiaXRtYXBJZCA9IGJpdG1hcElkO1xuICAgICAgaWYgKGJpdG1hcCkge1xuICAgICAgICB0aGlzLiNiaXRtYXAgPSBiaXRtYXA7XG4gICAgICB9XG4gICAgICB0aGlzLiNtaXNzaW5nQ2FudmFzID0gZmFsc2U7XG4gICAgICB0aGlzLiNjcmVhdGVDYW52YXMoKTtcbiAgICB9XG4gIH1cbiAgX29uUmVzaXplZCgpIHtcbiAgICB0aGlzLm9uU2NhbGVDaGFuZ2luZygpO1xuICB9XG4gIG9uU2NhbGVDaGFuZ2luZygpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiNyZXNpemVUaW1lb3V0SWQgIT09IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNyZXNpemVUaW1lb3V0SWQpO1xuICAgIH1cbiAgICBjb25zdCBUSU1FX1RPX1dBSVQgPSAyMDA7XG4gICAgdGhpcy4jcmVzaXplVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLiNyZXNpemVUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgdGhpcy4jZHJhd0JpdG1hcCgpO1xuICAgIH0sIFRJTUVfVE9fV0FJVCk7XG4gIH1cbiAgI2NyZWF0ZUNhbnZhcygpIHtcbiAgICBjb25zdCB7XG4gICAgICBkaXZcbiAgICB9ID0gdGhpcztcbiAgICBsZXQge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcy4jYml0bWFwO1xuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICBjb25zdCBNQVhfUkFUSU8gPSAwLjc1O1xuICAgIGlmICh0aGlzLndpZHRoKSB7XG4gICAgICB3aWR0aCA9IHRoaXMud2lkdGggKiBwYWdlV2lkdGg7XG4gICAgICBoZWlnaHQgPSB0aGlzLmhlaWdodCAqIHBhZ2VIZWlnaHQ7XG4gICAgfSBlbHNlIGlmICh3aWR0aCA+IE1BWF9SQVRJTyAqIHBhZ2VXaWR0aCB8fCBoZWlnaHQgPiBNQVhfUkFUSU8gKiBwYWdlSGVpZ2h0KSB7XG4gICAgICBjb25zdCBmYWN0b3IgPSBNYXRoLm1pbihNQVhfUkFUSU8gKiBwYWdlV2lkdGggLyB3aWR0aCwgTUFYX1JBVElPICogcGFnZUhlaWdodCAvIGhlaWdodCk7XG4gICAgICB3aWR0aCAqPSBmYWN0b3I7XG4gICAgICBoZWlnaHQgKj0gZmFjdG9yO1xuICAgIH1cbiAgICB0aGlzLl91aU1hbmFnZXIuZW5hYmxlV2FpdGluZyhmYWxzZSk7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy4jY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBjYW52YXMuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImltZ1wiKTtcbiAgICB0aGlzLmFkZENvbnRhaW5lcihjYW52YXMpO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aCAvIHBhZ2VXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAvIHBhZ2VIZWlnaHQ7XG4gICAgdGhpcy5zZXREaW1zKCk7XG4gICAgaWYgKHRoaXMuX2luaXRpYWxPcHRpb25zPy5pc0NlbnRlcmVkKSB7XG4gICAgICB0aGlzLmNlbnRlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gICAgfVxuICAgIHRoaXMuX2luaXRpYWxPcHRpb25zID0gbnVsbDtcbiAgICBpZiAoIXRoaXMuX3VpTWFuYWdlci51c2VOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlIHx8ICF0aGlzLl91aU1hbmFnZXIudXNlTmV3QWx0VGV4dEZsb3cgfHwgdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICBkaXYuaGlkZGVuID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuI2RyYXdCaXRtYXAoKTtcbiAgICBpZiAoIXRoaXMuI2hhc0JlZW5BZGRlZEluVW5kb1N0YWNrKSB7XG4gICAgICB0aGlzLnBhcmVudC5hZGRVbmRvYWJsZUVkaXRvcih0aGlzKTtcbiAgICAgIHRoaXMuI2hhc0JlZW5BZGRlZEluVW5kb1N0YWNrID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fcmVwb3J0VGVsZW1ldHJ5KHtcbiAgICAgIGFjdGlvbjogXCJpbnNlcnRlZF9pbWFnZVwiXG4gICAgfSk7XG4gICAgaWYgKHRoaXMuI2JpdG1hcEZpbGVOYW1lKSB7XG4gICAgICB0aGlzLmRpdi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWRlc2NyaXB0aW9uXCIsIHRoaXMuI2JpdG1hcEZpbGVOYW1lKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5hMTF5QWxlcnQoXCJwZGZqcy1lZGl0b3Itc3RhbXAtYWRkZWQtYWxlcnRcIik7XG4gICAgfVxuICB9XG4gIGNvcHlDYW52YXMobWF4RGF0YURpbWVuc2lvbiwgbWF4UHJldmlld0RpbWVuc2lvbiwgY3JlYXRlSW1hZ2VEYXRhID0gZmFsc2UpIHtcbiAgICBpZiAoIW1heERhdGFEaW1lbnNpb24pIHtcbiAgICAgIG1heERhdGFEaW1lbnNpb24gPSAyMjQ7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoOiBiaXRtYXBXaWR0aCxcbiAgICAgIGhlaWdodDogYml0bWFwSGVpZ2h0XG4gICAgfSA9IHRoaXMuI2JpdG1hcDtcbiAgICBjb25zdCBvdXRwdXRTY2FsZSA9IG5ldyBPdXRwdXRTY2FsZSgpO1xuICAgIGxldCBiaXRtYXAgPSB0aGlzLiNiaXRtYXA7XG4gICAgbGV0IHdpZHRoID0gYml0bWFwV2lkdGgsIGhlaWdodCA9IGJpdG1hcEhlaWdodDtcbiAgICBsZXQgY2FudmFzID0gbnVsbDtcbiAgICBpZiAobWF4UHJldmlld0RpbWVuc2lvbikge1xuICAgICAgaWYgKGJpdG1hcFdpZHRoID4gbWF4UHJldmlld0RpbWVuc2lvbiB8fCBiaXRtYXBIZWlnaHQgPiBtYXhQcmV2aWV3RGltZW5zaW9uKSB7XG4gICAgICAgIGNvbnN0IHJhdGlvID0gTWF0aC5taW4obWF4UHJldmlld0RpbWVuc2lvbiAvIGJpdG1hcFdpZHRoLCBtYXhQcmV2aWV3RGltZW5zaW9uIC8gYml0bWFwSGVpZ2h0KTtcbiAgICAgICAgd2lkdGggPSBNYXRoLmZsb29yKGJpdG1hcFdpZHRoICogcmF0aW8pO1xuICAgICAgICBoZWlnaHQgPSBNYXRoLmZsb29yKGJpdG1hcEhlaWdodCAqIHJhdGlvKTtcbiAgICAgIH1cbiAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICBjb25zdCBzY2FsZWRXaWR0aCA9IGNhbnZhcy53aWR0aCA9IE1hdGguY2VpbCh3aWR0aCAqIG91dHB1dFNjYWxlLnN4KTtcbiAgICAgIGNvbnN0IHNjYWxlZEhlaWdodCA9IGNhbnZhcy5oZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0ICogb3V0cHV0U2NhbGUuc3kpO1xuICAgICAgaWYgKCF0aGlzLiNpc1N2Zykge1xuICAgICAgICBiaXRtYXAgPSB0aGlzLiNzY2FsZUJpdG1hcChzY2FsZWRXaWR0aCwgc2NhbGVkSGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBjdHguZmlsdGVyID0gdGhpcy5fdWlNYW5hZ2VyLmhjbUZpbHRlcjtcbiAgICAgIGxldCB3aGl0ZSA9IFwid2hpdGVcIiwgYmxhY2sgPSBcIiNjZmNmZDhcIjtcbiAgICAgIGlmICh0aGlzLl91aU1hbmFnZXIuaGNtRmlsdGVyICE9PSBcIm5vbmVcIikge1xuICAgICAgICBibGFjayA9IFwiYmxhY2tcIjtcbiAgICAgIH0gZWxzZSBpZiAoQ29sb3JTY2hlbWUuaXNEYXJrTW9kZSkge1xuICAgICAgICB3aGl0ZSA9IFwiIzhmOGY5ZFwiO1xuICAgICAgICBibGFjayA9IFwiIzQyNDE0ZFwiO1xuICAgICAgfVxuICAgICAgY29uc3QgYm94RGltID0gMTU7XG4gICAgICBjb25zdCBib3hEaW1XaWR0aCA9IGJveERpbSAqIG91dHB1dFNjYWxlLnN4O1xuICAgICAgY29uc3QgYm94RGltSGVpZ2h0ID0gYm94RGltICogb3V0cHV0U2NhbGUuc3k7XG4gICAgICBjb25zdCBwYXR0ZXJuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyhib3hEaW1XaWR0aCAqIDIsIGJveERpbUhlaWdodCAqIDIpO1xuICAgICAgY29uc3QgcGF0dGVybkN0eCA9IHBhdHRlcm4uZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgcGF0dGVybkN0eC5maWxsU3R5bGUgPSB3aGl0ZTtcbiAgICAgIHBhdHRlcm5DdHguZmlsbFJlY3QoMCwgMCwgYm94RGltV2lkdGggKiAyLCBib3hEaW1IZWlnaHQgKiAyKTtcbiAgICAgIHBhdHRlcm5DdHguZmlsbFN0eWxlID0gYmxhY2s7XG4gICAgICBwYXR0ZXJuQ3R4LmZpbGxSZWN0KDAsIDAsIGJveERpbVdpZHRoLCBib3hEaW1IZWlnaHQpO1xuICAgICAgcGF0dGVybkN0eC5maWxsUmVjdChib3hEaW1XaWR0aCwgYm94RGltSGVpZ2h0LCBib3hEaW1XaWR0aCwgYm94RGltSGVpZ2h0KTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBjdHguY3JlYXRlUGF0dGVybihwYXR0ZXJuLCBcInJlcGVhdFwiKTtcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBzY2FsZWRXaWR0aCwgc2NhbGVkSGVpZ2h0KTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UoYml0bWFwLCAwLCAwLCBiaXRtYXAud2lkdGgsIGJpdG1hcC5oZWlnaHQsIDAsIDAsIHNjYWxlZFdpZHRoLCBzY2FsZWRIZWlnaHQpO1xuICAgIH1cbiAgICBsZXQgaW1hZ2VEYXRhID0gbnVsbDtcbiAgICBpZiAoY3JlYXRlSW1hZ2VEYXRhKSB7XG4gICAgICBsZXQgZGF0YVdpZHRoLCBkYXRhSGVpZ2h0O1xuICAgICAgaWYgKG91dHB1dFNjYWxlLnN5bW1ldHJpYyAmJiBiaXRtYXAud2lkdGggPCBtYXhEYXRhRGltZW5zaW9uICYmIGJpdG1hcC5oZWlnaHQgPCBtYXhEYXRhRGltZW5zaW9uKSB7XG4gICAgICAgIGRhdGFXaWR0aCA9IGJpdG1hcC53aWR0aDtcbiAgICAgICAgZGF0YUhlaWdodCA9IGJpdG1hcC5oZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiaXRtYXAgPSB0aGlzLiNiaXRtYXA7XG4gICAgICAgIGlmIChiaXRtYXBXaWR0aCA+IG1heERhdGFEaW1lbnNpb24gfHwgYml0bWFwSGVpZ2h0ID4gbWF4RGF0YURpbWVuc2lvbikge1xuICAgICAgICAgIGNvbnN0IHJhdGlvID0gTWF0aC5taW4obWF4RGF0YURpbWVuc2lvbiAvIGJpdG1hcFdpZHRoLCBtYXhEYXRhRGltZW5zaW9uIC8gYml0bWFwSGVpZ2h0KTtcbiAgICAgICAgICBkYXRhV2lkdGggPSBNYXRoLmZsb29yKGJpdG1hcFdpZHRoICogcmF0aW8pO1xuICAgICAgICAgIGRhdGFIZWlnaHQgPSBNYXRoLmZsb29yKGJpdG1hcEhlaWdodCAqIHJhdGlvKTtcbiAgICAgICAgICBpZiAoIXRoaXMuI2lzU3ZnKSB7XG4gICAgICAgICAgICBiaXRtYXAgPSB0aGlzLiNzY2FsZUJpdG1hcChkYXRhV2lkdGgsIGRhdGFIZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgb2Zmc2NyZWVuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyhkYXRhV2lkdGgsIGRhdGFIZWlnaHQpO1xuICAgICAgY29uc3Qgb2Zmc2NyZWVuQ3R4ID0gb2Zmc2NyZWVuLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBvZmZzY3JlZW5DdHguZHJhd0ltYWdlKGJpdG1hcCwgMCwgMCwgYml0bWFwLndpZHRoLCBiaXRtYXAuaGVpZ2h0LCAwLCAwLCBkYXRhV2lkdGgsIGRhdGFIZWlnaHQpO1xuICAgICAgaW1hZ2VEYXRhID0ge1xuICAgICAgICB3aWR0aDogZGF0YVdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGRhdGFIZWlnaHQsXG4gICAgICAgIGRhdGE6IG9mZnNjcmVlbkN0eC5nZXRJbWFnZURhdGEoMCwgMCwgZGF0YVdpZHRoLCBkYXRhSGVpZ2h0KS5kYXRhXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgY2FudmFzLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBpbWFnZURhdGFcbiAgICB9O1xuICB9XG4gICNzY2FsZUJpdG1hcCh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGg6IGJpdG1hcFdpZHRoLFxuICAgICAgaGVpZ2h0OiBiaXRtYXBIZWlnaHRcbiAgICB9ID0gdGhpcy4jYml0bWFwO1xuICAgIGxldCBuZXdXaWR0aCA9IGJpdG1hcFdpZHRoO1xuICAgIGxldCBuZXdIZWlnaHQgPSBiaXRtYXBIZWlnaHQ7XG4gICAgbGV0IGJpdG1hcCA9IHRoaXMuI2JpdG1hcDtcbiAgICB3aGlsZSAobmV3V2lkdGggPiAyICogd2lkdGggfHwgbmV3SGVpZ2h0ID4gMiAqIGhlaWdodCkge1xuICAgICAgY29uc3QgcHJldldpZHRoID0gbmV3V2lkdGg7XG4gICAgICBjb25zdCBwcmV2SGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgaWYgKG5ld1dpZHRoID4gMiAqIHdpZHRoKSB7XG4gICAgICAgIG5ld1dpZHRoID0gbmV3V2lkdGggPj0gMTYzODQgPyBNYXRoLmZsb29yKG5ld1dpZHRoIC8gMikgLSAxIDogTWF0aC5jZWlsKG5ld1dpZHRoIC8gMik7XG4gICAgICB9XG4gICAgICBpZiAobmV3SGVpZ2h0ID4gMiAqIGhlaWdodCkge1xuICAgICAgICBuZXdIZWlnaHQgPSBuZXdIZWlnaHQgPj0gMTYzODQgPyBNYXRoLmZsb29yKG5ld0hlaWdodCAvIDIpIC0gMSA6IE1hdGguY2VpbChuZXdIZWlnaHQgLyAyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9mZnNjcmVlbiA9IG5ldyBPZmZzY3JlZW5DYW52YXMobmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICBjb25zdCBjdHggPSBvZmZzY3JlZW4uZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgY3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDAsIHByZXZXaWR0aCwgcHJldkhlaWdodCwgMCwgMCwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICBiaXRtYXAgPSBvZmZzY3JlZW4udHJhbnNmZXJUb0ltYWdlQml0bWFwKCk7XG4gICAgfVxuICAgIHJldHVybiBiaXRtYXA7XG4gIH1cbiAgI2RyYXdCaXRtYXAoKSB7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgb3V0cHV0U2NhbGUgPSBuZXcgT3V0cHV0U2NhbGUoKTtcbiAgICBjb25zdCBzY2FsZWRXaWR0aCA9IE1hdGguY2VpbCh3aWR0aCAqIHBhcmVudFdpZHRoICogb3V0cHV0U2NhbGUuc3gpO1xuICAgIGNvbnN0IHNjYWxlZEhlaWdodCA9IE1hdGguY2VpbChoZWlnaHQgKiBwYXJlbnRIZWlnaHQgKiBvdXRwdXRTY2FsZS5zeSk7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy4jY2FudmFzO1xuICAgIGlmICghY2FudmFzIHx8IGNhbnZhcy53aWR0aCA9PT0gc2NhbGVkV2lkdGggJiYgY2FudmFzLmhlaWdodCA9PT0gc2NhbGVkSGVpZ2h0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbnZhcy53aWR0aCA9IHNjYWxlZFdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBzY2FsZWRIZWlnaHQ7XG4gICAgY29uc3QgYml0bWFwID0gdGhpcy4jaXNTdmcgPyB0aGlzLiNiaXRtYXAgOiB0aGlzLiNzY2FsZUJpdG1hcChzY2FsZWRXaWR0aCwgc2NhbGVkSGVpZ2h0KTtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGN0eC5maWx0ZXIgPSB0aGlzLl91aU1hbmFnZXIuaGNtRmlsdGVyO1xuICAgIGN0eC5kcmF3SW1hZ2UoYml0bWFwLCAwLCAwLCBiaXRtYXAud2lkdGgsIGJpdG1hcC5oZWlnaHQsIDAsIDAsIHNjYWxlZFdpZHRoLCBzY2FsZWRIZWlnaHQpO1xuICB9XG4gICNzZXJpYWxpemVCaXRtYXAodG9VcmwpIHtcbiAgICBpZiAodG9VcmwpIHtcbiAgICAgIGlmICh0aGlzLiNpc1N2Zykge1xuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmdldFN2Z1VybCh0aGlzLiNiaXRtYXBJZCk7XG4gICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgKHtcbiAgICAgICAgd2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0XG4gICAgICB9ID0gdGhpcy4jYml0bWFwKTtcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBjdHguZHJhd0ltYWdlKHRoaXMuI2JpdG1hcCwgMCwgMCk7XG4gICAgICByZXR1cm4gY2FudmFzLnRvRGF0YVVSTCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy4jaXNTdmcpIHtcbiAgICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5yb3VuZCh0aGlzLndpZHRoICogcGFnZVdpZHRoICogUGl4ZWxzUGVySW5jaC5QREZfVE9fQ1NTX1VOSVRTKTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGgucm91bmQodGhpcy5oZWlnaHQgKiBwYWdlSGVpZ2h0ICogUGl4ZWxzUGVySW5jaC5QREZfVE9fQ1NTX1VOSVRTKTtcbiAgICAgIGNvbnN0IG9mZnNjcmVlbiA9IG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodCk7XG4gICAgICBjb25zdCBjdHggPSBvZmZzY3JlZW4uZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLiNiaXRtYXAsIDAsIDAsIHRoaXMuI2JpdG1hcC53aWR0aCwgdGhpcy4jYml0bWFwLmhlaWdodCwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICByZXR1cm4gb2Zmc2NyZWVuLnRyYW5zZmVyVG9JbWFnZUJpdG1hcCgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RydWN0dXJlZENsb25lKHRoaXMuI2JpdG1hcCk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKSB7XG4gICAgbGV0IGluaXRpYWxEYXRhID0gbnVsbDtcbiAgICBsZXQgbWlzc2luZ0NhbnZhcyA9IGZhbHNlO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgU3RhbXBBbm5vdGF0aW9uRWxlbWVudCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgcmVjdDogcmVjdDIsXG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgc3RydWN0UGFyZW50LFxuICAgICAgICAgIHBvcHVwUmVmLFxuICAgICAgICAgIHJpY2hUZXh0LFxuICAgICAgICAgIGNvbnRlbnRzT2JqLFxuICAgICAgICAgIGNyZWF0aW9uRGF0ZSxcbiAgICAgICAgICBtb2RpZmljYXRpb25EYXRlXG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgcGFyZW50OiB7XG4gICAgICAgICAgcGFnZToge1xuICAgICAgICAgICAgcGFnZU51bWJlclxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2FudmFzXG4gICAgICB9ID0gZGF0YTtcbiAgICAgIGxldCBiaXRtYXBJZDIsIGJpdG1hcDI7XG4gICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgIGRlbGV0ZSBkYXRhLmNhbnZhcztcbiAgICAgICAgKHtcbiAgICAgICAgICBpZDogYml0bWFwSWQyLFxuICAgICAgICAgIGJpdG1hcDogYml0bWFwMlxuICAgICAgICB9ID0gdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5nZXRGcm9tQ2FudmFzKGNvbnRhaW5lci5pZCwgY2FudmFzKSk7XG4gICAgICAgIGNhbnZhcy5yZW1vdmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pc3NpbmdDYW52YXMgPSB0cnVlO1xuICAgICAgICBkYXRhLl9oYXNOb0NhbnZhcyA9IHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCBhbHRUZXh0ID0gKGF3YWl0IHBhcmVudC5fc3RydWN0VHJlZS5nZXRBcmlhQXR0cmlidXRlcyhgJHtBbm5vdGF0aW9uUHJlZml4fSR7aWR9YCkpPy5nZXQoXCJhcmlhLWxhYmVsXCIpIHx8IFwiXCI7XG4gICAgICBpbml0aWFsRGF0YSA9IGRhdGEgPSB7XG4gICAgICAgIGFubm90YXRpb25UeXBlOiBBbm5vdGF0aW9uRWRpdG9yVHlwZS5TVEFNUCxcbiAgICAgICAgYml0bWFwSWQ6IGJpdG1hcElkMixcbiAgICAgICAgYml0bWFwOiBiaXRtYXAyLFxuICAgICAgICBwYWdlSW5kZXg6IHBhZ2VOdW1iZXIgLSAxLFxuICAgICAgICByZWN0OiByZWN0Mi5zbGljZSgwKSxcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIGFubm90YXRpb25FbGVtZW50SWQ6IGlkLFxuICAgICAgICBpZCxcbiAgICAgICAgZGVsZXRlZDogZmFsc2UsXG4gICAgICAgIGFjY2Vzc2liaWxpdHlEYXRhOiB7XG4gICAgICAgICAgZGVjb3JhdGl2ZTogZmFsc2UsXG4gICAgICAgICAgYWx0VGV4dFxuICAgICAgICB9LFxuICAgICAgICBpc1N2ZzogZmFsc2UsXG4gICAgICAgIHN0cnVjdFBhcmVudCxcbiAgICAgICAgcG9wdXBSZWYsXG4gICAgICAgIHJpY2hUZXh0LFxuICAgICAgICBjb21tZW50OiBjb250ZW50c09iaj8uc3RyIHx8IG51bGwsXG4gICAgICAgIGNyZWF0aW9uRGF0ZSxcbiAgICAgICAgbW9kaWZpY2F0aW9uRGF0ZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgZWRpdG9yID0gYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlY3QsXG4gICAgICBiaXRtYXAsXG4gICAgICBiaXRtYXBVcmwsXG4gICAgICBiaXRtYXBJZCxcbiAgICAgIGlzU3ZnLFxuICAgICAgYWNjZXNzaWJpbGl0eURhdGFcbiAgICB9ID0gZGF0YTtcbiAgICBpZiAobWlzc2luZ0NhbnZhcykge1xuICAgICAgdWlNYW5hZ2VyLmFkZE1pc3NpbmdDYW52YXMoZGF0YS5pZCwgZWRpdG9yKTtcbiAgICAgIGVkaXRvci4jbWlzc2luZ0NhbnZhcyA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChiaXRtYXBJZCAmJiB1aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmlzVmFsaWRJZChiaXRtYXBJZCkpIHtcbiAgICAgIGVkaXRvci4jYml0bWFwSWQgPSBiaXRtYXBJZDtcbiAgICAgIGlmIChiaXRtYXApIHtcbiAgICAgICAgZWRpdG9yLiNiaXRtYXAgPSBiaXRtYXA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVkaXRvci4jYml0bWFwVXJsID0gYml0bWFwVXJsO1xuICAgIH1cbiAgICBlZGl0b3IuI2lzU3ZnID0gaXNTdmc7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gZWRpdG9yLnBhZ2VEaW1lbnNpb25zO1xuICAgIGVkaXRvci53aWR0aCA9IChyZWN0WzJdIC0gcmVjdFswXSkgLyBwYXJlbnRXaWR0aDtcbiAgICBlZGl0b3IuaGVpZ2h0ID0gKHJlY3RbM10gLSByZWN0WzFdKSAvIHBhcmVudEhlaWdodDtcbiAgICBpZiAoYWNjZXNzaWJpbGl0eURhdGEpIHtcbiAgICAgIGVkaXRvci5hbHRUZXh0RGF0YSA9IGFjY2Vzc2liaWxpdHlEYXRhO1xuICAgIH1cbiAgICBlZGl0b3IuX2luaXRpYWxEYXRhID0gaW5pdGlhbERhdGE7XG4gICAgaWYgKGRhdGEuY29tbWVudCkge1xuICAgICAgZWRpdG9yLnNldENvbW1lbnREYXRhKGRhdGEpO1xuICAgIH1cbiAgICBlZGl0b3IuI2hhc0JlZW5BZGRlZEluVW5kb1N0YWNrID0gISFpbml0aWFsRGF0YTtcbiAgICByZXR1cm4gZWRpdG9yO1xuICB9XG4gIHNlcmlhbGl6ZShpc0ZvckNvcHlpbmcgPSBmYWxzZSwgY29udGV4dCA9IG51bGwpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5kZWxldGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVEZWxldGVkKCk7XG4gICAgfVxuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBPYmplY3QuYXNzaWduKHN1cGVyLnNlcmlhbGl6ZShpc0ZvckNvcHlpbmcpLCB7XG4gICAgICBiaXRtYXBJZDogdGhpcy4jYml0bWFwSWQsXG4gICAgICBpc1N2ZzogdGhpcy4jaXNTdmdcbiAgICB9KTtcbiAgICB0aGlzLmFkZENvbW1lbnQoc2VyaWFsaXplZCk7XG4gICAgaWYgKGlzRm9yQ29weWluZykge1xuICAgICAgc2VyaWFsaXplZC5iaXRtYXBVcmwgPSB0aGlzLiNzZXJpYWxpemVCaXRtYXAodHJ1ZSk7XG4gICAgICBzZXJpYWxpemVkLmFjY2Vzc2liaWxpdHlEYXRhID0gdGhpcy5zZXJpYWxpemVBbHRUZXh0KHRydWUpO1xuICAgICAgc2VyaWFsaXplZC5pc0NvcHkgPSB0cnVlO1xuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGRlY29yYXRpdmUsXG4gICAgICBhbHRUZXh0XG4gICAgfSA9IHRoaXMuc2VyaWFsaXplQWx0VGV4dChmYWxzZSk7XG4gICAgaWYgKCFkZWNvcmF0aXZlICYmIGFsdFRleHQpIHtcbiAgICAgIHNlcmlhbGl6ZWQuYWNjZXNzaWJpbGl0eURhdGEgPSB7XG4gICAgICAgIHR5cGU6IFwiRmlndXJlXCIsXG4gICAgICAgIGFsdDogYWx0VGV4dFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgY29uc3QgY2hhbmdlcyA9IHRoaXMuI2hhc0VsZW1lbnRDaGFuZ2VkKHNlcmlhbGl6ZWQpO1xuICAgICAgaWYgKGNoYW5nZXMuaXNTYW1lKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGNoYW5nZXMuaXNTYW1lQWx0VGV4dCkge1xuICAgICAgICBkZWxldGUgc2VyaWFsaXplZC5hY2Nlc3NpYmlsaXR5RGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlcmlhbGl6ZWQuYWNjZXNzaWJpbGl0eURhdGEuc3RydWN0UGFyZW50ID0gdGhpcy5faW5pdGlhbERhdGEuc3RydWN0UGFyZW50ID8/IC0xO1xuICAgICAgfVxuICAgICAgc2VyaWFsaXplZC5pZCA9IHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZDtcbiAgICAgIGRlbGV0ZSBzZXJpYWxpemVkLmJpdG1hcElkO1xuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfVxuICAgIGlmIChjb250ZXh0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gICAgY29udGV4dC5zdGFtcHMgfHw9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3QgYXJlYSA9IHRoaXMuI2lzU3ZnID8gKHNlcmlhbGl6ZWQucmVjdFsyXSAtIHNlcmlhbGl6ZWQucmVjdFswXSkgKiAoc2VyaWFsaXplZC5yZWN0WzNdIC0gc2VyaWFsaXplZC5yZWN0WzFdKSA6IG51bGw7XG4gICAgaWYgKCFjb250ZXh0LnN0YW1wcy5oYXModGhpcy4jYml0bWFwSWQpKSB7XG4gICAgICBjb250ZXh0LnN0YW1wcy5zZXQodGhpcy4jYml0bWFwSWQsIHtcbiAgICAgICAgYXJlYSxcbiAgICAgICAgc2VyaWFsaXplZFxuICAgICAgfSk7XG4gICAgICBzZXJpYWxpemVkLmJpdG1hcCA9IHRoaXMuI3NlcmlhbGl6ZUJpdG1hcChmYWxzZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLiNpc1N2Zykge1xuICAgICAgY29uc3QgcHJldkRhdGEgPSBjb250ZXh0LnN0YW1wcy5nZXQodGhpcy4jYml0bWFwSWQpO1xuICAgICAgaWYgKGFyZWEgPiBwcmV2RGF0YS5hcmVhKSB7XG4gICAgICAgIHByZXZEYXRhLmFyZWEgPSBhcmVhO1xuICAgICAgICBwcmV2RGF0YS5zZXJpYWxpemVkLmJpdG1hcC5jbG9zZSgpO1xuICAgICAgICBwcmV2RGF0YS5zZXJpYWxpemVkLmJpdG1hcCA9IHRoaXMuI3NlcmlhbGl6ZUJpdG1hcChmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkO1xuICB9XG4gICNoYXNFbGVtZW50Q2hhbmdlZChzZXJpYWxpemVkKSB7XG4gICAgY29uc3Qge1xuICAgICAgcGFnZUluZGV4LFxuICAgICAgYWNjZXNzaWJpbGl0eURhdGE6IHtcbiAgICAgICAgYWx0VGV4dFxuICAgICAgfVxuICAgIH0gPSB0aGlzLl9pbml0aWFsRGF0YTtcbiAgICBjb25zdCBpc1NhbWVQYWdlSW5kZXggPSBzZXJpYWxpemVkLnBhZ2VJbmRleCA9PT0gcGFnZUluZGV4O1xuICAgIGNvbnN0IGlzU2FtZUFsdFRleHQgPSAoc2VyaWFsaXplZC5hY2Nlc3NpYmlsaXR5RGF0YT8uYWx0IHx8IFwiXCIpID09PSBhbHRUZXh0O1xuICAgIHJldHVybiB7XG4gICAgICBpc1NhbWU6ICF0aGlzLmhhc0VkaXRlZENvbW1lbnQgJiYgIXRoaXMuX2hhc0JlZW5Nb3ZlZCAmJiAhdGhpcy5faGFzQmVlblJlc2l6ZWQgJiYgaXNTYW1lUGFnZUluZGV4ICYmIGlzU2FtZUFsdFRleHQsXG4gICAgICBpc1NhbWVBbHRUZXh0XG4gICAgfTtcbiAgfVxuICByZW5kZXJBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKSB7XG4gICAgaWYgKHRoaXMuZGVsZXRlZCkge1xuICAgICAgYW5ub3RhdGlvbi5oaWRlKCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYW5ub3RhdGlvbi51cGRhdGVFZGl0ZWQoe1xuICAgICAgcmVjdDogdGhpcy5nZXRQREZSZWN0KCksXG4gICAgICBwb3B1cDogdGhpcy5jb21tZW50XG4gICAgfSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmNsYXNzIEFubm90YXRpb25FZGl0b3JMYXllciB7XG4gICNhY2Nlc3NpYmlsaXR5TWFuYWdlcjtcbiAgI2FsbG93Q2xpY2sgPSBmYWxzZTtcbiAgI2Fubm90YXRpb25MYXllciA9IG51bGw7XG4gICNjbGlja0FDID0gbnVsbDtcbiAgI2VkaXRvckZvY3VzVGltZW91dElkID0gbnVsbDtcbiAgI2VkaXRvcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAjaGFkUG9pbnRlckRvd24gPSBmYWxzZTtcbiAgI2lzRGlzYWJsaW5nID0gZmFsc2U7XG4gICNpc0VuYWJsaW5nID0gZmFsc2U7XG4gICNkcmF3aW5nQUMgPSBudWxsO1xuICAjZm9jdXNlZEVsZW1lbnQgPSBudWxsO1xuICAjdGV4dExheWVyID0gbnVsbDtcbiAgI3RleHRTZWxlY3Rpb25BQyA9IG51bGw7XG4gICN0ZXh0TGF5ZXJEYmxDbGlja0FDID0gbnVsbDtcbiAgI2xhc3RQb2ludGVyRG93blRpbWVzdGFtcCA9IC0xO1xuICAjdWlNYW5hZ2VyO1xuICBzdGF0aWMgX2luaXRpYWxpemVkID0gZmFsc2U7XG4gIHN0YXRpYyAjZWRpdG9yVHlwZXMgPSBuZXcgTWFwKFtGcmVlVGV4dEVkaXRvciwgSW5rRWRpdG9yLCBTdGFtcEVkaXRvciwgSGlnaGxpZ2h0RWRpdG9yLCBTaWduYXR1cmVFZGl0b3JdLm1hcCgodHlwZSkgPT4gW3R5cGUuX2VkaXRvclR5cGUsIHR5cGVdKSk7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB1aU1hbmFnZXIsXG4gICAgcGFnZUluZGV4LFxuICAgIGRpdixcbiAgICBzdHJ1Y3RUcmVlTGF5ZXIsXG4gICAgYWNjZXNzaWJpbGl0eU1hbmFnZXIsXG4gICAgYW5ub3RhdGlvbkxheWVyLFxuICAgIGRyYXdMYXllcixcbiAgICB0ZXh0TGF5ZXIsXG4gICAgdmlld3BvcnQsXG4gICAgbDEwblxuICB9KSB7XG4gICAgY29uc3QgZWRpdG9yVHlwZXMgPSBbLi4uQW5ub3RhdGlvbkVkaXRvckxheWVyLiNlZGl0b3JUeXBlcy52YWx1ZXMoKV07XG4gICAgaWYgKCFBbm5vdGF0aW9uRWRpdG9yTGF5ZXIuX2luaXRpYWxpemVkKSB7XG4gICAgICBBbm5vdGF0aW9uRWRpdG9yTGF5ZXIuX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yVHlwZSBvZiBlZGl0b3JUeXBlcykge1xuICAgICAgICBlZGl0b3JUeXBlLmluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdWlNYW5hZ2VyLnJlZ2lzdGVyRWRpdG9yVHlwZXMoZWRpdG9yVHlwZXMpO1xuICAgIHRoaXMuI3VpTWFuYWdlciA9IHVpTWFuYWdlcjtcbiAgICB0aGlzLnBhZ2VJbmRleCA9IHBhZ2VJbmRleDtcbiAgICB0aGlzLmRpdiA9IGRpdjtcbiAgICB0aGlzLiNhY2Nlc3NpYmlsaXR5TWFuYWdlciA9IGFjY2Vzc2liaWxpdHlNYW5hZ2VyO1xuICAgIHRoaXMuI2Fubm90YXRpb25MYXllciA9IGFubm90YXRpb25MYXllcjtcbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgdGhpcy4jdGV4dExheWVyID0gdGV4dExheWVyO1xuICAgIHRoaXMuZHJhd0xheWVyID0gZHJhd0xheWVyO1xuICAgIHRoaXMuX3N0cnVjdFRyZWUgPSBzdHJ1Y3RUcmVlTGF5ZXI7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLmFkZExheWVyKHRoaXMpO1xuICB9XG4gIGdldCBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLiNlZGl0b3JzLnNpemUgPT09IDA7XG4gIH1cbiAgZ2V0IGlzSW52aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmlzRW1wdHkgJiYgdGhpcy4jdWlNYW5hZ2VyLmdldE1vZGUoKSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORTtcbiAgfVxuICB1cGRhdGVUb29sYmFyKG9wdGlvbnMpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIudXBkYXRlVG9vbGJhcihvcHRpb25zKTtcbiAgfVxuICB1cGRhdGVNb2RlKG1vZGUgPSB0aGlzLiN1aU1hbmFnZXIuZ2V0TW9kZSgpKSB7XG4gICAgdGhpcy4jY2xlYW51cCgpO1xuICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FOlxuICAgICAgICB0aGlzLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwibm9uRWRpdGluZ1wiLCB0cnVlKTtcbiAgICAgICAgdGhpcy5kaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLnRvZ2dsZVBvaW50ZXJFdmVudHMoZmFsc2UpO1xuICAgICAgICB0aGlzLnRvZ2dsZUFubm90YXRpb25MYXllclBvaW50ZXJFdmVudHModHJ1ZSk7XG4gICAgICAgIHRoaXMuZGlzYWJsZUNsaWNrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclR5cGUuSU5LOlxuICAgICAgICB0aGlzLmRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMudG9nZ2xlUG9pbnRlckV2ZW50cyh0cnVlKTtcbiAgICAgICAgdGhpcy5lbmFibGVDbGljaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hUOlxuICAgICAgICB0aGlzLmVuYWJsZVRleHRTZWxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy50b2dnbGVQb2ludGVyRXZlbnRzKGZhbHNlKTtcbiAgICAgICAgdGhpcy5kaXNhYmxlQ2xpY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMudG9nZ2xlUG9pbnRlckV2ZW50cyh0cnVlKTtcbiAgICAgICAgdGhpcy5lbmFibGVDbGljaygpO1xuICAgIH1cbiAgICB0aGlzLnRvZ2dsZUFubm90YXRpb25MYXllclBvaW50ZXJFdmVudHMoZmFsc2UpO1xuICAgIGNvbnN0IHtcbiAgICAgIGNsYXNzTGlzdFxuICAgIH0gPSB0aGlzLmRpdjtcbiAgICBjbGFzc0xpc3QudG9nZ2xlKFwibm9uRWRpdGluZ1wiLCBmYWxzZSk7XG4gICAgaWYgKG1vZGUgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLlBPUFVQKSB7XG4gICAgICBjbGFzc0xpc3QudG9nZ2xlKFwiY29tbWVudEVkaXRpbmdcIiwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsYXNzTGlzdC50b2dnbGUoXCJjb21tZW50RWRpdGluZ1wiLCBmYWxzZSk7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgQW5ub3RhdGlvbkVkaXRvckxheWVyLiNlZGl0b3JUeXBlcy52YWx1ZXMoKSkge1xuICAgICAgICBjbGFzc0xpc3QudG9nZ2xlKGAke2VkaXRvclR5cGUuX3R5cGV9RWRpdGluZ2AsIG1vZGUgPT09IGVkaXRvclR5cGUuX2VkaXRvclR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmRpdi5oaWRkZW4gPSBmYWxzZTtcbiAgfVxuICBoYXNUZXh0TGF5ZXIodGV4dExheWVyKSB7XG4gICAgcmV0dXJuIHRleHRMYXllciA9PT0gdGhpcy4jdGV4dExheWVyPy5kaXY7XG4gIH1cbiAgc2V0RWRpdGluZ1N0YXRlKGlzRWRpdGluZykge1xuICAgIHRoaXMuI3VpTWFuYWdlci5zZXRFZGl0aW5nU3RhdGUoaXNFZGl0aW5nKTtcbiAgfVxuICBhZGRDb21tYW5kcyhwYXJhbXMpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIuYWRkQ29tbWFuZHMocGFyYW1zKTtcbiAgfVxuICBjbGVhblVuZG9TdGFjayh0eXBlKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLmNsZWFuVW5kb1N0YWNrKHR5cGUpO1xuICB9XG4gIHRvZ2dsZURyYXdpbmcoZW5hYmxlZCA9IGZhbHNlKSB7XG4gICAgdGhpcy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImRyYXdpbmdcIiwgIWVuYWJsZWQpO1xuICB9XG4gIHRvZ2dsZVBvaW50ZXJFdmVudHMoZW5hYmxlZCA9IGZhbHNlKSB7XG4gICAgdGhpcy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImRpc2FibGVkXCIsICFlbmFibGVkKTtcbiAgfVxuICB0b2dnbGVBbm5vdGF0aW9uTGF5ZXJQb2ludGVyRXZlbnRzKGVuYWJsZWQgPSBmYWxzZSkge1xuICAgIHRoaXMuI2Fubm90YXRpb25MYXllcj8uZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJkaXNhYmxlZFwiLCAhZW5hYmxlZCk7XG4gIH1cbiAgZ2V0ICNhbGxFZGl0b3JzSXRlcmF0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2VkaXRvcnMuc2l6ZSAhPT0gMCA/IHRoaXMuI2VkaXRvcnMudmFsdWVzKCkgOiB0aGlzLiN1aU1hbmFnZXIuZ2V0RWRpdG9ycyh0aGlzLnBhZ2VJbmRleCk7XG4gIH1cbiAgYXN5bmMgZW5hYmxlKCkge1xuICAgIHRoaXMuI2lzRW5hYmxpbmcgPSB0cnVlO1xuICAgIHRoaXMuZGl2LnRhYkluZGV4ID0gMDtcbiAgICB0aGlzLnRvZ2dsZVBvaW50ZXJFdmVudHModHJ1ZSk7XG4gICAgdGhpcy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcIm5vbkVkaXRpbmdcIiwgZmFsc2UpO1xuICAgIHRoaXMuI3RleHRMYXllckRibENsaWNrQUM/LmFib3J0KCk7XG4gICAgdGhpcy4jdGV4dExheWVyRGJsQ2xpY2tBQyA9IG51bGw7XG4gICAgY29uc3QgYW5ub3RhdGlvbkVsZW1lbnRJZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2FsbEVkaXRvcnNJdGVyYXRvcikge1xuICAgICAgZWRpdG9yLmVuYWJsZUVkaXRpbmcoKTtcbiAgICAgIGVkaXRvci5zaG93KHRydWUpO1xuICAgICAgaWYgKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICAgIHRoaXMuI3VpTWFuYWdlci5yZW1vdmVDaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9uKGVkaXRvcik7XG4gICAgICAgIGFubm90YXRpb25FbGVtZW50SWRzLmFkZChlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGFubm90YXRpb25MYXllciA9IHRoaXMuI2Fubm90YXRpb25MYXllcjtcbiAgICBpZiAoYW5ub3RhdGlvbkxheWVyKSB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRhYmxlIG9mIGFubm90YXRpb25MYXllci5nZXRFZGl0YWJsZUFubm90YXRpb25zKCkpIHtcbiAgICAgICAgZWRpdGFibGUuaGlkZSgpO1xuICAgICAgICBpZiAodGhpcy4jdWlNYW5hZ2VyLmlzRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGVkaXRhYmxlLmRhdGEuaWQpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFubm90YXRpb25FbGVtZW50SWRzLmhhcyhlZGl0YWJsZS5kYXRhLmlkKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVkaXRvciA9IGF3YWl0IHRoaXMuZGVzZXJpYWxpemUoZWRpdGFibGUpO1xuICAgICAgICBpZiAoIWVkaXRvcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkT3JSZWJ1aWxkKGVkaXRvcik7XG4gICAgICAgIGVkaXRvci5lbmFibGVFZGl0aW5nKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2lzRW5hYmxpbmcgPSBmYWxzZTtcbiAgICB0aGlzLiN1aU1hbmFnZXIuX2V2ZW50QnVzLmRpc3BhdGNoKFwiZWRpdG9yc3JlbmRlcmVkXCIsIHtcbiAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgIHBhZ2VOdW1iZXI6IHRoaXMucGFnZUluZGV4ICsgMVxuICAgIH0pO1xuICB9XG4gIGRpc2FibGUoKSB7XG4gICAgdGhpcy4jaXNEaXNhYmxpbmcgPSB0cnVlO1xuICAgIHRoaXMuZGl2LnRhYkluZGV4ID0gLTE7XG4gICAgdGhpcy50b2dnbGVQb2ludGVyRXZlbnRzKGZhbHNlKTtcbiAgICB0aGlzLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwibm9uRWRpdGluZ1wiLCB0cnVlKTtcbiAgICBpZiAodGhpcy4jdGV4dExheWVyICYmICF0aGlzLiN0ZXh0TGF5ZXJEYmxDbGlja0FDKSB7XG4gICAgICB0aGlzLiN0ZXh0TGF5ZXJEYmxDbGlja0FDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jdWlNYW5hZ2VyLmNvbWJpbmVkU2lnbmFsKHRoaXMuI3RleHRMYXllckRibENsaWNrQUMpO1xuICAgICAgdGhpcy4jdGV4dExheWVyLmRpdi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgKGUpID0+IHtcbiAgICAgICAgY29uc3QgREJMX0NMSUNLX1RIUkVTSE9MRCA9IDUwMDtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGNsaWVudFgsXG4gICAgICAgICAgY2xpZW50WSxcbiAgICAgICAgICB0aW1lU3RhbXBcbiAgICAgICAgfSA9IGU7XG4gICAgICAgIGNvbnN0IGxhc3RQb2ludGVyRG93blRpbWVzdGFtcCA9IHRoaXMuI2xhc3RQb2ludGVyRG93blRpbWVzdGFtcDtcbiAgICAgICAgaWYgKHRpbWVTdGFtcCAtIGxhc3RQb2ludGVyRG93blRpbWVzdGFtcCA+IERCTF9DTElDS19USFJFU0hPTEQpIHtcbiAgICAgICAgICB0aGlzLiNsYXN0UG9pbnRlckRvd25UaW1lc3RhbXAgPSB0aW1lU3RhbXA7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2xhc3RQb2ludGVyRG93blRpbWVzdGFtcCA9IC0xO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgY2xhc3NMaXN0OiBjbGFzc0xpc3QyXG4gICAgICAgIH0gPSB0aGlzLmRpdjtcbiAgICAgICAgY2xhc3NMaXN0Mi50b2dnbGUoXCJnZXRFbGVtZW50c1wiLCB0cnVlKTtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBkb2N1bWVudC5lbGVtZW50c0Zyb21Qb2ludChjbGllbnRYLCBjbGllbnRZKTtcbiAgICAgICAgY2xhc3NMaXN0Mi50b2dnbGUoXCJnZXRFbGVtZW50c1wiLCBmYWxzZSk7XG4gICAgICAgIGlmICghdGhpcy5kaXYuY29udGFpbnMoZWxlbWVudHNbMF0pKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpZDtcbiAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKGBeJHtBbm5vdGF0aW9uRWRpdG9yUHJlZml4fVswLTldKyRgKTtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgICAgaWYgKHJlZ2V4LnRlc3QoZWxlbWVudC5pZCkpIHtcbiAgICAgICAgICAgIGlkID0gZWxlbWVudC5pZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuI2VkaXRvcnMuZ2V0KGlkKTtcbiAgICAgICAgaWYgKGVkaXRvcj8uYW5ub3RhdGlvbkVsZW1lbnRJZCA9PT0gbnVsbCkge1xuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGVkaXRvci5kYmxjbGljayhlKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBzaWduYWwsXG4gICAgICAgIGNhcHR1cmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBhbm5vdGF0aW9uTGF5ZXIgPSB0aGlzLiNhbm5vdGF0aW9uTGF5ZXI7XG4gICAgaWYgKGFubm90YXRpb25MYXllcikge1xuICAgICAgY29uc3QgY2hhbmdlZEFubm90YXRpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGNvbnN0IHJlc2V0QW5ub3RhdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jYWxsRWRpdG9yc0l0ZXJhdG9yKSB7XG4gICAgICAgIGVkaXRvci5kaXNhYmxlRWRpdGluZygpO1xuICAgICAgICBpZiAoIWVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICAgICAgZWRpdG9yLnVwZGF0ZUZha2VBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uTGF5ZXIpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlZGl0b3Iuc2VyaWFsaXplKCkgIT09IG51bGwpIHtcbiAgICAgICAgICBjaGFuZ2VkQW5ub3RhdGlvbnMuc2V0KGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkLCBlZGl0b3IpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc2V0QW5ub3RhdGlvbnMuc2V0KGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkLCBlZGl0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2V0RWRpdGFibGVBbm5vdGF0aW9uKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKT8uc2hvdygpO1xuICAgICAgICBlZGl0b3IucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBlZGl0YWJsZXMgPSBhbm5vdGF0aW9uTGF5ZXIuZ2V0RWRpdGFibGVBbm5vdGF0aW9ucygpO1xuICAgICAgZm9yIChjb25zdCBlZGl0YWJsZSBvZiBlZGl0YWJsZXMpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGlkXG4gICAgICAgIH0gPSBlZGl0YWJsZS5kYXRhO1xuICAgICAgICBpZiAodGhpcy4jdWlNYW5hZ2VyLmlzRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGlkKSkge1xuICAgICAgICAgIGVkaXRhYmxlLnVwZGF0ZUVkaXRlZCh7XG4gICAgICAgICAgICBkZWxldGVkOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVkaXRvciA9IHJlc2V0QW5ub3RhdGlvbnMuZ2V0KGlkKTtcbiAgICAgICAgaWYgKGVkaXRvcikge1xuICAgICAgICAgIGVkaXRvci5yZXNldEFubm90YXRpb25FbGVtZW50KGVkaXRhYmxlKTtcbiAgICAgICAgICBlZGl0b3Iuc2hvdyhmYWxzZSk7XG4gICAgICAgICAgZWRpdGFibGUuc2hvdygpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVkaXRvciA9IGNoYW5nZWRBbm5vdGF0aW9ucy5nZXQoaWQpO1xuICAgICAgICBpZiAoZWRpdG9yKSB7XG4gICAgICAgICAgdGhpcy4jdWlNYW5hZ2VyLmFkZENoYW5nZWRFeGlzdGluZ0Fubm90YXRpb24oZWRpdG9yKTtcbiAgICAgICAgICBpZiAoZWRpdG9yLnJlbmRlckFubm90YXRpb25FbGVtZW50KGVkaXRhYmxlKSkge1xuICAgICAgICAgICAgZWRpdG9yLnNob3coZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlZGl0YWJsZS5zaG93KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2NsZWFudXAoKTtcbiAgICBpZiAodGhpcy5pc0VtcHR5KSB7XG4gICAgICB0aGlzLmRpdi5oaWRkZW4gPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjbGFzc0xpc3RcbiAgICB9ID0gdGhpcy5kaXY7XG4gICAgZm9yIChjb25zdCBlZGl0b3JUeXBlIG9mIEFubm90YXRpb25FZGl0b3JMYXllci4jZWRpdG9yVHlwZXMudmFsdWVzKCkpIHtcbiAgICAgIGNsYXNzTGlzdC5yZW1vdmUoYCR7ZWRpdG9yVHlwZS5fdHlwZX1FZGl0aW5nYCk7XG4gICAgfVxuICAgIHRoaXMuZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcbiAgICB0aGlzLnRvZ2dsZUFubm90YXRpb25MYXllclBvaW50ZXJFdmVudHModHJ1ZSk7XG4gICAgdGhpcy4jaXNEaXNhYmxpbmcgPSBmYWxzZTtcbiAgfVxuICBnZXRFZGl0YWJsZUFubm90YXRpb24oaWQpIHtcbiAgICByZXR1cm4gdGhpcy4jYW5ub3RhdGlvbkxheWVyPy5nZXRFZGl0YWJsZUFubm90YXRpb24oaWQpIHx8IG51bGw7XG4gIH1cbiAgc2V0QWN0aXZlRWRpdG9yKGVkaXRvcikge1xuICAgIGNvbnN0IGN1cnJlbnRBY3RpdmUgPSB0aGlzLiN1aU1hbmFnZXIuZ2V0QWN0aXZlKCk7XG4gICAgaWYgKGN1cnJlbnRBY3RpdmUgPT09IGVkaXRvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiN1aU1hbmFnZXIuc2V0QWN0aXZlRWRpdG9yKGVkaXRvcik7XG4gIH1cbiAgZW5hYmxlVGV4dFNlbGVjdGlvbigpIHtcbiAgICB0aGlzLmRpdi50YWJJbmRleCA9IC0xO1xuICAgIGlmICh0aGlzLiN0ZXh0TGF5ZXI/LmRpdiAmJiAhdGhpcy4jdGV4dFNlbGVjdGlvbkFDKSB7XG4gICAgICB0aGlzLiN0ZXh0U2VsZWN0aW9uQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICBjb25zdCBzaWduYWwgPSB0aGlzLiN1aU1hbmFnZXIuY29tYmluZWRTaWduYWwodGhpcy4jdGV4dFNlbGVjdGlvbkFDKTtcbiAgICAgIHRoaXMuI3RleHRMYXllci5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHRoaXMuI3RleHRMYXllclBvaW50ZXJEb3duLmJpbmQodGhpcyksIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIHRoaXMuI3RleHRMYXllci5kaXYuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodGluZ1wiKTtcbiAgICB9XG4gIH1cbiAgZGlzYWJsZVRleHRTZWxlY3Rpb24oKSB7XG4gICAgdGhpcy5kaXYudGFiSW5kZXggPSAwO1xuICAgIGlmICh0aGlzLiN0ZXh0TGF5ZXI/LmRpdiAmJiB0aGlzLiN0ZXh0U2VsZWN0aW9uQUMpIHtcbiAgICAgIHRoaXMuI3RleHRTZWxlY3Rpb25BQy5hYm9ydCgpO1xuICAgICAgdGhpcy4jdGV4dFNlbGVjdGlvbkFDID0gbnVsbDtcbiAgICAgIHRoaXMuI3RleHRMYXllci5kaXYuY2xhc3NMaXN0LnJlbW92ZShcImhpZ2hsaWdodGluZ1wiKTtcbiAgICB9XG4gIH1cbiAgI3RleHRMYXllclBvaW50ZXJEb3duKGV2ZW50KSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnVuc2VsZWN0QWxsKCk7XG4gICAgY29uc3Qge1xuICAgICAgdGFyZ2V0XG4gICAgfSA9IGV2ZW50O1xuICAgIGlmICh0YXJnZXQgPT09IHRoaXMuI3RleHRMYXllci5kaXYgfHwgKHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJyb2xlXCIpID09PSBcImltZ1wiIHx8IHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoXCJlbmRPZkNvbnRlbnRcIikpICYmIHRoaXMuI3RleHRMYXllci5kaXYuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBpc01hY1xuICAgICAgfSA9IHV0aWxfRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8IGV2ZW50LmN0cmxLZXkgJiYgaXNNYWMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy4jdWlNYW5hZ2VyLnNob3dBbGxFZGl0b3JzKFwiaGlnaGxpZ2h0XCIsIHRydWUsIHRydWUpO1xuICAgICAgdGhpcy4jdGV4dExheWVyLmRpdi5jbGFzc0xpc3QuYWRkKFwiZnJlZVwiKTtcbiAgICAgIHRoaXMudG9nZ2xlRHJhd2luZygpO1xuICAgICAgSGlnaGxpZ2h0RWRpdG9yLnN0YXJ0SGlnaGxpZ2h0aW5nKHRoaXMsIHRoaXMuI3VpTWFuYWdlci5kaXJlY3Rpb24gPT09IFwibHRyXCIsIHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLiN0ZXh0TGF5ZXIuZGl2LFxuICAgICAgICB4OiBldmVudC54LFxuICAgICAgICB5OiBldmVudC55XG4gICAgICB9KTtcbiAgICAgIHRoaXMuI3RleHRMYXllci5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuI3RleHRMYXllci5kaXYuY2xhc3NMaXN0LnJlbW92ZShcImZyZWVcIik7XG4gICAgICAgIHRoaXMudG9nZ2xlRHJhd2luZyh0cnVlKTtcbiAgICAgIH0sIHtcbiAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgc2lnbmFsOiB0aGlzLiN1aU1hbmFnZXIuX3NpZ25hbFxuICAgICAgfSk7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuICBlbmFibGVDbGljaygpIHtcbiAgICBpZiAodGhpcy4jY2xpY2tBQykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNjbGlja0FDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI3VpTWFuYWdlci5jb21iaW5lZFNpZ25hbCh0aGlzLiNjbGlja0FDKTtcbiAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgdGhpcy5wb2ludGVyZG93bi5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBjb25zdCBwb2ludGVydXAgPSB0aGlzLnBvaW50ZXJ1cC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgcG9pbnRlcnVwLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmNhbmNlbFwiLCBwb2ludGVydXAsIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gIGRpc2FibGVDbGljaygpIHtcbiAgICB0aGlzLiNjbGlja0FDPy5hYm9ydCgpO1xuICAgIHRoaXMuI2NsaWNrQUMgPSBudWxsO1xuICB9XG4gIGF0dGFjaChlZGl0b3IpIHtcbiAgICB0aGlzLiNlZGl0b3JzLnNldChlZGl0b3IuaWQsIGVkaXRvcik7XG4gICAgY29uc3Qge1xuICAgICAgYW5ub3RhdGlvbkVsZW1lbnRJZFxuICAgIH0gPSBlZGl0b3I7XG4gICAgaWYgKGFubm90YXRpb25FbGVtZW50SWQgJiYgdGhpcy4jdWlNYW5hZ2VyLmlzRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGFubm90YXRpb25FbGVtZW50SWQpKSB7XG4gICAgICB0aGlzLiN1aU1hbmFnZXIucmVtb3ZlRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGVkaXRvcik7XG4gICAgfVxuICB9XG4gIGRldGFjaChlZGl0b3IpIHtcbiAgICB0aGlzLiNlZGl0b3JzLmRlbGV0ZShlZGl0b3IuaWQpO1xuICAgIHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyPy5yZW1vdmVQb2ludGVySW5UZXh0TGF5ZXIoZWRpdG9yLmNvbnRlbnREaXYpO1xuICAgIGlmICghdGhpcy4jaXNEaXNhYmxpbmcgJiYgZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIHRoaXMuI3VpTWFuYWdlci5hZGREZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoZWRpdG9yKTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlKGVkaXRvcikge1xuICAgIHRoaXMuZGV0YWNoKGVkaXRvcik7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnJlbW92ZUVkaXRvcihlZGl0b3IpO1xuICAgIGVkaXRvci5kaXYucmVtb3ZlKCk7XG4gICAgZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSA9IGZhbHNlO1xuICB9XG4gIGNoYW5nZVBhcmVudChlZGl0b3IpIHtcbiAgICBpZiAoZWRpdG9yLnBhcmVudCA9PT0gdGhpcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZWRpdG9yLnBhcmVudCAmJiBlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLmFkZERlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gICAgICBBbm5vdGF0aW9uRWRpdG9yLmRlbGV0ZUFubm90YXRpb25FbGVtZW50KGVkaXRvcik7XG4gICAgICBlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuYXR0YWNoKGVkaXRvcik7XG4gICAgZWRpdG9yLnBhcmVudD8uZGV0YWNoKGVkaXRvcik7XG4gICAgZWRpdG9yLnNldFBhcmVudCh0aGlzKTtcbiAgICBpZiAoZWRpdG9yLmRpdiAmJiBlZGl0b3IuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICBlZGl0b3IuZGl2LnJlbW92ZSgpO1xuICAgICAgdGhpcy5kaXYuYXBwZW5kKGVkaXRvci5kaXYpO1xuICAgIH1cbiAgfVxuICBhZGQoZWRpdG9yKSB7XG4gICAgaWYgKGVkaXRvci5wYXJlbnQgPT09IHRoaXMgJiYgZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNoYW5nZVBhcmVudChlZGl0b3IpO1xuICAgIHRoaXMuI3VpTWFuYWdlci5hZGRFZGl0b3IoZWRpdG9yKTtcbiAgICB0aGlzLmF0dGFjaChlZGl0b3IpO1xuICAgIGlmICghZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgY29uc3QgZGl2ID0gZWRpdG9yLnJlbmRlcigpO1xuICAgICAgdGhpcy5kaXYuYXBwZW5kKGRpdik7XG4gICAgICBlZGl0b3IuaXNBdHRhY2hlZFRvRE9NID0gdHJ1ZTtcbiAgICB9XG4gICAgZWRpdG9yLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gICAgZWRpdG9yLm9uY2VBZGRlZCghdGhpcy4jaXNFbmFibGluZyk7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLmFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoZWRpdG9yKTtcbiAgICBlZGl0b3IuX3JlcG9ydFRlbGVtZXRyeShlZGl0b3IudGVsZW1ldHJ5SW5pdGlhbERhdGEpO1xuICB9XG4gIG1vdmVFZGl0b3JJbkRPTShlZGl0b3IpIHtcbiAgICBpZiAoIWVkaXRvci5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYWN0aXZlRWxlbWVudFxuICAgIH0gPSBkb2N1bWVudDtcbiAgICBpZiAoZWRpdG9yLmRpdi5jb250YWlucyhhY3RpdmVFbGVtZW50KSAmJiAhdGhpcy4jZWRpdG9yRm9jdXNUaW1lb3V0SWQpIHtcbiAgICAgIGVkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gZmFsc2U7XG4gICAgICB0aGlzLiNlZGl0b3JGb2N1c1RpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLiNlZGl0b3JGb2N1c1RpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgIGlmICghZWRpdG9yLmRpdi5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgICAgIGVkaXRvci5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgKCkgPT4ge1xuICAgICAgICAgICAgZWRpdG9yLl9mb2N1c0V2ZW50c0FsbG93ZWQgPSB0cnVlO1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG9uY2U6IHRydWUsXG4gICAgICAgICAgICBzaWduYWw6IHRoaXMuI3VpTWFuYWdlci5fc2lnbmFsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSwgMCk7XG4gICAgfVxuICAgIGVkaXRvci5fc3RydWN0VHJlZVBhcmVudElkID0gdGhpcy4jYWNjZXNzaWJpbGl0eU1hbmFnZXI/Lm1vdmVFbGVtZW50SW5ET00odGhpcy5kaXYsIGVkaXRvci5kaXYsIGVkaXRvci5jb250ZW50RGl2LCB0cnVlKTtcbiAgfVxuICBhZGRPclJlYnVpbGQoZWRpdG9yKSB7XG4gICAgaWYgKGVkaXRvci5uZWVkc1RvQmVSZWJ1aWx0KCkpIHtcbiAgICAgIGVkaXRvci5wYXJlbnQgfHw9IHRoaXM7XG4gICAgICBlZGl0b3IucmVidWlsZCgpO1xuICAgICAgZWRpdG9yLnNob3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGQoZWRpdG9yKTtcbiAgICB9XG4gIH1cbiAgYWRkVW5kb2FibGVFZGl0b3IoZWRpdG9yKSB7XG4gICAgY29uc3QgY21kID0gKCkgPT4gZWRpdG9yLl91aU1hbmFnZXIucmVidWlsZChlZGl0b3IpO1xuICAgIGNvbnN0IHVuZG8gPSAoKSA9PiB7XG4gICAgICBlZGl0b3IucmVtb3ZlKCk7XG4gICAgfTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZCxcbiAgICAgIHVuZG8sXG4gICAgICBtdXN0RXhlYzogZmFsc2VcbiAgICB9KTtcbiAgfVxuICBnZXRFZGl0b3JCeVVJRCh1aWQpIHtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNlZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICBpZiAoZWRpdG9yLnVpZCA9PT0gdWlkKSB7XG4gICAgICAgIHJldHVybiBlZGl0b3I7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdldE5leHRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy4jdWlNYW5hZ2VyLmdldElkKCk7XG4gIH1cbiAgZ2V0ICNjdXJyZW50RWRpdG9yVHlwZSgpIHtcbiAgICByZXR1cm4gQW5ub3RhdGlvbkVkaXRvckxheWVyLiNlZGl0b3JUeXBlcy5nZXQodGhpcy4jdWlNYW5hZ2VyLmdldE1vZGUoKSk7XG4gIH1cbiAgY29tYmluZWRTaWduYWwoYWMpIHtcbiAgICByZXR1cm4gdGhpcy4jdWlNYW5hZ2VyLmNvbWJpbmVkU2lnbmFsKGFjKTtcbiAgfVxuICAjY3JlYXRlTmV3RWRpdG9yKHBhcmFtcykge1xuICAgIGNvbnN0IGVkaXRvclR5cGUgPSB0aGlzLiNjdXJyZW50RWRpdG9yVHlwZTtcbiAgICByZXR1cm4gZWRpdG9yVHlwZSA/IG5ldyBlZGl0b3JUeXBlLnByb3RvdHlwZS5jb25zdHJ1Y3RvcihwYXJhbXMpIDogbnVsbDtcbiAgfVxuICBjYW5DcmVhdGVOZXdFbXB0eUVkaXRvcigpIHtcbiAgICByZXR1cm4gdGhpcy4jY3VycmVudEVkaXRvclR5cGU/LmNhbkNyZWF0ZU5ld0VtcHR5RWRpdG9yKCk7XG4gIH1cbiAgYXN5bmMgcGFzdGVFZGl0b3Iob3B0aW9ucywgcGFyYW1zKSB7XG4gICAgdGhpcy51cGRhdGVUb29sYmFyKG9wdGlvbnMpO1xuICAgIGF3YWl0IHRoaXMuI3VpTWFuYWdlci51cGRhdGVNb2RlKG9wdGlvbnMubW9kZSk7XG4gICAgY29uc3Qge1xuICAgICAgb2Zmc2V0WCxcbiAgICAgIG9mZnNldFlcbiAgICB9ID0gdGhpcy4jZ2V0Q2VudGVyUG9pbnQoKTtcbiAgICBjb25zdCBpZCA9IHRoaXMuZ2V0TmV4dElkKCk7XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy4jY3JlYXRlTmV3RWRpdG9yKHtcbiAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgIGlkLFxuICAgICAgeDogb2Zmc2V0WCxcbiAgICAgIHk6IG9mZnNldFksXG4gICAgICB1aU1hbmFnZXI6IHRoaXMuI3VpTWFuYWdlcixcbiAgICAgIGlzQ2VudGVyZWQ6IHRydWUsXG4gICAgICAuLi5wYXJhbXNcbiAgICB9KTtcbiAgICBpZiAoZWRpdG9yKSB7XG4gICAgICB0aGlzLmFkZChlZGl0b3IpO1xuICAgIH1cbiAgfVxuICBhc3luYyBkZXNlcmlhbGl6ZShkYXRhKSB7XG4gICAgcmV0dXJuIGF3YWl0IEFubm90YXRpb25FZGl0b3JMYXllci4jZWRpdG9yVHlwZXMuZ2V0KGRhdGEuYW5ub3RhdGlvblR5cGUgPz8gZGF0YS5hbm5vdGF0aW9uRWRpdG9yVHlwZSk/LmRlc2VyaWFsaXplKGRhdGEsIHRoaXMsIHRoaXMuI3VpTWFuYWdlcikgfHwgbnVsbDtcbiAgfVxuICBjcmVhdGVBbmRBZGROZXdFZGl0b3IoZXZlbnQsIGlzQ2VudGVyZWQsIGRhdGEgPSB7fSkge1xuICAgIGNvbnN0IGlkID0gdGhpcy5nZXROZXh0SWQoKTtcbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLiNjcmVhdGVOZXdFZGl0b3Ioe1xuICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgaWQsXG4gICAgICB4OiBldmVudC5vZmZzZXRYLFxuICAgICAgeTogZXZlbnQub2Zmc2V0WSxcbiAgICAgIHVpTWFuYWdlcjogdGhpcy4jdWlNYW5hZ2VyLFxuICAgICAgaXNDZW50ZXJlZCxcbiAgICAgIC4uLmRhdGFcbiAgICB9KTtcbiAgICBpZiAoZWRpdG9yKSB7XG4gICAgICB0aGlzLmFkZChlZGl0b3IpO1xuICAgIH1cbiAgICByZXR1cm4gZWRpdG9yO1xuICB9XG4gIGdldCBib3VuZGluZ0NsaWVudFJlY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB9XG4gICNnZXRDZW50ZXJQb2ludCgpIHtcbiAgICBjb25zdCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXMuYm91bmRpbmdDbGllbnRSZWN0O1xuICAgIGNvbnN0IHRsWCA9IE1hdGgubWF4KDAsIHgpO1xuICAgIGNvbnN0IHRsWSA9IE1hdGgubWF4KDAsIHkpO1xuICAgIGNvbnN0IGJyWCA9IE1hdGgubWluKHdpbmRvdy5pbm5lcldpZHRoLCB4ICsgd2lkdGgpO1xuICAgIGNvbnN0IGJyWSA9IE1hdGgubWluKHdpbmRvdy5pbm5lckhlaWdodCwgeSArIGhlaWdodCk7XG4gICAgY29uc3QgY2VudGVyWCA9ICh0bFggKyBiclgpIC8gMiAtIHg7XG4gICAgY29uc3QgY2VudGVyWSA9ICh0bFkgKyBiclkpIC8gMiAtIHk7XG4gICAgY29uc3QgW29mZnNldFgsIG9mZnNldFldID0gdGhpcy52aWV3cG9ydC5yb3RhdGlvbiAlIDE4MCA9PT0gMCA/IFtjZW50ZXJYLCBjZW50ZXJZXSA6IFtjZW50ZXJZLCBjZW50ZXJYXTtcbiAgICByZXR1cm4ge1xuICAgICAgb2Zmc2V0WCxcbiAgICAgIG9mZnNldFlcbiAgICB9O1xuICB9XG4gIGFkZE5ld0VkaXRvcihkYXRhID0ge30pIHtcbiAgICB0aGlzLmNyZWF0ZUFuZEFkZE5ld0VkaXRvcih0aGlzLiNnZXRDZW50ZXJQb2ludCgpLCB0cnVlLCBkYXRhKTtcbiAgfVxuICBzZXRTZWxlY3RlZChlZGl0b3IpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIuc2V0U2VsZWN0ZWQoZWRpdG9yKTtcbiAgfVxuICB0b2dnbGVTZWxlY3RlZChlZGl0b3IpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIudG9nZ2xlU2VsZWN0ZWQoZWRpdG9yKTtcbiAgfVxuICB1bnNlbGVjdChlZGl0b3IpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIudW5zZWxlY3QoZWRpdG9yKTtcbiAgfVxuICBwb2ludGVydXAoZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBpc01hY1xuICAgIH0gPSB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgZXZlbnQuY3RybEtleSAmJiBpc01hYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSB0aGlzLmRpdikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2hhZFBvaW50ZXJEb3duKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2hhZFBvaW50ZXJEb3duID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuI2N1cnJlbnRFZGl0b3JUeXBlPy5pc0RyYXdlciAmJiB0aGlzLiNjdXJyZW50RWRpdG9yVHlwZS5zdXBwb3J0TXVsdGlwbGVEcmF3aW5ncykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2FsbG93Q2xpY2spIHtcbiAgICAgIHRoaXMuI2FsbG93Q2xpY2sgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50TW9kZSA9IHRoaXMuI3VpTWFuYWdlci5nZXRNb2RlKCk7XG4gICAgaWYgKGN1cnJlbnRNb2RlID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5TVEFNUCB8fCBjdXJyZW50TW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuU0lHTkFUVVJFKSB7XG4gICAgICB0aGlzLiN1aU1hbmFnZXIudW5zZWxlY3RBbGwoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jcmVhdGVBbmRBZGROZXdFZGl0b3IoZXZlbnQsIGZhbHNlKTtcbiAgfVxuICBwb2ludGVyZG93bihldmVudCkge1xuICAgIGlmICh0aGlzLiN1aU1hbmFnZXIuZ2V0TW9kZSgpID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQpIHtcbiAgICAgIHRoaXMuZW5hYmxlVGV4dFNlbGVjdGlvbigpO1xuICAgIH1cbiAgICBpZiAodGhpcy4jaGFkUG9pbnRlckRvd24pIHtcbiAgICAgIHRoaXMuI2hhZFBvaW50ZXJEb3duID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGlzTWFjXG4gICAgfSA9IHV0aWxfRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCB8fCBldmVudC5jdHJsS2V5ICYmIGlzTWFjKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChldmVudC50YXJnZXQgIT09IHRoaXMuZGl2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2hhZFBvaW50ZXJEb3duID0gdHJ1ZTtcbiAgICBpZiAodGhpcy4jY3VycmVudEVkaXRvclR5cGU/LmlzRHJhd2VyKSB7XG4gICAgICB0aGlzLnN0YXJ0RHJhd2luZ1Nlc3Npb24oZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLiN1aU1hbmFnZXIuZ2V0QWN0aXZlKCk7XG4gICAgdGhpcy4jYWxsb3dDbGljayA9ICFlZGl0b3IgfHwgZWRpdG9yLmlzRW1wdHkoKTtcbiAgfVxuICBzdGFydERyYXdpbmdTZXNzaW9uKGV2ZW50KSB7XG4gICAgdGhpcy5kaXYuZm9jdXMoe1xuICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgIH0pO1xuICAgIGlmICh0aGlzLiNkcmF3aW5nQUMpIHtcbiAgICAgIHRoaXMuI2N1cnJlbnRFZGl0b3JUeXBlLnN0YXJ0RHJhd2luZyh0aGlzLCB0aGlzLiN1aU1hbmFnZXIsIGZhbHNlLCBldmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3VpTWFuYWdlci5zZXRDdXJyZW50RHJhd2luZ1Nlc3Npb24odGhpcyk7XG4gICAgdGhpcy4jZHJhd2luZ0FDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI3VpTWFuYWdlci5jb21iaW5lZFNpZ25hbCh0aGlzLiNkcmF3aW5nQUMpO1xuICAgIHRoaXMuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsICh7XG4gICAgICByZWxhdGVkVGFyZ2V0XG4gICAgfSkgPT4ge1xuICAgICAgaWYgKHJlbGF0ZWRUYXJnZXQgJiYgIXRoaXMuZGl2LmNvbnRhaW5zKHJlbGF0ZWRUYXJnZXQpKSB7XG4gICAgICAgIHRoaXMuI2ZvY3VzZWRFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb21taXRPclJlbW92ZSgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuI2N1cnJlbnRFZGl0b3JUeXBlLnN0YXJ0RHJhd2luZyh0aGlzLCB0aGlzLiN1aU1hbmFnZXIsIGZhbHNlLCBldmVudCk7XG4gIH1cbiAgcGF1c2Uob24pIHtcbiAgICBpZiAob24pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWN0aXZlRWxlbWVudFxuICAgICAgfSA9IGRvY3VtZW50O1xuICAgICAgaWYgKHRoaXMuZGl2LmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgIHRoaXMuI2ZvY3VzZWRFbGVtZW50ID0gYWN0aXZlRWxlbWVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2ZvY3VzZWRFbGVtZW50KSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy4jZm9jdXNlZEVsZW1lbnQ/LmZvY3VzKCk7XG4gICAgICAgIHRoaXMuI2ZvY3VzZWRFbGVtZW50ID0gbnVsbDtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgfVxuICBlbmREcmF3aW5nU2Vzc2lvbihpc0Fib3J0ZWQgPSBmYWxzZSkge1xuICAgIGlmICghdGhpcy4jZHJhd2luZ0FDKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnNldEN1cnJlbnREcmF3aW5nU2Vzc2lvbihudWxsKTtcbiAgICB0aGlzLiNkcmF3aW5nQUMuYWJvcnQoKTtcbiAgICB0aGlzLiNkcmF3aW5nQUMgPSBudWxsO1xuICAgIHRoaXMuI2ZvY3VzZWRFbGVtZW50ID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcy4jY3VycmVudEVkaXRvclR5cGUuZW5kRHJhd2luZyhpc0Fib3J0ZWQpO1xuICB9XG4gIGZpbmROZXdQYXJlbnQoZWRpdG9yLCB4LCB5KSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLiN1aU1hbmFnZXIuZmluZFBhcmVudCh4LCB5KTtcbiAgICBpZiAobGF5ZXIgPT09IG51bGwgfHwgbGF5ZXIgPT09IHRoaXMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGF5ZXIuY2hhbmdlUGFyZW50KGVkaXRvcik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29tbWl0T3JSZW1vdmUoKSB7XG4gICAgaWYgKHRoaXMuI2RyYXdpbmdBQykge1xuICAgICAgdGhpcy5lbmREcmF3aW5nU2Vzc2lvbigpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBvblNjYWxlQ2hhbmdpbmcoKSB7XG4gICAgaWYgKCF0aGlzLiNkcmF3aW5nQUMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY3VycmVudEVkaXRvclR5cGUub25TY2FsZUNoYW5naW5nV2hlbkRyYXdpbmcodGhpcyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgaWYgKHRoaXMuI3VpTWFuYWdlci5nZXRBY3RpdmUoKT8ucGFyZW50ID09PSB0aGlzKSB7XG4gICAgICB0aGlzLiN1aU1hbmFnZXIuY29tbWl0T3JSZW1vdmUoKTtcbiAgICAgIHRoaXMuI3VpTWFuYWdlci5zZXRBY3RpdmVFZGl0b3IobnVsbCk7XG4gICAgfVxuICAgIGlmICh0aGlzLiNlZGl0b3JGb2N1c1RpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2VkaXRvckZvY3VzVGltZW91dElkKTtcbiAgICAgIHRoaXMuI2VkaXRvckZvY3VzVGltZW91dElkID0gbnVsbDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jZWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgdGhpcy4jYWNjZXNzaWJpbGl0eU1hbmFnZXI/LnJlbW92ZVBvaW50ZXJJblRleHRMYXllcihlZGl0b3IuY29udGVudERpdik7XG4gICAgICBlZGl0b3Iuc2V0UGFyZW50KG51bGwpO1xuICAgICAgZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSA9IGZhbHNlO1xuICAgICAgZWRpdG9yLmRpdi5yZW1vdmUoKTtcbiAgICB9XG4gICAgdGhpcy5kaXYgPSBudWxsO1xuICAgIHRoaXMuI2VkaXRvcnMuY2xlYXIoKTtcbiAgICB0aGlzLiN1aU1hbmFnZXIucmVtb3ZlTGF5ZXIodGhpcyk7XG4gIH1cbiAgI2NsZWFudXAoKSB7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jZWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGVkaXRvci5pc0VtcHR5KCkpIHtcbiAgICAgICAgZWRpdG9yLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZW5kZXIoe1xuICAgIHZpZXdwb3J0XG4gIH0pIHtcbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgc2V0TGF5ZXJEaW1lbnNpb25zKHRoaXMuZGl2LCB2aWV3cG9ydCk7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jdWlNYW5hZ2VyLmdldEVkaXRvcnModGhpcy5wYWdlSW5kZXgpKSB7XG4gICAgICB0aGlzLmFkZChlZGl0b3IpO1xuICAgICAgZWRpdG9yLnJlYnVpbGQoKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVNb2RlKCk7XG4gIH1cbiAgdXBkYXRlKHtcbiAgICB2aWV3cG9ydFxuICB9KSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgdGhpcy4jY2xlYW51cCgpO1xuICAgIGNvbnN0IG9sZFJvdGF0aW9uID0gdGhpcy52aWV3cG9ydC5yb3RhdGlvbjtcbiAgICBjb25zdCByb3RhdGlvbiA9IHZpZXdwb3J0LnJvdGF0aW9uO1xuICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICBzZXRMYXllckRpbWVuc2lvbnModGhpcy5kaXYsIHtcbiAgICAgIHJvdGF0aW9uXG4gICAgfSk7XG4gICAgaWYgKG9sZFJvdGF0aW9uICE9PSByb3RhdGlvbikge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jZWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgICBlZGl0b3Iucm90YXRlKHJvdGF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0IHBhZ2VEaW1lbnNpb25zKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2VXaWR0aCxcbiAgICAgIHBhZ2VIZWlnaHRcbiAgICB9ID0gdGhpcy52aWV3cG9ydC5yYXdEaW1zO1xuICAgIHJldHVybiBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XTtcbiAgfVxuICBnZXQgc2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3VpTWFuYWdlci52aWV3UGFyYW1ldGVycy5yZWFsU2NhbGU7XG4gIH1cbn1cbmNsYXNzIERyYXdMYXllciB7XG4gICNwYXJlbnQgPSBudWxsO1xuICAjbWFwcGluZyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICN0b1VwZGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHN0YXRpYyAjaWQgPSAwO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcGFnZUluZGV4XG4gIH0pIHtcbiAgICB0aGlzLnBhZ2VJbmRleCA9IHBhZ2VJbmRleDtcbiAgfVxuICBzZXRQYXJlbnQocGFyZW50KSB7XG4gICAgaWYgKCF0aGlzLiNwYXJlbnQpIHtcbiAgICAgIHRoaXMuI3BhcmVudCA9IHBhcmVudDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI3BhcmVudCAhPT0gcGFyZW50KSB7XG4gICAgICBpZiAodGhpcy4jbWFwcGluZy5zaXplID4gMCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJvb3Qgb2YgdGhpcy4jbWFwcGluZy52YWx1ZXMoKSkge1xuICAgICAgICAgIHJvb3QucmVtb3ZlKCk7XG4gICAgICAgICAgcGFyZW50LmFwcGVuZChyb290KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy4jcGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0IF9zdmdGYWN0b3J5KCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfc3ZnRmFjdG9yeVwiLCBuZXcgRE9NU1ZHRmFjdG9yeSgpKTtcbiAgfVxuICBzdGF0aWMgI3NldEJveChlbGVtZW50LCBbeCwgeSwgd2lkdGgsIGhlaWdodF0pIHtcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSBlbGVtZW50O1xuICAgIHN0eWxlLnRvcCA9IGAkezEwMCAqIHl9JWA7XG4gICAgc3R5bGUubGVmdCA9IGAkezEwMCAqIHh9JWA7XG4gICAgc3R5bGUud2lkdGggPSBgJHsxMDAgKiB3aWR0aH0lYDtcbiAgICBzdHlsZS5oZWlnaHQgPSBgJHsxMDAgKiBoZWlnaHR9JWA7XG4gIH1cbiAgI2NyZWF0ZVNWRygpIHtcbiAgICBjb25zdCBzdmcgPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlKDEsIDEsIHRydWUpO1xuICAgIHRoaXMuI3BhcmVudC5hcHBlbmQoc3ZnKTtcbiAgICBzdmcuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgdHJ1ZSk7XG4gICAgcmV0dXJuIHN2ZztcbiAgfVxuICAjY3JlYXRlQ2xpcFBhdGgoZGVmcywgcGF0aElkKSB7XG4gICAgY29uc3QgY2xpcFBhdGggPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcImNsaXBQYXRoXCIpO1xuICAgIGRlZnMuYXBwZW5kKGNsaXBQYXRoKTtcbiAgICBjb25zdCBjbGlwUGF0aElkID0gYGNsaXBfJHtwYXRoSWR9YDtcbiAgICBjbGlwUGF0aC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBjbGlwUGF0aElkKTtcbiAgICBjbGlwUGF0aC5zZXRBdHRyaWJ1dGUoXCJjbGlwUGF0aFVuaXRzXCIsIFwib2JqZWN0Qm91bmRpbmdCb3hcIik7XG4gICAgY29uc3QgY2xpcFBhdGhVc2UgPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInVzZVwiKTtcbiAgICBjbGlwUGF0aC5hcHBlbmQoY2xpcFBhdGhVc2UpO1xuICAgIGNsaXBQYXRoVXNlLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgYCMke3BhdGhJZH1gKTtcbiAgICBjbGlwUGF0aFVzZS5jbGFzc0xpc3QuYWRkKFwiY2xpcFwiKTtcbiAgICByZXR1cm4gY2xpcFBhdGhJZDtcbiAgfVxuICAjdXBkYXRlUHJvcGVydGllcyhlbGVtZW50LCBwcm9wZXJ0aWVzKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocHJvcGVydGllcykpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRyYXcocHJvcGVydGllcywgaXNQYXRoVXBkYXRhYmxlID0gZmFsc2UsIGhhc0NsaXAgPSBmYWxzZSkge1xuICAgIGNvbnN0IGlkID0gRHJhd0xheWVyLiNpZCsrO1xuICAgIGNvbnN0IHJvb3QgPSB0aGlzLiNjcmVhdGVTVkcoKTtcbiAgICBjb25zdCBkZWZzID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJkZWZzXCIpO1xuICAgIHJvb3QuYXBwZW5kKGRlZnMpO1xuICAgIGNvbnN0IHBhdGggPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInBhdGhcIik7XG4gICAgZGVmcy5hcHBlbmQocGF0aCk7XG4gICAgY29uc3QgcGF0aElkID0gYHBhdGhfcCR7dGhpcy5wYWdlSW5kZXh9XyR7aWR9YDtcbiAgICBwYXRoLnNldEF0dHJpYnV0ZShcImlkXCIsIHBhdGhJZCk7XG4gICAgcGF0aC5zZXRBdHRyaWJ1dGUoXCJ2ZWN0b3ItZWZmZWN0XCIsIFwibm9uLXNjYWxpbmctc3Ryb2tlXCIpO1xuICAgIGlmIChpc1BhdGhVcGRhdGFibGUpIHtcbiAgICAgIHRoaXMuI3RvVXBkYXRlLnNldChpZCwgcGF0aCk7XG4gICAgfVxuICAgIGNvbnN0IGNsaXBQYXRoSWQgPSBoYXNDbGlwID8gdGhpcy4jY3JlYXRlQ2xpcFBhdGgoZGVmcywgcGF0aElkKSA6IG51bGw7XG4gICAgY29uc3QgdXNlID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJ1c2VcIik7XG4gICAgcm9vdC5hcHBlbmQodXNlKTtcbiAgICB1c2Uuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBgIyR7cGF0aElkfWApO1xuICAgIHRoaXMudXBkYXRlUHJvcGVydGllcyhyb290LCBwcm9wZXJ0aWVzKTtcbiAgICB0aGlzLiNtYXBwaW5nLnNldChpZCwgcm9vdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkLFxuICAgICAgY2xpcFBhdGhJZDogYHVybCgjJHtjbGlwUGF0aElkfSlgXG4gICAgfTtcbiAgfVxuICBkcmF3T3V0bGluZShwcm9wZXJ0aWVzLCBtdXN0UmVtb3ZlU2VsZkludGVyc2VjdGlvbnMpIHtcbiAgICBjb25zdCBpZCA9IERyYXdMYXllci4jaWQrKztcbiAgICBjb25zdCByb290ID0gdGhpcy4jY3JlYXRlU1ZHKCk7XG4gICAgY29uc3QgZGVmcyA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwiZGVmc1wiKTtcbiAgICByb290LmFwcGVuZChkZWZzKTtcbiAgICBjb25zdCBwYXRoID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIpO1xuICAgIGRlZnMuYXBwZW5kKHBhdGgpO1xuICAgIGNvbnN0IHBhdGhJZCA9IGBwYXRoX3Ake3RoaXMucGFnZUluZGV4fV8ke2lkfWA7XG4gICAgcGF0aC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBwYXRoSWQpO1xuICAgIHBhdGguc2V0QXR0cmlidXRlKFwidmVjdG9yLWVmZmVjdFwiLCBcIm5vbi1zY2FsaW5nLXN0cm9rZVwiKTtcbiAgICBsZXQgbWFza0lkO1xuICAgIGlmIChtdXN0UmVtb3ZlU2VsZkludGVyc2VjdGlvbnMpIHtcbiAgICAgIGNvbnN0IG1hc2sgPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcIm1hc2tcIik7XG4gICAgICBkZWZzLmFwcGVuZChtYXNrKTtcbiAgICAgIG1hc2tJZCA9IGBtYXNrX3Ake3RoaXMucGFnZUluZGV4fV8ke2lkfWA7XG4gICAgICBtYXNrLnNldEF0dHJpYnV0ZShcImlkXCIsIG1hc2tJZCk7XG4gICAgICBtYXNrLnNldEF0dHJpYnV0ZShcIm1hc2tVbml0c1wiLCBcIm9iamVjdEJvdW5kaW5nQm94XCIpO1xuICAgICAgY29uc3QgcmVjdCA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwicmVjdFwiKTtcbiAgICAgIG1hc2suYXBwZW5kKHJlY3QpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjFcIik7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBcIjFcIik7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ3aGl0ZVwiKTtcbiAgICAgIGNvbnN0IHVzZSA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwidXNlXCIpO1xuICAgICAgbWFzay5hcHBlbmQodXNlKTtcbiAgICAgIHVzZS5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIGAjJHtwYXRoSWR9YCk7XG4gICAgICB1c2Uuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwibm9uZVwiKTtcbiAgICAgIHVzZS5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwiYmxhY2tcIik7XG4gICAgICB1c2Uuc2V0QXR0cmlidXRlKFwiZmlsbC1ydWxlXCIsIFwibm9uemVyb1wiKTtcbiAgICAgIHVzZS5jbGFzc0xpc3QuYWRkKFwibWFza1wiKTtcbiAgICB9XG4gICAgY29uc3QgdXNlMSA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwidXNlXCIpO1xuICAgIHJvb3QuYXBwZW5kKHVzZTEpO1xuICAgIHVzZTEuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBgIyR7cGF0aElkfWApO1xuICAgIGlmIChtYXNrSWQpIHtcbiAgICAgIHVzZTEuc2V0QXR0cmlidXRlKFwibWFza1wiLCBgdXJsKCMke21hc2tJZH0pYCk7XG4gICAgfVxuICAgIGNvbnN0IHVzZTIgPSB1c2UxLmNsb25lTm9kZSgpO1xuICAgIHJvb3QuYXBwZW5kKHVzZTIpO1xuICAgIHVzZTEuY2xhc3NMaXN0LmFkZChcIm1haW5PdXRsaW5lXCIpO1xuICAgIHVzZTIuY2xhc3NMaXN0LmFkZChcInNlY29uZGFyeU91dGxpbmVcIik7XG4gICAgdGhpcy51cGRhdGVQcm9wZXJ0aWVzKHJvb3QsIHByb3BlcnRpZXMpO1xuICAgIHRoaXMuI21hcHBpbmcuc2V0KGlkLCByb290KTtcbiAgICByZXR1cm4gaWQ7XG4gIH1cbiAgZmluYWxpemVEcmF3KGlkLCBwcm9wZXJ0aWVzKSB7XG4gICAgdGhpcy4jdG9VcGRhdGUuZGVsZXRlKGlkKTtcbiAgICB0aGlzLnVwZGF0ZVByb3BlcnRpZXMoaWQsIHByb3BlcnRpZXMpO1xuICB9XG4gIHVwZGF0ZVByb3BlcnRpZXMoZWxlbWVudE9ySWQsIHByb3BlcnRpZXMpIHtcbiAgICBpZiAoIXByb3BlcnRpZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcm9vdCxcbiAgICAgIGJib3gsXG4gICAgICByb290Q2xhc3MsXG4gICAgICBwYXRoXG4gICAgfSA9IHByb3BlcnRpZXM7XG4gICAgY29uc3QgZWxlbWVudCA9IHR5cGVvZiBlbGVtZW50T3JJZCA9PT0gXCJudW1iZXJcIiA/IHRoaXMuI21hcHBpbmcuZ2V0KGVsZW1lbnRPcklkKSA6IGVsZW1lbnRPcklkO1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocm9vdCkge1xuICAgICAgdGhpcy4jdXBkYXRlUHJvcGVydGllcyhlbGVtZW50LCByb290KTtcbiAgICB9XG4gICAgaWYgKGJib3gpIHtcbiAgICAgIERyYXdMYXllci4jc2V0Qm94KGVsZW1lbnQsIGJib3gpO1xuICAgIH1cbiAgICBpZiAocm9vdENsYXNzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNsYXNzTGlzdFxuICAgICAgfSA9IGVsZW1lbnQ7XG4gICAgICBmb3IgKGNvbnN0IFtjbGFzc05hbWUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhyb290Q2xhc3MpKSB7XG4gICAgICAgIGNsYXNzTGlzdC50b2dnbGUoY2xhc3NOYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXRoKSB7XG4gICAgICBjb25zdCBkZWZzID0gZWxlbWVudC5maXJzdENoaWxkO1xuICAgICAgY29uc3QgcGF0aEVsZW1lbnQgPSBkZWZzLmZpcnN0Q2hpbGQ7XG4gICAgICB0aGlzLiN1cGRhdGVQcm9wZXJ0aWVzKHBhdGhFbGVtZW50LCBwYXRoKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlUGFyZW50KGlkLCBsYXllcikge1xuICAgIGlmIChsYXllciA9PT0gdGhpcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByb290ID0gdGhpcy4jbWFwcGluZy5nZXQoaWQpO1xuICAgIGlmICghcm9vdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsYXllci4jcGFyZW50LmFwcGVuZChyb290KTtcbiAgICB0aGlzLiNtYXBwaW5nLmRlbGV0ZShpZCk7XG4gICAgbGF5ZXIuI21hcHBpbmcuc2V0KGlkLCByb290KTtcbiAgfVxuICByZW1vdmUoaWQpIHtcbiAgICB0aGlzLiN0b1VwZGF0ZS5kZWxldGUoaWQpO1xuICAgIGlmICh0aGlzLiNwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jbWFwcGluZy5nZXQoaWQpLnJlbW92ZSgpO1xuICAgIHRoaXMuI21hcHBpbmcuZGVsZXRlKGlkKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI3BhcmVudCA9IG51bGw7XG4gICAgZm9yIChjb25zdCByb290IG9mIHRoaXMuI21hcHBpbmcudmFsdWVzKCkpIHtcbiAgICAgIHJvb3QucmVtb3ZlKCk7XG4gICAgfVxuICAgIHRoaXMuI21hcHBpbmcuY2xlYXIoKTtcbiAgICB0aGlzLiN0b1VwZGF0ZS5jbGVhcigpO1xuICB9XG59XG57XG4gIGdsb2JhbFRoaXMuX3BkZmpzVGVzdGluZ1V0aWxzID0ge1xuICAgIEhpZ2hsaWdodE91dGxpbmVyXG4gIH07XG59XG5nbG9iYWxUaGlzLnBkZmpzTGliID0ge1xuICBBYm9ydEV4Y2VwdGlvbixcbiAgQW5ub3RhdGlvbkVkaXRvckxheWVyLFxuICBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZSxcbiAgQW5ub3RhdGlvbkVkaXRvclR5cGUsXG4gIEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIsXG4gIEFubm90YXRpb25MYXllcixcbiAgQW5ub3RhdGlvbk1vZGUsXG4gIEFubm90YXRpb25UeXBlLFxuICBhcHBseU9wYWNpdHksXG4gIGJ1aWxkLFxuICBDb2xvclBpY2tlcixcbiAgY3JlYXRlVmFsaWRBYnNvbHV0ZVVybCxcbiAgQ1NTQ29uc3RhbnRzLFxuICBET01TVkdGYWN0b3J5LFxuICBEcmF3TGF5ZXIsXG4gIEZlYXR1cmVUZXN0OiB1dGlsX0ZlYXR1cmVUZXN0LFxuICBmZXRjaERhdGEsXG4gIGZpbmRDb250cmFzdENvbG9yLFxuICBnZXREb2N1bWVudCxcbiAgZ2V0RmlsZW5hbWVGcm9tVXJsLFxuICBnZXRQZGZGaWxlbmFtZUZyb21VcmwsXG4gIGdldFJHQixcbiAgZ2V0VXVpZCxcbiAgZ2V0WGZhUGFnZVZpZXdwb3J0LFxuICBHbG9iYWxXb3JrZXJPcHRpb25zLFxuICBJbWFnZUtpbmQ6IHV0aWxfSW1hZ2VLaW5kLFxuICBJbnZhbGlkUERGRXhjZXB0aW9uLFxuICBpc0RhdGFTY2hlbWUsXG4gIGlzUGRmRmlsZSxcbiAgaXNWYWxpZEV4cGxpY2l0RGVzdCxcbiAgTWF0aENsYW1wLFxuICBub0NvbnRleHRNZW51LFxuICBub3JtYWxpemVVbmljb2RlLFxuICBPUFMsXG4gIE91dHB1dFNjYWxlLFxuICBQYXNzd29yZFJlc3BvbnNlcyxcbiAgUERGRGF0YVJhbmdlVHJhbnNwb3J0LFxuICBQREZEYXRlU3RyaW5nLFxuICBQREZXb3JrZXIsXG4gIFBlcm1pc3Npb25GbGFnLFxuICBQaXhlbHNQZXJJbmNoLFxuICBSZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24sXG4gIHJlbmRlclJpY2hUZXh0LFxuICBSZXNwb25zZUV4Y2VwdGlvbixcbiAgc2V0TGF5ZXJEaW1lbnNpb25zLFxuICBzaGFkb3csXG4gIFNpZ25hdHVyZUV4dHJhY3RvcixcbiAgc3RvcEV2ZW50LFxuICBTdXBwb3J0ZWRJbWFnZU1pbWVUeXBlcyxcbiAgVGV4dExheWVyLFxuICBUb3VjaE1hbmFnZXIsXG4gIHVwZGF0ZVVybEhhc2gsXG4gIFV0aWwsXG4gIFZlcmJvc2l0eUxldmVsLFxuICB2ZXJzaW9uLFxuICBYZmFMYXllclxufTtcbmNvbnN0IHBkZmpzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgQWJvcnRFeGNlcHRpb24sXG4gIEFubm90YXRpb25FZGl0b3JMYXllcixcbiAgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUsXG4gIEFubm90YXRpb25FZGl0b3JUeXBlLFxuICBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLFxuICBBbm5vdGF0aW9uTGF5ZXIsXG4gIEFubm90YXRpb25Nb2RlLFxuICBBbm5vdGF0aW9uVHlwZSxcbiAgQ1NTQ29uc3RhbnRzLFxuICBDb2xvclBpY2tlcixcbiAgRE9NU1ZHRmFjdG9yeSxcbiAgRHJhd0xheWVyLFxuICBGZWF0dXJlVGVzdDogdXRpbF9GZWF0dXJlVGVzdCxcbiAgR2xvYmFsV29ya2VyT3B0aW9ucyxcbiAgSW1hZ2VLaW5kOiB1dGlsX0ltYWdlS2luZCxcbiAgSW52YWxpZFBERkV4Y2VwdGlvbixcbiAgTWF0aENsYW1wLFxuICBPUFMsXG4gIE91dHB1dFNjYWxlLFxuICBQREZEYXRhUmFuZ2VUcmFuc3BvcnQsXG4gIFBERkRhdGVTdHJpbmcsXG4gIFBERldvcmtlcixcbiAgUGFzc3dvcmRSZXNwb25zZXMsXG4gIFBlcm1pc3Npb25GbGFnLFxuICBQaXhlbHNQZXJJbmNoLFxuICBSZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24sXG4gIFJlc3BvbnNlRXhjZXB0aW9uLFxuICBTaWduYXR1cmVFeHRyYWN0b3IsXG4gIFN1cHBvcnRlZEltYWdlTWltZVR5cGVzLFxuICBUZXh0TGF5ZXIsXG4gIFRvdWNoTWFuYWdlcixcbiAgVXRpbCxcbiAgVmVyYm9zaXR5TGV2ZWwsXG4gIFhmYUxheWVyLFxuICBhcHBseU9wYWNpdHksXG4gIGJ1aWxkLFxuICBjcmVhdGVWYWxpZEFic29sdXRlVXJsLFxuICBmZXRjaERhdGEsXG4gIGZpbmRDb250cmFzdENvbG9yLFxuICBnZXREb2N1bWVudCxcbiAgZ2V0RmlsZW5hbWVGcm9tVXJsLFxuICBnZXRQZGZGaWxlbmFtZUZyb21VcmwsXG4gIGdldFJHQixcbiAgZ2V0VXVpZCxcbiAgZ2V0WGZhUGFnZVZpZXdwb3J0LFxuICBpc0RhdGFTY2hlbWUsXG4gIGlzUGRmRmlsZSxcbiAgaXNWYWxpZEV4cGxpY2l0RGVzdCxcbiAgbm9Db250ZXh0TWVudSxcbiAgbm9ybWFsaXplVW5pY29kZSxcbiAgcmVuZGVyUmljaFRleHQsXG4gIHNldExheWVyRGltZW5zaW9ucyxcbiAgc2hhZG93LFxuICBzdG9wRXZlbnQsXG4gIHVwZGF0ZVVybEhhc2gsXG4gIHZlcnNpb25cbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSk7XG5jbGFzcyBTaGFwZSB7XG4gIHN0YXRpYyB0b2xlcmFuY2UgPSAyO1xuICBzdGF0aWMgYXBwbHlUcmFuc2Zvcm0ocCwgbSkge1xuICAgIGNvbnN0IHh0ID0gcFswXSAqIG1bMF0gKyBwWzFdICogbVsyXSArIG1bNF07XG4gICAgY29uc3QgeXQgPSBwWzBdICogbVsxXSArIHBbMV0gKiBtWzNdICsgbVs1XTtcbiAgICByZXR1cm4gW3h0LCB5dF07XG4gIH1cbn1cbmNsYXNzIFBvaW50IGV4dGVuZHMgU2hhcGUge1xuICB4O1xuICB5O1xuICBjb25zdHJ1Y3Rvcih4LCB5KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH1cbiAgZXF1YWwocG9pbnQpIHtcbiAgICByZXR1cm4gcG9pbnQueCA9PT0gdGhpcy54ICYmIHBvaW50LnkgPT09IHRoaXMueTtcbiAgfVxuICB0cmFuc2Zvcm0obWF0cml4KSB7XG4gICAgY29uc3QgcCA9IFNoYXBlLmFwcGx5VHJhbnNmb3JtKFt0aGlzLngsIHRoaXMueV0sIG1hdHJpeCk7XG4gICAgdGhpcy54ID0gcFswXTtcbiAgICB0aGlzLnkgPSBwWzFdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG52YXIgTGluZURpcmVjdGlvbiA9IC8qIEBfX1BVUkVfXyAqLyAoKExpbmVEaXJlY3Rpb24yKSA9PiB7XG4gIExpbmVEaXJlY3Rpb24yW0xpbmVEaXJlY3Rpb24yW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XG4gIExpbmVEaXJlY3Rpb24yW0xpbmVEaXJlY3Rpb24yW1wiSG9yaXpvbnRhbFwiXSA9IDFdID0gXCJIb3Jpem9udGFsXCI7XG4gIExpbmVEaXJlY3Rpb24yW0xpbmVEaXJlY3Rpb24yW1wiVmVydGljYWxcIl0gPSAyXSA9IFwiVmVydGljYWxcIjtcbiAgcmV0dXJuIExpbmVEaXJlY3Rpb24yO1xufSkoTGluZURpcmVjdGlvbiB8fCB7fSk7XG5jbGFzcyBMaW5lIGV4dGVuZHMgU2hhcGUge1xuICBmcm9tO1xuICB0bztcbiAgZGlyZWN0aW9uID0gMDtcbiAgbGVuZ3RoID0gMDtcbiAgaW50ZXJzZWN0aW9ucyA9IFtdO1xuICBnYXBzID0gW107XG4gIGNvbnN0cnVjdG9yKGZyb20sIHRvKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgIHRoaXMudG8gPSB0bztcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuICBpbml0KCkge1xuICAgIGxldCBmcm9tID0gdGhpcy5mcm9tO1xuICAgIGxldCB0byA9IHRoaXMudG87XG4gICAgaWYgKE1hdGguYWJzKGZyb20ueSAtIHRvLnkpIDwgU2hhcGUudG9sZXJhbmNlKSB7XG4gICAgICB0aGlzLmRpcmVjdGlvbiA9IDE7XG4gICAgICB0by55ID0gZnJvbS55O1xuICAgICAgaWYgKGZyb20ueCA+IHRvLngpIHtcbiAgICAgICAgY29uc3QgdGVtcCA9IGZyb207XG4gICAgICAgIGZyb20gPSB0bztcbiAgICAgICAgdG8gPSB0ZW1wO1xuICAgICAgfVxuICAgICAgdGhpcy5sZW5ndGggPSB0by54IC0gZnJvbS54O1xuICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoZnJvbS54IC0gdG8ueCkgPCBTaGFwZS50b2xlcmFuY2UpIHtcbiAgICAgIHRoaXMuZGlyZWN0aW9uID0gMjtcbiAgICAgIHRvLnggPSBmcm9tLng7XG4gICAgICBpZiAoZnJvbS55ID4gdG8ueSkge1xuICAgICAgICBjb25zdCB0ZW1wID0gZnJvbTtcbiAgICAgICAgZnJvbSA9IHRvO1xuICAgICAgICB0byA9IHRlbXA7XG4gICAgICB9XG4gICAgICB0aGlzLmxlbmd0aCA9IHRvLnkgLSBmcm9tLnk7XG4gICAgfVxuICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgdGhpcy50byA9IHRvO1xuICB9XG4gIF92YWxpZCA9IHZvaWQgMDtcbiAgZ2V0IHZhbGlkKCkge1xuICAgIGlmICh0aGlzLl92YWxpZCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLl92YWxpZCA9IHRoaXMuZGlyZWN0aW9uICE9PSAwICYmIHRoaXMubGVuZ3RoID4gU2hhcGUudG9sZXJhbmNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdmFsaWQ7XG4gIH1cbiAgZ2V0IG5vcm1hbGl6ZWQoKSB7XG4gICAgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAxKSB7XG4gICAgICByZXR1cm4gbmV3IExpbmUoXG4gICAgICAgIG5ldyBQb2ludCh0aGlzLmZyb20ueCAtIFNoYXBlLnRvbGVyYW5jZSwgdGhpcy5mcm9tLnkpLFxuICAgICAgICBuZXcgUG9pbnQodGhpcy50by54ICsgU2hhcGUudG9sZXJhbmNlLCB0aGlzLmZyb20ueSlcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gMikge1xuICAgICAgcmV0dXJuIG5ldyBMaW5lKFxuICAgICAgICBuZXcgUG9pbnQodGhpcy5mcm9tLngsIHRoaXMuZnJvbS55IC0gU2hhcGUudG9sZXJhbmNlKSxcbiAgICAgICAgbmV3IFBvaW50KHRoaXMuZnJvbS54LCB0aGlzLnRvLnkgKyBTaGFwZS50b2xlcmFuY2UpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhZGRHYXAobGluZSkge1xuICAgIHRoaXMuZ2Fwcy5wdXNoKGxpbmUpO1xuICB9XG4gIGNvbnRhaW5zUG9pbnQocCkge1xuICAgIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gMikge1xuICAgICAgcmV0dXJuIHRoaXMuZnJvbS54ID09PSBwLnggJiYgcC55ID49IHRoaXMuZnJvbS55ICYmIHAueSA8PSB0aGlzLnRvLnk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRoaXMuZnJvbS55ID09PSBwLnkgJiYgcC54ID49IHRoaXMuZnJvbS54ICYmIHAueCA8PSB0aGlzLnRvLng7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyAvLyB0b2RvIGltcGxlbWVudFxuICAvLyBwdWJsaWMgY29udGFpbnNMaW5lKGw6TGluZSk6Ym9vbGVhbntcbiAgLy8gICAgIGlmKHRoaXMuZGlyZWN0aW9uID09PSBMaW5lRGlyZWN0aW9uLlZlcnRpY2FsICYmIGwuZGlyZWN0aW9uID09PSBMaW5lRGlyZWN0aW9uLlZlcnRpY2FsKXtcbiAgLy8gICAgICAgICByZXR1cm4gdGhpcy5mcm9tLnggPT09IGwuZnJvbS54XG4gIC8vICAgICB9XG4gIC8vICAgICBlbHNlIGlmKHRoaXMuZGlyZWN0aW9uID09PSBMaW5lRGlyZWN0aW9uLkhvcml6b250YWwgJiYgbC5kaXJlY3Rpb24gPT09IExpbmVEaXJlY3Rpb24uSG9yaXpvbnRhbCl7XG4gIC8vICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbS55ID09PSBsLmZyb20ueVxuICAvLyAgICAgfVxuICAvLyAgICAgcmV0dXJuIGZhbHNlXG4gIC8vIH1cbiAgYWRkSW50ZXJzZWN0aW9uUG9pbnQocG9pbnQpIHtcbiAgICBmb3IgKGNvbnN0IGludFBvaW50IG9mIHRoaXMuaW50ZXJzZWN0aW9ucykge1xuICAgICAgaWYgKGludFBvaW50LmVxdWFsKHBvaW50KSkgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmludGVyc2VjdGlvbnMucHVzaChwb2ludCk7XG4gIH1cbiAgaW50ZXJzZWN0aW9uKGxpbmUpIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmICghdGhpcy52YWxpZCB8fCAhbGluZS52YWxpZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgdGhpc05vcm1hbGl6ZWQgPSB0aGlzLm5vcm1hbGl6ZWQ7XG4gICAgY29uc3QgbGluZU5vcm1hbGl6ZWQgPSBsaW5lLm5vcm1hbGl6ZWQ7XG4gICAgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAxICYmIGxpbmUuZGlyZWN0aW9uID09PSAyKSB7XG4gICAgICBjb25zdCB4ID0gbGluZU5vcm1hbGl6ZWQuZnJvbS54O1xuICAgICAgY29uc3QgeSA9IHRoaXNOb3JtYWxpemVkLmZyb20ueTtcbiAgICAgIGNvbnN0IGlzT2sgPSB4ID4gdGhpc05vcm1hbGl6ZWQuZnJvbS54ICYmIHggPCB0aGlzTm9ybWFsaXplZC50by54ICYmIHkgPiBsaW5lTm9ybWFsaXplZC5mcm9tLnkgJiYgeSA8IGxpbmVOb3JtYWxpemVkLnRvLnk7XG4gICAgICBpZiAoaXNPaykge1xuICAgICAgICBjb25zdCBpbnRQb2ludCA9IG5ldyBQb2ludCh4LCB5KTtcbiAgICAgICAgdGhpcy5hZGRJbnRlcnNlY3Rpb25Qb2ludChpbnRQb2ludCk7XG4gICAgICAgIGxpbmUuYWRkSW50ZXJzZWN0aW9uUG9pbnQoaW50UG9pbnQpO1xuICAgICAgICByZXN1bHQgPSBpbnRQb2ludDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAyICYmIGxpbmUuZGlyZWN0aW9uID09PSAxKSB7XG4gICAgICBjb25zdCB4ID0gdGhpc05vcm1hbGl6ZWQuZnJvbS54O1xuICAgICAgY29uc3QgeSA9IGxpbmVOb3JtYWxpemVkLmZyb20ueTtcbiAgICAgIGNvbnN0IGlzT2sgPSB4ID4gbGluZU5vcm1hbGl6ZWQuZnJvbS54ICYmIHggPCBsaW5lTm9ybWFsaXplZC50by54ICYmIHkgPiB0aGlzTm9ybWFsaXplZC5mcm9tLnkgJiYgeSA8IHRoaXNOb3JtYWxpemVkLnRvLnk7XG4gICAgICBpZiAoaXNPaykge1xuICAgICAgICBjb25zdCBpbnRQb2ludCA9IG5ldyBQb2ludCh4LCB5KTtcbiAgICAgICAgdGhpcy5hZGRJbnRlcnNlY3Rpb25Qb2ludChpbnRQb2ludCk7XG4gICAgICAgIGxpbmUuYWRkSW50ZXJzZWN0aW9uUG9pbnQoaW50UG9pbnQpO1xuICAgICAgICByZXN1bHQgPSBpbnRQb2ludDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB0cmFuc2Zvcm0obWF0cml4KSB7XG4gICAgY29uc3QgcDEgPSB0aGlzLmZyb20udHJhbnNmb3JtKG1hdHJpeCk7XG4gICAgY29uc3QgcDIgPSB0aGlzLnRvLnRyYW5zZm9ybShtYXRyaXgpO1xuICAgIGNvbnN0IHggPSBNYXRoLm1pbihwMS54LCBwMi54KTtcbiAgICBjb25zdCB5ID0gTWF0aC5taW4ocDEueSwgcDIueSk7XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLmFicyhwMS54IC0gcDIueCk7XG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5hYnMocDEueSAtIHAyLnkpO1xuICAgIHRoaXMuZnJvbSA9IG5ldyBQb2ludCh4LCB5KTtcbiAgICB0aGlzLnRvID0gbmV3IFBvaW50KHggKyB3aWR0aCwgeSArIGhlaWdodCk7XG4gICAgdGhpcy5pbml0KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbmNsYXNzIFRhYmxlRGF0YSB7XG4gIG1pblhZO1xuICBtYXhYWTtcbiAgcm93cztcbiAgcm93UGl2b3RzO1xuICBjb2xQaXZvdHM7XG4gIGNvbnN0cnVjdG9yKG1pblhZLCBtYXhYWSwgcm93UGl2b3RzLCBjb2xQaXZvdHMpIHtcbiAgICB0aGlzLm1pblhZID0gbWluWFk7XG4gICAgdGhpcy5tYXhYWSA9IG1heFhZO1xuICAgIHRoaXMucm93cyA9IFtdO1xuICAgIHRoaXMucm93UGl2b3RzID0gcm93UGl2b3RzO1xuICAgIHRoaXMuY29sUGl2b3RzID0gY29sUGl2b3RzO1xuICB9XG4gIGZpbmRDZWxsKHgsIHkpIHtcbiAgICBpZiAoeCA+PSB0aGlzLm1pblhZLnggJiYgeSA+PSB0aGlzLm1pblhZLnkgJiYgeCA8PSB0aGlzLm1heFhZLnggJiYgeSA8PSB0aGlzLm1heFhZLnkpIHtcbiAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRoaXMucm93cykge1xuICAgICAgICBmb3IgKGNvbnN0IGNlbGwgb2Ygcm93KSB7XG4gICAgICAgICAgaWYgKGNlbGwubWluWFkueCA8PSB4ICYmIGNlbGwubWluWFkueSA8PSB5ICYmIGNlbGwubWF4WFkueCA+PSB4ICYmIGNlbGwubWF4WFkueSA+PSB5KSB7XG4gICAgICAgICAgICByZXR1cm4gY2VsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBnZXQgY2VsbENvdW50KCkge1xuICAgIHJldHVybiB0aGlzLnJvd3MucmVkdWNlKChhY2MsIHJvdykgPT4gYWNjICsgcm93Lmxlbmd0aCwgMCk7XG4gIH1cbiAgZ2V0IHJvd0NvdW50KCkge1xuICAgIHJldHVybiB0aGlzLnJvd3MubGVuZ3RoO1xuICB9XG4gIGNoZWNrKCkge1xuICAgIGNvbnN0IHZpcnR1YWxDZWxsQ291bnQgPSAodGhpcy5jb2xQaXZvdHMubGVuZ3RoIC0gMSkgKiAodGhpcy5yb3dQaXZvdHMubGVuZ3RoIC0gMSk7XG4gICAgbGV0IGFsbENlbGxDb3VudCA9IDA7XG4gICAgZm9yIChjb25zdCByb3cgb2YgdGhpcy5yb3dzKSB7XG4gICAgICBmb3IgKGNvbnN0IGNlbGwgb2Ygcm93KSB7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gKGNlbGwuY29sc3BhbiB8fCAxKSAqIChjZWxsLnJvd3NwYW4gfHwgMSk7XG4gICAgICAgIGFsbENlbGxDb3VudCArPSBjb3VudDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZpcnR1YWxDZWxsQ291bnQgIT09IGFsbENlbGxDb3VudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIGNvbnN0IHRhYmxlQXJyID0gW107XG4gICAgZm9yIChjb25zdCByb3cgb2YgdGhpcy5yb3dzKSB7XG4gICAgICBjb25zdCByb3dBcnIgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgY2VsbCBvZiByb3cpIHtcbiAgICAgICAgbGV0IHRleHQgPSBjZWxsLnRleHQuam9pbihcIlwiKTtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXltcXHNdK3xbXFxzXSskL2csIFwiXCIpO1xuICAgICAgICB0ZXh0ID0gdGV4dC50cmltKCk7XG4gICAgICAgIHJvd0Fyci5wdXNoKHRleHQpO1xuICAgICAgfVxuICAgICAgdGFibGVBcnIucHVzaChyb3dBcnIpO1xuICAgIH1cbiAgICByZXR1cm4gdGFibGVBcnI7XG4gIH1cbn1cbmNsYXNzIFRhYmxlIHtcbiAgaExpbmVzID0gW107XG4gIHZMaW5lcyA9IFtdO1xuICBjb25zdHJ1Y3RvcihsaW5lKSB7XG4gICAgaWYgKGxpbmUuZGlyZWN0aW9uID09PSBMaW5lRGlyZWN0aW9uLkhvcml6b250YWwpIHtcbiAgICAgIHRoaXMuaExpbmVzLnB1c2gobGluZSk7XG4gICAgfSBlbHNlIGlmIChsaW5lLmRpcmVjdGlvbiA9PT0gTGluZURpcmVjdGlvbi5WZXJ0aWNhbCkge1xuICAgICAgdGhpcy52TGluZXMucHVzaChsaW5lKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaExpbmVzLmxlbmd0aCArIHRoaXMudkxpbmVzLmxlbmd0aCA+IDQ7XG4gIH1cbiAgZ2V0IHJvd1Bpdm90cygpIHtcbiAgICBjb25zdCByb3dTZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgbGluZSBvZiB0aGlzLmhMaW5lcykge1xuICAgICAgcm93U2V0LmFkZChsaW5lLmZyb20ueSk7XG4gICAgfVxuICAgIHJldHVybiBbLi4ucm93U2V0XS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gIH1cbiAgZ2V0IGNvbFBpdm90cygpIHtcbiAgICBjb25zdCBjb2xTZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgbGluZSBvZiB0aGlzLnZMaW5lcykge1xuICAgICAgY29sU2V0LmFkZChsaW5lLmZyb20ueCk7XG4gICAgfVxuICAgIHJldHVybiBbLi4uY29sU2V0XS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gIH1cbiAgYWRkKGxpbmUpIHtcbiAgICBjb25zdCBoYXNJbnRlcnNlY3Rpb24gPSB0aGlzLmludGVyc2VjdGlvbihsaW5lKTtcbiAgICBpZiAoaGFzSW50ZXJzZWN0aW9uKSB7XG4gICAgICBpZiAobGluZS5kaXJlY3Rpb24gPT09IExpbmVEaXJlY3Rpb24uSG9yaXpvbnRhbCkge1xuICAgICAgICB0aGlzLmhMaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAobGluZS5kaXJlY3Rpb24gPT09IExpbmVEaXJlY3Rpb24uVmVydGljYWwpIHtcbiAgICAgICAgdGhpcy52TGluZXMucHVzaChsaW5lKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpbnRlcnNlY3Rpb24obGluZSkge1xuICAgIGxldCBmbGFnID0gZmFsc2U7XG4gICAgaWYgKCFsaW5lLnZhbGlkKSByZXR1cm4gZmxhZztcbiAgICBpZiAobGluZS5kaXJlY3Rpb24gPT09IExpbmVEaXJlY3Rpb24uSG9yaXpvbnRhbCkge1xuICAgICAgZm9yIChjb25zdCB2TGluZSBvZiB0aGlzLnZMaW5lcykge1xuICAgICAgICBjb25zdCBwID0gbGluZS5pbnRlcnNlY3Rpb24odkxpbmUpO1xuICAgICAgICBpZiAocCkge1xuICAgICAgICAgIGZsYWcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsaW5lLmRpcmVjdGlvbiA9PT0gTGluZURpcmVjdGlvbi5WZXJ0aWNhbCkge1xuICAgICAgZm9yIChjb25zdCBoTGluZSBvZiB0aGlzLmhMaW5lcykge1xuICAgICAgICBjb25zdCBwID0gbGluZS5pbnRlcnNlY3Rpb24oaExpbmUpO1xuICAgICAgICBpZiAocCkge1xuICAgICAgICAgIGZsYWcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmbGFnO1xuICB9XG4gIGdldFNhbWVIb3Jpem9udGFsKGxpbmUpIHtcbiAgICBjb25zdCBzYW1lID0gW2xpbmVdO1xuICAgIGNvbnN0IG90aGVyID0gW107XG4gICAgd2hpbGUgKHRoaXMuaExpbmVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGhMaW5lID0gdGhpcy5oTGluZXMuc2hpZnQoKTtcbiAgICAgIGlmICghaExpbmUpIGNvbnRpbnVlO1xuICAgICAgaWYgKGhMaW5lLmZyb20ueSA9PT0gbGluZS5mcm9tLnkpIHtcbiAgICAgICAgc2FtZS5wdXNoKGhMaW5lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG90aGVyLnB1c2goaExpbmUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmhMaW5lcyA9IG90aGVyO1xuICAgIHJldHVybiBzYW1lO1xuICB9XG4gIGdldFNhbWVWZXJ0aWNhbChsaW5lKSB7XG4gICAgY29uc3Qgc2FtZSA9IFtsaW5lXTtcbiAgICBjb25zdCBvdGhlciA9IFtdO1xuICAgIHdoaWxlICh0aGlzLnZMaW5lcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCB2TGluZSA9IHRoaXMudkxpbmVzLnNoaWZ0KCk7XG4gICAgICBpZiAoIXZMaW5lKSBjb250aW51ZTtcbiAgICAgIGlmICh2TGluZS5mcm9tLnggPT09IGxpbmUuZnJvbS54KSB7XG4gICAgICAgIHNhbWUucHVzaCh2TGluZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdGhlci5wdXNoKHZMaW5lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy52TGluZXMgPSBvdGhlcjtcbiAgICByZXR1cm4gc2FtZTtcbiAgfVxuICBtZXJnZUhvcml6b250YWxMaW5lcyhsaW5lcykge1xuICAgIGxpbmVzLnNvcnQoKGwxLCBsMikgPT4gbDEuZnJvbS54IC0gbDIuZnJvbS54KTtcbiAgICBjb25zdCBtaW5YID0gbGluZXNbMF0uZnJvbS54O1xuICAgIGNvbnN0IG1heFggPSBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXS50by54O1xuICAgIGNvbnN0IHJlc3VsdExpbmUgPSBuZXcgTGluZShuZXcgUG9pbnQobWluWCwgbGluZXNbMF0uZnJvbS55KSwgbmV3IFBvaW50KG1heFgsIGxpbmVzWzBdLmZyb20ueSkpO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHByZXZMaW5lID0gbGluZXNbaSAtIDFdO1xuICAgICAgY29uc3QgY3VyckxpbmUgPSBsaW5lc1tpXTtcbiAgICAgIGlmIChNYXRoLmFicyhwcmV2TGluZS50by54IC0gY3VyckxpbmUuZnJvbS54KSA+IFNoYXBlLnRvbGVyYW5jZSkge1xuICAgICAgICBjb25zdCBnYXBMaW5lID0gbmV3IExpbmUoXG4gICAgICAgICAgbmV3IFBvaW50KHByZXZMaW5lLnRvLngsIHByZXZMaW5lLmZyb20ueSksXG4gICAgICAgICAgbmV3IFBvaW50KGN1cnJMaW5lLmZyb20ueCwgY3VyckxpbmUuZnJvbS55KVxuICAgICAgICApO1xuICAgICAgICByZXN1bHRMaW5lLmFkZEdhcChnYXBMaW5lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdExpbmU7XG4gIH1cbiAgbWVyZ2VWZXJ0aWNhbExpbmVzKGxpbmVzKSB7XG4gICAgbGluZXMuc29ydCgobDEsIGwyKSA9PiBsMS5mcm9tLnkgLSBsMi5mcm9tLnkpO1xuICAgIGNvbnN0IG1pblkgPSBsaW5lc1swXS5mcm9tLnk7XG4gICAgY29uc3QgbWF4WSA9IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLnRvLnk7XG4gICAgY29uc3QgcmVzdWx0TGluZSA9IG5ldyBMaW5lKG5ldyBQb2ludChsaW5lc1swXS5mcm9tLngsIG1pblkpLCBuZXcgUG9pbnQobGluZXNbMF0uZnJvbS54LCBtYXhZKSk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcHJldkxpbmUgPSBsaW5lc1tpIC0gMV07XG4gICAgICBjb25zdCBjdXJyTGluZSA9IGxpbmVzW2ldO1xuICAgICAgaWYgKE1hdGguYWJzKHByZXZMaW5lLnRvLnkgLSBjdXJyTGluZS5mcm9tLnkpID4gU2hhcGUudG9sZXJhbmNlKSB7XG4gICAgICAgIGNvbnN0IGdhcExpbmUgPSBuZXcgTGluZShuZXcgUG9pbnQocHJldkxpbmUudG8ueCwgcHJldkxpbmUudG8ueSksIG5ldyBQb2ludChwcmV2TGluZS50by54LCBjdXJyTGluZS5mcm9tLnkpKTtcbiAgICAgICAgcmVzdWx0TGluZS5hZGRHYXAoZ2FwTGluZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRMaW5lO1xuICB9XG4gIG5vcm1hbGl6ZSgpIHtcbiAgICB0aGlzLmhMaW5lcyA9IHRoaXMuaExpbmVzLmZpbHRlcigobCkgPT4gbC5pbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDEpO1xuICAgIHRoaXMudkxpbmVzID0gdGhpcy52TGluZXMuZmlsdGVyKChsKSA9PiBsLmludGVyc2VjdGlvbnMubGVuZ3RoID4gMSk7XG4gICAgdGhpcy5oTGluZXMuc29ydCgobDEsIGwyKSA9PiBsMS5mcm9tLnkgLSBsMi5mcm9tLnkpO1xuICAgIHRoaXMudkxpbmVzLnNvcnQoKGwxLCBsMikgPT4gbDEuZnJvbS54IC0gbDIuZnJvbS54KTtcbiAgICBjb25zdCBuZXdITGluZXMgPSBbXTtcbiAgICB3aGlsZSAodGhpcy5oTGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgbGluZSA9IHRoaXMuaExpbmVzLnNoaWZ0KCk7XG4gICAgICBpZiAoIWxpbmUpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgbGluZXMgPSB0aGlzLmdldFNhbWVIb3Jpem9udGFsKGxpbmUpO1xuICAgICAgY29uc3QgbWVyZ2VkID0gdGhpcy5tZXJnZUhvcml6b250YWxMaW5lcyhsaW5lcyk7XG4gICAgICBuZXdITGluZXMucHVzaChtZXJnZWQpO1xuICAgIH1cbiAgICB0aGlzLmhMaW5lcyA9IG5ld0hMaW5lcztcbiAgICBjb25zdCBuZXdWTGluZXMgPSBbXTtcbiAgICB3aGlsZSAodGhpcy52TGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgbGluZSA9IHRoaXMudkxpbmVzLnNoaWZ0KCk7XG4gICAgICBpZiAoIWxpbmUpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgbGluZXMgPSB0aGlzLmdldFNhbWVWZXJ0aWNhbChsaW5lKTtcbiAgICAgIGNvbnN0IG1lcmdlZCA9IHRoaXMubWVyZ2VWZXJ0aWNhbExpbmVzKGxpbmVzKTtcbiAgICAgIG5ld1ZMaW5lcy5wdXNoKG1lcmdlZCk7XG4gICAgfVxuICAgIHRoaXMudkxpbmVzID0gbmV3VkxpbmVzO1xuICB9XG4gIHZlcnRpY2FsRXhpc3RzKGxpbmUsIHkxLCB5Mikge1xuICAgIGlmIChsaW5lLmRpcmVjdGlvbiAhPT0gTGluZURpcmVjdGlvbi5WZXJ0aWNhbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGluZSBpcyBub3QgdmVydGljYWxcIik7XG4gICAgfVxuICAgIGlmICh5MSA+PSB5Mikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwieTEgbXVzdCBiZSBsZXNzIHRoYW4geTJcIik7XG4gICAgfVxuICAgIGlmIChsaW5lLmZyb20ueSA8PSB5MSAmJiBsaW5lLnRvLnkgPj0geTIpIHtcbiAgICAgIGZvciAoY29uc3QgZ2FwIG9mIGxpbmUuZ2Fwcykge1xuICAgICAgICBpZiAoZ2FwLmZyb20ueSA8PSB5MSAmJiBnYXAudG8ueSA+PSB5Mikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBob3Jpem9udGFsRXhpc3RzKGxpbmUsIHgxLCB4Mikge1xuICAgIGlmIChsaW5lLmRpcmVjdGlvbiAhPT0gTGluZURpcmVjdGlvbi5Ib3Jpem9udGFsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMaW5lIGlzIG5vdCBob3Jpem9udGFsXCIpO1xuICAgIH1cbiAgICBpZiAoeDEgPj0geDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIngxIG11c3QgYmUgbGVzcyB0aGFuIHgyXCIpO1xuICAgIH1cbiAgICBpZiAobGluZS5mcm9tLnggPD0geDEgJiYgbGluZS50by54ID49IHgyKSB7XG4gICAgICBmb3IgKGNvbnN0IGdhcCBvZiBsaW5lLmdhcHMpIHtcbiAgICAgICAgaWYgKGdhcC5mcm9tLnggPD0geDEgJiYgZ2FwLnRvLnggPj0geDIpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZmluZEJvdHRvbUxpbmVJbmRleChoMkluZGV4LCB4TWlkZGxlKSB7XG4gICAgZm9yIChsZXQgaSA9IGgySW5kZXg7IGkgPCB0aGlzLmhMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaExpbmUgPSB0aGlzLmhMaW5lc1tpXTtcbiAgICAgIGlmIChoTGluZS5mcm9tLnggPD0geE1pZGRsZSAmJiBoTGluZS50by54ID49IHhNaWRkbGUpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICBmaW5kVmVydGljYWxMaW5lSW5kZXhzKHRvcEhMaW5lLCB5TWlkZGxlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdkxpbmUgPSB0aGlzLnZMaW5lc1tpXTtcbiAgICAgIGlmICh2TGluZS5mcm9tLnkgPD0geU1pZGRsZSAmJiB2TGluZS50by55ID49IHlNaWRkbGUgJiYgdG9wSExpbmUuaW50ZXJzZWN0aW9uKHZMaW5lKSkge1xuICAgICAgICByZXN1bHQucHVzaChpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBnZXRSb3coaDFJbmRleCwgaDJJbmRleCwgeU1pZGRsZSkge1xuICAgIGNvbnN0IHRhYmxlUm93ID0gW107XG4gICAgY29uc3QgdG9wSExpbmUgPSB0aGlzLmhMaW5lc1toMUluZGV4XTtcbiAgICBjb25zdCB2TGluZUluZGV4ZXMgPSB0aGlzLmZpbmRWZXJ0aWNhbExpbmVJbmRleHModG9wSExpbmUsIHlNaWRkbGUpO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdkxpbmVJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBsZWZ0VkxpbmUgPSB0aGlzLnZMaW5lc1t2TGluZUluZGV4ZXNbaSAtIDFdXTtcbiAgICAgIGNvbnN0IHJpZ2h0VkxpbmUgPSB0aGlzLnZMaW5lc1t2TGluZUluZGV4ZXNbaV1dO1xuICAgICAgY29uc3QgeE1pZGRsZSA9IChsZWZ0VkxpbmUuZnJvbS54ICsgcmlnaHRWTGluZS5mcm9tLngpIC8gMjtcbiAgICAgIGNvbnN0IGJvdHRvbUhMaW5lSW5kZXggPSB0aGlzLmZpbmRCb3R0b21MaW5lSW5kZXgoaDJJbmRleCwgeE1pZGRsZSk7XG4gICAgICBjb25zdCBib3R0b21ITGluZSA9IHRoaXMuaExpbmVzW2JvdHRvbUhMaW5lSW5kZXhdO1xuICAgICAgY29uc3QgdGFibGVDZWxsID0ge1xuICAgICAgICBtaW5YWTogbmV3IFBvaW50KGxlZnRWTGluZS5mcm9tLngsIHRvcEhMaW5lLmZyb20ueSksXG4gICAgICAgIG1heFhZOiBuZXcgUG9pbnQocmlnaHRWTGluZS5mcm9tLngsIGJvdHRvbUhMaW5lLmZyb20ueSksXG4gICAgICAgIHdpZHRoOiByaWdodFZMaW5lLmZyb20ueCAtIGxlZnRWTGluZS5mcm9tLngsXG4gICAgICAgIGhlaWdodDogYm90dG9tSExpbmUuZnJvbS55IC0gdG9wSExpbmUuZnJvbS55LFxuICAgICAgICB0ZXh0OiBbXVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNvbFNwYW4gPSB2TGluZUluZGV4ZXNbaV0gLSB2TGluZUluZGV4ZXNbaSAtIDFdO1xuICAgICAgY29uc3Qgcm93U3BhbiA9IGJvdHRvbUhMaW5lSW5kZXggLSBoMUluZGV4O1xuICAgICAgaWYgKGNvbFNwYW4gPiAxKSB7XG4gICAgICAgIHRhYmxlQ2VsbC5jb2xzcGFuID0gY29sU3BhbjtcbiAgICAgIH1cbiAgICAgIGlmIChyb3dTcGFuID4gMSkge1xuICAgICAgICB0YWJsZUNlbGwucm93c3BhbiA9IHJvd1NwYW47XG4gICAgICB9XG4gICAgICB0YWJsZVJvdy5wdXNoKHRhYmxlQ2VsbCk7XG4gICAgfVxuICAgIHJldHVybiB0YWJsZVJvdztcbiAgfVxuICB0b0RhdGEoKSB7XG4gICAgY29uc3Qgcm93UGl2b3RzID0gdGhpcy5yb3dQaXZvdHM7XG4gICAgY29uc3QgY29sUGl2b3RzID0gdGhpcy5jb2xQaXZvdHM7XG4gICAgY29uc3QgbWluWFkgPSBuZXcgUG9pbnQoY29sUGl2b3RzWzBdLCByb3dQaXZvdHNbMF0pO1xuICAgIGNvbnN0IG1heFhZID0gbmV3IFBvaW50KGNvbFBpdm90c1tjb2xQaXZvdHMubGVuZ3RoIC0gMV0sIHJvd1Bpdm90c1tyb3dQaXZvdHMubGVuZ3RoIC0gMV0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBUYWJsZURhdGEobWluWFksIG1heFhZLCByb3dQaXZvdHMsIGNvbFBpdm90cyk7XG4gICAgZm9yIChsZXQgaDEgPSAxOyBoMSA8IHRoaXMuaExpbmVzLmxlbmd0aDsgaDErKykge1xuICAgICAgY29uc3QgcHJldkhMaW5lID0gdGhpcy5oTGluZXNbaDEgLSAxXTtcbiAgICAgIGNvbnN0IGN1cnJITGluZSA9IHRoaXMuaExpbmVzW2gxXTtcbiAgICAgIGNvbnN0IFlNaWRkbGUgPSAocHJldkhMaW5lLmZyb20ueSArIGN1cnJITGluZS5mcm9tLnkpIC8gMjtcbiAgICAgIGNvbnN0IHJvd0RhdGEgPSB0aGlzLmdldFJvdyhoMSAtIDEsIGgxLCBZTWlkZGxlKTtcbiAgICAgIHJlc3VsdC5yb3dzLnB1c2gocm93RGF0YSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbmNsYXNzIExpbmVTdG9yZSB7XG4gIGhMaW5lcyA9IFtdO1xuICB2TGluZXMgPSBbXTtcbiAgYWRkKGxpbmUpIHtcbiAgICBpZiAobGluZS52YWxpZCkge1xuICAgICAgaWYgKGxpbmUuZGlyZWN0aW9uID09PSBMaW5lRGlyZWN0aW9uLkhvcml6b250YWwpIHtcbiAgICAgICAgdGhpcy5oTGluZXMucHVzaChsaW5lKTtcbiAgICAgIH0gZWxzZSBpZiAobGluZS5kaXJlY3Rpb24gPT09IExpbmVEaXJlY3Rpb24uVmVydGljYWwpIHtcbiAgICAgICAgdGhpcy52TGluZXMucHVzaChsaW5lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYWRkUmVjdGFuZ2xlKHJlY3QpIHtcbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgcmVjdC5nZXRMaW5lcygpKSB7XG4gICAgICB0aGlzLmFkZChsaW5lKTtcbiAgICB9XG4gIH1cbiAgZ2V0VGFibGVEYXRhKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IHRhYmxlcyA9IHRoaXMuZ2V0VGFibGVzKCk7XG4gICAgZm9yIChjb25zdCB0YWJsZSBvZiB0YWJsZXMpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSB0YWJsZS50b0RhdGEoKTtcbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGRhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGdldFRhYmxlcygpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICB3aGlsZSAodGhpcy5oTGluZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICBjb25zdCBoTGluZSA9IHRoaXMuaExpbmVzLnNoaWZ0KCk7XG4gICAgICBpZiAoIWhMaW5lKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IGZpbGxlZCA9IHRoaXMudHJ5RmlsbChyZXN1bHQsIGhMaW5lKTtcbiAgICAgIGlmIChmaWxsZWQpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgdGFibGUgPSBuZXcgVGFibGUoaExpbmUpO1xuICAgICAgdGhpcy5maWxsVGFibGUodGFibGUpO1xuICAgICAgcmVzdWx0LnB1c2godGFibGUpO1xuICAgIH1cbiAgICB3aGlsZSAodGhpcy52TGluZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICBjb25zdCB2TGluZSA9IHRoaXMudkxpbmVzLnNoaWZ0KCk7XG4gICAgICBpZiAoIXZMaW5lKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IGZpbGxlZCA9IHRoaXMudHJ5RmlsbChyZXN1bHQsIHZMaW5lKTtcbiAgICAgIGlmIChmaWxsZWQpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgdGFibGUgPSBuZXcgVGFibGUodkxpbmUpO1xuICAgICAgdGhpcy5maWxsVGFibGUodGFibGUpO1xuICAgICAgcmVzdWx0LnB1c2godGFibGUpO1xuICAgIH1cbiAgICBjb25zdCB2YWxpZFRhYmxlcyA9IHJlc3VsdC5maWx0ZXIoKHQpID0+IHQuaXNWYWxpZCk7XG4gICAgZm9yIChjb25zdCB0YWJsZSBvZiB2YWxpZFRhYmxlcykge1xuICAgICAgdGFibGUubm9ybWFsaXplKCk7XG4gICAgfVxuICAgIHJldHVybiB2YWxpZFRhYmxlcztcbiAgfVxuICBub3JtYWxpemUoKSB7XG4gICAgdGhpcy5ub3JtYWxpemVIb3Jpem9udGFsKCk7XG4gICAgdGhpcy5ub3JtYWxpemVWZXJ0aWNhbCgpO1xuICB9XG4gIG5vcm1hbGl6ZUhvcml6b250YWwoKSB7XG4gICAgdGhpcy5oTGluZXMuc29ydCgobDEsIGwyKSA9PiBsMS5mcm9tLnkgLSBsMi5mcm9tLnkpO1xuICAgIGNvbnN0IG5ld0xpbmVzID0gW107XG4gICAgbGV0IHNhbWVZID0gW107XG4gICAgZm9yIChjb25zdCBsaW5lIG9mIHRoaXMuaExpbmVzKSB7XG4gICAgICBpZiAoc2FtZVkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHNhbWVZLnB1c2gobGluZSk7XG4gICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKHNhbWVZWzBdPy5mcm9tLnkgLSBsaW5lLmZyb20ueSkgPCBTaGFwZS50b2xlcmFuY2UpIHtcbiAgICAgICAgc2FtZVkucHVzaChsaW5lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG1lcmdlZCA9IHRoaXMubWFyZ2VIb3Jpem9udGFsTGluZXMoc2FtZVkpO1xuICAgICAgICBuZXdMaW5lcy5wdXNoKC4uLm1lcmdlZCk7XG4gICAgICAgIHNhbWVZID0gW2xpbmVdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2FtZVkubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgbWVyZ2VkID0gdGhpcy5tYXJnZUhvcml6b250YWxMaW5lcyhzYW1lWSk7XG4gICAgICBuZXdMaW5lcy5wdXNoKC4uLm1lcmdlZCk7XG4gICAgfVxuICAgIHRoaXMuaExpbmVzID0gbmV3TGluZXM7XG4gIH1cbiAgbm9ybWFsaXplVmVydGljYWwoKSB7XG4gICAgdGhpcy52TGluZXMuc29ydCgobDEsIGwyKSA9PiBsMS5mcm9tLnggLSBsMi5mcm9tLngpO1xuICAgIGNvbnN0IG5ld0xpbmVzID0gW107XG4gICAgbGV0IHNhbWVYID0gW107XG4gICAgZm9yIChjb25zdCBsaW5lIG9mIHRoaXMudkxpbmVzKSB7XG4gICAgICBpZiAoc2FtZVgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHNhbWVYLnB1c2gobGluZSk7XG4gICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKHNhbWVYWzBdPy5mcm9tLnggLSBsaW5lLmZyb20ueCkgPCBTaGFwZS50b2xlcmFuY2UpIHtcbiAgICAgICAgc2FtZVgucHVzaChsaW5lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG1lcmdlZCA9IHRoaXMubWFyZ2VWZXJ0aWNhbExpbmVzKHNhbWVYKTtcbiAgICAgICAgbmV3TGluZXMucHVzaCguLi5tZXJnZWQpO1xuICAgICAgICBzYW1lWCA9IFtsaW5lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNhbWVYLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IG1lcmdlZCA9IHRoaXMubWFyZ2VWZXJ0aWNhbExpbmVzKHNhbWVYKTtcbiAgICAgIG5ld0xpbmVzLnB1c2goLi4ubWVyZ2VkKTtcbiAgICB9XG4gICAgdGhpcy52TGluZXMgPSBuZXdMaW5lcztcbiAgfVxuICBmaWxsVGFibGUodGFibGUpIHtcbiAgICBjb25zdCBuZXdWTGluZXMgPSBbXTtcbiAgICBjb25zdCBuZXdITGluZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHZMaW5lIG9mIHRoaXMudkxpbmVzKSB7XG4gICAgICBpZiAoIXRhYmxlLmFkZCh2TGluZSkpIHtcbiAgICAgICAgbmV3VkxpbmVzLnB1c2godkxpbmUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGhMaW5lIG9mIHRoaXMuaExpbmVzKSB7XG4gICAgICBpZiAoIXRhYmxlLmFkZChoTGluZSkpIHtcbiAgICAgICAgbmV3SExpbmVzLnB1c2goaExpbmUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmhMaW5lcyA9IG5ld0hMaW5lcztcbiAgICB0aGlzLnZMaW5lcyA9IG5ld1ZMaW5lcztcbiAgfVxuICB0cnlGaWxsKHRhYmxlcywgbGluZSkge1xuICAgIGZvciAoY29uc3QgdGFibGUgb2YgdGFibGVzKSB7XG4gICAgICBpZiAodGFibGUuYWRkKGxpbmUpKSB7XG4gICAgICAgIHRoaXMuZmlsbFRhYmxlKHRhYmxlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBtYXJnZUhvcml6b250YWxMaW5lcyhzYW1lWUxpbmVzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgc2FtZVlMaW5lcy5zb3J0KChsMSwgbDIpID0+IGwxLmZyb20ueCAtIGwyLmZyb20ueCk7XG4gICAgY29uc3Qgc2FtZVkgPSBzYW1lWUxpbmVzWzBdPy5mcm9tLnk7XG4gICAgaWYgKHNhbWVZID09PSB2b2lkIDApIHJldHVybiByZXN1bHQ7XG4gICAgbGV0IG1pblggPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICBsZXQgbWF4WCA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICAgIGZvciAoY29uc3QgbGluZSBvZiBzYW1lWUxpbmVzKSB7XG4gICAgICBpZiAobGluZS5mcm9tLnggLSBtYXhYIDwgU2hhcGUudG9sZXJhbmNlKSB7XG4gICAgICAgIGlmIChsaW5lLmZyb20ueCA8IG1pblgpIHtcbiAgICAgICAgICBtaW5YID0gbGluZS5mcm9tLng7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmUudG8ueCA+IG1heFgpIHtcbiAgICAgICAgICBtYXhYID0gbGluZS50by54O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobWF4WCA+IG1pblgpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChuZXcgTGluZShuZXcgUG9pbnQobWluWCwgc2FtZVkpLCBuZXcgUG9pbnQobWF4WCwgc2FtZVkpKSk7XG4gICAgICAgIH1cbiAgICAgICAgbWluWCA9IGxpbmUuZnJvbS54O1xuICAgICAgICBtYXhYID0gbGluZS50by54O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsYXN0ID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgaWYgKGxhc3QuZnJvbS54ICE9PSBtaW5YICYmIGxhc3QudG8ueCAhPT0gbWF4WCkge1xuICAgICAgICByZXN1bHQucHVzaChuZXcgTGluZShuZXcgUG9pbnQobWluWCwgc2FtZVkpLCBuZXcgUG9pbnQobWF4WCwgc2FtZVkpKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wdXNoKG5ldyBMaW5lKG5ldyBQb2ludChtaW5YLCBzYW1lWSksIG5ldyBQb2ludChtYXhYLCBzYW1lWSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBtYXJnZVZlcnRpY2FsTGluZXMoc2FtZVhMaW5lcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHNhbWVYTGluZXMuc29ydCgobDEsIGwyKSA9PiBsMS5mcm9tLnkgLSBsMi5mcm9tLnkpO1xuICAgIGNvbnN0IHNhbWVYID0gc2FtZVhMaW5lc1swXT8uZnJvbS54O1xuICAgIGlmIChzYW1lWCA9PT0gdm9pZCAwKSByZXR1cm4gcmVzdWx0O1xuICAgIGxldCBtaW5ZID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgbGV0IG1heFkgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjtcbiAgICBmb3IgKGNvbnN0IGxpbmUgb2Ygc2FtZVhMaW5lcykge1xuICAgICAgaWYgKGxpbmUuZnJvbS55IC0gbWF4WSA8IFNoYXBlLnRvbGVyYW5jZSkge1xuICAgICAgICBpZiAobGluZS5mcm9tLnkgPCBtaW5ZKSB7XG4gICAgICAgICAgbWluWSA9IGxpbmUuZnJvbS55O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5lLnRvLnkgPiBtYXhZKSB7XG4gICAgICAgICAgbWF4WSA9IGxpbmUudG8ueTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG1heFkgPiBtaW5ZKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2gobmV3IExpbmUobmV3IFBvaW50KHNhbWVYLCBtaW5ZKSwgbmV3IFBvaW50KHNhbWVYLCBtYXhZKSkpO1xuICAgICAgICB9XG4gICAgICAgIG1pblkgPSBsaW5lLmZyb20ueTtcbiAgICAgICAgbWF4WSA9IGxpbmUudG8ueTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbGFzdCA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGlmIChsYXN0LmZyb20ueSAhPT0gbWluWSAmJiBsYXN0LnRvLnkgIT09IG1heFkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobmV3IExpbmUobmV3IFBvaW50KHNhbWVYLCBtaW5ZKSwgbmV3IFBvaW50KHNhbWVYLCBtYXhZKSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucHVzaChuZXcgTGluZShuZXcgUG9pbnQoc2FtZVgsIG1pblkpLCBuZXcgUG9pbnQoc2FtZVgsIG1heFkpKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbmNsYXNzIFJlY3RhbmdsZSBleHRlbmRzIFNoYXBlIHtcbiAgZnJvbTtcbiAgd2lkdGg7XG4gIGhlaWdodDtcbiAgY29uc3RydWN0b3IoZnJvbSwgd2lkdGgsIGhlaWdodCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cbiAgZ2V0IHRvKCkge1xuICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy5mcm9tLnggKyB0aGlzLndpZHRoLCB0aGlzLmZyb20ueSArIHRoaXMuaGVpZ2h0KTtcbiAgfVxuICBnZXRMaW5lcygpIHtcbiAgICBjb25zdCB0byA9IHRoaXMudG87XG4gICAgY29uc3QgbGluZXMgPSBbXG4gICAgICBuZXcgTGluZSh0aGlzLmZyb20sIG5ldyBQb2ludCh0by54LCB0aGlzLmZyb20ueSkpLFxuICAgICAgbmV3IExpbmUodGhpcy5mcm9tLCBuZXcgUG9pbnQodGhpcy5mcm9tLngsIHRvLnkpKSxcbiAgICAgIG5ldyBMaW5lKG5ldyBQb2ludCh0by54LCB0aGlzLmZyb20ueSksIHRvKSxcbiAgICAgIG5ldyBMaW5lKG5ldyBQb2ludCh0aGlzLmZyb20ueCwgdG8ueSksIHRvKVxuICAgIF07XG4gICAgcmV0dXJuIGxpbmVzLmZpbHRlcigobCkgPT4gbC52YWxpZCk7XG4gIH1cbiAgdHJhbnNmb3JtKG1hdHJpeCkge1xuICAgIGNvbnN0IHAxID0gU2hhcGUuYXBwbHlUcmFuc2Zvcm0oW3RoaXMuZnJvbS54LCB0aGlzLmZyb20ueV0sIG1hdHJpeCk7XG4gICAgY29uc3QgcDIgPSBTaGFwZS5hcHBseVRyYW5zZm9ybShbdGhpcy5mcm9tLnggKyB0aGlzLndpZHRoLCB0aGlzLmZyb20ueSArIHRoaXMuaGVpZ2h0XSwgbWF0cml4KTtcbiAgICBjb25zdCB4ID0gTWF0aC5taW4ocDFbMF0sIHAyWzBdKTtcbiAgICBjb25zdCB5ID0gTWF0aC5taW4ocDFbMV0sIHAyWzFdKTtcbiAgICBjb25zdCB3aWR0aCA9IE1hdGguYWJzKHAxWzBdIC0gcDJbMF0pO1xuICAgIGNvbnN0IGhlaWdodCA9IE1hdGguYWJzKHAxWzFdIC0gcDJbMV0pO1xuICAgIHRoaXMuZnJvbSA9IG5ldyBQb2ludCh4LCB5KTtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEhlYWRlcih1cmwsIGNoZWNrID0gZmFsc2UpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBmZXRjaDIgPSBnbG9iYWxUaGlzLmZldGNoO1xuICAgIGlmICh0eXBlb2YgZmV0Y2gyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNvbnN0IGhlYWRSZXNwID0gYXdhaXQgZmV0Y2gyKHVybCwgeyBtZXRob2Q6IFwiSEVBRFwiIH0pO1xuICAgICAgY29uc3QgaGVhZGVyc09iaiA9IHt9O1xuICAgICAgaGVhZFJlc3AuaGVhZGVycy5mb3JFYWNoKCh2LCBrKSA9PiB7XG4gICAgICAgIGhlYWRlcnNPYmpba10gPSB2O1xuICAgICAgfSk7XG4gICAgICBjb25zdCBzaXplID0gaGVhZFJlc3AuaGVhZGVycy5nZXQoXCJjb250ZW50LWxlbmd0aFwiKSA/IHBhcnNlSW50KGhlYWRSZXNwLmhlYWRlcnMuZ2V0KFwiY29udGVudC1sZW5ndGhcIiksIDEwKSA6IHZvaWQgMDtcbiAgICAgIGxldCBpc1BkZjtcbiAgICAgIGlmIChjaGVjaykge1xuICAgICAgICBjb25zdCByYW5nZVJlc3AgPSBhd2FpdCBmZXRjaDIodXJsLCB7IG1ldGhvZDogXCJHRVRcIiwgaGVhZGVyczogeyBSYW5nZTogXCJieXRlcz0wLTRcIiB9IH0pO1xuICAgICAgICBpZiAocmFuZ2VSZXNwLm9rKSB7XG4gICAgICAgICAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgcmFuZ2VSZXNwLmFycmF5QnVmZmVyKCkpO1xuICAgICAgICAgIGNvbnN0IGhlYWRlclN0ciA9IEFycmF5LmZyb20oYnVmKS5tYXAoKGIpID0+IFN0cmluZy5mcm9tQ2hhckNvZGUoYikpLmpvaW4oXCJcIik7XG4gICAgICAgICAgaXNQZGYgPSBoZWFkZXJTdHIuc3RhcnRzV2l0aChcIiVQREZcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXNQZGYgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgb2s6IGhlYWRSZXNwLm9rLCBzdGF0dXM6IGhlYWRSZXNwLnN0YXR1cywgc2l6ZSwgaXNQZGYsIGhlYWRlcnM6IGhlYWRlcnNPYmogfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRmV0Y2ggQVBJIG5vdCBhdmFpbGFibGVcIik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9rOiBmYWxzZSxcbiAgICAgIHN0YXR1czogdm9pZCAwLFxuICAgICAgc2l6ZTogdm9pZCAwLFxuICAgICAgaXNQZGY6IGZhbHNlLFxuICAgICAgaGVhZGVyczoge30sXG4gICAgICBlcnJvcjogbmV3IEVycm9yKFN0cmluZyhlcnJvcikpXG4gICAgfTtcbiAgfVxufVxuY2xhc3MgSW1hZ2VSZXN1bHQge1xuICBwYWdlcyA9IFtdO1xuICB0b3RhbCA9IDA7XG4gIGdldFBhZ2VJbWFnZShudW0sIG5hbWUpIHtcbiAgICBmb3IgKGNvbnN0IHBhZ2VEYXRhIG9mIHRoaXMucGFnZXMpIHtcbiAgICAgIGlmIChwYWdlRGF0YS5wYWdlTnVtYmVyID09PSBudW0pIHtcbiAgICAgICAgZm9yIChjb25zdCBpbWcgb2YgcGFnZURhdGEuaW1hZ2VzKSB7XG4gICAgICAgICAgaWYgKGltZy5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gaW1nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdHJ1Y3Rvcih0b3RhbCkge1xuICAgIHRoaXMudG90YWwgPSB0b3RhbDtcbiAgfVxufVxuY29uc3QgWE1QX0RBVEVfUFJPUEVSVElFUyA9IFtcbiAgXCJ4bXA6Y3JlYXRlZGF0ZVwiLFxuICBcInhtcDptb2RpZnlkYXRlXCIsXG4gIFwieG1wOm1ldGFkYXRhZGF0ZVwiLFxuICBcInhhcDpjcmVhdGVkYXRlXCIsXG4gIFwieGFwOm1vZGlmeWRhdGVcIixcbiAgXCJ4YXA6bWV0YWRhdGFkYXRlXCJcbl07XG5jbGFzcyBJbmZvUmVzdWx0IHtcbiAgLy8gVG90YWwgbnVtYmVyIG9mIHBhZ2VzIGluIHRoZSBQREYgZG9jdW1lbnQgKGNvdW50IG9mIHBoeXNpY2FsIHBhZ2VzKS5cbiAgdG90YWw7XG4gIC8qKlxuICAgKiBUaGUgUERGICdJbmZvJyBkaWN0aW9uYXJ5LiBUeXBpY2FsIGZpZWxkcyBpbmNsdWRlIHRpdGxlLCBhdXRob3IsIHN1YmplY3QsXG4gICAqIENyZWF0b3IsIFByb2R1Y2VyIGFuZCBDcmVhdGlvbi9Nb2RpZmljYXRpb24gZGF0ZXMuIFRoZSBleGFjdCBzdHJ1Y3R1cmUgaXNcbiAgICogZGV0ZXJtaW5lZCBieSB0aGUgUERGIGFuZCBhcyByZXR1cm5lZCBieSBQREYuanMuXG4gICAqL1xuICAvLyBiaW9tZS1pZ25vcmUgbGludC9zdXNwaWNpb3VzL25vRXhwbGljaXRBbnk6IDx1bnN1cHBvcnRlZCB1bmRlcmxpbmUgdHlwZT5cbiAgaW5mbztcbiAgLy8gTG93LWxldmVsIGRvY3VtZW50IG1ldGFkYXRhIG9iamVjdCAoWE1QKS4gVXNlIHRoaXMgdG8gYWNjZXNzIGV4dGVuZGVkXG4gIC8vIHByb3BlcnRpZXMgdGhhdCBhcmUgbm90IHByZXNlbnQgaW4gdGhlIEluZm8gZGljdGlvbmFyeS5cbiAgbWV0YWRhdGE7XG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiBkb2N1bWVudCBmaW5nZXJwcmludCBzdHJpbmdzIHByb3ZpZGVkIGJ5IFBERi5qcy4gVXNlZnVsXG4gICAqIGZvciBjYWNoaW5nLCBkZS1kdXBsaWNhdGlvbiBvciBpZGVudGlmeWluZyBhIGRvY3VtZW50IGFjcm9zcyBydW5zLlxuICAgKi9cbiAgZmluZ2VycHJpbnRzO1xuICAvKipcbiAgICogUGVybWlzc2lvbiBmbGFncyBmb3IgdGhlIGRvY3VtZW50IGFzIHJldHVybmVkIGJ5IFBERi5qcyAob3IgbnVsbCkuXG4gICAqIFRoZXNlIGZsYWdzIGluZGljYXRlIGNhcGFiaWxpdGllcyBzdWNoIGFzIHByaW50aW5nLCBjb3B5aW5nIGFuZFxuICAgKiBvdGhlciByZXN0cmljdGlvbnMgaW1wb3NlZCBieSB0aGUgUERGIHNlY3VyaXR5IHNldHRpbmdzLlxuICAgKi9cbiAgcGVybWlzc2lvbjtcbiAgLyoqXG4gICAqIE9wdGlvbmFsIGRvY3VtZW50IG91dGxpbmUgKGJvb2ttYXJrcykuIFdoZW4gcHJlc2VudCB0aGlzIGlzIHRoZVxuICAgKiBoaWVyYXJjaGljYWwgbmF2aWdhdGlvbiBzdHJ1Y3R1cmUgd2hpY2ggdmlld2VycyB1c2UgZm9yIHF1aWNrIGFjY2Vzcy5cbiAgICovXG4gIG91dGxpbmU7XG4gIC8vIFJlc3VsdHMgd2l0aCBwZXItcGFnZSBoeXBlcmxpbmsgZXh0cmFjdGlvbi4gRW1wdHkgYXJyYXkgYnkgZGVmYXVsdC5cbiAgcGFnZXMgPSBbXTtcbiAgLyoqXG4gICAqIENvbGxlY3RzIGRhdGVzIGZyb20gZGlmZmVyZW50IHNvdXJjZXMgKEluZm8gZGljdGlvbmFyeSBhbmQgWE1QL1hBUCBtZXRhZGF0YSlcbiAgICogYW5kIHJldHVybnMgdGhlbSBhcyBhIERhdGVOb2RlIHdoZXJlIGF2YWlsYWJsZS4gVGhpcyBoZWxwcyBjYWxsZXJzIGNvbXBhcmVcbiAgICogYW5kIGNob29zZSB0aGUgbW9zdCByZWxldmFudCB0aW1lc3RhbXAgKGZvciBleGFtcGxlIGEgY3JlYXRpb24gZGF0ZSB2cyBYTVAgZGF0ZSkuXG4gICAqL1xuICBnZXREYXRlTm9kZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBjb25zdCBDcmVhdGlvbkRhdGUgPSB0aGlzLmluZm8/LkNyZWF0aW9uRGF0ZTtcbiAgICBpZiAoQ3JlYXRpb25EYXRlKSB7XG4gICAgICByZXN1bHQuQ3JlYXRpb25EYXRlID0gUERGRGF0ZVN0cmluZy50b0RhdGVPYmplY3QoQ3JlYXRpb25EYXRlKTtcbiAgICB9XG4gICAgY29uc3QgTW9kRGF0ZSA9IHRoaXMuaW5mbz8uTW9kRGF0ZTtcbiAgICBpZiAoTW9kRGF0ZSkge1xuICAgICAgcmVzdWx0Lk1vZERhdGUgPSBQREZEYXRlU3RyaW5nLnRvRGF0ZU9iamVjdChNb2REYXRlKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLm1ldGFkYXRhKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgWE1QX0RBVEVfUFJPUEVSVElFUykge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLm1ldGFkYXRhPy5nZXQocHJvcCk7XG4gICAgICBjb25zdCBkYXRlID0gdGhpcy5wYXJzZUlTT0RhdGVTdHJpbmcodmFsdWUpO1xuICAgICAgc3dpdGNoIChwcm9wKSB7XG4gICAgICAgIGNhc2UgWE1QX0RBVEVfUFJPUEVSVElFU1swXTpcbiAgICAgICAgICByZXN1bHQuWG1wQ3JlYXRlRGF0ZSA9IGRhdGU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWE1QX0RBVEVfUFJPUEVSVElFU1sxXTpcbiAgICAgICAgICByZXN1bHQuWG1wTW9kaWZ5RGF0ZSA9IGRhdGU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWE1QX0RBVEVfUFJPUEVSVElFU1syXTpcbiAgICAgICAgICByZXN1bHQuWG1wTWV0YWRhdGFEYXRlID0gZGF0ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBYTVBfREFURV9QUk9QRVJUSUVTWzNdOlxuICAgICAgICAgIHJlc3VsdC5YYXBDcmVhdGVEYXRlID0gZGF0ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBYTVBfREFURV9QUk9QRVJUSUVTWzRdOlxuICAgICAgICAgIHJlc3VsdC5YYXBNb2RpZnlEYXRlID0gZGF0ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBYTVBfREFURV9QUk9QRVJUSUVTWzVdOlxuICAgICAgICAgIHJlc3VsdC5YYXBNZXRhZGF0YURhdGUgPSBkYXRlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBUcnkgdG8gcGFyc2UgYW4gSVNPLTg2MDEgZGF0ZSBzdHJpbmcgZnJvbSBYTVAvWEFQIG1ldGFkYXRhLiBJZiB0aGVcbiAgICogdmFsdWUgaXMgZmFsc3kgb3IgY2Fubm90IGJlIHBhcnNlZCwgdW5kZWZpbmVkIGlzIHJldHVybmVkIHRvIGluZGljYXRlXG4gICAqIGFic2VuY2Ugb3IgdW5wYXJzYWJsZSBpbnB1dC5cbiAgICovXG4gIHBhcnNlSVNPRGF0ZVN0cmluZyhpc29EYXRlU3RyaW5nKSB7XG4gICAgaWYgKCFpc29EYXRlU3RyaW5nKSByZXR1cm4gdm9pZCAwO1xuICAgIGNvbnN0IHBhcnNlZERhdGUgPSBEYXRlLnBhcnNlKGlzb0RhdGVTdHJpbmcpO1xuICAgIGlmICghTnVtYmVyLmlzTmFOKHBhcnNlZERhdGUpKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUocGFyc2VkRGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgY29uc3RydWN0b3IodG90YWwpIHtcbiAgICB0aGlzLnRvdGFsID0gdG90YWw7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldERlZmF1bHRQYXJzZVBhcmFtZXRlcnMocGFyYW1zKSB7XG4gIHBhcmFtcy5saW5lVGhyZXNob2xkID0gcGFyYW1zPy5saW5lVGhyZXNob2xkID8/IDQuNjtcbiAgcGFyYW1zLmNlbGxUaHJlc2hvbGQgPSBwYXJhbXM/LmNlbGxUaHJlc2hvbGQgPz8gNztcbiAgcGFyYW1zLmNlbGxTZXBhcmF0b3IgPSBwYXJhbXM/LmNlbGxTZXBhcmF0b3IgPz8gXCJcdFwiO1xuICBwYXJhbXMubGluZUVuZm9yY2UgPSBwYXJhbXM/LmxpbmVFbmZvcmNlID8/IHRydWU7XG4gIHBhcmFtcy5wYWdlSm9pbmVyID0gcGFyYW1zPy5wYWdlSm9pbmVyID8/IFwiXFxuLS0gcGFnZV9udW1iZXIgb2YgdG90YWxfbnVtYmVyIC0tXCI7XG4gIHBhcmFtcy5pbWFnZVRocmVzaG9sZCA9IHBhcmFtcz8uaW1hZ2VUaHJlc2hvbGQgPz8gODA7XG4gIHBhcmFtcy5pbWFnZURhdGFVcmwgPSBwYXJhbXM/LmltYWdlRGF0YVVybCA/PyB0cnVlO1xuICBwYXJhbXMuaW1hZ2VCdWZmZXIgPSBwYXJhbXM/LmltYWdlQnVmZmVyID8/IHRydWU7XG4gIHBhcmFtcy5zY2FsZSA9IHBhcmFtcz8uc2NhbGUgPz8gMTtcbiAgcmV0dXJuIHBhcmFtcztcbn1cbnZhciBQYXRoR2VvbWV0cnkgPSAvKiBAX19QVVJFX18gKi8gKChQYXRoR2VvbWV0cnkyKSA9PiB7XG4gIFBhdGhHZW9tZXRyeTJbUGF0aEdlb21ldHJ5MltcInVuZGVmaW5lZFwiXSA9IDBdID0gXCJ1bmRlZmluZWRcIjtcbiAgUGF0aEdlb21ldHJ5MltQYXRoR2VvbWV0cnkyW1wiaGxpbmVcIl0gPSAxXSA9IFwiaGxpbmVcIjtcbiAgUGF0aEdlb21ldHJ5MltQYXRoR2VvbWV0cnkyW1widmxpbmVcIl0gPSAyXSA9IFwidmxpbmVcIjtcbiAgUGF0aEdlb21ldHJ5MltQYXRoR2VvbWV0cnkyW1wicmVjdGFuZ2xlXCJdID0gM10gPSBcInJlY3RhbmdsZVwiO1xuICByZXR1cm4gUGF0aEdlb21ldHJ5Mjtcbn0pKFBhdGhHZW9tZXRyeSB8fCB7fSk7XG5jbGFzcyBTY3JlZW5zaG90UmVzdWx0IHtcbiAgcGFnZXMgPSBbXTtcbiAgdG90YWwgPSAwO1xuICBjb25zdHJ1Y3Rvcih0b3RhbCkge1xuICAgIHRoaXMudG90YWwgPSB0b3RhbDtcbiAgfVxufVxuY2xhc3MgVGFibGVSZXN1bHQge1xuICBwYWdlcyA9IFtdO1xuICBtZXJnZWRUYWJsZXMgPSBbXTtcbiAgdG90YWwgPSAwO1xuICBjb25zdHJ1Y3Rvcih0b3RhbCkge1xuICAgIHRoaXMudG90YWwgPSB0b3RhbDtcbiAgfVxufVxuY2xhc3MgVGV4dFJlc3VsdCB7XG4gIHBhZ2VzID0gW107XG4gIHRleHQgPSBcIlwiO1xuICB0b3RhbCA9IDA7XG4gIGdldFBhZ2VUZXh0KG51bSkge1xuICAgIGZvciAoY29uc3QgcGFnZURhdGEgb2YgdGhpcy5wYWdlcykge1xuICAgICAgaWYgKHBhZ2VEYXRhLm51bSA9PT0gbnVtKSByZXR1cm4gcGFnZURhdGEudGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgY29uc3RydWN0b3IodG90YWwpIHtcbiAgICB0aGlzLnRvdGFsID0gdG90YWw7XG4gIH1cbn1cbmNsYXNzIFBERlBhcnNlIHtcbiAgb3B0aW9ucztcbiAgZG9jO1xuICBwcm9ncmVzcyA9IHsgbG9hZGVkOiAtMSwgdG90YWw6IDAgfTtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBwYXJzZXIgd2l0aCBgRG9jdW1lbnRJbml0UGFyYW1ldGVyc2AuXG4gICAqIENvbnZlcnRzIE5vZGUuanMgYEJ1ZmZlcmAgZGF0YSB0byBgVWludDhBcnJheWAgYXV0b21hdGljYWxseSBhbmQgZW5zdXJlcyBhIGRlZmF1bHQgdmVyYm9zaXR5IGxldmVsLlxuICAgKiBAcGFyYW0gb3B0aW9ucyBJbml0aWFsaXphdGlvbiBwYXJhbWV0ZXJzLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnZlcmJvc2l0eSA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zLnZlcmJvc2l0eSA9IFZlcmJvc2l0eUxldmVsLkVSUk9SUztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgb3B0aW9ucy5kYXRhIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICBvcHRpb25zLmRhdGEgPSBuZXcgVWludDhBcnJheShvcHRpb25zLmRhdGEpO1xuICAgIH1cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIGFzeW5jIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuZG9jKSB7XG4gICAgICBhd2FpdCB0aGlzLmRvYy5kZXN0cm95KCk7XG4gICAgICB0aGlzLmRvYyA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgLy8gYmlvbWUtaWdub3JlLXN0YXJ0IGxpbnQvc3VzcGljaW91cy9ub0V4cGxpY2l0QW55OiB1bnN1cHBvcnRlZCB1bmRlcmxpbmUgdHlwZVxuICBzdGF0aWMgZ2V0IGlzTm9kZUpTKCkge1xuICAgIGNvbnN0IGlzTm9kZUpTMiA9IHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIGAke3Byb2Nlc3N9YCA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIgJiYgIXByb2Nlc3MudmVyc2lvbnMubncgJiYgIShwcm9jZXNzLnZlcnNpb25zLmVsZWN0cm9uICYmIHR5cGVvZiBwcm9jZXNzLnR5cGUgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy50eXBlICE9PSBcImJyb3dzZXJcIik7XG4gICAgcmV0dXJuIGlzTm9kZUpTMjtcbiAgfVxuICBzdGF0aWMgc2V0V29ya2VyKHdvcmtlclNyYykge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcy5wZGZqcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgZ2xvYmFsVGhpcy5wZGZqcyA9IHBkZmpzO1xuICAgIH1cbiAgICBpZiAoR2xvYmFsV29ya2VyT3B0aW9ucyA9PT0gbnVsbCkgcmV0dXJuIFwiXCI7XG4gICAgaWYgKHdvcmtlclNyYyAhPT0gdm9pZCAwKSB7XG4gICAgICBHbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyYyA9IHdvcmtlclNyYztcbiAgICAgIHJldHVybiBHbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyYztcbiAgICB9XG4gICAgcmV0dXJuIEdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjO1xuICB9XG4gIC8vIGJpb21lLWlnbm9yZS1lbmQgbGludC9zdXNwaWNpb3VzL25vRXhwbGljaXRBbnk6IHVuc3VwcG9ydGVkIHVuZGVybGluZSB0eXBlXG4gIC8qKlxuICAgKiBQZXJmb3JtIGFuIEhUVFAgSEVBRCByZXF1ZXN0IHRvIHJldHJpZXZlIHRoZSBmaWxlIHNpemUgYW5kIHZlcmlmeSBleGlzdGVuY2U7XG4gICAqIHdoZW4gYGNoZWNrYCBpcyB0cnVlLCBmZXRjaCBhIHNtYWxsIHJhbmdlIGFuZCBpbnNwZWN0IHRoZSBtYWdpYyBudW1iZXIgdG8gY29uZmlybSB0aGUgVVJMIHBvaW50cyB0byBhIHZhbGlkIFBERi5cbiAgICogQHBhcmFtIGNoZWNrIFdoZW4gYHRydWVgLCBkb3dubG9hZCBhIHNtYWxsIGJ5dGUgcmFuZ2UgdG8gdmFsaWRhdGUgdGhlIGZpbGUgc2lnbmF0dXJlLlxuICAgKiBEZWZhdWx0OiBgZmFsc2VgLlxuICAgKi9cbiAgYXN5bmMgZ2V0SGVhZGVyKGNoZWNrID0gZmFsc2UpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy51cmwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImdldEhlYWRlcjogb3B0aW9ucy51cmwgaXMgbm90IHNldFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IGdldEhlYWRlcih0aGlzLm9wdGlvbnMudXJsLCBjaGVjayk7XG4gIH1cbiAgLyoqXG4gICAqIExvYWQgZG9jdW1lbnQtbGV2ZWwgbWV0YWRhdGEgKGluZm8sIG91dGxpbmUsIHBlcm1pc3Npb25zLCBwYWdlIGxhYmVscykgYW5kIG9wdGlvbmFsbHkgZ2F0aGVyIHBlci1wYWdlIGxpbmsgZGV0YWlscy5cbiAgICogQHBhcmFtIHBhcmFtcyBQYXJzZSBvcHRpb25zOyBzZXQgYHBhcnNlUGFnZUluZm9gIHRvIGNvbGxlY3QgcGVyLXBhZ2UgbWV0YWRhdGEgZGVzY3JpYmVkIGluIGBQYXJzZVBhcmFtZXRlcnNgLlxuICAgKiBAcmV0dXJucyBBZ2dyZWdhdGVkIGRvY3VtZW50IG1ldGFkYXRhIGluIGFuIGBJbmZvUmVzdWx0YC5cbiAgICovXG4gIGFzeW5jIGdldEluZm8ocGFyYW1zID0ge30pIHtcbiAgICBjb25zdCBkb2MgPSBhd2FpdCB0aGlzLmxvYWQoKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgSW5mb1Jlc3VsdChkb2MubnVtUGFnZXMpO1xuICAgIGNvbnN0IHsgaW5mbzogaW5mbzIsIG1ldGFkYXRhIH0gPSBhd2FpdCBkb2MuZ2V0TWV0YWRhdGEoKTtcbiAgICByZXN1bHQuaW5mbyA9IGluZm8yO1xuICAgIHJlc3VsdC5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgIHJlc3VsdC5maW5nZXJwcmludHMgPSBkb2MuZmluZ2VycHJpbnRzO1xuICAgIHJlc3VsdC5vdXRsaW5lID0gYXdhaXQgZG9jLmdldE91dGxpbmUoKTtcbiAgICByZXN1bHQucGVybWlzc2lvbiA9IGF3YWl0IGRvYy5nZXRQZXJtaXNzaW9ucygpO1xuICAgIGNvbnN0IHBhZ2VMYWJlbHMgPSBhd2FpdCBkb2MuZ2V0UGFnZUxhYmVscygpO1xuICAgIGlmIChwYXJhbXMucGFyc2VQYWdlSW5mbykge1xuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gcmVzdWx0LnRvdGFsOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkUGFyc2UoaSwgcmVzdWx0LnRvdGFsLCBwYXJhbXMpKSB7XG4gICAgICAgICAgY29uc3QgcGFnZSA9IGF3YWl0IGRvYy5nZXRQYWdlKGkpO1xuICAgICAgICAgIGNvbnN0IHBhZ2VMaW5rUmVzdWx0ID0gYXdhaXQgdGhpcy5nZXRQYWdlTGlua3MocGFnZSk7XG4gICAgICAgICAgcGFnZUxpbmtSZXN1bHQucGFnZUxhYmVsID0gcGFnZUxhYmVscz8uW3BhZ2UucGFnZU51bWJlcl07XG4gICAgICAgICAgcmVzdWx0LnBhZ2VzLnB1c2gocGFnZUxpbmtSZXN1bHQpO1xuICAgICAgICAgIHBhZ2UuY2xlYW51cCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYXN5bmMgZ2V0UGFnZUxpbmtzKHBhZ2UpIHtcbiAgICBjb25zdCB2aWV3cG9ydCA9IHBhZ2UuZ2V0Vmlld3BvcnQoeyBzY2FsZTogMSB9KTtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBwYWdlTnVtYmVyOiBwYWdlLnBhZ2VOdW1iZXIsXG4gICAgICBsaW5rczogW10sXG4gICAgICB3aWR0aDogdmlld3BvcnQud2lkdGgsXG4gICAgICBoZWlnaHQ6IHZpZXdwb3J0LmhlaWdodFxuICAgIH07XG4gICAgY29uc3QgYW5ub3RhdGlvbnMgPSBhd2FpdCBwYWdlLmdldEFubm90YXRpb25zKHsgaW50ZW50OiBcImRpc3BsYXlcIiB9KSB8fCBbXTtcbiAgICBmb3IgKGNvbnN0IGkgb2YgYW5ub3RhdGlvbnMpIHtcbiAgICAgIGlmIChpLnN1YnR5cGUgIT09IFwiTGlua1wiKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IHVybCA9IGkudXJsID8/IGkudW5zYWZlVXJsO1xuICAgICAgaWYgKCF1cmwpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgdGV4dCA9IGkub3ZlcmxhaWRUZXh0IHx8IFwiXCI7XG4gICAgICByZXN1bHQubGlua3MucHVzaCh7IHVybCwgdGV4dCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogRXh0cmFjdCBwbGFpbiB0ZXh0IGZvciBlYWNoIHJlcXVlc3RlZCBwYWdlLCBvcHRpb25hbGx5IGVucmljaGluZyBoeXBlcmxpbmtzIGFuZCBlbmZvcmNpbmcgbGluZSBvciBjZWxsIHNlcGFyYXRvcnMuXG4gICAqIEBwYXJhbSBwYXJhbXMgUGFyc2Ugb3B0aW9ucyBjb250cm9sbGluZyBwYWdpbmF0aW9uLCBsaW5rIGhhbmRsaW5nLCBhbmQgbGluZS9jZWxsIHRocmVzaG9sZHMuXG4gICAqIEByZXR1cm5zIEEgYFRleHRSZXN1bHRgIGNvbnRhaW5pbmcgcGFnZS13aXNlIHRleHQgYW5kIGEgY29uY2F0ZW5hdGVkIGRvY3VtZW50IHN0cmluZy5cbiAgICovXG4gIGFzeW5jIGdldFRleHQocGFyYW1zID0ge30pIHtcbiAgICBjb25zdCBkb2MgPSBhd2FpdCB0aGlzLmxvYWQoKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVGV4dFJlc3VsdChkb2MubnVtUGFnZXMpO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IHJlc3VsdC50b3RhbDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5zaG91bGRQYXJzZShpLCByZXN1bHQudG90YWwsIHBhcmFtcykpIHtcbiAgICAgICAgY29uc3QgcGFnZSA9IGF3YWl0IGRvYy5nZXRQYWdlKGkpO1xuICAgICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgdGhpcy5nZXRQYWdlVGV4dChwYWdlLCBwYXJhbXMsIHJlc3VsdC50b3RhbCk7XG4gICAgICAgIHJlc3VsdC5wYWdlcy5wdXNoKHtcbiAgICAgICAgICB0ZXh0LFxuICAgICAgICAgIG51bTogaVxuICAgICAgICB9KTtcbiAgICAgICAgcGFnZS5jbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgcGFnZSBvZiByZXN1bHQucGFnZXMpIHtcbiAgICAgIHJlc3VsdC50ZXh0ICs9IGAke3BhZ2UudGV4dH1cblxuYDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBhc3luYyBsb2FkKCkge1xuICAgIGlmICh0aGlzLmRvYyA9PT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBsb2FkaW5nVGFzayA9IGdldERvY3VtZW50KHRoaXMub3B0aW9ucyk7XG4gICAgICBsb2FkaW5nVGFzay5vblByb2dyZXNzID0gKHByb2dyZXNzKSA9PiB7XG4gICAgICAgIHRoaXMucHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICAgIH07XG4gICAgICB0aGlzLmRvYyA9IGF3YWl0IGxvYWRpbmdUYXNrLnByb21pc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRvYztcbiAgfVxuICBzaG91bGRQYXJzZShjdXJyZW50UGFnZSwgdG90YWxQYWdlLCBwYXJhbXMpIHtcbiAgICBwYXJhbXMucGFydGlhbCA9IHBhcmFtcz8ucGFydGlhbCA/PyBbXTtcbiAgICBwYXJhbXMuZmlyc3QgPSBwYXJhbXM/LmZpcnN0ID8/IDA7XG4gICAgcGFyYW1zLmxhc3QgPSBwYXJhbXM/Lmxhc3QgPz8gMDtcbiAgICBpZiAocGFyYW1zLnBhcnRpYWwubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHBhcmFtcy5wYXJ0aWFsLmluY2x1ZGVzKGN1cnJlbnRQYWdlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5maXJzdCA+IDAgJiYgcGFyYW1zLmxhc3QgPiAwKSB7XG4gICAgICBpZiAoY3VycmVudFBhZ2UgPj0gcGFyYW1zLmZpcnN0ICYmIGN1cnJlbnRQYWdlIDw9IHBhcmFtcy5sYXN0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLmZpcnN0ID4gMCkge1xuICAgICAgaWYgKGN1cnJlbnRQYWdlIDw9IHBhcmFtcy5maXJzdCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5sYXN0ID4gMCkge1xuICAgICAgaWYgKGN1cnJlbnRQYWdlID4gdG90YWxQYWdlIC0gcGFyYW1zLmxhc3QpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGFzeW5jIGdldFBhZ2VUZXh0KHBhZ2UsIHBhcnNlUGFyYW1zLCB0b3RhbCkge1xuICAgIGNvbnN0IHZpZXdwb3J0ID0gcGFnZS5nZXRWaWV3cG9ydCh7IHNjYWxlOiAxIH0pO1xuICAgIGNvbnN0IHBhcmFtcyA9IHNldERlZmF1bHRQYXJzZVBhcmFtZXRlcnMocGFyc2VQYXJhbXMpO1xuICAgIGNvbnN0IHRleHRDb250ZW50ID0gYXdhaXQgcGFnZS5nZXRUZXh0Q29udGVudCh7XG4gICAgICBpbmNsdWRlTWFya2VkQ29udGVudDogISFwYXJhbXMuaW5jbHVkZU1hcmtlZENvbnRlbnQsXG4gICAgICBkaXNhYmxlTm9ybWFsaXphdGlvbjogISFwYXJhbXMuZGlzYWJsZU5vcm1hbGl6YXRpb25cbiAgICB9KTtcbiAgICBsZXQgbGlua3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGlmIChwYXJhbXMucGFyc2VIeXBlcmxpbmtzKSB7XG4gICAgICBsaW5rcyA9IGF3YWl0IHRoaXMuZ2V0SHlwZXJsaW5rcyhwYWdlLCB2aWV3cG9ydCk7XG4gICAgfVxuICAgIGNvbnN0IHN0ckJ1ZiA9IFtdO1xuICAgIGxldCBsYXN0WDtcbiAgICBsZXQgbGFzdFk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHRleHRDb250ZW50Lml0ZW1zKSB7XG4gICAgICBpZiAoIShcInN0clwiIGluIGl0ZW0pKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IHRtID0gaXRlbS50cmFuc2Zvcm0gPz8gaXRlbS50cmFuc2Zvcm07XG4gICAgICBjb25zdCBbeCwgeV0gPSB2aWV3cG9ydC5jb252ZXJ0VG9WaWV3cG9ydFBvaW50KHRtWzRdLCB0bVs1XSk7XG4gICAgICBpZiAocGFyYW1zLnBhcnNlSHlwZXJsaW5rcykge1xuICAgICAgICBjb25zdCBwb3NBcnIgPSBsaW5rcy5nZXQoaXRlbS5zdHIpIHx8IFtdO1xuICAgICAgICBjb25zdCBoaXQgPSBwb3NBcnIuZmluZCgobCkgPT4geCA+PSBsLnJlY3QubGVmdCAmJiB4IDw9IGwucmVjdC5yaWdodCAmJiB5ID49IGwucmVjdC50b3AgJiYgeSA8PSBsLnJlY3QuYm90dG9tKTtcbiAgICAgICAgaWYgKGhpdCkge1xuICAgICAgICAgIGl0ZW0uc3RyID0gYFske2l0ZW0uc3RyfV0oJHtoaXQudXJsfSlgO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zLmxpbmVFbmZvcmNlKSB7XG4gICAgICAgIGlmIChsYXN0WSAhPT0gdm9pZCAwICYmIE1hdGguYWJzKGxhc3RZIC0geSkgPiBwYXJhbXMubGluZVRocmVzaG9sZCkge1xuICAgICAgICAgIGNvbnN0IGxhc3RJdGVtID0gc3RyQnVmLmxlbmd0aCA/IHN0ckJ1ZltzdHJCdWYubGVuZ3RoIC0gMV0gOiB2b2lkIDA7XG4gICAgICAgICAgY29uc3QgaXNDdXJyZW50SXRlbUhhc05ld0xpbmUgPSBpdGVtLnN0ci5zdGFydHNXaXRoKFwiXFxuXCIpIHx8IGl0ZW0uc3RyLnRyaW0oKSA9PT0gXCJcIiAmJiBpdGVtLmhhc0VPTDtcbiAgICAgICAgICBpZiAobGFzdEl0ZW0/LmVuZHNXaXRoKFwiXFxuXCIpID09PSBmYWxzZSAmJiAhaXNDdXJyZW50SXRlbUhhc05ld0xpbmUpIHtcbiAgICAgICAgICAgIHN0ckJ1Zi5wdXNoKFwiXFxuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcy5jZWxsU2VwYXJhdG9yKSB7XG4gICAgICAgIGlmIChsYXN0WSAhPT0gdm9pZCAwICYmIE1hdGguYWJzKGxhc3RZIC0geSkgPCBwYXJhbXMubGluZVRocmVzaG9sZCkge1xuICAgICAgICAgIGlmIChsYXN0WCAhPT0gdm9pZCAwICYmIE1hdGguYWJzKGxhc3RYIC0geCkgPiBwYXJhbXMuY2VsbFRocmVzaG9sZCkge1xuICAgICAgICAgICAgaXRlbS5zdHIgPSBgJHtwYXJhbXMuY2VsbFNlcGFyYXRvcn0ke2l0ZW0uc3RyfWA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdHJCdWYucHVzaChpdGVtLnN0cik7XG4gICAgICBsYXN0WCA9IHggKyBpdGVtLndpZHRoO1xuICAgICAgbGFzdFkgPSB5O1xuICAgICAgaWYgKGl0ZW0uaGFzRU9MKSB7XG4gICAgICAgIHN0ckJ1Zi5wdXNoKFwiXFxuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFyYW1zLnBhZ2VKb2luZXIpIHtcbiAgICAgIGxldCBwYWdlTnVtYmVyID0gcGFyYW1zLnBhZ2VKb2luZXIucmVwbGFjZShcInBhZ2VfbnVtYmVyXCIsIGAke3BhZ2UucGFnZU51bWJlcn1gKTtcbiAgICAgIHBhZ2VOdW1iZXIgPSBwYWdlTnVtYmVyLnJlcGxhY2UoXCJ0b3RhbF9udW1iZXJcIiwgYCR7dG90YWx9YCk7XG4gICAgICBzdHJCdWYucHVzaChwYWdlTnVtYmVyKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5pdGVtSm9pbmVyKSB7XG4gICAgICByZXR1cm4gc3RyQnVmLmpvaW4ocGFyYW1zLml0ZW1Kb2luZXIpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyQnVmLmpvaW4oXCJcIik7XG4gIH1cbiAgYXN5bmMgZ2V0SHlwZXJsaW5rcyhwYWdlLCB2aWV3cG9ydCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3QgYW5ub3RhdGlvbnMgPSBhd2FpdCBwYWdlLmdldEFubm90YXRpb25zKHsgaW50ZW50OiBcImRpc3BsYXlcIiB9KSB8fCBbXTtcbiAgICBmb3IgKGNvbnN0IGkgb2YgYW5ub3RhdGlvbnMpIHtcbiAgICAgIGlmIChpLnN1YnR5cGUgIT09IFwiTGlua1wiKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IHVybCA9IGkudXJsID8/IGkudW5zYWZlVXJsO1xuICAgICAgaWYgKCF1cmwpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgdGV4dCA9IGkub3ZlcmxhaWRUZXh0O1xuICAgICAgaWYgKCF0ZXh0KSBjb250aW51ZTtcbiAgICAgIGNvbnN0IHJlY3RWcCA9IHZpZXdwb3J0LmNvbnZlcnRUb1ZpZXdwb3J0UmVjdGFuZ2xlKGkucmVjdCk7XG4gICAgICBjb25zdCBsZWZ0ID0gTWF0aC5taW4ocmVjdFZwWzBdLCByZWN0VnBbMl0pIC0gMC41O1xuICAgICAgY29uc3QgdG9wID0gTWF0aC5taW4ocmVjdFZwWzFdLCByZWN0VnBbM10pIC0gMC41O1xuICAgICAgY29uc3QgcmlnaHQgPSBNYXRoLm1heChyZWN0VnBbMF0sIHJlY3RWcFsyXSkgKyAwLjU7XG4gICAgICBjb25zdCBib3R0b20gPSBNYXRoLm1heChyZWN0VnBbMV0sIHJlY3RWcFszXSkgKyAwLjU7XG4gICAgICBjb25zdCBwb3MgPSB7IHJlY3Q6IHsgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tIH0sIHVybCwgdGV4dCwgdXNlZDogZmFsc2UgfTtcbiAgICAgIGNvbnN0IGVsID0gcmVzdWx0LmdldCh0ZXh0KTtcbiAgICAgIGlmIChlbCkge1xuICAgICAgICBlbC5wdXNoKHBvcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQuc2V0KHRleHQsIFtwb3NdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogRXh0cmFjdCBlbWJlZGRlZCBpbWFnZXMgZnJvbSByZXF1ZXN0ZWQgcGFnZXMuXG4gICAqXG4gICAqIEJlaGF2aW9yIG5vdGVzOlxuICAgKiAtIFBhZ2VzIGFyZSBzZWxlY3RlZCBhY2NvcmRpbmcgdG8gUGFyc2VQYXJhbWV0ZXJzIChwYXJ0aWFsLCBmaXJzdCwgbGFzdCkuXG4gICAqIC0gSW1hZ2VzIHNtYWxsZXIgdGhhbiBgcGFyYW1zLmltYWdlVGhyZXNob2xkYCAod2lkdGggT1IgaGVpZ2h0KSBhcmUgc2tpcHBlZC5cbiAgICogLSBSZXR1cm5lZCBJbWFnZVJlc3VsdCBjb250YWlucyBwZXItcGFnZSBQYWdlSW1hZ2VzOyBlYWNoIGltYWdlIGVudHJ5IGluY2x1ZGVzOlxuICAgKiAgICAgLSBkYXRhOiBVaW50OEFycmF5IChwcmVzZW50IHdoZW4gcGFyYW1zLmltYWdlQnVmZmVyID09PSB0cnVlKVxuICAgKiAgICAgLSBkYXRhVXJsOiBzdHJpbmcgKHByZXNlbnQgd2hlbiBwYXJhbXMuaW1hZ2VEYXRhVXJsID09PSB0cnVlKVxuICAgKiAgICAgLSB3aWR0aCwgaGVpZ2h0LCBraW5kLCBuYW1lXG4gICAqIC0gV29ya3MgaW4gYm90aCBOb2RlLmpzIChjYW52YXMudG9CdWZmZXIpIGFuZCBicm93c2VyIChjYW52YXMudG9EYXRhVVJMKSBlbnZpcm9ubWVudHMuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMgUGFyc2VQYXJhbWV0ZXJzIGNvbnRyb2xsaW5nIHBhZ2Ugc2VsZWN0aW9uLCB0aHJlc2hvbGRzIGFuZCBvdXRwdXQgZm9ybWF0LlxuICAgKiBAcmV0dXJucyBQcm9taXNlPEltYWdlUmVzdWx0PiB3aXRoIGV4dHJhY3RlZCBpbWFnZXMgZ3JvdXBlZCBieSBwYWdlLlxuICAgKi9cbiAgYXN5bmMgZ2V0SW1hZ2UocGFyYW1zID0ge30pIHtcbiAgICBjb25zdCBkb2MgPSBhd2FpdCB0aGlzLmxvYWQoKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgSW1hZ2VSZXN1bHQoZG9jLm51bVBhZ2VzKTtcbiAgICBzZXREZWZhdWx0UGFyc2VQYXJhbWV0ZXJzKHBhcmFtcyk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gcmVzdWx0LnRvdGFsOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLnNob3VsZFBhcnNlKGksIHJlc3VsdC50b3RhbCwgcGFyYW1zKSkge1xuICAgICAgICBjb25zdCBwYWdlID0gYXdhaXQgZG9jLmdldFBhZ2UoaSk7XG4gICAgICAgIGNvbnN0IG9wcyA9IGF3YWl0IHBhZ2UuZ2V0T3BlcmF0b3JMaXN0KCk7XG4gICAgICAgIGNvbnN0IHBhZ2VJbWFnZXMgPSB7IHBhZ2VOdW1iZXI6IGksIGltYWdlczogW10gfTtcbiAgICAgICAgcmVzdWx0LnBhZ2VzLnB1c2gocGFnZUltYWdlcyk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgb3BzLmZuQXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAob3BzLmZuQXJyYXlbal0gPT09IE9QUy5wYWludElubGluZUltYWdlWE9iamVjdCB8fCBvcHMuZm5BcnJheVtqXSA9PT0gT1BTLnBhaW50SW1hZ2VYT2JqZWN0KSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gb3BzLmFyZ3NBcnJheVtqXVswXTtcbiAgICAgICAgICAgIGNvbnN0IGlzQ29tbW9uID0gcGFnZS5jb21tb25PYmpzLmhhcyhuYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGltZ1Byb21pc2UgPSBpc0NvbW1vbiA/IHRoaXMucmVzb2x2ZUVtYmVkZGVkSW1hZ2UocGFnZS5jb21tb25PYmpzLCBuYW1lKSA6IHRoaXMucmVzb2x2ZUVtYmVkZGVkSW1hZ2UocGFnZS5vYmpzLCBuYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwga2luZCwgZGF0YSB9ID0gYXdhaXQgaW1nUHJvbWlzZTtcbiAgICAgICAgICAgIGlmIChwYXJhbXMuaW1hZ2VUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgaWYgKHBhcmFtcy5pbWFnZVRocmVzaG9sZCA+PSB3aWR0aCB8fCBwYXJhbXMuaW1hZ2VUaHJlc2hvbGQgPj0gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhbnZhc0ZhY3RvcnkgPSBkb2MuY2FudmFzRmFjdG9yeTtcbiAgICAgICAgICAgIGNvbnN0IGNhbnZhc0FuZENvbnRleHQgPSBjYW52YXNGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXNBbmRDb250ZXh0LmNvbnRleHQ7XG4gICAgICAgICAgICBsZXQgaW1nRGF0YSA9IG51bGw7XG4gICAgICAgICAgICBpZiAoa2luZCA9PT0gdXRpbF9JbWFnZUtpbmQuUkdCQV8zMkJQUCkge1xuICAgICAgICAgICAgICBpbWdEYXRhID0gY29udGV4dC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgIGltZ0RhdGEuZGF0YS5zZXQoZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpbWdEYXRhID0gY29udGV4dC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgIHRoaXMuY29udmVydFRvUkdCQSh7XG4gICAgICAgICAgICAgICAgc3JjOiBkYXRhLFxuICAgICAgICAgICAgICAgIGRlc3Q6IG5ldyBVaW50MzJBcnJheShpbWdEYXRhLmRhdGEuYnVmZmVyKSxcbiAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICAgICAga2luZFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHQucHV0SW1hZ2VEYXRhKGltZ0RhdGEsIDAsIDApO1xuICAgICAgICAgICAgbGV0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgICAgICBsZXQgZGF0YVVybCA9IFwiXCI7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhbnZhc0FuZENvbnRleHQuY2FudmFzLnRvQnVmZmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgbGV0IG5vZGVCdWZmZXI7XG4gICAgICAgICAgICAgIGlmIChwYXJhbXMuaW1hZ2VCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICBub2RlQnVmZmVyID0gY2FudmFzQW5kQ29udGV4dC5jYW52YXMudG9CdWZmZXIoXCJpbWFnZS9wbmdcIik7XG4gICAgICAgICAgICAgICAgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkobm9kZUJ1ZmZlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHBhcmFtcy5pbWFnZURhdGFVcmwpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgZGF0YVVybCA9IGBkYXRhOmltYWdlL3BuZztiYXNlNjQsJHtub2RlQnVmZmVyLnRvU3RyaW5nKFwiYmFzZTY0XCIpfWA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG5vZGVCdWZmZXIgPSBjYW52YXNBbmRDb250ZXh0LmNhbnZhcy50b0J1ZmZlcihcImltYWdlL3BuZ1wiKTtcbiAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KG5vZGVCdWZmZXIpO1xuICAgICAgICAgICAgICAgICAgZGF0YVVybCA9IGBkYXRhOmltYWdlL3BuZztiYXNlNjQsJHtub2RlQnVmZmVyLnRvU3RyaW5nKFwiYmFzZTY0XCIpfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAocGFyYW1zLmltYWdlQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW1hZ2VEYXRhID0gY2FudmFzQW5kQ29udGV4dC5jb250ZXh0LmdldEltYWdlRGF0YShcbiAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgY2FudmFzQW5kQ29udGV4dC5jYW52YXMud2lkdGgsXG4gICAgICAgICAgICAgICAgICBjYW52YXNBbmRDb250ZXh0LmNhbnZhcy5oZWlnaHRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGltYWdlRGF0YS5kYXRhKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocGFyYW1zLmltYWdlRGF0YVVybCkge1xuICAgICAgICAgICAgICAgIGRhdGFVcmwgPSBjYW52YXNBbmRDb250ZXh0LmNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS9wbmdcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhZ2VJbWFnZXMuaW1hZ2VzLnB1c2goe1xuICAgICAgICAgICAgICBkYXRhOiBidWZmZXIsXG4gICAgICAgICAgICAgIGRhdGFVcmwsXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgIGtpbmRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGNvbnZlcnRUb1JHQkEoe1xuICAgIHNyYyxcbiAgICBkZXN0LFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBraW5kXG4gIH0pIHtcbiAgICBpZiAoa2luZCA9PT0gdXRpbF9JbWFnZUtpbmQuUkdCXzI0QlBQKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCBzcmMubGVuZ3RoOyBpICs9IDMsIGorKykge1xuICAgICAgICBjb25zdCByID0gc3JjW2ldO1xuICAgICAgICBjb25zdCBnID0gc3JjW2kgKyAxXTtcbiAgICAgICAgY29uc3QgYiA9IHNyY1tpICsgMl07XG4gICAgICAgIGRlc3Rbal0gPSAyNTUgPDwgMjQgfCBiIDw8IDE2IHwgZyA8PCA4IHwgcjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGtpbmQgPT09IHV0aWxfSW1hZ2VLaW5kLkdSQVlTQ0FMRV8xQlBQKSB7XG4gICAgICBsZXQgcGl4ZWxJbmRleCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNyYy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBieXRlID0gc3JjW2ldO1xuICAgICAgICBmb3IgKGxldCBiaXQgPSA3OyBiaXQgPj0gMDsgYml0LS0pIHtcbiAgICAgICAgICBpZiAocGl4ZWxJbmRleCA+PSB3aWR0aCAqIGhlaWdodCkgYnJlYWs7XG4gICAgICAgICAgY29uc3QgaXNXaGl0ZSA9IChieXRlID4+IGJpdCAmIDEpID09PSAxO1xuICAgICAgICAgIGNvbnN0IGdyYXkgPSBpc1doaXRlID8gMjU1IDogMDtcbiAgICAgICAgICBkZXN0W3BpeGVsSW5kZXgrK10gPSAyNTUgPDwgMjQgfCBncmF5IDw8IDE2IHwgZ3JheSA8PCA4IHwgZ3JheTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gdm9pZCAwIHx8IGtpbmQgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGJ5dGVzUGVyUGl4ZWwgPSBzcmMubGVuZ3RoIC8gKHdpZHRoICogaGVpZ2h0KTtcbiAgICAgIGlmIChNYXRoLmFicyhieXRlc1BlclBpeGVsIC0gMykgPCAwLjEpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgc3JjLmxlbmd0aDsgaSArPSAzLCBqKyspIHtcbiAgICAgICAgICBjb25zdCByID0gc3JjW2ldO1xuICAgICAgICAgIGNvbnN0IGcgPSBzcmNbaSArIDFdO1xuICAgICAgICAgIGNvbnN0IGIgPSBzcmNbaSArIDJdO1xuICAgICAgICAgIGRlc3Rbal0gPSAyNTUgPDwgMjQgfCBiIDw8IDE2IHwgZyA8PCA4IHwgcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhieXRlc1BlclBpeGVsIC0gNCkgPCAwLjEpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgc3JjLmxlbmd0aDsgaSArPSA0LCBqKyspIHtcbiAgICAgICAgICBjb25zdCByID0gc3JjW2ldO1xuICAgICAgICAgIGNvbnN0IGcgPSBzcmNbaSArIDFdO1xuICAgICAgICAgIGNvbnN0IGIgPSBzcmNbaSArIDJdO1xuICAgICAgICAgIGNvbnN0IGEgPSBzcmNbaSArIDNdO1xuICAgICAgICAgIGRlc3Rbal0gPSBhIDw8IDI0IHwgYiA8PCAxNiB8IGcgPDwgOCB8IHI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoYnl0ZXNQZXJQaXhlbCAtIDEpIDwgMC4xKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3JjLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgZ3JheSA9IHNyY1tpXTtcbiAgICAgICAgICBkZXN0W2ldID0gMjU1IDw8IDI0IHwgZ3JheSA8PCAxNiB8IGdyYXkgPDwgOCB8IGdyYXk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgY29udmVydFRvUkdCQTogQ2Fubm90IGluZmVyIGltYWdlIGZvcm1hdC4ga2luZDogJHtraW5kfSwgYnl0ZXNQZXJQaXhlbDogJHtieXRlc1BlclBpeGVsfSwgd2lkdGg6ICR7d2lkdGh9LCBoZWlnaHQ6ICR7aGVpZ2h0fSwgZGF0YUxlbmd0aDogJHtzcmMubGVuZ3RofWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgY29udmVydFRvUkdCQTogVW5zdXBwb3J0ZWQgaW1hZ2Uga2luZDogJHtraW5kfS4gQXZhaWxhYmxlIGtpbmRzOiBHUkFZU0NBTEVfMUJQUD0ke3V0aWxfSW1hZ2VLaW5kLkdSQVlTQ0FMRV8xQlBQfSwgUkdCXzI0QlBQPSR7dXRpbF9JbWFnZUtpbmQuUkdCXzI0QlBQfSwgUkdCQV8zMkJQUD0ke3V0aWxfSW1hZ2VLaW5kLlJHQkFfMzJCUFB9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmVzb2x2ZUVtYmVkZGVkSW1hZ2UocGRmT2JqZWN0cywgbmFtZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBwZGZPYmplY3RzLmdldChuYW1lLCAoaW1nRGF0YSkgPT4ge1xuICAgICAgICBpZiAoaW1nRGF0YSkge1xuICAgICAgICAgIGxldCBkYXRhQnVmZjtcbiAgICAgICAgICBpZiAoaW1nRGF0YS5kYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgZGF0YUJ1ZmYgPSBpbWdEYXRhLmRhdGE7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbWdEYXRhLmRhdGEgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkge1xuICAgICAgICAgICAgZGF0YUJ1ZmYgPSBuZXcgVWludDhBcnJheShpbWdEYXRhLmRhdGEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW1nRGF0YS5kYXRhPy5idWZmZXIpIHtcbiAgICAgICAgICAgIGRhdGFCdWZmID0gbmV3IFVpbnQ4QXJyYXkoaW1nRGF0YS5kYXRhLmJ1ZmZlcik7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbWdEYXRhLmJpdG1hcCkge1xuICAgICAgICAgICAgY29uc3QgY2FudmFzRmFjdG9yeSA9IHRoaXMuZG9jLmNhbnZhc0ZhY3Rvcnk7XG4gICAgICAgICAgICBjb25zdCBjYW52YXNBbmRDb250ZXh0ID0gY2FudmFzRmFjdG9yeS5jcmVhdGUoaW1nRGF0YS5iaXRtYXAud2lkdGgsIGltZ0RhdGEuYml0bWFwLmhlaWdodCk7XG4gICAgICAgICAgICBjYW52YXNBbmRDb250ZXh0LmNvbnRleHQuZHJhd0ltYWdlKGltZ0RhdGEuYml0bWFwLCAwLCAwKTtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGNhbnZhc0FuZENvbnRleHQuY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgaW1nRGF0YS5iaXRtYXAud2lkdGgsIGltZ0RhdGEuYml0bWFwLmhlaWdodCk7XG4gICAgICAgICAgICBkYXRhQnVmZiA9IG5ldyBVaW50OEFycmF5KGltYWdlRGF0YS5kYXRhLmJ1ZmZlcik7XG4gICAgICAgICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoaW1nRGF0YS5kYXRhKSkge1xuICAgICAgICAgICAgZGF0YUJ1ZmYgPSBuZXcgVWludDhBcnJheShpbWdEYXRhLmRhdGEuYnVmZmVyLCBpbWdEYXRhLmRhdGEuYnl0ZU9mZnNldCwgaW1nRGF0YS5kYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWRhdGFCdWZmKSB7XG4gICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBgSW1hZ2Ugb2JqZWN0ICR7bmFtZX06IGRhdGEgZmllbGQgaXMgZW1wdHkgb3IgaW52YWxpZC4gQXZhaWxhYmxlIGZpZWxkczogJHtPYmplY3Qua2V5cyhpbWdEYXRhKS5qb2luKFwiLCBcIil9YFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGF0YUJ1ZmYubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBJbWFnZSBvYmplY3QgJHtuYW1lfTogZGF0YSBidWZmZXIgaXMgZW1wdHkgKGxlbmd0aDogMClgKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUoeyB3aWR0aDogaW1nRGF0YS53aWR0aCwgaGVpZ2h0OiBpbWdEYXRhLmhlaWdodCwga2luZDogaW1nRGF0YS5raW5kLCBkYXRhOiBkYXRhQnVmZiB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBJbWFnZSBvYmplY3QgJHtuYW1lfSBub3QgZm91bmRgKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXIgcGFnZXMgdG8gcmFzdGVyIHNjcmVlbnNob3RzLlxuICAgKlxuICAgKiBCZWhhdmlvciBub3RlczpcbiAgICogLSBQYWdlcyBhcmUgc2VsZWN0ZWQgYWNjb3JkaW5nIHRvIFBhcnNlUGFyYW1ldGVycyAocGFydGlhbCwgZmlyc3QsIGxhc3QpLlxuICAgKiAtIFVzZSBwYXJhbXMuc2NhbGUgZm9yIHpvb207IGlmIHBhcmFtcy5kZXNpcmVkV2lkdGggaXMgc3BlY2lmaWVkIGl0IHRha2VzIHByZWNlZGVuY2UuXG4gICAqIC0gRWFjaCBTY3JlZW5zaG90UmVzdWx0IHBhZ2UgY29udGFpbnM6XG4gICAqICAgICAtIGRhdGE6IFVpbnQ4QXJyYXkgKHdoZW4gcGFyYW1zLmltYWdlQnVmZmVyID09PSB0cnVlKVxuICAgKiAgICAgLSBkYXRhVXJsOiBzdHJpbmcgKHdoZW4gcGFyYW1zLmltYWdlRGF0YVVybCA9PT0gdHJ1ZSlcbiAgICogICAgIC0gcGFnZU51bWJlciwgd2lkdGgsIGhlaWdodCwgc2NhbGVcbiAgICogLSBXb3JrcyBpbiBib3RoIE5vZGUuanMgKGNhbnZhcy50b0J1ZmZlcikgYW5kIGJyb3dzZXIgKGNhbnZhcy50b0RhdGFVUkwpIGVudmlyb25tZW50cy5cbiAgICpcbiAgICogQHBhcmFtIHBhcnNlUGFyYW1zIFBhcnNlUGFyYW1ldGVycyBjb250cm9sbGluZyBwYWdlIHNlbGVjdGlvbiBhbmQgcmVuZGVyIG9wdGlvbnMuXG4gICAqIEByZXR1cm5zIFByb21pc2U8U2NyZWVuc2hvdFJlc3VsdD4gd2l0aCByZW5kZXJlZCBwYWdlIGltYWdlcy5cbiAgICovXG4gIGFzeW5jIGdldFNjcmVlbnNob3QocGFyc2VQYXJhbXMgPSB7fSkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHNldERlZmF1bHRQYXJzZVBhcmFtZXRlcnMocGFyc2VQYXJhbXMpO1xuICAgIGNvbnN0IGRvYyA9IGF3YWl0IHRoaXMubG9hZCgpO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTY3JlZW5zaG90UmVzdWx0KGRvYy5udW1QYWdlcyk7XG4gICAgaWYgKHRoaXMuZG9jID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBERiBkb2N1bWVudCBub3QgbG9hZGVkXCIpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSByZXN1bHQudG90YWw7IGkrKykge1xuICAgICAgaWYgKHRoaXMuc2hvdWxkUGFyc2UoaSwgcmVzdWx0LnRvdGFsLCBwYXJhbXMpKSB7XG4gICAgICAgIGNvbnN0IHBhZ2UgPSBhd2FpdCB0aGlzLmRvYy5nZXRQYWdlKGkpO1xuICAgICAgICBsZXQgdmlld3BvcnQgPSBwYWdlLmdldFZpZXdwb3J0KHsgc2NhbGU6IHBhcmFtcy5zY2FsZSB9KTtcbiAgICAgICAgaWYgKHBhcmFtcy5kZXNpcmVkV2lkdGgpIHtcbiAgICAgICAgICB2aWV3cG9ydCA9IHBhZ2UuZ2V0Vmlld3BvcnQoeyBzY2FsZTogMSB9KTtcbiAgICAgICAgICBjb25zdCBzY2FsZSA9IHBhcmFtcy5kZXNpcmVkV2lkdGggLyB2aWV3cG9ydC53aWR0aDtcbiAgICAgICAgICB2aWV3cG9ydCA9IHBhZ2UuZ2V0Vmlld3BvcnQoeyBzY2FsZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYW52YXNGYWN0b3J5ID0gdGhpcy5kb2MuY2FudmFzRmFjdG9yeTtcbiAgICAgICAgY29uc3QgY2FudmFzQW5kQ29udGV4dCA9IGNhbnZhc0ZhY3RvcnkuY3JlYXRlKHZpZXdwb3J0LndpZHRoLCB2aWV3cG9ydC5oZWlnaHQpO1xuICAgICAgICBjb25zdCByZW5kZXJDb250ZXh0ID0ge1xuICAgICAgICAgIGNhbnZhc0NvbnRleHQ6IGNhbnZhc0FuZENvbnRleHQuY29udGV4dCxcbiAgICAgICAgICB2aWV3cG9ydCxcbiAgICAgICAgICBjYW52YXM6IGNhbnZhc0FuZENvbnRleHQuY2FudmFzXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlbmRlclRhc2sgPSBwYWdlLnJlbmRlcihyZW5kZXJDb250ZXh0KTtcbiAgICAgICAgYXdhaXQgcmVuZGVyVGFzay5wcm9taXNlO1xuICAgICAgICBsZXQgZGF0YSA9IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIGxldCBkYXRhVXJsID0gXCJcIjtcbiAgICAgICAgaWYgKHR5cGVvZiBjYW52YXNBbmRDb250ZXh0LmNhbnZhcy50b0J1ZmZlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgbGV0IG5vZGVCdWZmZXI7XG4gICAgICAgICAgaWYgKHBhcmFtcy5pbWFnZUJ1ZmZlcikge1xuICAgICAgICAgICAgbm9kZUJ1ZmZlciA9IGNhbnZhc0FuZENvbnRleHQuY2FudmFzLnRvQnVmZmVyKFwiaW1hZ2UvcG5nXCIpO1xuICAgICAgICAgICAgZGF0YSA9IG5ldyBVaW50OEFycmF5KG5vZGVCdWZmZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFyYW1zLmltYWdlRGF0YVVybCkge1xuICAgICAgICAgICAgaWYgKG5vZGVCdWZmZXIpIHtcbiAgICAgICAgICAgICAgZGF0YVVybCA9IGBkYXRhOmltYWdlL3BuZztiYXNlNjQsJHtub2RlQnVmZmVyLnRvU3RyaW5nKFwiYmFzZTY0XCIpfWA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBub2RlQnVmZmVyID0gY2FudmFzQW5kQ29udGV4dC5jYW52YXMudG9CdWZmZXIoXCJpbWFnZS9wbmdcIik7XG4gICAgICAgICAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShub2RlQnVmZmVyKTtcbiAgICAgICAgICAgICAgZGF0YVVybCA9IGBkYXRhOmltYWdlL3BuZztiYXNlNjQsJHtub2RlQnVmZmVyLnRvU3RyaW5nKFwiYmFzZTY0XCIpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChwYXJhbXMuaW1hZ2VCdWZmZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGNhbnZhc0FuZENvbnRleHQuY29udGV4dC5nZXRJbWFnZURhdGEoXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIGNhbnZhc0FuZENvbnRleHQuY2FudmFzLndpZHRoLFxuICAgICAgICAgICAgICBjYW52YXNBbmRDb250ZXh0LmNhbnZhcy5oZWlnaHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoaW1hZ2VEYXRhLmRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFyYW1zLmltYWdlRGF0YVVybCkge1xuICAgICAgICAgICAgZGF0YVVybCA9IGNhbnZhc0FuZENvbnRleHQuY2FudmFzLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnBhZ2VzLnB1c2goe1xuICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgZGF0YVVybCxcbiAgICAgICAgICBwYWdlTnVtYmVyOiBpLFxuICAgICAgICAgIHdpZHRoOiB2aWV3cG9ydC53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHZpZXdwb3J0LmhlaWdodCxcbiAgICAgICAgICBzY2FsZTogdmlld3BvcnQuc2NhbGVcbiAgICAgICAgfSk7XG4gICAgICAgIHBhZ2UuY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBEZXRlY3QgYW5kIGV4dHJhY3QgdGFibGVzIGZyb20gcGFnZXMgYnkgYW5hbHlzaW5nIHZlY3RvciBkcmF3aW5nIG9wZXJhdG9ycywgdGhlbiBwb3B1bGF0ZSBjZWxscyB3aXRoIHRleHQuXG4gICAqXG4gICAqIEJlaGF2aW9yIG5vdGVzOlxuICAgKiAtIFNjYW5zIG9wZXJhdG9yIGxpc3RzIGZvciByZWN0YW5nbGVzL2xpbmVzIHRoYXQgZm9ybSB0YWJsZSBncmlkcyAodXNlcyBQYXRoR2VvbWV0cnkgYW5kIExpbmVTdG9yZSkuXG4gICAqIC0gTm9ybWFsaXplcyBkZXRlY3RlZCBnZW9tZXRyeSBhbmQgbWF0Y2hlcyBwb3NpdGlvbmVkIHRleHQgdG8gdGFibGUgY2VsbHMuXG4gICAqIC0gSG9ub3JzIFBhcnNlUGFyYW1ldGVycyBmb3IgcGFnZSBzZWxlY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMgUGFyc2VQYXJhbWV0ZXJzIGNvbnRyb2xsaW5nIHdoaWNoIHBhZ2VzIHRvIGFuYWx5c2UgKHBhcnRpYWwvZmlyc3QvbGFzdCkuXG4gICAqIEByZXR1cm5zIFByb21pc2U8VGFibGVSZXN1bHQ+IGNvbnRhaW5pbmcgZGlzY292ZXJlZCB0YWJsZXMgcGVyIHBhZ2UuXG4gICAqL1xuICBhc3luYyBnZXRUYWJsZShwYXJhbXMgPSB7fSkge1xuICAgIGNvbnN0IGRvYyA9IGF3YWl0IHRoaXMubG9hZCgpO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBUYWJsZVJlc3VsdChkb2MubnVtUGFnZXMpO1xuICAgIGlmICh0aGlzLmRvYyA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQREYgZG9jdW1lbnQgbm90IGxvYWRlZFwiKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gcmVzdWx0LnRvdGFsOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLnNob3VsZFBhcnNlKGksIHJlc3VsdC50b3RhbCwgcGFyYW1zKSkge1xuICAgICAgICBjb25zdCBwYWdlID0gYXdhaXQgdGhpcy5kb2MuZ2V0UGFnZShpKTtcbiAgICAgICAgY29uc3Qgc3RvcmUgPSBhd2FpdCB0aGlzLmdldFBhZ2VUYWJsZXMocGFnZSk7XG4gICAgICAgIHN0b3JlLm5vcm1hbGl6ZSgpO1xuICAgICAgICBjb25zdCB0YWJsZURhdGFBcnIgPSBzdG9yZS5nZXRUYWJsZURhdGEoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5maWxsUGFnZVRhYmxlcyhwYWdlLCB0YWJsZURhdGFBcnIpO1xuICAgICAgICBmb3IgKGNvbnN0IHRhYmxlIG9mIHRhYmxlRGF0YUFycikge1xuICAgICAgICAgIGNvbnN0IHBhZ2VUYWJsZVJlc3VsdCA9IHsgbnVtOiBpLCB0YWJsZXM6IHRhYmxlLnRvQXJyYXkoKSB9O1xuICAgICAgICAgIHJlc3VsdC5wYWdlcy5wdXNoKHBhZ2VUYWJsZVJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcGFnZS5jbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZ2V0UGF0aEdlb21ldHJ5KG1tKSB7XG4gICAgY29uc3Qgd2lkdGggPSBtbVsyXSAtIG1tWzBdO1xuICAgIGNvbnN0IGhlaWdodCA9IG1tWzNdIC0gbW1bMV07XG4gICAgaWYgKG1tWzBdID09PSBJbmZpbml0eSkge1xuICAgICAgcmV0dXJuIFBhdGhHZW9tZXRyeS51bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICh3aWR0aCA+IDUgJiYgaGVpZ2h0ID4gNSkge1xuICAgICAgcmV0dXJuIFBhdGhHZW9tZXRyeS5yZWN0YW5nbGU7XG4gICAgfSBlbHNlIGlmICh3aWR0aCA+IDUgJiYgaGVpZ2h0ID09PSAwKSB7XG4gICAgICByZXR1cm4gUGF0aEdlb21ldHJ5LmhsaW5lO1xuICAgIH0gZWxzZSBpZiAod2lkdGggPT09IDAgJiYgaGVpZ2h0ID4gNSkge1xuICAgICAgcmV0dXJuIFBhdGhHZW9tZXRyeS52bGluZTtcbiAgICB9XG4gICAgcmV0dXJuIFBhdGhHZW9tZXRyeS51bmRlZmluZWQ7XG4gIH1cbiAgYXN5bmMgZ2V0UGFnZVRhYmxlcyhwYWdlKSB7XG4gICAgY29uc3QgbGluZVN0b3JlID0gbmV3IExpbmVTdG9yZSgpO1xuICAgIGNvbnN0IHZpZXdwb3J0ID0gcGFnZS5nZXRWaWV3cG9ydCh7IHNjYWxlOiAxIH0pO1xuICAgIGxldCB0cmFuc2Zvcm1NYXRyaXggPSBbMSwgMCwgMCwgMSwgMCwgMF07XG4gICAgY29uc3QgdHJhbnNmb3JtU3RhY2sgPSBbXTtcbiAgICBjb25zdCBvcExpc3QgPSBhd2FpdCBwYWdlLmdldE9wZXJhdG9yTGlzdCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3BMaXN0LmZuQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGZuID0gb3BMaXN0LmZuQXJyYXlbaV07XG4gICAgICBjb25zdCBhcmdzID0gb3BMaXN0LmFyZ3NBcnJheVtpXTtcbiAgICAgIGNvbnN0IG9wID0gYXJncz8uWzBdID8/IDA7XG4gICAgICBjb25zdCBtbSA9IGFyZ3M/LlsyXSA/PyBbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV07XG4gICAgICBpZiAoZm4gPT09IE9QUy5jb25zdHJ1Y3RQYXRoKSB7XG4gICAgICAgIGlmIChvcCA9PT0gT1BTLmZpbGwpIDtcbiAgICAgICAgaWYgKG9wICE9PSBPUFMuc3Ryb2tlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGcgPSB0aGlzLmdldFBhdGhHZW9tZXRyeShtbSk7XG4gICAgICAgIGlmIChwZyA9PT0gUGF0aEdlb21ldHJ5LnJlY3RhbmdsZSkge1xuICAgICAgICAgIGNvbnN0IHJlY3QgPSBuZXcgUmVjdGFuZ2xlKG5ldyBQb2ludChtbVswXSwgbW1bMV0pLCBtbVsyXSAtIG1tWzBdLCBtbVszXSAtIG1tWzFdKTtcbiAgICAgICAgICByZWN0LnRyYW5zZm9ybSh0cmFuc2Zvcm1NYXRyaXgpO1xuICAgICAgICAgIHJlY3QudHJhbnNmb3JtKHZpZXdwb3J0LnRyYW5zZm9ybSk7XG4gICAgICAgICAgbGluZVN0b3JlLmFkZFJlY3RhbmdsZShyZWN0KTtcbiAgICAgICAgfSBlbHNlIGlmIChwZyA9PT0gUGF0aEdlb21ldHJ5LmhsaW5lIHx8IHBnID09PSBQYXRoR2VvbWV0cnkudmxpbmUpIHtcbiAgICAgICAgICBjb25zdCBmcm9tID0gbmV3IFBvaW50KG1tWzBdLCBtbVsxXSk7XG4gICAgICAgICAgY29uc3QgdG8gPSBuZXcgUG9pbnQobW1bMl0sIG1tWzNdKTtcbiAgICAgICAgICBjb25zdCBsaW5lID0gbmV3IExpbmUoZnJvbSwgdG8pO1xuICAgICAgICAgIGxpbmUudHJhbnNmb3JtKHRyYW5zZm9ybU1hdHJpeCk7XG4gICAgICAgICAgbGluZS50cmFuc2Zvcm0odmlld3BvcnQudHJhbnNmb3JtKTtcbiAgICAgICAgICBsaW5lU3RvcmUuYWRkKGxpbmUpO1xuICAgICAgICB9IGVsc2UgO1xuICAgICAgfSBlbHNlIGlmIChmbiA9PT0gT1BTLnNldExpbmVXaWR0aCkgO1xuICAgICAgZWxzZSBpZiAoZm4gPT09IE9QUy5zYXZlKSB7XG4gICAgICAgIHRyYW5zZm9ybVN0YWNrLnB1c2godHJhbnNmb3JtTWF0cml4KTtcbiAgICAgIH0gZWxzZSBpZiAoZm4gPT09IE9QUy5yZXN0b3JlKSB7XG4gICAgICAgIGNvbnN0IHJlc3RvcmVkTWF0cml4ID0gdHJhbnNmb3JtU3RhY2sucG9wKCk7XG4gICAgICAgIGlmIChyZXN0b3JlZE1hdHJpeCkge1xuICAgICAgICAgIHRyYW5zZm9ybU1hdHJpeCA9IHJlc3RvcmVkTWF0cml4O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGZuID09PSBPUFMudHJhbnNmb3JtKSB7XG4gICAgICAgIHRyYW5zZm9ybU1hdHJpeCA9IFV0aWwudHJhbnNmb3JtKHRyYW5zZm9ybU1hdHJpeCwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsaW5lU3RvcmU7XG4gIH1cbiAgLy8gcHJpdmF0ZSBhc3luYyBnZXRQYWdlR2VvbWV0cnkocGFnZTogUERGUGFnZVByb3h5KTogUHJvbWlzZTxMaW5lU3RvcmU+IHtcbiAgLy8gXHRjb25zdCBsaW5lU3RvcmU6IExpbmVTdG9yZSA9IG5ldyBMaW5lU3RvcmUoKTtcbiAgLy8gXHRjb25zdCBvcExpc3QgPSBhd2FpdCBwYWdlLmdldE9wZXJhdG9yTGlzdCgpO1xuICAvLyBcdGNvbnN0IHZpZXdwb3J0ID0gcGFnZS5nZXRWaWV3cG9ydCh7IHNjYWxlOiAxIH0pO1xuICAvLyBcdGxldCB0cmFuc2Zvcm1NYXRyaXggPSBbMSwgMCwgMCwgMSwgMCwgMF07XG4gIC8vIFx0Y29uc3QgdHJhbnNmb3JtU3RhY2s6IEFycmF5PEFycmF5PG51bWJlcj4+ID0gW107XG4gIC8vIFx0bGV0IGN1cnJlbnRfeDogbnVtYmVyID0gMDtcbiAgLy8gXHRsZXQgY3VycmVudF95OiBudW1iZXIgPSAwO1xuICAvLyBcdGZvciAobGV0IGogPSAwOyBqIDwgb3BMaXN0LmZuQXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgLy8gXHRcdGNvbnN0IGZuID0gb3BMaXN0LmZuQXJyYXlbal07XG4gIC8vIFx0XHRjb25zdCBhcmdzID0gb3BMaXN0LmFyZ3NBcnJheVtqXTtcbiAgLy8gXHRcdGlmIChmbiA9PT0gcGRmanMuT1BTLmNvbnN0cnVjdFBhdGgpIHtcbiAgLy8gXHRcdFx0d2hpbGUgKGFyZ3NbMF0ubGVuZ3RoKSB7XG4gIC8vIFx0XHRcdFx0Y29uc3Qgb3AgPSBhcmdzWzBdLnNoaWZ0KCk7XG4gIC8vIFx0XHRcdFx0Y29uc3QgY29tYmluZWRNYXRyaXggPSBwZGZqcy5VdGlsLnRyYW5zZm9ybSh2aWV3cG9ydC50cmFuc2Zvcm0sIHRyYW5zZm9ybU1hdHJpeCk7XG4gIC8vIFx0XHRcdFx0aWYgKG9wID09PSBwZGZqcy5PUFMucmVjdGFuZ2xlKSB7XG4gIC8vIFx0XHRcdFx0XHRjb25zdCB4ID0gYXJnc1sxXS5zaGlmdCgpO1xuICAvLyBcdFx0XHRcdFx0Y29uc3QgeSA9IGFyZ3NbMV0uc2hpZnQoKTtcbiAgLy8gXHRcdFx0XHRcdGNvbnN0IHdpZHRoID0gYXJnc1sxXS5zaGlmdCgpO1xuICAvLyBcdFx0XHRcdFx0Y29uc3QgaGVpZ2h0ID0gYXJnc1sxXS5zaGlmdCgpO1xuICAvLyBcdFx0XHRcdFx0aWYgKE1hdGgubWluKHdpZHRoLCBoZWlnaHQpIDw9IDIpIHtcbiAgLy8gXHRcdFx0XHRcdFx0Ly8gVE9ETyByZW1vdmVcbiAgLy8gXHRcdFx0XHRcdFx0ZGVidWdnZXI7XG4gIC8vIFx0XHRcdFx0XHR9XG4gIC8vIFx0XHRcdFx0XHRjb25zdCByZWN0ID0gbmV3IFJlY3RhbmdsZShuZXcgUG9pbnQoeCwgeSksIHdpZHRoLCBoZWlnaHQpO1xuICAvLyBcdFx0XHRcdFx0cmVjdC50cmFuc2Zvcm0oY29tYmluZWRNYXRyaXgpO1xuICAvLyBcdFx0XHRcdFx0Ly9yZWN0LnRyYW5zZm9ybSh2aWV3cG9ydC50cmFuc2Zvcm0pO1xuICAvLyBcdFx0XHRcdFx0bGluZVN0b3JlLmFkZFJlY3RhbmdsZShyZWN0KTtcbiAgLy8gXHRcdFx0XHR9IGVsc2UgaWYgKG9wID09PSBwZGZqcy5PUFMubW92ZVRvKSB7XG4gIC8vIFx0XHRcdFx0XHRjdXJyZW50X3ggPSBhcmdzWzFdLnNoaWZ0KCk7XG4gIC8vIFx0XHRcdFx0XHRjdXJyZW50X3kgPSBhcmdzWzFdLnNoaWZ0KCk7XG4gIC8vIFx0XHRcdFx0fSBlbHNlIGlmIChvcCA9PT0gcGRmanMuT1BTLmxpbmVUbykge1xuICAvLyBcdFx0XHRcdFx0Y29uc3QgeCA9IGFyZ3NbMV0uc2hpZnQoKTtcbiAgLy8gXHRcdFx0XHRcdGNvbnN0IHkgPSBhcmdzWzFdLnNoaWZ0KCk7XG4gIC8vIFx0XHRcdFx0XHQvL2RlZmF1bHQgdHJhc2Zvcm1cbiAgLy8gXHRcdFx0XHRcdGNvbnN0IGZyb20gPSBuZXcgUG9pbnQoY3VycmVudF94LCBjdXJyZW50X3kpO1xuICAvLyBcdFx0XHRcdFx0Y29uc3QgdG8gPSBuZXcgUG9pbnQoeCwgeSk7XG4gIC8vIFx0XHRcdFx0XHRjb25zdCBsaW5lID0gbmV3IExpbmUoZnJvbSwgdG8pO1xuICAvLyBcdFx0XHRcdFx0bGluZS50cmFuc2Zvcm0oY29tYmluZWRNYXRyaXgpO1xuICAvLyBcdFx0XHRcdFx0Ly9saW5lLnRyYW5zZm9ybSh2aWV3cG9ydC50cmFuc2Zvcm0pO1xuICAvLyBcdFx0XHRcdFx0Ly8gLy8gdmlld3BvcnQgdHJhbnNmb3JtXG4gIC8vIFx0XHRcdFx0XHQvLyBjb25zdCBfZnJvbSA9IHZpZXdwb3J0LmNvbnZlcnRUb1ZpZXdwb3J0UG9pbnQobGluZS5mcm9tLngsIGxpbmUuZnJvbS55KVxuICAvLyBcdFx0XHRcdFx0Ly8gY29uc3QgX3RvID0gdmlld3BvcnQuY29udmVydFRvVmlld3BvcnRQb2ludChsaW5lLnRvLngsIGxpbmUudG8ueSlcbiAgLy8gXHRcdFx0XHRcdC8vXG4gIC8vIFx0XHRcdFx0XHQvLyBjb25zdCB0cmFuc2Zvcm1lZExpbmUgPSBuZXcgTGluZShuZXcgUG9pbnQoX2Zyb21bMF0sIF9mcm9tWzFdKSwgbmV3IFBvaW50KF90b1swXSwgX3RvWzFdKSlcbiAgLy8gXHRcdFx0XHRcdGxpbmVTdG9yZS5hZGQobGluZSk7XG4gIC8vIFx0XHRcdFx0XHRjdXJyZW50X3ggPSB4O1xuICAvLyBcdFx0XHRcdFx0Y3VycmVudF95ID0geTtcbiAgLy8gXHRcdFx0XHR9XG4gIC8vIFx0XHRcdH1cbiAgLy8gXHRcdH0gZWxzZSBpZiAoZm4gPT09IHBkZmpzLk9QUy5zYXZlKSB7XG4gIC8vIFx0XHRcdHRyYW5zZm9ybVN0YWNrLnB1c2godHJhbnNmb3JtTWF0cml4KTtcbiAgLy8gXHRcdH0gZWxzZSBpZiAoZm4gPT09IHBkZmpzLk9QUy5yZXN0b3JlKSB7XG4gIC8vIFx0XHRcdGNvbnN0IHJlc3RvcmVkTWF0cml4ID0gdHJhbnNmb3JtU3RhY2sucG9wKCk7XG4gIC8vIFx0XHRcdGlmIChyZXN0b3JlZE1hdHJpeCkge1xuICAvLyBcdFx0XHRcdHRyYW5zZm9ybU1hdHJpeCA9IHJlc3RvcmVkTWF0cml4O1xuICAvLyBcdFx0XHR9XG4gIC8vIFx0XHR9IGVsc2UgaWYgKGZuID09PSBwZGZqcy5PUFMudHJhbnNmb3JtKSB7XG4gIC8vIFx0XHRcdC8vdHJhbnNmb3JtTWF0cml4ID0gdGhpcy50cmFuc2Zvcm1fZm4odHJhbnNmb3JtTWF0cml4LCBhcmdzKTtcbiAgLy8gXHRcdFx0dHJhbnNmb3JtTWF0cml4ID0gcGRmanMuVXRpbC50cmFuc2Zvcm0odHJhbnNmb3JtTWF0cml4LCBhcmdzKTtcbiAgLy8gXHRcdH1cbiAgLy8gXHR9XG4gIC8vIFx0cmV0dXJuIGxpbmVTdG9yZTtcbiAgLy8gfVxuICBhc3luYyBmaWxsUGFnZVRhYmxlcyhwYWdlLCBwYWdlVGFibGVzKSB7XG4gICAgY29uc3Qgdmlld3BvcnQgPSBwYWdlLmdldFZpZXdwb3J0KHsgc2NhbGU6IDEgfSk7XG4gICAgY29uc3QgdGV4dENvbnRlbnQgPSBhd2FpdCBwYWdlLmdldFRleHRDb250ZW50KHtcbiAgICAgIGluY2x1ZGVNYXJrZWRDb250ZW50OiBmYWxzZSxcbiAgICAgIGRpc2FibGVOb3JtYWxpemF0aW9uOiBmYWxzZVxuICAgIH0pO1xuICAgIGZvciAoY29uc3QgdGV4dEl0ZW0gb2YgdGV4dENvbnRlbnQuaXRlbXMpIHtcbiAgICAgIGlmICghKFwic3RyXCIgaW4gdGV4dEl0ZW0pKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IHR4ID0gVXRpbC50cmFuc2Zvcm0oXG4gICAgICAgIFV0aWwudHJhbnNmb3JtKHZpZXdwb3J0LnRyYW5zZm9ybSwgdGV4dEl0ZW0udHJhbnNmb3JtKSxcbiAgICAgICAgWzEsIDAsIDAsIC0xLCAwLCAwXVxuICAgICAgKTtcbiAgICAgIGZvciAoY29uc3QgcGFnZVRhYmxlIG9mIHBhZ2VUYWJsZXMpIHtcbiAgICAgICAgY29uc3QgY2VsbCA9IHBhZ2VUYWJsZS5maW5kQ2VsbCh0eFs0XSwgdHhbNV0pO1xuICAgICAgICBpZiAoY2VsbCkge1xuICAgICAgICAgIGNlbGwudGV4dC5wdXNoKHRleHRJdGVtLnN0cik7XG4gICAgICAgICAgaWYgKHRleHRJdGVtLmhhc0VPTCkge1xuICAgICAgICAgICAgY2VsbC50ZXh0LnB1c2goXCJcXG5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5leHBvcnRzLlBERlBhcnNlID0gUERGUGFyc2U7XG5leHBvcnRzLlZlcmJvc2l0eUxldmVsID0gVmVyYm9zaXR5TGV2ZWw7XG5leHBvcnRzLmdldEhlYWRlciA9IGdldEhlYWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmNqcy5tYXBcbiJdLCJuYW1lcyI6WyJfX3R5cGVFcnJvciIsIm1zZyIsIlR5cGVFcnJvciIsIl9fYWNjZXNzQ2hlY2siLCJvYmoiLCJtZW1iZXIiLCJoYXMiLCJfX3ByaXZhdGVHZXQiLCJnZXR0ZXIiLCJjYWxsIiwiZ2V0IiwiX19wcml2YXRlQWRkIiwidmFsdWUiLCJXZWFrU2V0IiwiYWRkIiwic2V0IiwiX19wcml2YXRlU2V0Iiwic2V0dGVyIiwiX19wcml2YXRlTWV0aG9kIiwibWV0aG9kIiwiX19wcml2YXRlV3JhcHBlciIsIl8iLCJfY2FwYWJpbGl0eSIsIl9tZXNzYWdlSGFuZGxlciIsIl9wb3J0IiwiX3dlYldvcmtlciIsIl9mYWtlV29ya2VySWQiLCJfaXNXb3JrZXJEaXNhYmxlZCIsIl93b3JrZXJQb3J0cyIsIl9QREZXb3JrZXJfaW5zdGFuY2VzIiwicmVzb2x2ZV9mbiIsImluaXRpYWxpemVGcm9tUG9ydF9mbiIsImluaXRpYWxpemVfZm4iLCJzZXR1cEZha2VXb3JrZXJfZm4iLCJfUERGV29ya2VyX3N0YXRpYyIsIm1haW5UaHJlYWRXb3JrZXJNZXNzYWdlSGFuZGxlcl9nZXQiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsIl9kb2N1bWVudEN1cnJlbnRTY3JpcHQiLCJkb2N1bWVudCIsImN1cnJlbnRTY3JpcHQiLCJfX3dlYnBhY2tfbW9kdWxlc19fIiwibW9kdWxlMiIsIl9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cyIsIl9fd2VicGFja19yZXF1aXJlX18yIiwiaXNDYWxsYWJsZSIsIml0IiwiYUNhbGxhYmxlIiwiYW5PYmplY3QiLCJ0cnlUb1N0cmluZyIsImdldEl0ZXJhdG9yTWV0aG9kIiwiJFR5cGVFcnJvciIsImFyZ3VtZW50IiwidXNpbmdJdGVyYXRvciIsIml0ZXJhdG9yTWV0aG9kIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiX191bnVzZWRfd2VicGFja19tb2R1bGUiLCIkIiwiaXRlcmF0ZSIsImdldEl0ZXJhdG9yRGlyZWN0IiwiaXRlcmF0b3JDbG9zZSIsIml0ZXJhdG9ySGVscGVyV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IiLCJmaW5kV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IiLCJ0YXJnZXQiLCJwcm90byIsInJlYWwiLCJmb3JjZWQiLCJmaW5kIiwicHJlZGljYXRlIiwiZXJyb3IiLCJyZWNvcmQiLCJjb3VudGVyIiwic3RvcCIsIklTX1JFQ09SRCIsIklOVEVSUlVQVEVEIiwicmVzdWx0IiwidW5jdXJyeVRoaXMiLCJmYWlscyIsImhhc093biIsIkRFU0NSSVBUT1JTIiwiQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUiLCJDT05GSUdVUkFCTEUiLCJpbnNwZWN0U291cmNlIiwiSW50ZXJuYWxTdGF0ZU1vZHVsZSIsImVuZm9yY2VJbnRlcm5hbFN0YXRlIiwiZW5mb3JjZSIsImdldEludGVybmFsU3RhdGUiLCIkU3RyaW5nIiwiU3RyaW5nIiwic3RyaW5nU2xpY2UiLCJzbGljZSIsInJlcGxhY2UiLCJqb2luIiwiQ09ORklHVVJBQkxFX0xFTkdUSCIsIlRFTVBMQVRFIiwic3BsaXQiLCJtYWtlQnVpbHRJbiIsIm5hbWUiLCJvcHRpb25zIiwiY29uZmlndXJhYmxlIiwiYXJpdHkiLCJjb25zdHJ1Y3RvciIsIndyaXRhYmxlIiwicHJvdG90eXBlIiwic3RhdGUiLCJzb3VyY2UiLCJGdW5jdGlvbiIsInRvU3RyaW5nIiwiRnVuY3Rpb25Qcm90b3R5cGUiLCJnZXREZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiRVhJU1RTIiwiUFJPUEVSIiwic29tZXRoaW5nIiwiZ2V0QnVpbHRJbiIsImdsb2JhbFRoaXMyIiwiYW5VaW50OEFycmF5Iiwibm90RGV0YWNoZWQiLCJudW1iZXJUb1N0cmluZyIsIlVpbnQ4QXJyYXkyIiwiVWludDhBcnJheSIsIklOQ09SUkVDVF9CRUhBVklPUl9PUl9ET0VTTlRfRVhJU1RTIiwidG9IZXgiLCJidWZmZXIiLCJpIiwiaGV4IiwiZm4iLCJJVEVSQVRPUl9JTlNURUFEX09GX1JFQ09SRCIsIml0ZXJhdG9yIiwibmV4dCIsInN0ZXAiLCJkb25lIiwiZ2V0SXRlcmF0b3JGbGF0dGVuYWJsZSIsImNyZWF0ZUl0ZXJhdG9yUHJveHkiLCJJU19QVVJFIiwiaXRlcmF0b3JIZWxwZXJUaHJvd3NPbkludmFsaWRJdGVyYXRvciIsIkZMQVRfTUFQX1dJVEhPVVRfVEhST1dJTkdfT05fSU5WQUxJRF9JVEVSQVRPUiIsImZsYXRNYXBXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciIsIkZPUkNFRCIsIkl0ZXJhdG9yUHJveHkiLCJtYXBwZXIiLCJpbm5lciIsImZsYXRNYXAiLCJ0ZXN0IiwiYmluZCIsImhhc093blByb3BlcnR5IiwiY2xhc3NvZiIsImlzUHJvdG90eXBlT2YiLCJQcm90b3R5cGUiLCJtZXRob2ROYW1lIiwiSXRlcmF0b3IiLCJjZWlsMiIsIk1hdGgiLCJjZWlsIiwiZmxvb3IyIiwiZmxvb3IiLCJ0cnVuYyIsIngiLCJuIiwiVVNFX1NZTUJPTF9BU19VSUQiLCIkT2JqZWN0IiwiJFN5bWJvbCIsImdldE1ldGhvZCIsImlzTnVsbE9yVW5kZWZpbmVkIiwiSXRlcmF0b3JzIiwid2VsbEtub3duU3ltYm9sIiwiSVRFUkFUT1IiLCJhbHBoYWJldCIsImludGVybmFsT2JqZWN0S2V5cyIsImVudW1CdWdLZXlzIiwia2V5cyIsIk8iLCJleGVjIiwia2xhc3MiLCJldmVyeVdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yIiwiZXZlcnkiLCJzdG9wcGVkIiwiTkFUSVZFX1dFQUtfTUFQIiwiaXNPYmplY3QiLCJjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkiLCJzaGFyZWQiLCJzaGFyZWRLZXkiLCJoaWRkZW5LZXlzIiwiT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQiLCJUeXBlRXJyb3IyIiwiV2Vha01hcDIiLCJXZWFrTWFwIiwiZ2V0dGVyRm9yIiwiVFlQRSIsInR5cGUiLCJzdG9yZSIsIm1ldGFkYXRhIiwiZmFjYWRlIiwiU1RBVEUiLCJudW1iZXIiLCJpdGVycyIsImtpbmQiLCJWOCIsIkVOVklST05NRU5UIiwic3RydWN0dXJlZENsb25lMiIsInN0cnVjdHVyZWRDbG9uZSIsIkFycmF5QnVmZmVyIiwiY2xvbmUiLCJ0cmFuc2ZlciIsImJ5dGVMZW5ndGgiLCJhcHBseSIsIm5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlIiwicGVyZm9ybSIsIlByb21pc2UyIiwiUHJvbWlzZSIsIkFDQ0VQVF9BUkdVTUVOVFMiLCJzdGF0IiwiY2FsbGJhY2tmbiIsImFyZ3MiLCJwcm9taXNlQ2FwYWJpbGl0eSIsImYiLCJyZWplY3QiLCJyZXNvbHZlIiwicHJvbWlzZSIsInVuaW9uIiwic2V0TWV0aG9kR2V0S2V5c0JlZm9yZUNsb25pbmciLCJzZXRNZXRob2RBY2NlcHRTZXRMaWtlIiwiY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyIsIk1BUF9XSVRIT1VUX1RIUk9XSU5HX09OX0lOVkFMSURfSVRFUkFUT1IiLCJtYXBXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciIsIm1hcCIsInRvSW5kZXhlZE9iamVjdCIsImluZGV4T2YiLCJwdXNoIiwib2JqZWN0IiwibmFtZXMiLCJrZXkiLCJkZXNjcmlwdG9yIiwiVE9fU1RSSU5HX1RBRyIsIkYiLCJnZXRQcm90b3R5cGVPZiIsIlN5bnRheEVycm9yMiIsIlN5bnRheEVycm9yIiwicGFyc2VJbnQyIiwicGFyc2VJbnQiLCJtaW4iLCJOT1RfSEVYIiwic3RyaW5nIiwiaW50byIsInN0cmluZ0xlbmd0aCIsIm1heExlbmd0aCIsImJ5dGVzIiwicmVhZCIsIndyaXR0ZW4iLCJoZXhpdHMiLCJkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlIiwiaHRtbCIsImRvY3VtZW50Q3JlYXRlRWxlbWVudCIsIkdUIiwiTFQiLCJQUk9UT1RZUEUiLCJTQ1JJUFQiLCJJRV9QUk9UTyIsIkVtcHR5Q29uc3RydWN0b3IiLCJzY3JpcHRUYWciLCJjb250ZW50IiwiTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWCIsImFjdGl2ZVhEb2N1bWVudDIiLCJ3cml0ZSIsImNsb3NlIiwidGVtcCIsInBhcmVudFdpbmRvdyIsIk51bGxQcm90b09iamVjdFZpYUlGcmFtZSIsImlmcmFtZSIsIkpTIiwiaWZyYW1lRG9jdW1lbnQiLCJzdHlsZSIsImRpc3BsYXkiLCJhcHBlbmRDaGlsZCIsInNyYyIsImNvbnRlbnRXaW5kb3ciLCJvcGVuIiwiYWN0aXZlWERvY3VtZW50IiwiTnVsbFByb3RvT2JqZWN0IiwiQWN0aXZlWE9iamVjdCIsImRvbWFpbiIsImNyZWF0ZSIsIlByb3BlcnRpZXMiLCJpc1N1cGVyc2V0T2YiLCJJTkNPUlJFQ1QiLCJGSUxURVJfV0lUSE9VVF9USFJPV0lOR19PTl9JTlZBTElEX0lURVJBVE9SIiwiZmlsdGVyV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IiLCJmaWx0ZXIiLCIkZGVmYXVsdCIsImlzQXJyYXlJdGVyYXRvck1ldGhvZCIsImxlbmd0aE9mQXJyYXlMaWtlIiwiZ2V0SXRlcmF0b3IiLCJSZXN1bHQiLCJSZXN1bHRQcm90b3R5cGUiLCJpdGVyYWJsZSIsInVuYm91bmRGdW5jdGlvbiIsInRoYXQiLCJBU19FTlRSSUVTIiwiSVNfSVRFUkFUT1IiLCJpdGVyRm4iLCJpbmRleCIsImNvbmRpdGlvbiIsImNhbGxGbiIsImlzU3ltYm9sIiwib3JkaW5hcnlUb1ByaW1pdGl2ZSIsIlRPX1BSSU1JVElWRSIsImlucHV0IiwicHJlZiIsImV4b3RpY1RvUHJpbSIsInRvT2JqZWN0IiwiQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSIiwiT2JqZWN0UHJvdG90eXBlIiwicmVwbGFjZW1lbnQiLCJpc0ZvcmNlZCIsImZlYXR1cmUiLCJkZXRlY3Rpb24iLCJkYXRhIiwibm9ybWFsaXplIiwiUE9MWUZJTEwiLCJOQVRJVkUiLCJ0b0xvd2VyQ2FzZSIsImNvbW1vbkFscGhhYmV0IiwiYmFzZTY0QWxwaGFiZXQiLCJiYXNlNjRVcmxBbHBoYWJldCIsImludmVyc2UiLCJjaGFyYWN0ZXJzIiwiY2hhckF0IiwiaTJjIiwiYzJpIiwiaTJjVXJsIiwiYzJpVXJsIiwicGFzc2VkIiwicmVxdWlyZWQiLCJuYXZpZ2F0b3IyIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwidW5jdXJyeVRoaXNBY2Nlc3NvciIsInJlcXVpcmVPYmplY3RDb2VyY2libGUiLCJhUG9zc2libGVQcm90b3R5cGUiLCJzZXRQcm90b3R5cGVPZiIsIkNPUlJFQ1RfU0VUVEVSIiwiQXJyYXkiLCJfX3Byb3RvX18iLCIkUmFuZ2VFcnJvciIsIlJhbmdlRXJyb3IiLCIkSW5maW5pdHkiLCJJbmZpbml0eSIsIiROYU4iLCJOYU4iLCJhYnMiLCJwb3ciLCJQT1dfMl8xMDIzIiwiTUFYX1NBRkVfSU5URUdFUiIsIk1BWF9ET1VCTEUiLCJOdW1iZXIiLCJNQVhfVkFMVUUiLCJNQVhfVUxQIiwiTk9UX0FfTlVNQkVSIiwiTUlOVVNfSU5GSU5JVFkiLCJQTFVTX0lORklOSVRZIiwiTUlOVVNfWkVSTyIsIkZJTklURSIsInR3b3N1bSIsInkiLCJoaSIsImxvIiwic3VtUHJlY2lzZSIsIml0ZW1zIiwibnVtYmVycyIsImNvdW50IiwibjIiLCJwYXJ0aWFscyIsIm92ZXJmbG93Iiwic3VtIiwidG1wIiwiYWN0dWFsbHlVc2VkUGFydGlhbHMiLCJqIiwic2lnbiIsIiR0aGlzIiwiZHVtbXkiLCJXcmFwcGVyIiwiTmV3VGFyZ2V0IiwiTmV3VGFyZ2V0UHJvdG90eXBlIiwiTkFUSVZFX0FSUkFZX0JVRkZFUiIsImFycmF5QnVmZmVyQnl0ZUxlbmd0aCIsIkRhdGFWaWV3MiIsIkRhdGFWaWV3IiwiaWQiLCJwb3N0Zml4IiwicmFuZG9tIiwiYVNldCIsIlNldEhlbHBlcnMiLCJzaXplIiwiZ2V0U2V0UmVjb3JkIiwiaXRlcmF0ZVNldCIsIml0ZXJhdGVTaW1wbGUiLCJyZW1vdmUiLCJkaWZmZXJlbmNlIiwib3RoZXIiLCJvdGhlclJlYyIsImUiLCJpbmNsdWRlcyIsImlzUG9zc2libGVQcm90b3R5cGUiLCJzb21lV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IiLCJzb21lIiwic3ltbWV0cmljRGlmZmVyZW5jZSIsImtleXNJdGVyIiwiZnVuY3Rpb25Ub1N0cmluZyIsImV4cG9ydHMyIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwidG9JbnRlZ2VyT3JJbmZpbml0eSIsIklOVkFMSURfU0laRSIsIm1heCIsIlNldFJlY29yZCIsImludFNpemUiLCJudW1TaXplIiwiaXNTdWJzZXRPZiIsImlzRGlzam9pbnRGcm9tIiwiZG9jdW1lbnQyIiwiY3JlYXRlRWxlbWVudCIsInNldEFycmF5TGVuZ3RoIiwiZG9lc05vdEV4Y2VlZFNhZmVJbnRlZ2VyIiwiSU5DT1JSRUNUX1RPX0xFTkdUSCIsInByb3BlckVycm9yT25Ob25Xcml0YWJsZUxlbmd0aCIsIml0ZW0iLCJsZW4iLCJhcmdDb3VudCIsIkFycmF5UHJvdG90eXBlIiwidXNlckFnZW50U3RhcnRzV2l0aCIsIkJ1biIsInZlcnNpb24iLCJEZW5vIiwicHJvY2VzcyIsIndpbmRvdyIsImFTdHJpbmciLCIkZnJvbUhleCIsInNldEZyb21IZXgiLCJ2YWwiLCJ2YWx1ZU9mIiwiaXNBcnJheSIsIlNldFByb3RvdHlwZSIsIlNldCIsImdldEJ1aWx0SW5Ob2RlTW9kdWxlIiwiUFJPUEVSX1NUUlVDVFVSRURfQ0xPTkVfVFJBTlNGRVIiLCIkQXJyYXlCdWZmZXIiLCIkTWVzc2FnZUNoYW5uZWwiLCJNZXNzYWdlQ2hhbm5lbCIsImRldGFjaCIsIldvcmtlclRocmVhZHMiLCJjaGFubmVsIiwiJGRldGFjaCIsInRyYW5zZmVyYWJsZSIsInBvcnQxIiwicG9zdE1lc3NhZ2UiLCJWOF9WRVJTSU9OIiwic3ltYm9sIiwic2hhbSIsIlNJTEVOVF9PTl9OT05fV1JJVEFCTEVfTEVOR1RIX1NFVCIsIk1FVEhPRF9OQU1FIiwiRXhwZWN0ZWRFcnJvciIsIkl0ZXJhdG9yMiIsIkl0ZXJhdG9yUHJvdG90eXBlIiwiQ0xPU0VEIiwiY2hlY2siLCJnbG9iYWxUaGlzIiwic2VsZiIsImdsb2JhbCIsImRlZmluZUJ1aWx0SW4iLCJ2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCIsIiRVUkxTZWFyY2hQYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUiLCJhcHBlbmQiLCIkZGVsZXRlIiwiZm9yRWFjaCIsInBhcmFtcyIsIiR2YWx1ZSIsImVudHJpZXMiLCJ2IiwiayIsImRpbmRleCIsImZvdW5kIiwiZW50cmllc0xlbmd0aCIsImVudHJ5IiwiZW51bWVyYWJsZSIsInVuc2FmZSIsIndpdGhSZXNvbHZlcnMiLCJkZWZpbmVCdWlsdEluQWNjZXNzb3IiLCJ1aWQiLCJJbnQ4QXJyYXkyIiwiSW50OEFycmF5IiwiSW50OEFycmF5UHJvdG90eXBlIiwiVWludDhDbGFtcGVkQXJyYXkyIiwiVWludDhDbGFtcGVkQXJyYXkiLCJVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSIsIlR5cGVkQXJyYXkiLCJUeXBlZEFycmF5UHJvdG90eXBlIiwiVFlQRURfQVJSQVlfVEFHIiwiVFlQRURfQVJSQVlfQ09OU1RSVUNUT1IiLCJOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTIiwib3BlcmEiLCJUWVBFRF9BUlJBWV9UQUdfUkVRVUlSRUQiLCJOQU1FIiwiQ29uc3RydWN0b3IiLCJUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCIsIkludDE2QXJyYXkiLCJVaW50MTZBcnJheSIsIkludDMyQXJyYXkiLCJVaW50MzJBcnJheSIsIkZsb2F0MzJBcnJheSIsIkZsb2F0NjRBcnJheSIsIkJpZ0ludEFycmF5Q29uc3RydWN0b3JzTGlzdCIsIkJpZ0ludDY0QXJyYXkiLCJCaWdVaW50NjRBcnJheSIsImlzVmlldyIsImlzVmlldzIiLCJnZXRUeXBlZEFycmF5Q29uc3RydWN0b3IiLCJpc1R5cGVkQXJyYXkiLCJhVHlwZWRBcnJheSIsImFUeXBlZEFycmF5Q29uc3RydWN0b3IiLCJDIiwiZXhwb3J0VHlwZWRBcnJheU1ldGhvZCIsIktFWSIsInByb3BlcnR5IiwiQVJSQVkiLCJUeXBlZEFycmF5Q29uc3RydWN0b3IiLCJlcnJvcjIiLCJleHBvcnRUeXBlZEFycmF5U3RhdGljTWV0aG9kIiwiVHlwZWRBcnJheTIiLCJkZWZpbmVQcm9wZXJ0eU1vZHVsZSIsImNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciIsImRvY3VtZW50QWxsIiwiYWxsIiwiSUU4X0RPTV9ERUZJTkUiLCJWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyIsInRvUHJvcGVydHlLZXkiLCIkZGVmaW5lUHJvcGVydHkiLCIkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiRU5VTUVSQUJMRSIsIldSSVRBQkxFIiwiUCIsIkF0dHJpYnV0ZXMiLCJjdXJyZW50IiwiY3JlYXRlU2V0TGlrZSIsImNyZWF0ZVNldExpa2VXaXRoSW5maW5pdHlTaXplIiwiRXJyb3IiLCJjYWxsYmFjayIsIlNldDIiLCJub3RBTmFOIiwidG9Qb3NpdGl2ZUludGVnZXIiLCJ0YWtlV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IiLCJyZW1haW5pbmciLCJ0YWtlIiwibGltaXQiLCJhbkluc3RhbmNlIiwiaW5oZXJpdElmUmVxdWlyZWQiLCJub3JtYWxpemVTdHJpbmdBcmd1bWVudCIsIkRPTUV4Y2VwdGlvbkNvbnN0YW50cyIsImNsZWFyRXJyb3JTdGFjayIsIkRPTV9FWENFUFRJT04iLCJFcnJvcjIiLCJOYXRpdmVET01FeGNlcHRpb24iLCIkRE9NRXhjZXB0aW9uIiwiRE9NRXhjZXB0aW9uIiwiRE9NRXhjZXB0aW9uUHJvdG90eXBlIiwiYXJndW1lbnRzTGVuZ3RoIiwibWVzc2FnZSIsInN0YWNrIiwiRVJST1JfSEFTX1NUQUNLIiwiRE9NX0VYQ0VQVElPTl9IQVNfU1RBQ0siLCJCVUdHWV9ERVNDUklQVE9SIiwiRk9SQ0VEX0NPTlNUUlVDVE9SIiwiUG9seWZpbGxlZERPTUV4Y2VwdGlvbiIsIlBvbHlmaWxsZWRET01FeGNlcHRpb25Qcm90b3R5cGUiLCJjb25zdGFudCIsImNvbnN0YW50TmFtZSIsInMiLCJjIiwiSW5kZXhTaXplRXJyb3IiLCJtIiwiRE9NU3RyaW5nU2l6ZUVycm9yIiwiSGllcmFyY2h5UmVxdWVzdEVycm9yIiwiV3JvbmdEb2N1bWVudEVycm9yIiwiSW52YWxpZENoYXJhY3RlckVycm9yIiwiTm9EYXRhQWxsb3dlZEVycm9yIiwiTm9Nb2RpZmljYXRpb25BbGxvd2VkRXJyb3IiLCJOb3RGb3VuZEVycm9yIiwiTm90U3VwcG9ydGVkRXJyb3IiLCJJblVzZUF0dHJpYnV0ZUVycm9yIiwiSW52YWxpZFN0YXRlRXJyb3IiLCJJbnZhbGlkTW9kaWZpY2F0aW9uRXJyb3IiLCJOYW1lc3BhY2VFcnJvciIsIkludmFsaWRBY2Nlc3NFcnJvciIsIlZhbGlkYXRpb25FcnJvciIsIlR5cGVNaXNtYXRjaEVycm9yIiwiU2VjdXJpdHlFcnJvciIsIk5ldHdvcmtFcnJvciIsIkFib3J0RXJyb3IiLCJVUkxNaXNtYXRjaEVycm9yIiwiUXVvdGFFeGNlZWRlZEVycm9yIiwiVGltZW91dEVycm9yIiwiSW52YWxpZE5vZGVUeXBlRXJyb3IiLCJEYXRhQ2xvbmVFcnJvciIsImdldE93blByb3BlcnR5TmFtZXNNb2R1bGUiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUiLCJjb25jYXQiLCJvd25LZXlzIiwiaXNEZXRhY2hlZCIsImFycmF5RnJvbUNvbnN0cnVjdG9yQW5kTGlzdCIsIiRmcm9tQmFzZTY0IiwiZnJvbUJhc2U2NCIsImxpc3QiLCIkbGVuZ3RoIiwiSW5kZXhlZE9iamVjdCIsImludGVnZXIiLCJ0b0luZGV4IiwiZGV0YWNoVHJhbnNmZXJhYmxlIiwiQXJyYXlCdWZmZXIyIiwiQXJyYXlCdWZmZXJQcm90b3R5cGUiLCJEYXRhVmlld1Byb3RvdHlwZSIsImlzUmVzaXphYmxlIiwibWF4Qnl0ZUxlbmd0aCIsImdldEludDgiLCJzZXRJbnQ4IiwiYXJyYXlCdWZmZXIiLCJuZXdMZW5ndGgiLCJwcmVzZXJ2ZVJlc2l6YWJpbGl0eSIsIm5ld0J5dGVMZW5ndGgiLCJmaXhlZExlbmd0aCIsIm5ld0J1ZmZlciIsImEiLCJiIiwiY29weUxlbmd0aCIsIlVTRV9OQVRJVkVfVVJMIiwiVVJMMiIsInBhcnNlIiwidXJsIiwidXJsU3RyaW5nIiwiYmFzZSIsInRvUHJpbWl0aXZlIiwicHJpbSIsIkJpZ0ludCIsIlYiLCJmdW5jIiwiUHJvbWlzZUNhcGFiaWxpdHkiLCIkJHJlc29sdmUiLCIkJHJlamVjdCIsIk5BVElWRV9CSU5EIiwidG9MZW5ndGgiLCJFTlRSSUVTIiwiZGVmaW5lR2xvYmFsUHJvcGVydHkiLCJjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzIiwiVEFSR0VUIiwiR0xPQkFMIiwiU1RBVElDIiwidGFyZ2V0UHJvcGVydHkiLCJzb3VyY2VQcm9wZXJ0eSIsImRvbnRDYWxsR2V0U2V0IiwiZGV0YWNoZWQiLCJzZXRGcm9tQmFzZTY0Iiwib2JqZWN0S2V5cyIsImRlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsInNpbXBsZSIsIm5vbkNvbmZpZ3VyYWJsZSIsIm5vbldyaXRhYmxlIiwiVE9fU1RSSU5HX1RBR19TVVBQT1JUIiwiY2xhc3NvZlJhdyIsIkNPUlJFQ1RfQVJHVU1FTlRTIiwidHJ5R2V0IiwidGFnIiwiY2FsbGVlIiwiYml0bWFwIiwiTkFUSVZFX1NZTUJPTCIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwicHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUiLCJVUkwiLCJzZWFyY2hQYXJhbXMiLCJwYXJhbXMyIiwicGF0aG5hbWUiLCJ0b0pTT04iLCJzb3J0IiwiaHJlZiIsInVzZXJuYW1lIiwiaG9zdCIsImhhc2giLCJnZXRBbGwiLCIkaGFzIiwidmFsdWVzIiwiZm9yRWFjaFdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yIiwiU0hBUkVEIiwidmVyc2lvbnMiLCJtb2RlIiwiY29weXJpZ2h0IiwibGljZW5zZSIsIlNFVF9MSUtFX0lOQ09SUkVDVF9CRUhBVklPUiIsInNldExpa2UiLCJiYXNlU2V0IiwiY2xlYXIiLCJCVUdHWV9TQUZBUklfSVRFUkFUT1JTIiwiUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlIiwiYXJyYXlJdGVyYXRvciIsIk5FV19JVEVSQVRPUl9QUk9UT1RZUEUiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUiLCJleGNlcHRpb25zIiwiYUZ1bmN0aW9uIiwibmFtZXNwYWNlIiwiJHRyYW5zZmVyIiwidHJhbnNmZXJUb0ZpeGVkTGVuZ3RoIiwiaW50ZXJzZWN0aW9uIiwiZnJvbSIsImNyZWF0ZVByb3BlcnR5IiwiQ09OU1RSVUNUT1IiLCJOYXRpdmVJdGVyYXRvciIsIkl0ZXJhdG9yQ29uc3RydWN0b3IiLCJkZWZpbmVJdGVyYXRvclByb3RvdHlwZUFjY2Vzc29yIiwiU3ltYm9sMiIsIldlbGxLbm93blN5bWJvbHNTdG9yZSIsImNyZWF0ZVdlbGxLbm93blN5bWJvbCIsIndpdGhvdXRTZXR0ZXIiLCIkU3ludGF4RXJyb3IiLCIkcGFyc2VJbnQiLCJmcm9tQ2hhckNvZGUiLCJhdCIsImNvZGVQb2ludHMiLCJJU180X0hFWF9ESUdJVFMiLCJJU19DMF9DT05UUk9MX0NPREUiLCJ1bnRlcm1pbmF0ZWQiLCJjaHIiLCJ0d29DaGFycyIsImZvdXJIZXhEaWdpdHMiLCJlbmQiLCJGQUlMU19PTl9JTklUSUFMX1VOREVGSU5FRCIsInJlZHVjZSIsInJlZHVjZVdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yIiwicmVkdWNlciIsIm5vSW5pdGlhbCIsImFjY3VtdWxhdG9yIiwicGFyc2VKU09OU3RyaW5nIiwiSlNPTjIiLCJKU09OIiwiTnVtYmVyMiIsIm5hdGl2ZVBhcnNlIiwiZW51bWVyYWJsZU93blByb3BlcnRpZXMiLCJJU19ESUdJVCIsIklTX05PTl9aRVJPX0RJR0lUIiwiSVNfTlVNQkVSX1NUQVJUIiwiSVNfV0hJVEVTUEFDRSIsIlBSSU1JVElWRSIsIk9CSkVDVCIsIiRwYXJzZSIsInJldml2ZXIiLCJjb250ZXh0IiwiQ29udGV4dCIsInJvb3QiLCJlbmRJbmRleCIsInNraXAiLCJpbnRlcm5hbGl6ZSIsImhvbGRlciIsIm5vZGUiLCJ1bm1vZGlmaWVkIiwiZWxlbWVudFJlY29yZHNMZW4iLCJub2RlSXNBcnJheSIsIm5vZGVzIiwiaW50ZXJuYWxpemVQcm9wZXJ0eSIsIk5vZGUyIiwiZm9yayIsIm5leHRJbmRleCIsImFycmF5Iiwia2V5d29yZCIsInN0YXJ0IiwiZXhwZWN0S2V5cGFpciIsInVudGlsIiwiZXhwZWN0RWxlbWVudCIsInBhcnNlZCIsInN0YXJ0SW5kZXgiLCJleHBvbmVudFN0YXJ0SW5kZXgiLCJyZWdleCIsIk5PX1NPVVJDRV9TVVBQT1JUIiwidW5zYWZlSW50IiwiUFJPUEVSX0JBU0VfUEFSU0UiLCJ0ZXh0IiwiaW50ZXJydXB0aWJsZSIsImdldE93blByb3BlcnR5TmFtZXMiLCIkRXJyb3IiLCJURVNUIiwiYXJnIiwiVjhfT1JfQ0hBS1JBX1NUQUNLX0VOVFJZIiwiSVNfVjhfT1JfQ0hBS1JBX1NUQUNLIiwiZHJvcEVudHJpZXMiLCJwcmVwYXJlU3RhY2tUcmFjZSIsInN0cmluZ0hhbmRsaW5nIiwiUmVmbGVjdCIsIiRwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIk5BU0hPUk5fQlVHIiwiYW5PYmplY3RPclVuZGVmaW5lZCIsImJhc2U2NE1hcCIsImdldEFscGhhYmV0T3B0aW9uIiwic2tpcEFzY2lpV2hpdGVzcGFjZSIsImRlY29kZUJhc2U2NENodW5rIiwiY2h1bmsiLCJ0aHJvd09uRXh0cmFCaXRzIiwiY2h1bmtMZW5ndGgiLCJ0cmlwbGV0IiwiY2h1bmtCeXRlcyIsIndyaXRlQnl0ZXMiLCJlbGVtZW50cyIsImVsZW1lbnRzTGVuZ3RoIiwibGFzdENodW5rSGFuZGxpbmciLCJyZW1haW5pbmdCeXRlcyIsIkRST1BfV0lUSE9VVF9USFJPV0lOR19PTl9JTlZBTElEX0lURVJBVE9SIiwiZHJvcFdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yIiwiZHJvcCIsIklTX05PREUiLCJnZXRCdWlsdGluTW9kdWxlIiwiZGVmaW5lQnVpbHRJbnMiLCJjcmVhdGVJdGVyUmVzdWx0T2JqZWN0IiwiaXRlcmF0b3JDbG9zZUFsbCIsIklURVJBVE9SX0hFTFBFUiIsIldSQVBfRk9SX1ZBTElEX0lURVJBVE9SIiwiTk9STUFMIiwiVEhST1ciLCJzZXRJbnRlcm5hbFN0YXRlIiwiY3JlYXRlSXRlcmF0b3JQcm94eVByb3RvdHlwZSIsIm5leHRIYW5kbGVyIiwicmV0dXJuSGFuZGxlclJlc3VsdCIsInJldHVybk1ldGhvZCIsIm9wZW5JdGVycyIsIldyYXBGb3JWYWxpZEl0ZXJhdG9yUHJvdG90eXBlIiwiSXRlcmF0b3JIZWxwZXJQcm90b3R5cGUiLCJSRVRVUk5fSEFORExFUl9SRVNVTFQiLCJ0b0Jhc2U2NCIsIm9taXRQYWRkaW5nIiwic2hpZnQiLCJ1bmN1cnJ5VGhpc1dpdGhCaW5kIiwicHJvY2VzczIiLCJEZW5vMiIsInY4IiwibWF0Y2giLCJ2ZXJzaW9uMiIsImlubmVyUmVzdWx0IiwiaW5uZXJFcnJvciIsImFycmF5V2l0aCIsIkFycmF5QnVmZmVyVmlld0NvcmUiLCJpc0JpZ0ludEFycmF5IiwidG9CaWdJbnQiLCJQUk9QRVJfT1JERVIiLCJUSFJPV19PTl9ORUdBVElWRV9GUkFDVElPTkFMX0lOREVYIiwicmVsYXRpdmVJbmRleCIsImFjdHVhbFZhbHVlIiwidG9BYnNvbHV0ZUluZGV4IiwiY3JlYXRlTWV0aG9kIiwiSVNfSU5DTFVERVMiLCJlbCIsImZyb21JbmRleCIsImFjdHVhbEluZGV4IiwiQSIsIl9fd2VicGFja19tb2R1bGVfY2FjaGVfXyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJtb2R1bGVJZCIsImNhY2hlZE1vZHVsZSIsImQiLCJkZWZpbml0aW9uIiwibyIsInByb3AiLCJpc05vZGVKUyIsIm53IiwiZWxlY3Ryb24iLCJGT05UX0lERU5USVRZX01BVFJJWCIsIkxJTkVfRkFDVE9SIiwiUmVuZGVyaW5nSW50ZW50RmxhZyIsIkFOWSIsIkRJU1BMQVkiLCJQUklOVCIsIkFOTk9UQVRJT05TX0ZPUk1TIiwiQU5OT1RBVElPTlNfU1RPUkFHRSIsIkFOTk9UQVRJT05TX0RJU0FCTEUiLCJJU19FRElUSU5HIiwiT1BMSVNUIiwiQW5ub3RhdGlvbk1vZGUiLCJESVNBQkxFIiwiRU5BQkxFIiwiRU5BQkxFX0ZPUk1TIiwiRU5BQkxFX1NUT1JBR0UiLCJBbm5vdGF0aW9uRWRpdG9yUHJlZml4IiwiQW5ub3RhdGlvbkVkaXRvclR5cGUiLCJOT05FIiwiRlJFRVRFWFQiLCJISUdITElHSFQiLCJTVEFNUCIsIklOSyIsIlBPUFVQIiwiU0lHTkFUVVJFIiwiQ09NTUVOVCIsIkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlIiwiUkVTSVpFIiwiQ1JFQVRFIiwiRlJFRVRFWFRfU0laRSIsIkZSRUVURVhUX0NPTE9SIiwiRlJFRVRFWFRfT1BBQ0lUWSIsIklOS19DT0xPUiIsIklOS19USElDS05FU1MiLCJJTktfT1BBQ0lUWSIsIkhJR0hMSUdIVF9DT0xPUiIsIkhJR0hMSUdIVF9USElDS05FU1MiLCJISUdITElHSFRfRlJFRSIsIkhJR0hMSUdIVF9TSE9XX0FMTCIsIkRSQVdfU1RFUCIsIlBlcm1pc3Npb25GbGFnIiwiTU9ESUZZX0NPTlRFTlRTIiwiQ09QWSIsIk1PRElGWV9BTk5PVEFUSU9OUyIsIkZJTExfSU5URVJBQ1RJVkVfRk9STVMiLCJDT1BZX0ZPUl9BQ0NFU1NJQklMSVRZIiwiQVNTRU1CTEUiLCJQUklOVF9ISUdIX1FVQUxJVFkiLCJUZXh0UmVuZGVyaW5nTW9kZSIsIkZJTEwiLCJTVFJPS0UiLCJGSUxMX1NUUk9LRSIsIklOVklTSUJMRSIsIkZJTExfU1RST0tFX01BU0siLCJBRERfVE9fUEFUSF9GTEFHIiwidXRpbF9JbWFnZUtpbmQiLCJHUkFZU0NBTEVfMUJQUCIsIlJHQl8yNEJQUCIsIlJHQkFfMzJCUFAiLCJBbm5vdGF0aW9uVHlwZSIsIlRFWFQiLCJMSU5LIiwiTElORSIsIlNRVUFSRSIsIkNJUkNMRSIsIlBPTFlHT04iLCJQT0xZTElORSIsIlVOREVSTElORSIsIlNRVUlHR0xZIiwiU1RSSUtFT1VUIiwiQ0FSRVQiLCJGSUxFQVRUQUNITUVOVCIsIlNPVU5EIiwiTU9WSUUiLCJXSURHRVQiLCJTQ1JFRU4iLCJQUklOVEVSTUFSSyIsIlRSQVBORVQiLCJXQVRFUk1BUksiLCJUSFJFRUQiLCJSRURBQ1QiLCJBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlIiwiU09MSUQiLCJEQVNIRUQiLCJCRVZFTEVEIiwiSU5TRVQiLCJWZXJib3NpdHlMZXZlbCIsIkVSUk9SUyIsIldBUk5JTkdTIiwiSU5GT1MiLCJPUFMiLCJkZXBlbmRlbmN5Iiwic2V0TGluZVdpZHRoIiwic2V0TGluZUNhcCIsInNldExpbmVKb2luIiwic2V0TWl0ZXJMaW1pdCIsInNldERhc2giLCJzZXRSZW5kZXJpbmdJbnRlbnQiLCJzZXRGbGF0bmVzcyIsInNldEdTdGF0ZSIsInNhdmUiLCJyZXN0b3JlIiwidHJhbnNmb3JtIiwibW92ZVRvIiwibGluZVRvIiwiY3VydmVUbyIsImN1cnZlVG8yIiwiY3VydmVUbzMiLCJjbG9zZVBhdGgiLCJyZWN0YW5nbGUiLCJzdHJva2UiLCJjbG9zZVN0cm9rZSIsImZpbGwiLCJlb0ZpbGwiLCJmaWxsU3Ryb2tlIiwiZW9GaWxsU3Ryb2tlIiwiY2xvc2VGaWxsU3Ryb2tlIiwiY2xvc2VFT0ZpbGxTdHJva2UiLCJlbmRQYXRoIiwiY2xpcCIsImVvQ2xpcCIsImJlZ2luVGV4dCIsImVuZFRleHQiLCJzZXRDaGFyU3BhY2luZyIsInNldFdvcmRTcGFjaW5nIiwic2V0SFNjYWxlIiwic2V0TGVhZGluZyIsInNldEZvbnQiLCJzZXRUZXh0UmVuZGVyaW5nTW9kZSIsInNldFRleHRSaXNlIiwibW92ZVRleHQiLCJzZXRMZWFkaW5nTW92ZVRleHQiLCJzZXRUZXh0TWF0cml4IiwibmV4dExpbmUiLCJzaG93VGV4dCIsInNob3dTcGFjZWRUZXh0IiwibmV4dExpbmVTaG93VGV4dCIsIm5leHRMaW5lU2V0U3BhY2luZ1Nob3dUZXh0Iiwic2V0Q2hhcldpZHRoIiwic2V0Q2hhcldpZHRoQW5kQm91bmRzIiwic2V0U3Ryb2tlQ29sb3JTcGFjZSIsInNldEZpbGxDb2xvclNwYWNlIiwic2V0U3Ryb2tlQ29sb3IiLCJzZXRTdHJva2VDb2xvck4iLCJzZXRGaWxsQ29sb3IiLCJzZXRGaWxsQ29sb3JOIiwic2V0U3Ryb2tlR3JheSIsInNldEZpbGxHcmF5Iiwic2V0U3Ryb2tlUkdCQ29sb3IiLCJzZXRGaWxsUkdCQ29sb3IiLCJzZXRTdHJva2VDTVlLQ29sb3IiLCJzZXRGaWxsQ01ZS0NvbG9yIiwic2hhZGluZ0ZpbGwiLCJiZWdpbklubGluZUltYWdlIiwiYmVnaW5JbWFnZURhdGEiLCJlbmRJbmxpbmVJbWFnZSIsInBhaW50WE9iamVjdCIsIm1hcmtQb2ludCIsIm1hcmtQb2ludFByb3BzIiwiYmVnaW5NYXJrZWRDb250ZW50IiwiYmVnaW5NYXJrZWRDb250ZW50UHJvcHMiLCJlbmRNYXJrZWRDb250ZW50IiwiYmVnaW5Db21wYXQiLCJlbmRDb21wYXQiLCJwYWludEZvcm1YT2JqZWN0QmVnaW4iLCJwYWludEZvcm1YT2JqZWN0RW5kIiwiYmVnaW5Hcm91cCIsImVuZEdyb3VwIiwiYmVnaW5Bbm5vdGF0aW9uIiwiZW5kQW5ub3RhdGlvbiIsInBhaW50SW1hZ2VNYXNrWE9iamVjdCIsInBhaW50SW1hZ2VNYXNrWE9iamVjdEdyb3VwIiwicGFpbnRJbWFnZVhPYmplY3QiLCJwYWludElubGluZUltYWdlWE9iamVjdCIsInBhaW50SW5saW5lSW1hZ2VYT2JqZWN0R3JvdXAiLCJwYWludEltYWdlWE9iamVjdFJlcGVhdCIsInBhaW50SW1hZ2VNYXNrWE9iamVjdFJlcGVhdCIsInBhaW50U29saWRDb2xvckltYWdlTWFzayIsImNvbnN0cnVjdFBhdGgiLCJzZXRTdHJva2VUcmFuc3BhcmVudCIsInNldEZpbGxUcmFuc3BhcmVudCIsInJhd0ZpbGxQYXRoIiwiRHJhd09QUyIsIlBhc3N3b3JkUmVzcG9uc2VzIiwiTkVFRF9QQVNTV09SRCIsIklOQ09SUkVDVF9QQVNTV09SRCIsInZlcmJvc2l0eSIsInNldFZlcmJvc2l0eUxldmVsIiwibGV2ZWwiLCJpc0ludGVnZXIiLCJnZXRWZXJib3NpdHlMZXZlbCIsImluZm8iLCJjb25zb2xlIiwid2FybiIsInVucmVhY2hhYmxlIiwiYXNzZXJ0IiwiY29uZCIsIl9pc1ZhbGlkUHJvdG9jb2wiLCJwcm90b2NvbCIsImNyZWF0ZVZhbGlkQWJzb2x1dGVVcmwiLCJiYXNlVXJsIiwiYWRkRGVmYXVsdFByb3RvY29sIiwic3RhcnRzV2l0aCIsImRvdHMiLCJ0cnlDb252ZXJ0RW5jb2RpbmciLCJzdHJpbmdUb1VURjhTdHJpbmciLCJhYnNvbHV0ZVVybCIsInVwZGF0ZVVybEhhc2giLCJhbGxvd1JlbCIsInJlcyIsInNoYWRvdyIsIm5vblNlcmlhbGl6YWJsZSIsIkJhc2VFeGNlcHRpb24iLCJCYXNlRXhjZXB0aW9uQ2xvc3VyZSIsIkJhc2VFeGNlcHRpb24yIiwiUGFzc3dvcmRFeGNlcHRpb24iLCJjb2RlIiwiVW5rbm93bkVycm9yRXhjZXB0aW9uIiwiZGV0YWlscyIsIkludmFsaWRQREZFeGNlcHRpb24iLCJSZXNwb25zZUV4Y2VwdGlvbiIsInN0YXR1cyIsIm1pc3NpbmciLCJGb3JtYXRFcnJvciIsIkFib3J0RXhjZXB0aW9uIiwiYnl0ZXNUb1N0cmluZyIsIk1BWF9BUkdVTUVOVF9DT1VOVCIsInN0ckJ1ZiIsImNodW5rRW5kIiwic3ViYXJyYXkiLCJzdHJpbmdUb0J5dGVzIiwic3RyIiwiY2hhckNvZGVBdCIsInN0cmluZzMyIiwiaXNMaXR0bGVFbmRpYW4iLCJidWZmZXI4IiwidmlldzMyIiwiaXNFdmFsU3VwcG9ydGVkIiwidXRpbF9GZWF0dXJlVGVzdCIsImlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkIiwiT2Zmc2NyZWVuQ2FudmFzIiwiaXNJbWFnZURlY29kZXJTdXBwb3J0ZWQiLCJJbWFnZURlY29kZXIiLCJwbGF0Zm9ybSIsImlzQW5kcm9pZCIsImlzTGludXgiLCJpc01hYyIsImlzV2luZG93cyIsImlzRmlyZWZveCIsImlzQ1NTUm91bmRTdXBwb3J0ZWQiLCJDU1MiLCJzdXBwb3J0cyIsImhleE51bWJlcnMiLCJwYWRTdGFydCIsIlV0aWwiLCJtYWtlSGV4Q29sb3IiLCJyIiwiZyIsImRvbU1hdHJpeFRvVHJhbnNmb3JtIiwiZG0iLCJzY2FsZU1pbk1heCIsIm1pbk1heCIsIm0xIiwibTIiLCJtdWx0aXBseUJ5RE9NTWF0cml4IiwibWQiLCJhcHBseVRyYW5zZm9ybSIsInAiLCJwb3MiLCJwMCIsInAxIiwiYXBwbHlUcmFuc2Zvcm1Ub0JlemllciIsIm0wIiwibTMiLCJtNCIsIm01IiwicEkiLCJwSTEiLCJhcHBseUludmVyc2VUcmFuc2Zvcm0iLCJheGlhbEFsaWduZWRCb3VuZGluZ0JveCIsInJlY3QiLCJvdXRwdXQiLCJyMCIsInIxIiwicjIiLCJyMyIsImEwIiwiYTIiLCJhMSIsImEzIiwiYjAiLCJiMiIsImIxIiwiYjMiLCJtMXIwIiwibTFyMiIsIm0ycjEiLCJtMnIzIiwiaW52ZXJzZVRyYW5zZm9ybSIsInNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlIiwibWF0cml4IiwiZmlyc3QiLCJzZWNvbmQiLCJzcXJ0Iiwibm9ybWFsaXplUmVjdCIsImludGVyc2VjdCIsInJlY3QxIiwicmVjdDIiLCJ4TG93IiwieEhpZ2giLCJ5TG93IiwieUhpZ2giLCJwb2ludEJvdW5kaW5nQm94IiwicmVjdEJvdW5kaW5nQm94IiwieDAiLCJ5MCIsIngxIiwieTEiLCJnZXRFeHRyZW11bU9uQ3VydmUiLCJ4MiIsIngzIiwieTIiLCJ5MyIsInQiLCJtdCIsInR0IiwidHR0IiwiZ2V0RXh0cmVtdW0iLCJkZWx0YSIsInNxcnREZWx0YSIsImJlemllckJvdW5kaW5nQm94IiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiZXNjYXBlIiwiTm9ybWFsaXplUmVnZXgiLCJOb3JtYWxpemF0aW9uTWFwIiwibm9ybWFsaXplVW5pY29kZSIsIk1hcCIsInJlcGxhY2VBbGwiLCJwMiIsImdldFV1aWQiLCJjcnlwdG8iLCJyYW5kb21VVUlEIiwiYnVmIiwiZ2V0UmFuZG9tVmFsdWVzIiwiQW5ub3RhdGlvblByZWZpeCIsIl9pc1ZhbGlkRXhwbGljaXREZXN0IiwidmFsaWRSZWYiLCJ2YWxpZE5hbWUiLCJkZXN0IiwicGFnZSIsInpvb20iLCJhcmdzTGVuIiwiYWxsb3dOdWxsIiwiTWF0aENsYW1wIiwidG9CYXNlNjRVdGlsIiwiYXJyIiwiYnRvYSIsImZyb21CYXNlNjRVdGlsIiwiYXRvYiIsIkFib3J0U2lnbmFsIiwiYW55IiwiYWMiLCJBYm9ydENvbnRyb2xsZXIiLCJzaWduYWwiLCJhYm9ydGVkIiwiYWJvcnQiLCJyZWFzb24iLCJhZGRFdmVudExpc3RlbmVyIiwiWGZhVGV4dCIsInRleHRDb250ZW50IiwieGZhIiwic3R5bGVzIiwid2FsayIsInNob3VsZEJ1aWxkVGV4dCIsImF0dHJpYnV0ZXMiLCJjaGlsZHJlbiIsImNoaWxkIiwiWGZhTGF5ZXIiLCJzZXR1cFN0b3JhZ2UiLCJlbGVtZW50Iiwic3RvcmFnZSIsImludGVudCIsInN0b3JlZERhdGEiLCJnZXRWYWx1ZSIsImV2ZW50Iiwic2V0VmFsdWUiLCJ4ZmFPbiIsInNldEF0dHJpYnV0ZSIsInhmYU9mZiIsInJlbW92ZUF0dHJpYnV0ZSIsImNoZWNrZWQiLCJnZXRBdHRyaWJ1dGUiLCJvcHRpb24iLCJzZWxlY3RlZCIsInNlbGVjdGVkSW5kZXgiLCJzZXRBdHRyaWJ1dGVzIiwibGlua1NlcnZpY2UiLCJpc0hUTUxBbmNob3JFbGVtZW50IiwiSFRNTEFuY2hvckVsZW1lbnQiLCJhc3NpZ24iLCJhZGRMaW5rQXR0cmlidXRlcyIsIm5ld1dpbmRvdyIsImRhdGFJZCIsInJlbmRlciIsInBhcmFtZXRlcnMiLCJhbm5vdGF0aW9uU3RvcmFnZSIsInhmYUh0bWwiLCJyb290SHRtbCIsImlzTm90Rm9yUmljaFRleHQiLCJyb290RGl2IiwiZGl2Iiwidmlld3BvcnQiLCJ0ZXh0RGl2cyIsImNyZWF0ZVRleHROb2RlIiwicGFyZW50IiwicG9wIiwiY2hpbGRIdG1sIiwieG1sbnMiLCJjcmVhdGVFbGVtZW50TlMiLCJxdWVyeVNlbGVjdG9yQWxsIiwidXBkYXRlIiwiaGlkZGVuIiwiU1ZHX05TIiwiUGl4ZWxzUGVySW5jaCIsIlBERiIsIlBERl9UT19DU1NfVU5JVFMiLCJmZXRjaERhdGEiLCJpc1ZhbGlkRmV0Y2hVcmwiLCJiYXNlVVJJIiwicmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwic3RhdHVzVGV4dCIsImJsb2IiLCJqc29uIiwicmVxdWVzdCIsIlhNTEh0dHBSZXF1ZXN0IiwicmVzcG9uc2VUeXBlIiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVhZHlTdGF0ZSIsIkRPTkUiLCJyZXNwb25zZVRleHQiLCJzZW5kIiwiUGFnZVZpZXdwb3J0Iiwidmlld0JveCIsInVzZXJVbml0Iiwic2NhbGUiLCJyb3RhdGlvbiIsIm9mZnNldFgiLCJvZmZzZXRZIiwiZG9udEZsaXAiLCJjZW50ZXJYIiwiY2VudGVyWSIsInJvdGF0ZUEiLCJyb3RhdGVCIiwicm90YXRlQyIsInJvdGF0ZUQiLCJvZmZzZXRDYW52YXNYIiwib2Zmc2V0Q2FudmFzWSIsIndpZHRoIiwiaGVpZ2h0IiwicmF3RGltcyIsImRpbXMiLCJwYWdlV2lkdGgiLCJwYWdlSGVpZ2h0IiwicGFnZVgiLCJwYWdlWSIsImNvbnZlcnRUb1ZpZXdwb3J0UG9pbnQiLCJjb252ZXJ0VG9WaWV3cG9ydFJlY3RhbmdsZSIsInRvcExlZnQiLCJib3R0b21SaWdodCIsImNvbnZlcnRUb1BkZlBvaW50IiwiUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uIiwiZXh0cmFEZWxheSIsImlzRGF0YVNjaGVtZSIsImlpIiwidHJpbSIsInN1YnN0cmluZyIsImlzUGRmRmlsZSIsImZpbGVuYW1lIiwiZ2V0RmlsZW5hbWVGcm9tVXJsIiwibGFzdEluZGV4T2YiLCJnZXRQZGZGaWxlbmFtZUZyb21VcmwiLCJkZWZhdWx0RmlsZW5hbWUiLCJnZXRVUkwiLCJuZXdVUkwiLCJkZWNvZGUiLCJkZWNvZGVkIiwicGRmUmVnZXgiLCJyZXZlcnNlIiwicmVGaWxlbmFtZSIsImhhc2hGaWxlbmFtZSIsIlN0YXRUaW1lciIsInRpbWUiLCJzdGFydGVkIiwiRGF0ZSIsIm5vdyIsInRpbWVFbmQiLCJ0aW1lcyIsIm91dEJ1ZiIsImxvbmdlc3QiLCJwYWRFbmQiLCJub0NvbnRleHRNZW51IiwicHJldmVudERlZmF1bHQiLCJzdG9wRXZlbnQiLCJzdG9wUHJvcGFnYXRpb24iLCJkZXByZWNhdGVkIiwibG9nIiwiUERGRGF0ZVN0cmluZyIsInRvRGF0ZU9iamVjdCIsIlJlZ0V4cCIsIm1hdGNoZXMiLCJ5ZWFyIiwibW9udGgiLCJkYXkiLCJob3VyIiwibWludXRlIiwidW5pdmVyc2FsVGltZVJlbGF0aW9uIiwib2Zmc2V0SG91ciIsIm9mZnNldE1pbnV0ZSIsIlVUQyIsImdldFhmYVBhZ2VWaWV3cG9ydCIsInhmYVBhZ2UiLCJnZXRSR0IiLCJjb2xvciIsImNvbG9yUkdCIiwiZ2V0Q29sb3JWYWx1ZXMiLCJjb2xvcnMiLCJzcGFuIiwidmlzaWJpbGl0eSIsImNvbG9yU2NoZW1lIiwiYm9keSIsImNvbXB1dGVkQ29sb3IiLCJnZXRDb21wdXRlZFN0eWxlIiwiZ2V0Q3VycmVudFRyYW5zZm9ybSIsImN0eCIsImdldFRyYW5zZm9ybSIsImdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlIiwiaW52ZXJ0U2VsZiIsInNldExheWVyRGltZW5zaW9ucyIsIm11c3RGbGlwIiwibXVzdFJvdGF0ZSIsInVzZVJvdW5kIiwidyIsImgiLCJ3aWR0aFN0ciIsImhlaWdodFN0ciIsIk91dHB1dFNjYWxlIiwicGl4ZWxSYXRpbyIsInN4Iiwic3kiLCJzY2FsZWQiLCJzeW1tZXRyaWMiLCJsaW1pdENhbnZhcyIsIm1heFBpeGVscyIsIm1heERpbSIsImNhcEFyZWFGYWN0b3IiLCJtYXhBcmVhU2NhbGUiLCJtYXhXaWR0aFNjYWxlIiwibWF4SGVpZ2h0U2NhbGUiLCJjYXBQaXhlbHMiLCJtYXhTY2FsZSIsImRldmljZVBpeGVsUmF0aW8iLCJ3aW5QaXhlbHMiLCJzY3JlZW4iLCJhdmFpbFdpZHRoIiwiYXZhaWxIZWlnaHQiLCJTdXBwb3J0ZWRJbWFnZU1pbWVUeXBlcyIsIkNvbG9yU2NoZW1lIiwiaXNEYXJrTW9kZSIsIm1hdGNoTWVkaWEiLCJDU1NDb25zdGFudHMiLCJjb21tZW50Rm9yZWdyb3VuZENvbG9yIiwiY2xhc3NMaXN0IiwiYXBwbHlPcGFjaXR5Iiwib3BhY2l0eSIsIndoaXRlIiwicm91bmQiLCJSR0JUb0hTTCIsInJnYiIsImwiLCJIU0xUb1JHQiIsImhzbCIsImNvbXB1dGVMdW1pbmFuY2UiLCJjb250cmFzdFJhdGlvIiwiaHNsMSIsImhzbDIiLCJsdW0xIiwibHVtMiIsImNvbnRyYXN0Q2FjaGUiLCJmaW5kQ29udHJhc3RDb2xvciIsImJhc2VDb2xvciIsImZpeGVkQ29sb3IiLCJjYWNoZWRWYWx1ZSIsImJhc2VIU0wiLCJmaXhlZEhTTCIsImlzRml4ZWRDb2xvckRhcmsiLCJtaW5Db250cmFzdCIsIlBSRUNJU0lPTiIsIm1pZCIsInJlbmRlclJpY2hUZXh0IiwiZGlyIiwiY2xhc3NOYW1lIiwiY29udGFpbmVyIiwiZnJhZ21lbnQiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwibGluZXMiLCJsaW5lIiwiZmlyc3RDaGlsZCIsIkVkaXRvclRvb2xiYXIiLCJ0b29sYmFyIiwiY29sb3JQaWNrZXIiLCJlZGl0b3IiLCJidXR0b25zIiwiYWx0VGV4dCIsImNvbW1lbnQiLCJjb21tZW50QnV0dG9uRGl2aWRlciIsInNpZ25hdHVyZURlc2NyaXB0aW9uQnV0dG9uIiwibDEwblJlbW92ZSIsImZyZWV6ZSIsImZyZWV0ZXh0IiwiaGlnaGxpZ2h0IiwiaW5rIiwic3RhbXAiLCJzaWduYXR1cmUiLCJlZGl0VG9vbGJhciIsIl91aU1hbmFnZXIiLCJfc2lnbmFsIiwicG9pbnRlckRvd24iLCJwb3NpdGlvbiIsInRvb2xiYXJQb3NpdGlvbiIsImRpcmVjdGlvbiIsImluc2V0SW5saW5lRW5kIiwidG9wIiwiZm9jdXNJbiIsIl9mb2N1c0V2ZW50c0FsbG93ZWQiLCJmb2N1c091dCIsImFkZExpc3RlbmVyc1RvRWxlbWVudCIsImNhcHR1cmUiLCJoaWRlIiwiaGlkZURyb3Bkb3duIiwic2hvdyIsInNob3duIiwiYWRkRGVsZXRlQnV0dG9uIiwiZWRpdG9yVHlwZSIsImJ1dHRvbiIsInRhYkluZGV4IiwiZGVsZXRlIiwiZGl2aWRlciIsImFkZEFsdFRleHQiLCJhZGRDb21tZW50IiwiYmVmb3JlRWxlbWVudCIsInJlbmRlckZvclRvb2xiYXIiLCJpbnNlcnRCZWZvcmUiLCJhZGRDb2xvclBpY2tlciIsInJlbmRlckJ1dHRvbiIsImFkZEVkaXRTaWduYXR1cmVCdXR0b24iLCJzaWduYXR1cmVNYW5hZ2VyIiwicmVuZGVyRWRpdEJ1dHRvbiIsInJlbW92ZUJ1dHRvbiIsInJlbW92ZVRvb2xiYXJDb21tZW50QnV0dG9uIiwiYWRkQnV0dG9uIiwidG9vbCIsImFkZEJ1dHRvbkJlZm9yZSIsImJlZm9yZVNlbGVjdG9yIiwicXVlcnlTZWxlY3RvciIsInVwZGF0ZUVkaXRTaWduYXR1cmVCdXR0b24iLCJkZXNjcmlwdGlvbiIsInRpdGxlIiwiZGVzdHJveSIsIkZsb2F0aW5nVG9vbGJhciIsInVpTWFuYWdlciIsImhhc0NvbW1lbnRNYW5hZ2VyIiwibWFrZUJ1dHRvbiIsImNvbW1lbnRTZWxlY3Rpb24iLCJoaWdobGlnaHRTZWxlY3Rpb24iLCJnZXRMYXN0UG9pbnQiLCJib3hlcyIsImlzTFRSIiwibGFzdFkiLCJsYXN0WCIsImJveCIsImJ1dHRvbkNsYXNzIiwibDEwbklkIiwibGFiZWxMMTBuSWQiLCJjbGlja0hhbmRsZXIiLCJiaW5kRXZlbnRzIiwiSWRNYW5hZ2VyIiwiSW1hZ2VNYW5hZ2VyIiwiYmFzZUlkIiwiY2FjaGUiLCJfaXNTVkdGaXR0aW5nQ2FudmFzIiwic3ZnIiwiY2FudmFzIiwiZ2V0Q29udGV4dCIsIndpbGxSZWFkRnJlcXVlbnRseSIsImltYWdlIiwiSW1hZ2UiLCJ0aGVuIiwiZHJhd0ltYWdlIiwiZ2V0SW1hZ2VEYXRhIiwicmF3RGF0YSIsInJlZkNvdW50ZXIiLCJpc1N2ZyIsIkZpbGUiLCJmaWxlIiwiQmxvYiIsIm11c3RSZW1vdmVBc3BlY3RSYXRpb1Byb21pc2UiLCJmaWxlUmVhZGVyIiwiRmlsZVJlYWRlciIsImltYWdlRWxlbWVudCIsImltYWdlUHJvbWlzZSIsIm9ubG9hZCIsInN2Z1VybCIsIm9uZXJyb3IiLCJyZWFkQXNEYXRhVVJMIiwiY3JlYXRlSW1hZ2VCaXRtYXAiLCJnZXRGcm9tRmlsZSIsImxhc3RNb2RpZmllZCIsImdldEZyb21VcmwiLCJnZXRGcm9tQmxvYiIsImJsb2JQcm9taXNlIiwiZ2V0RnJvbUlkIiwiZ2V0RnJvbUNhbnZhcyIsIm9mZnNjcmVlbiIsInRyYW5zZmVyVG9JbWFnZUJpdG1hcCIsImdldFN2Z1VybCIsImRlbGV0ZUlkIiwidHJhbnNmZXJGcm9tSW1hZ2VCaXRtYXAiLCJjb252ZXJ0VG9CbG9iIiwiaXNWYWxpZElkIiwiQ29tbWFuZE1hbmFnZXIiLCJjb21tYW5kcyIsImxvY2tlZCIsIm1heFNpemUiLCJjbWQiLCJ1bmRvIiwicG9zdCIsIm11c3RFeGVjIiwib3ZlcndyaXRlSWZTYW1lVHlwZSIsImtlZXBVbmRvIiwic3BsaWNlIiwicmVkbyIsImhhc1NvbWV0aGluZ1RvVW5kbyIsImhhc1NvbWV0aGluZ1RvUmVkbyIsImNsZWFuVHlwZSIsIktleWJvYXJkTWFuYWdlciIsImNhbGxiYWNrcyIsImFsbEtleXMiLCJpc01hY0tleSIsInNlcmlhbGl6ZSIsImFsdEtleSIsImN0cmxLZXkiLCJtZXRhS2V5Iiwic2hpZnRLZXkiLCJzZWxmMiIsImluZm8yIiwiYnViYmxlcyIsImNoZWNrZXIiLCJDb2xvck1hbmFnZXIiLCJfY29sb3JzTWFwcGluZyIsIl9jb2xvcnMiLCJjb252ZXJ0IiwiUkdCIiwiZ2V0SGV4Q29kZSIsIkFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIiLCJhYm9ydENvbnRyb2xsZXIiLCJhY3RpdmVFZGl0b3IiLCJhbGxFZGl0YWJsZUFubm90YXRpb25zIiwiYWxsRWRpdG9ycyIsImFsbExheWVycyIsImFsdFRleHRNYW5hZ2VyIiwiY2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbnMiLCJjb21tYW5kTWFuYWdlciIsImNvbW1lbnRNYW5hZ2VyIiwiY29weVBhc3RlQUMiLCJjdXJyZW50RHJhd2luZ1Nlc3Npb24iLCJjdXJyZW50UGFnZUluZGV4IiwiZGVsZXRlZEFubm90YXRpb25zRWxlbWVudElkcyIsImRyYWdnaW5nRWRpdG9ycyIsImVkaXRvclR5cGVzIiwiZWRpdG9yc1RvUmVzY2FsZSIsImVuYWJsZUhpZ2hsaWdodEZsb2F0aW5nQnV0dG9uIiwiZW5hYmxlVXBkYXRlZEFkZEltYWdlIiwiZW5hYmxlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSIsImZpbHRlckZhY3RvcnkiLCJmb2N1c01haW5Db250YWluZXJUaW1lb3V0SWQiLCJmb2N1c01hbmFnZXJBQyIsImhpZ2hsaWdodENvbG9ycyIsImhpZ2hsaWdodFdoZW5TaGlmdFVwIiwiZmxvYXRpbmdUb29sYmFyIiwiaWRNYW5hZ2VyIiwiaXNFbmFibGVkIiwiaXNQb2ludGVyRG93biIsImlzV2FpdGluZyIsImtleWJvYXJkTWFuYWdlckFDIiwibGFzdEFjdGl2ZUVsZW1lbnQiLCJtYWluSGlnaGxpZ2h0Q29sb3JQaWNrZXIiLCJtaXNzaW5nQ2FudmFzZXMiLCJtbE1hbmFnZXIiLCJzZWxlY3RlZEVkaXRvcnMiLCJzZWxlY3RlZFRleHROb2RlIiwicGFnZUNvbG9ycyIsInNob3dBbGxTdGF0ZXMiLCJwZGZEb2N1bWVudCIsInByZXZpb3VzU3RhdGVzIiwidHJhbnNsYXRpb24iLCJ0cmFuc2xhdGlvblRpbWVvdXRJZCIsInZpZXdlciIsInZpZXdlckFsZXJ0IiwidXBkYXRlTW9kZUNhcGFiaWxpdHkiLCJUUkFOU0xBVEVfU01BTEwiLCJUUkFOU0xBVEVfQklHIiwiX2tleWJvYXJkTWFuYWdlciIsImFycm93Q2hlY2tlciIsImNvbnRhaW5zIiwiYWN0aXZlRWxlbWVudCIsInRhZ05hbWUiLCJoYXNTb21ldGhpbmdUb0NvbnRyb2wiLCJ0ZXh0SW5wdXRDaGVja2VyIiwiX3NlbGYiLCJIVE1MSW5wdXRFbGVtZW50Iiwic21hbGwiLCJiaWciLCJzZWxlY3RBbGwiLCJhZGROZXdFZGl0b3JGcm9tS2V5Ym9hcmQiLCJIVE1MQnV0dG9uRWxlbWVudCIsImlzRW50ZXJIYW5kbGVkIiwidW5zZWxlY3RBbGwiLCJ0cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMiLCJldmVudEJ1cyIsImVkaXRvclVuZG9CYXIiLCJzdXBwb3J0c1BpbmNoVG9ab29tIiwiX2VkaXRvclVuZG9CYXIiLCJpc0VkaXRpbmciLCJpc0VtcHR5IiwiaGFzU2VsZWN0ZWRFZGl0b3IiLCJoYXNTZWxlY3RlZFRleHQiLCJfZXZlbnRCdXMiLCJfb24iLCJvbkVkaXRpbmdBY3Rpb24iLCJvblBhZ2VDaGFuZ2luZyIsIm9uU2NhbGVDaGFuZ2luZyIsIm9uUm90YXRpb25DaGFuZ2luZyIsIm9uU2V0UHJlZmVyZW5jZSIsImV2dCIsInVwZGF0ZVBhcmFtcyIsImFkZFNlbGVjdGlvbkxpc3RlbmVyIiwiYWRkRHJhZ0FuZERyb3BMaXN0ZW5lcnMiLCJhZGRLZXlib2FyZE1hbmFnZXIiLCJ2aWV3UGFyYW1ldGVycyIsInJlYWxTY2FsZSIsImlzU2hpZnRLZXlEb3duIiwiX3N1cHBvcnRzUGluY2hUb1pvb20iLCJzZXRTaWRlYmFyVWlNYW5hZ2VyIiwibGF5ZXIiLCJjbGVhclRpbWVvdXQiLCJjb21iaW5lZFNpZ25hbCIsInVzZU5ld0FsdFRleHRGbG93IiwidXNlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSIsImhjbUZpbHRlciIsImFkZEhDTUZpbHRlciIsImZvcmVncm91bmQiLCJiYWNrZ3JvdW5kIiwiX2hpZ2hsaWdodENvbG9ycyIsInBhaXIiLCJ0b1VwcGVyQ2FzZSIsImhhc0hDTSIsImlzTmFtZUZvckhDTSIsImVuZHNXaXRoIiwiaGlnaGxpZ2h0Q29sb3JOYW1lcyIsImdldE5vbkhDTUNvbG9yIiwiY29sb3JOYW1lIiwiZ2V0Tm9uSENNQ29sb3JOYW1lIiwic2V0Q3VycmVudERyYXdpbmdTZXNzaW9uIiwiZGlzYWJsZVVzZXJTZWxlY3QiLCJzZXRNYWluSGlnaGxpZ2h0Q29sb3JQaWNrZXIiLCJlZGl0QWx0VGV4dCIsImZpcnN0VGltZSIsImVkaXRDb21tZW50IiwicG9zWCIsInBvc1kiLCJzaG93RGlhbG9nIiwic2VsZWN0Q29tbWVudCIsInBhZ2VJbmRleCIsImdldEVkaXRvckJ5VUlEIiwidG9nZ2xlQ29tbWVudCIsInVwZGF0ZUNvbW1lbnQiLCJnZXREYXRhIiwidXBkYXRlUG9wdXBDb2xvciIsInJlbW92ZUNvbW1lbnQiLCJyZW1vdmVDb21tZW50cyIsImlzU2VsZWN0ZWQiLCJ0b2dnbGVDb21tZW50UG9wdXAiLCJtYWtlQ29tbWVudENvbG9yIiwiZ2V0Q29tbWVudERpYWxvZ0VsZW1lbnQiLCJkaWFsb2dFbGVtZW50Iiwid2FpdEZvckVkaXRvcnNSZW5kZXJlZCIsInBhZ2VOdW1iZXIiLCJvbkVkaXRvcnNSZW5kZXJlZCIsIl9vZmYiLCJvbiIsImdldFNpZ25hdHVyZSIsInN3aXRjaFRvTW9kZSIsIm9uY2UiLCJkaXNwYXRjaCIsInNldFByZWZlcmVuY2UiLCJmb2N1c01haW5Db250YWluZXIiLCJmb2N1cyIsImZpbmRQYXJlbnQiLCJsYXllclgiLCJsYXllclkiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ0b2dnbGUiLCJhZGRTaG91bGRSZXNjYWxlIiwicmVtb3ZlU2hvdWxkUmVzY2FsZSIsImNvbW1pdE9yUmVtb3ZlIiwicGFnZXNSb3RhdGlvbiIsImdldEFuY2hvckVsZW1lbnRGb3JTZWxlY3Rpb24iLCJhbmNob3JOb2RlIiwibm9kZVR5cGUiLCJOb2RlIiwiVEVYVF9OT0RFIiwicGFyZW50RWxlbWVudCIsImdldExheWVyRm9yVGV4dExheWVyIiwidGV4dExheWVyIiwiY3VycmVudExheWVyIiwiaGFzVGV4dExheWVyIiwibWV0aG9kT2ZDcmVhdGlvbiIsInNlbGVjdGlvbiIsImdldFNlbGVjdGlvbiIsImlzQ29sbGFwc2VkIiwiYW5jaG9yT2Zmc2V0IiwiZm9jdXNOb2RlIiwiZm9jdXNPZmZzZXQiLCJhbmNob3JFbGVtZW50IiwiY2xvc2VzdCIsImdldFNlbGVjdGlvbkJveGVzIiwiZW1wdHkiLCJpc05vbmVNb2RlIiwiY3JlYXRlQW5kQWRkTmV3RWRpdG9yIiwic2hvd0FsbEVkaXRvcnMiLCJkaXNwbGF5RmxvYXRpbmdUb29sYmFyIiwiZ2V0QW5kUmVtb3ZlRGF0YUZyb21Bbm5vdGF0aW9uU3RvcmFnZSIsImFubm90YXRpb25JZCIsInN0b3JlZFZhbHVlIiwiZ2V0UmF3VmFsdWUiLCJhZGRUb0Fubm90YXRpb25TdG9yYWdlIiwiYTExeUFsZXJ0IiwibWVzc2FnZUlkIiwic3RyaW5naWZ5Iiwic2VsZWN0aW9uQ2hhbmdlIiwiZGlzcGF0Y2hVcGRhdGVTdGF0ZXMiLCJhY3RpdmVMYXllciIsInRvZ2dsZURyYXdpbmciLCJwb2ludGVydXAiLCJvblNlbGVjdEVuZCIsImFkZEZvY3VzTWFuYWdlciIsImJsdXIiLCJyZW1vdmVGb2N1c01hbmFnZXIiLCJoYXNTZWxlY3Rpb24iLCJsYXN0RWRpdG9yIiwia2V5ZG93biIsImtleXVwIiwicmVtb3ZlS2V5Ym9hcmRNYW5hZ2VyIiwiYWRkQ29weVBhc3RlTGlzdGVuZXJzIiwiY29weSIsImN1dCIsInBhc3RlIiwicmVtb3ZlQ29weVBhc3RlTGlzdGVuZXJzIiwiZHJhZ092ZXIiLCJhZGRFZGl0TGlzdGVuZXJzIiwicmVtb3ZlRWRpdExpc3RlbmVycyIsImRhdGFUcmFuc2ZlciIsImlzSGFuZGxpbmdNaW1lRm9yUGFzdGluZyIsImRyb3BFZmZlY3QiLCJlZGl0b3JzIiwic2VyaWFsaXplZCIsImNsaXBib2FyZERhdGEiLCJzZXREYXRhIiwiZXgiLCJuZXdFZGl0b3JzIiwiZGVzZXJpYWxpemVkRWRpdG9yIiwiZGVzZXJpYWxpemUiLCJhZGRFZGl0b3JUb0xheWVyIiwic2VsZWN0RWRpdG9ycyIsImFkZENvbW1hbmRzIiwiaXNFZGl0b3JIYW5kbGluZ0tleWJvYXJkIiwiaGFzQ2hhbmdlZCIsImRpc3BhdGNoVXBkYXRlVUkiLCJzZXRFZGl0aW5nU3RhdGUiLCJyZWdpc3RlckVkaXRvclR5cGVzIiwidHlwZXMiLCJkZWZhdWx0UHJvcGVydGllc1RvVXBkYXRlIiwiZ2V0SWQiLCJnZXRMYXllciIsImFkZExheWVyIiwiZW5hYmxlIiwiZGlzYWJsZSIsInJlbW92ZUxheWVyIiwidXBkYXRlTW9kZSIsImVkaXRJZCIsImlzRnJvbUtleWJvYXJkIiwibXVzdEVudGVySW5FZGl0TW9kZSIsImhpZGVTaWRlYmFyIiwiZGVzdHJveVBvcHVwIiwiZGlzYWJsZUFsbCIsImhpZGVTdGFuZGFsb25lQ29tbWVudEJ1dHRvbiIsImFkZFN0YW5kYWxvbmVDb21tZW50QnV0dG9uIiwibG9hZFNpZ25hdHVyZXMiLCJlbmFibGVBbGwiLCJnZXRBbm5vdGF0aW9uc0J5VHlwZSIsImVkaXRvckNsYXNzIiwiX2VkaXRvclR5cGUiLCJlbGVtZW50SWRzIiwiYWxsQ29tbWVudHMiLCJhbm5vdGF0aW9uRWxlbWVudElkIiwiaGFzQ29tbWVudCIsImRlbGV0ZWQiLCJhbm5vdGF0aW9uIiwicG9wdXBSZWYiLCJjb250ZW50c09iaiIsInNob3dTaWRlYmFyIiwic2V0U2VsZWN0ZWQiLCJlbnRlckluRWRpdE1vZGUiLCJ1bnNlbGVjdCIsImNhbkNyZWF0ZU5ld0VtcHR5RWRpdG9yIiwiYWRkTmV3RWRpdG9yIiwidXBkYXRlVG9vbGJhciIsImFjdGlvbiIsInVwZGF0ZURlZmF1bHRQYXJhbXMiLCJ2aXNpYmxlIiwidXBkYXRlQnV0dG9uIiwiZW5hYmxlV2FpdGluZyIsIm11c3RXYWl0IiwiZGlzYWJsZUNsaWNrIiwiZW5hYmxlQ2xpY2siLCJwcm9taXNlcyIsImdldEVkaXRvcnMiLCJnZXRFZGl0b3IiLCJhZGRFZGl0b3IiLCJyZW1vdmVFZGl0b3IiLCJzZXRUaW1lb3V0IiwiYWRkRGVsZXRlZEFubm90YXRpb25FbGVtZW50IiwiYWRkQ2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbiIsImlzRGVsZXRlZEFubm90YXRpb25FbGVtZW50IiwicmVtb3ZlRGVsZXRlZEFubm90YXRpb25FbGVtZW50IiwicmVtb3ZlQ2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbiIsImFkZE9yUmVidWlsZCIsInNldEFjdGl2ZUVkaXRvciIsInByb3BlcnRpZXNUb1VwZGF0ZSIsImxhc3RTZWxlY3RlZEVkaXRvciIsImVkIiwidXBkYXRlVUkiLCJ1cGRhdGVVSUZvckRlZmF1bHRQcm9wZXJ0aWVzIiwidG9nZ2xlU2VsZWN0ZWQiLCJzZWxlY3QiLCJmaXJzdFNlbGVjdGVkRWRpdG9yIiwiY2xlYW5VbmRvU3RhY2siLCJkcmF3aW5nRWRpdG9yIiwiZW5kRHJhd2luZ1Nlc3Npb24iLCJjb21taXQiLCJub0NvbW1pdCIsInRvdGFsWCIsInRvdGFsWSIsIlRJTUVfVE9fV0FJVCIsInRyYW5zbGF0ZUluUGFnZSIsInRyYW5zbGF0aW9uRG9uZSIsInNldFVwRHJhZ1Nlc3Npb24iLCJzYXZlZFgiLCJzYXZlZFkiLCJzYXZlZFBhZ2VJbmRleCIsIm5ld1giLCJuZXdZIiwibmV3UGFnZUluZGV4IiwiZW5kRHJhZ1Nlc3Npb24iLCJtdXN0QmVBZGRlZEluVW5kb1N0YWNrIiwibW92ZSIsIl9zZXRQYXJlbnRBbmRQb3NpdGlvbiIsImRyYWdTZWxlY3RlZEVkaXRvcnMiLCJ0eCIsInR5IiwiZHJhZyIsInJlYnVpbGQiLCJjaGFuZ2VQYXJlbnQiLCJnZXRBY3RpdmUiLCJzaG91bGRHZXRLZXlib2FyZEV2ZW50cyIsImlzQWN0aXZlIiwiZ2V0TW9kZSIsImlzRWRpdGluZ01vZGUiLCJpbWFnZU1hbmFnZXIiLCJyYW5nZUNvdW50IiwiZ2V0UmFuZ2VBdCIsImNvbW1vbkFuY2VzdG9yQ29udGFpbmVyIiwicGFyZW50V2lkdGgiLCJwYXJlbnRIZWlnaHQiLCJyb3RhdG9yIiwicmFuZ2UiLCJjb2xsYXBzZWQiLCJnZXRDbGllbnRSZWN0cyIsInJlbmRlckFubm90YXRpb25FbGVtZW50IiwiZWRpdG9ySWQiLCJoYXNCZWVuTW9kaWZpZWQiLCJzZXRNaXNzaW5nQ2FudmFzIiwic2V0Q2FudmFzIiwiYWRkTWlzc2luZ0NhbnZhcyIsIkFsdFRleHQiLCJhbHRUZXh0RGVjb3JhdGl2ZSIsImFsdFRleHRCdXR0b24iLCJhbHRUZXh0QnV0dG9uTGFiZWwiLCJhbHRUZXh0VG9vbHRpcCIsImFsdFRleHRUb29sdGlwVGltZW91dCIsImFsdFRleHRXYXNGcm9tS2V5Qm9hcmQiLCJiYWRnZSIsImd1ZXNzZWRUZXh0IiwidGV4dFdpdGhEaXNjbGFpbWVyIiwibDEwbk5ld0J1dHRvbiIsIl9sMTBuIiwiYWRkZWQiLCJyZXZpZXciLCJpbml0aWFsaXplIiwibDEwbiIsImxhYmVsIiwib25DbGljayIsIl9yZXBvcnRUZWxlbWV0cnkiLCJzZXRTdGF0ZSIsImZpbmlzaCIsImZvY3VzVmlzaWJsZSIsImhhc0RhdGEiLCJzZXRHdWVzc2VkVGV4dCIsImdlbmVyYXRlZEFsdFRleHQiLCJ0b2dnbGVBbHRUZXh0QmFkZ2UiLCJpc0ZvckNvcHlpbmciLCJkZWNvcmF0aXZlIiwiY2FuY2VsIiwiZW5hYmxlZCIsImRpc2FibGVkIiwidG9vbHRpcCIsIkRFTEFZX1RPX1NIT1dfVE9PTFRJUCIsInBhcmVudE5vZGUiLCJnZXRFbGVtZW50Rm9yQWx0VGV4dCIsIkNvbW1lbnQiLCJjb21tZW50U3RhbmRhbG9uZUJ1dHRvbiIsImNvbW1lbnRUb29sYmFyQnV0dG9uIiwiY29tbWVudFdhc0Zyb21LZXlCb2FyZCIsImluaXRpYWxUZXh0IiwicmljaFRleHQiLCJkYXRlIiwicG9wdXBQb3NpdGlvbiIsInJlbmRlckZvclN0YW5kYWxvbmUiLCJjb21tZW50QnV0dG9uUG9zaXRpb24iLCJjb21tZW50QnV0dG9uQ29sb3IiLCJiYWNrZ3JvdW5kQ29sb3IiLCJmb2N1c0J1dHRvbiIsIm9uVXBkYXRlZENvbG9yIiwiY29tbWVudEJ1dHRvbldpZHRoIiwiYm91bmRpbmdDbGllbnRSZWN0IiwiY29tbWVudFBvcHVwUG9zaXRpb25JbkxheWVyIiwicGFyZW50WCIsInBhcmVudFkiLCJoYXNEZWZhdWx0UG9wdXBQb3NpdGlvbiIsInJlbW92ZVN0YW5kYWxvbmVDb21tZW50QnV0dG9uIiwic2V0Q29tbWVudEJ1dHRvblN0YXRlcyIsImhhc1BvcHVwIiwiYXJpYUV4cGFuZGVkIiwiaXNTdGFuZGFsb25lIiwiYXJpYUhhc1BvcHVwIiwiYXJpYUNvbnRyb2xzIiwiYXJpYUNvbnRyb2xzRWxlbWVudHMiLCJlZGl0IiwicGFyZW50RGltZW5zaW9ucyIsImlzRGVsZXRlZCIsImhhc0JlZW5FZGl0ZWQiLCJzZXRJbml0aWFsVGV4dCIsIlRvdWNoTWFuYWdlciIsImlzUGluY2hpbmciLCJpc1BpbmNoaW5nU3RvcHBlZCIsImlzUGluY2hpbmdEaXNhYmxlZCIsIm9uUGluY2hTdGFydCIsIm9uUGluY2hpbmciLCJvblBpbmNoRW5kIiwicG9pbnRlckRvd25BQyIsInRvdWNoSW5mbyIsInRvdWNoTWFuYWdlckFDIiwidG91Y2hNb3ZlQUMiLCJvblRvdWNoU3RhcnQiLCJwYXNzaXZlIiwiTUlOX1RPVUNIX0RJU1RBTkNFX1RPX1BJTkNIIiwidG91Y2hlcyIsIm9wdHMiLCJjYW5jZWxQb2ludGVyRG93biIsInBvaW50ZXJUeXBlIiwib3B0Iiwib25Ub3VjaE1vdmUiLCJvblRvdWNoRW5kIiwidG91Y2gwIiwidG91Y2gxIiwiaWRlbnRpZmllciIsInRvdWNoMFgiLCJzY3JlZW5YIiwidG91Y2gwWSIsInNjcmVlblkiLCJ0b3VjaDFYIiwidG91Y2gxWSIsInNjcmVlbjBYIiwic2NyZWVuMFkiLCJzY3JlZW4xWCIsInNjcmVlbjFZIiwicFRvdWNoMFgiLCJwVG91Y2gwWSIsInBUb3VjaDFYIiwicFRvdWNoMVkiLCJwcmV2R2FwWCIsInByZXZHYXBZIiwiY3VyckdhcFgiLCJjdXJyR2FwWSIsImRpc3RhbmNlIiwiaHlwb3QiLCJwRGlzdGFuY2UiLCJvcmlnaW4iLCJBbm5vdGF0aW9uRWRpdG9yIiwiYWNjZXNzaWJpbGl0eURhdGEiLCJhbGxSZXNpemVyRGl2cyIsImRyYWdQb2ludGVySWQiLCJkcmFnUG9pbnRlclR5cGUiLCJyZXNpemVyc0RpdiIsImxhc3RQb2ludGVyQ29vcmRzIiwic2F2ZWREaW1lbnNpb25zIiwiZmFrZUFubm90YXRpb24iLCJmb2N1c0FDIiwiZm9jdXNlZFJlc2l6ZXJOYW1lIiwiaGFzQmVlbkNsaWNrZWQiLCJpbml0aWFsUmVjdCIsImlzSW5FZGl0TW9kZSIsImlzUmVzaXplckVuYWJsZWRGb3JLZXlib2FyZCIsIm1vdmVJbkRPTVRpbWVvdXQiLCJwcmV2RHJhZ1giLCJwcmV2RHJhZ1kiLCJ0ZWxlbWV0cnlUaW1lb3V0cyIsInRvdWNoTWFuYWdlciIsIl9sMTBuUmVzaXplciIsImlzRHJhZ2dhYmxlIiwiekluZGV4IiwiX2JvcmRlckxpbmVXaWR0aCIsIl9jb2xvck1hbmFnZXIiLCJfekluZGV4IiwiX3RlbGVtZXRyeVRpbWVvdXQiLCJfcmVzaXplcktleWJvYXJkTWFuYWdlciIsInJlc2l6ZSIsIl9yZXNpemVXaXRoS2V5Ym9hcmQiLCJfc3RvcFJlc2l6aW5nV2l0aEtleWJvYXJkIiwiX2lzQ29weSIsIl9lZGl0VG9vbGJhciIsIl9pbml0aWFsT3B0aW9ucyIsIl9pbml0aWFsRGF0YSIsIl9pc1Zpc2libGUiLCJfd2lsbEtlZXBBc3BlY3RSYXRpbyIsImlzQ2VudGVyZWQiLCJfc3RydWN0VHJlZVBhcmVudElkIiwiY3JlYXRpb25EYXRlIiwibW9kaWZpY2F0aW9uRGF0ZSIsInBhZ2VSb3RhdGlvbiIsInBhZ2VEaW1lbnNpb25zIiwicGFnZVRyYW5zbGF0aW9uIiwiaXNBdHRhY2hlZFRvRE9NIiwiX3R5cGUiLCJpc0RyYXdlciIsIl9kZWZhdWx0TGluZUNvbG9yIiwiZGVsZXRlQW5ub3RhdGlvbkVsZW1lbnQiLCJmYWtlRWRpdG9yIiwiRmFrZUVkaXRvciIsImdldE5leHRJZCIsInRvcE1pZGRsZSIsInRvcFJpZ2h0IiwibWlkZGxlUmlnaHQiLCJib3R0b21NaWRkbGUiLCJib3R0b21MZWZ0IiwibWlkZGxlTGVmdCIsImRvY3VtZW50RWxlbWVudCIsInBhcnNlRmxvYXQiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiX3ZhbHVlIiwibWltZSIsIl9pc0RyYWdnYWJsZSIsImNlbnRlciIsInBhcmVudFJvdGF0aW9uIiwiZml4QW5kU2V0UG9zaXRpb24iLCJzZXRJbkJhY2tncm91bmQiLCJzZXRJbkZvcmVncm91bmQiLCJzZXRQYXJlbnQiLCJzdG9wUmVzaXppbmciLCJmb2N1c2luIiwiZm9jdXNvdXQiLCJyZWxhdGVkVGFyZ2V0IiwiaXNNdWx0aXBsZVNlbGVjdGlvbiIsInNldEF0Iiwic2NyZWVuVG9QYWdlVHJhbnNsYXRpb24iLCJfbW92ZUFmdGVyUGFzdGUiLCJiYXNlWCIsImJhc2VZIiwiX29uVHJhbnNsYXRlZCIsInRyYW5zbGF0ZSIsIl9vblRyYW5zbGF0aW5nIiwic2Nyb2xsSW50b1ZpZXciLCJibG9jayIsImZpbmROZXdQYXJlbnQiLCJieCIsImJ5IiwiZ2V0QmFzZVRyYW5zbGF0aW9uIiwibGVmdCIsInRvRml4ZWQiLCJfaGFzQmVlbk1vdmVkIiwiX2hhc0JlZW5SZXNpemVkIiwiX211c3RGaXhQb3NpdGlvbiIsIm1vdmVJbkRPTSIsInJvdGF0ZVBvaW50IiwiYW5nbGUiLCJwYWdlVHJhbnNsYXRpb25Ub1NjcmVlbiIsImdldFJvdGF0aW9uTWF0cml4IiwicGFyZW50U2NhbGUiLCJzZXREaW1zIiwiZ2V0SW5pdGlhbFRyYW5zbGF0aW9uIiwiY3JlYXRlUmVzaXplcnMiLCJjbGFzc2VzIiwicmVzaXplclBvaW50ZXJkb3duIiwicHJlcGVuZCIsInNhdmVkRHJhZ2dhYmxlIiwidG9nZ2xlUG9pbnRlckV2ZW50cyIsInJlc2l6ZXJQb2ludGVybW92ZSIsInNhdmVkV2lkdGgiLCJzYXZlZEhlaWdodCIsInNhdmVkUGFyZW50Q3Vyc29yIiwiY3Vyc29yIiwic2F2ZWRDdXJzb3IiLCJwb2ludGVyVXBDYWxsYmFjayIsImFkZFJlc2l6ZVRvVW5kb1N0YWNrIiwiX29uUmVzaXplZCIsIm5ld1dpZHRoIiwibmV3SGVpZ2h0IiwiX3JvdW5kIiwibWluV2lkdGgiLCJNSU5fU0laRSIsIm1pbkhlaWdodCIsInJvdGF0aW9uTWF0cml4IiwidHJhbnNmIiwiaW52Um90YXRpb25NYXRyaXgiLCJpbnZUcmFuc2YiLCJnZXRQb2ludCIsImdldE9wcG9zaXRlIiwiaXNEaWFnb25hbCIsImlzSG9yaXpvbnRhbCIsInBvaW50Iiwib3Bwb3NpdGVQb2ludCIsInRyYW5zZk9wcG9zaXRlUG9pbnQiLCJvcHBvc2l0ZVgiLCJvcHBvc2l0ZVkiLCJyYXRpb1giLCJyYXRpb1kiLCJkZWx0YVgiLCJkZWx0YVkiLCJmcm9tS2V5Ym9hcmQiLCJsYXN0U2NyZWVuWCIsImxhc3RTY3JlZW5ZIiwib2xkRGlhZyIsIl9vblJlc2l6aW5nIiwiYWx0VGV4dEZpbmlzaCIsInRvb2xiYXJCdXR0b25zIiwiYWRkRWRpdFRvb2xiYXIiLCJhZGRDb21tZW50QnV0dG9uIiwiYWRkQ29tbWVudEJ1dHRvbkluVG9vbGJhciIsInJlbW92ZUNvbW1lbnRCdXR0b25Gcm9tVG9vbGJhciIsInJlbW92ZUVkaXRUb29sYmFyIiwiYWRkQ29udGFpbmVyIiwiZWRpdFRvb2xiYXJEaXYiLCJiZWZvcmUiLCJnZXRDbGllbnREaW1lbnNpb25zIiwiY3JlYXRlQWx0VGV4dCIsImFsdFRleHREYXRhIiwiZ3Vlc3NlZEFsdFRleHQiLCJzZXRHdWVzc2VkQWx0VGV4dCIsInNlcmlhbGl6ZUFsdFRleHQiLCJoYXNBbHRUZXh0IiwiaGFzQWx0VGV4dERhdGEiLCJmb2N1c0NvbW1lbnRCdXR0b24iLCJzZXRDb21tZW50RGF0YSIsInVwZGF0ZUZyb21Bbm5vdGF0aW9uTGF5ZXIiLCJoYXNFZGl0ZWRDb21tZW50IiwiaGFzRGVsZXRlZENvbW1lbnQiLCJzZXRTZWxlY3RlZENvbW1lbnRCdXR0b24iLCJzZXRTZWxlY3RlZEJ1dHRvbiIsIkRFRkFVTFRfUE9QVVBfV0lEVEgiLCJERUZBVUxUX1BPUFVQX0hFSUdIVCIsInRyWSIsImJsWCIsImJsWSIsInRyWCIsInBvcHVwIiwiY29udGVudHMiLCJwYXJlbnRCb3VuZGluZ0NsaWVudFJlY3QiLCJkZWZhdWx0TDEwbklkIiwiYWRkRm9jdXNMaXN0ZW5lcnMiLCJtYXhXaWR0aCIsIm1heEhlaWdodCIsInRvdWNoUGluY2hTdGFydENhbGxiYWNrIiwidG91Y2hQaW5jaENhbGxiYWNrIiwidG91Y2hQaW5jaEVuZENhbGxiYWNrIiwiX29yaWdpbiIsInByZXZEaXN0YW5jZSIsInNsb3dEb3duRmFjdG9yIiwiZmFjdG9yIiwidHJhbnNmQ2VudGVyUG9pbnQiLCJuZXdUcmFuc2ZDZW50ZXJQb2ludCIsInBvaW50ZXJkb3duIiwic2VsZWN0T25Qb2ludGVyRXZlbnQiLCJoYXNEcmFnZ2luZ1N0YXJ0ZWQiLCJjYW5jZWxEcmFnIiwiX29uU3RvcERyYWdnaW5nIiwiY2xpZW50WCIsImNsaWVudFkiLCJwb2ludGVySWQiLCJfb25TdGFydERyYWdnaW5nIiwiaXNQcmltYXJ5IiwibW92ZUVkaXRvckluRE9NIiwiZ2V0UmVjdCIsInNoaWZ0WCIsInNoaWZ0WSIsImdldFJlY3RJbkN1cnJlbnRDb29yZHMiLCJnZXRQREZSZWN0Iiwib25jZUFkZGVkIiwiZW5hYmxlRWRpdE1vZGUiLCJkaXNhYmxlRWRpdE1vZGUiLCJuZWVkc1RvQmVSZWJ1aWx0IiwiaXNPblNjcmVlbiIsImJvdHRvbSIsInJpZ2h0IiwiaW5uZXJIZWlnaHQiLCJpbm5lcldpZHRoIiwicm90YXRlIiwiX2FuZ2xlIiwic2VyaWFsaXplRGVsZXRlZCIsImFubm90YXRpb25UeXBlIiwic3RydWN0VHJlZVBhcmVudElkIiwiaXNDb3B5IiwidGltZW91dCIsIm1ha2VSZXNpemFibGUiLCJjb21tZW50QnV0dG9uUG9zaXRpb25JblBhZ2UiLCJjb21tZW50UG9wdXBQb3NpdGlvbiIsImVsZW1lbnRCZWZvcmVQb3B1cCIsImJvdW5kUmVzaXplcktleWRvd24iLCJyZXNpemVyS2V5ZG93biIsImJvdW5kUmVzaXplckJsdXIiLCJyZXNpemVyQmx1ciIsInJlc2l6ZXJGb2N1cyIsImZpcnN0UG9zaXRpb24iLCJuZXh0Rmlyc3RQb3NpdGlvbiIsImkyIiwibGFzdENoaWxkIiwic2V0UmVzaXplclRhYkluZGV4Iiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwicHJldmVudFNjcm9sbCIsImRpc2FibGVFZGl0aW5nIiwiZW5hYmxlRWRpdGluZyIsImNhbkNoYW5nZUNvbnRlbnQiLCJkYmxjbGljayIsIm5vZGVOYW1lIiwiY29udGVudERpdiIsInRlbGVtZXRyeUluaXRpYWxEYXRhIiwidGVsZW1ldHJ5RmluYWxEYXRhIiwidXBkYXRlRmFrZUFubm90YXRpb25FbGVtZW50IiwiYW5ub3RhdGlvbkxheWVyIiwiYWRkRmFrZUFubm90YXRpb24iLCJ1cGRhdGVFZGl0ZWQiLCJyZXNldEFubm90YXRpb25FbGVtZW50IiwiU0VFRCIsIk1BU0tfSElHSCIsIk1BU0tfTE9XIiwiTXVybXVySGFzaDNfNjQiLCJzZWVkIiwiaDEiLCJoMiIsImJsb2NrQ291bnRzIiwidGFpbExlbmd0aCIsImRhdGFVaW50MzIiLCJrMSIsImsyIiwiQzEiLCJDMiIsIkMxX0xPVyIsIkMyX0xPVyIsImhleGRpZ2VzdCIsIlNlcmlhbGl6YWJsZUVtcHR5IiwiQW5ub3RhdGlvblN0b3JhZ2UiLCJtb2RpZmllZCIsIm1vZGlmaWVkSWRzIiwiZWRpdG9yc01hcCIsIm9uU2V0TW9kaWZpZWQiLCJvblJlc2V0TW9kaWZpZWQiLCJvbkFubm90YXRpb25FZGl0b3IiLCJkZWZhdWx0VmFsdWUiLCJyZXNldE1vZGlmaWVkIiwic2V0TW9kaWZpZWQiLCJwcmludCIsIlByaW50QW5ub3RhdGlvblN0b3JhZ2UiLCJzZXJpYWxpemFibGUiLCJoYXNCaXRtYXAiLCJlZGl0b3JTdGF0cyIsInN0YXRzIiwidHlwZVRvRWRpdG9yIiwibnVtYmVyT2ZFZGl0ZWRDb21tZW50cyIsIm51bWJlck9mRGVsZXRlZENvbW1lbnRzIiwiaXNDb21tZW50RGVsZXRlZCIsImNvdW50ZXJzIiwiY29tbWVudHMiLCJlZGl0ZWQiLCJjb21wdXRlVGVsZW1ldHJ5RmluYWxEYXRhIiwicmVzZXRNb2RpZmllZElkcyIsInVwZGF0ZUVkaXRvciIsImlkcyIsIkZvbnRMb2FkZXIiLCJzeXN0ZW1Gb250cyIsIm93bmVyRG9jdW1lbnQiLCJzdHlsZUVsZW1lbnQiLCJfZG9jdW1lbnQiLCJuYXRpdmVGb250RmFjZXMiLCJsb2FkaW5nUmVxdWVzdHMiLCJsb2FkVGVzdEZvbnRJZCIsImFkZE5hdGl2ZUZvbnRGYWNlIiwibmF0aXZlRm9udEZhY2UiLCJmb250cyIsInJlbW92ZU5hdGl2ZUZvbnRGYWNlIiwiaW5zZXJ0UnVsZSIsInJ1bGUiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsInN0eWxlU2hlZXQiLCJzaGVldCIsImNzc1J1bGVzIiwibG9hZFN5c3RlbUZvbnQiLCJzeXN0ZW1Gb250SW5mbyIsImRpc2FibGVGb250RmFjZSIsIl9pbnNwZWN0Rm9udCIsImxvYWRlZE5hbWUiLCJpc0ZvbnRMb2FkaW5nQVBJU3VwcG9ydGVkIiwiZm9udEZhY2UiLCJGb250RmFjZSIsImxvYWQiLCJiYXNlRm9udE5hbWUiLCJmb250IiwiYXR0YWNoZWQiLCJtaXNzaW5nRmlsZSIsImNyZWF0ZU5hdGl2ZUZvbnRGYWNlIiwibG9hZGVkIiwiZmFtaWx5IiwiY3JlYXRlRm9udEZhY2VSdWxlIiwiaXNTeW5jRm9udExvYWRpbmdTdXBwb3J0ZWQiLCJfcXVldWVMb2FkaW5nQ2FsbGJhY2siLCJfcHJlcGFyZUZvbnRMb2FkRXZlbnQiLCJoYXNGb250cyIsImNvbXBsZXRlUmVxdWVzdCIsIm90aGVyUmVxdWVzdCIsImNvbXBsZXRlIiwiX2xvYWRUZXN0Rm9udCIsInRlc3RGb250IiwiaW50MzIiLCJkYXRhMiIsIm9mZnNldCIsInNwbGljZVN0cmluZyIsImluc2VydCIsImNodW5rMSIsImNodW5rMiIsImNhbGxlZCIsImlzRm9udFJlYWR5IiwiZmlsbFRleHQiLCJpbWFnZURhdGEiLCJDT01NRU5UX09GRlNFVCIsIkNGRl9DSEVDS1NVTV9PRkZTRVQiLCJYWFhYX1ZBTFVFIiwiY2hlY2tzdW0iLCJmb250RmFtaWx5IiwiRm9udEZhY2VPYmplY3QiLCJmb250RGF0YSIsInRyYW5zbGF0ZWREYXRhIiwiaW5zcGVjdEZvbnQiLCJleHRyYSIsImNoYXJQcm9jT3BlcmF0b3JMaXN0IiwiY29tcGlsZWRHbHlwaHMiLCJjc3NGb250SW5mbyIsImNzcyIsIndlaWdodCIsImZvbnRXZWlnaHQiLCJpdGFsaWNBbmdsZSIsIm1pbWV0eXBlIiwiZ2V0UGF0aEdlbmVyYXRvciIsIm9ianMiLCJjaGFyYWN0ZXIiLCJvYmpJZCIsImNtZHMiLCJwYXRoIiwiUGF0aDJEIiwiZm9udEV4dHJhUHJvcGVydGllcyIsImJsYWNrIiwiYm9sZCIsImlzSW52YWxpZFBERmpzRm9udCIsImlzVHlwZTNGb250IiwiaXRhbGljIiwicmVtZWFzdXJlIiwidmVydGljYWwiLCJhc2NlbnQiLCJkZWZhdWx0V2lkdGgiLCJkZXNjZW50IiwiYmJveCIsImZvbnRNYXRyaXgiLCJmYWxsYmFja05hbWUiLCJjbGVhckRhdGEiLCJkZWZhdWx0Vk1ldHJpY3MiLCJnZXRVcmxQcm9wIiwibG9jYXRpb24iLCJnZXREYXRhUHJvcCIsIkJ1ZmZlciIsImlzTmFOIiwiZ2V0RmFjdG9yeVVybFByb3AiLCJpc1JlZlByb3h5IiwibnVtIiwiZ2VuIiwiaXNOYW1lUHJveHkiLCJpc1ZhbGlkRXhwbGljaXREZXN0IiwiTG9vcGJhY2tQb3J0IiwibGlzdGVuZXJzIiwiZGVmZXJyZWQiLCJsaXN0ZW5lciIsInJtQWJvcnQiLCJvbkFib3J0IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInRlcm1pbmF0ZSIsIkNhbGxiYWNrS2luZCIsIkRBVEEiLCJFUlJPUiIsIlN0cmVhbUtpbmQiLCJDQU5DRUwiLCJDQU5DRUxfQ09NUExFVEUiLCJDTE9TRSIsIkVOUVVFVUUiLCJQVUxMIiwiUFVMTF9DT01QTEVURSIsIlNUQVJUX0NPTVBMRVRFIiwib25GbiIsIndyYXBSZWFzb24iLCJNZXNzYWdlSGFuZGxlciIsIm1lc3NhZ2VBQyIsInNvdXJjZU5hbWUiLCJ0YXJnZXROYW1lIiwiY29tT2JqIiwiY2FsbGJhY2tJZCIsInN0cmVhbUlkIiwic3RyZWFtU2lua3MiLCJzdHJlYW1Db250cm9sbGVycyIsImNhbGxiYWNrQ2FwYWJpbGl0aWVzIiwiYWN0aW9uSGFuZGxlciIsIm9uTWVzc2FnZSIsInN0cmVhbSIsInByb2Nlc3NTdHJlYW1NZXNzYWdlIiwiY2FwYWJpbGl0eSIsInRyeSIsImNyZWF0ZVN0cmVhbVNpbmsiLCJhY3Rpb25OYW1lIiwiaGFuZGxlciIsImFoIiwidHJhbnNmZXJzIiwic2VuZFdpdGhQcm9taXNlIiwic2VuZFdpdGhTdHJlYW0iLCJxdWV1ZWluZ1N0cmF0ZWd5IiwiUmVhZGFibGVTdHJlYW0iLCJjb250cm9sbGVyIiwic3RhcnRDYXBhYmlsaXR5Iiwic3RhcnRDYWxsIiwicHVsbENhbGwiLCJjYW5jZWxDYWxsIiwiaXNDbG9zZWQiLCJkZXNpcmVkU2l6ZSIsInB1bGwiLCJwdWxsQ2FwYWJpbGl0eSIsImNhbmNlbENhcGFiaWxpdHkiLCJzdHJlYW1TaW5rIiwiZW5xdWV1ZSIsImlzQ2FuY2VsbGVkIiwibGFzdERlc2lyZWRTaXplIiwic2lua0NhcGFiaWxpdHkiLCJyZWFkeSIsIm9uUHVsbCIsIm9uQ2FuY2VsIiwic3VjY2VzcyIsInN0cmVhbUNvbnRyb2xsZXIiLCJkZWxldGVTdHJlYW1Db250cm9sbGVyIiwiZGF0YVJlYXNvbiIsImFsbFNldHRsZWQiLCJCYXNlQ2FudmFzRmFjdG9yeSIsImVuYWJsZUhXQSIsIl9jcmVhdGVDYW52YXMiLCJyZXNldCIsImNhbnZhc0FuZENvbnRleHQiLCJET01DYW52YXNGYWN0b3J5IiwiQmFzZUNNYXBSZWFkZXJGYWN0b3J5IiwiaXNDb21wcmVzc2VkIiwiX2ZldGNoIiwiY01hcERhdGEiLCJjYXRjaCIsIkRPTUNNYXBSZWFkZXJGYWN0b3J5IiwiQmFzZUZpbHRlckZhY3RvcnkiLCJhZGRGaWx0ZXIiLCJtYXBzIiwiZmdDb2xvciIsImJnQ29sb3IiLCJhZGRBbHBoYUZpbHRlciIsImFkZEx1bWlub3NpdHlGaWx0ZXIiLCJhZGRIaWdobGlnaHRIQ01GaWx0ZXIiLCJmaWx0ZXJOYW1lIiwibmV3RmdDb2xvciIsIm5ld0JnQ29sb3IiLCJrZWVwSENNIiwiRE9NRmlsdGVyRmFjdG9yeSIsIl9jYWNoZSIsIl9kZWZzIiwiZG9jSWQiLCJfaGNtQ2FjaGUiLCJoY21DYWNoZSIsImRlZnMiLCJjb250YWluIiwiY3JlYXRlVGFibGVzIiwibWFwUjIiLCJ0YWJsZSIsIm1hcFIiLCJtYXBHIiwibWFwQiIsImJ1ZmZlclIiLCJidWZmZXJHIiwiYnVmZmVyQiIsImNyZWF0ZVVybCIsInRhYmxlUiIsInRhYmxlRyIsInRhYmxlQiIsImNyZWF0ZUZpbHRlciIsImFkZFRyYW5zZmVyTWFwQ29udmVyc2lvbiIsImZnUkdCIiwiYmdSR0IiLCJhZGRHcmF5Q29udmVyc2lvbiIsImdldFN0ZXBzIiwidGFibGVBIiwiYWRkVHJhbnNmZXJNYXBBbHBoYUNvbnZlcnNpb24iLCJhZGRMdW1pbm9zaXR5Q29udmVyc2lvbiIsImZnR3JheSIsImJnR3JheSIsIm5ld0ZnUkdCIiwibmV3QmdSR0IiLCJmZyIsImJnIiwibmV3U3RhcnQiLCJuZXdTdGVwIiwicHJldiIsImZlQ29sb3JNYXRyaXgiLCJhcHBlbmRGZUZ1bmMiLCJmZUNvbXBvbmVudFRyYW5zZmVyIiwiZmVGdW5jIiwiclRhYmxlIiwiZ1RhYmxlIiwiYlRhYmxlIiwiYVRhYmxlIiwiQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IiwiRE9NU3RhbmRhcmRGb250RGF0YUZhY3RvcnkiLCJCYXNlV2FzbUZhY3RvcnkiLCJET01XYXNtRmFjdG9yeSIsInJlcXVpcmUkMSIsImNyZWF0ZVJlcXVpcmUiLCJyZXF1aXJlIiwicGF0aFRvRmlsZVVSTCIsIl9fZmlsZW5hbWUiLCJET01NYXRyaXgiLCJJbWFnZURhdGEiLCJsYW5ndWFnZSIsIm5vZGVfdXRpbHNfZmV0Y2hEYXRhIiwiZnMiLCJyZWFkRmlsZSIsIk5vZGVGaWx0ZXJGYWN0b3J5IiwiTm9kZUNhbnZhc0ZhY3RvcnkiLCJjcmVhdGVDYW52YXMiLCJOb2RlQ01hcFJlYWRlckZhY3RvcnkiLCJOb2RlU3RhbmRhcmRGb250RGF0YUZhY3RvcnkiLCJOb2RlV2FzbUZhY3RvcnkiLCJGT1JDRURfREVQRU5ERU5DWV9MQUJFTCIsImV4cGFuZEJCb3giLCJtaW5YIiwibWluWSIsIm1heFgiLCJtYXhZIiwiRU1QVFlfQkJPWCIsIkJCb3hSZWFkZXIiLCJiYm94ZXMiLCJjb29yZHMiLCJlbnN1cmVEZWJ1Z01ldGFkYXRhIiwiZGVwZW5kZW5jaWVzIiwiaXNSZW5kZXJpbmdPcGVyYXRpb24iLCJDYW52YXNEZXBlbmRlbmN5VHJhY2tlciIsImluY3JlbWVudGFsIiwibmFtZWREZXBlbmRlbmNpZXMiLCJzYXZlc1N0YWNrIiwibWFya2VkQ29udGVudFN0YWNrIiwiYmFzZVRyYW5zZm9ybVN0YWNrIiwiY2xpcEJveCIsInBlbmRpbmdCQm94IiwicGVuZGluZ0JCb3hJZHgiLCJwZW5kaW5nRGVwZW5kZW5jaWVzIiwib3BlcmF0aW9ucyIsImZvbnRCQm94VHJ1c3R3b3J0aHkiLCJjYW52YXNXaWR0aCIsImNhbnZhc0hlaWdodCIsImJib3hlc0Nvb3JkcyIsImRlYnVnTWV0YWRhdGEiLCJvcGVyYXRpb25zQ291bnQiLCJyZWNvcmREZWJ1Z01ldGFkYXRhIiwic2FtZUxpbmVUZXh0IiwiaW5pdGlhbGl6ZUJCb3hlcyIsImdyb3dPcGVyYXRpb25zQ291bnQiLCJvbGRCQm94ZXMiLCJvcElkeCIsInByZXZpb3VzIiwibGFzdFNhdmUiLCJyZWNvcmRPcGVuTWFya2VyIiwiaWR4IiwiZ2V0T3Blbk1hcmtlciIsInJlY29yZENsb3NlTWFya2VyIiwicHVzaEJhc2VUcmFuc2Zvcm0iLCJwb3BCYXNlVHJhbnNmb3JtIiwicmVjb3JkU2ltcGxlRGF0YSIsInJlY29yZEluY3JlbWVudGFsRGF0YSIsInJlc2V0SW5jcmVtZW50YWxEYXRhIiwicmVjb3JkTmFtZWREYXRhIiwicmVjb3JkU2ltcGxlRGF0YUZyb21OYW1lZCIsImRlcE5hbWUiLCJmYWxsYmFja0lkeCIsInJlY29yZEZ1dHVyZUZvcmNlZERlcGVuZGVuY3kiLCJpbmhlcml0U2ltcGxlRGF0YUFzRnV0dXJlRm9yY2VkRGVwZW5kZW5jaWVzIiwiaW5oZXJpdFBlbmRpbmdEZXBlbmRlbmNpZXNBc0Z1dHVyZUZvcmNlZERlcGVuZGVuY2llcyIsImRlcCIsInJlc2V0QkJveCIsInJlY29yZENsaXBCb3giLCJyZWNvcmRCQm94IiwicmVjb3JkQ2hhcmFjdGVyQkJveCIsImdldE1lYXN1cmUiLCJmb250QkJveCIsImlzQkJveFRydXN0d29ydGh5IiwiY29tcHV0ZWRCQm94IiwicmVjb3JkRnVsbFBhZ2VCQm94IiwibWVhc3VyZSIsImFjdHVhbEJvdW5kaW5nQm94TGVmdCIsImFjdHVhbEJvdW5kaW5nQm94UmlnaHQiLCJhY3R1YWxCb3VuZGluZ0JveEFzY2VudCIsImFjdHVhbEJvdW5kaW5nQm94RGVzY2VudCIsImdldFNpbXBsZUluZGV4IiwiZGVwZW5kZW5jeU5hbWUiLCJyZWNvcmREZXBlbmRlbmNpZXMiLCJkZXBlbmRlbmN5TmFtZXMiLCJyZWNvcmROYW1lZERlcGVuZGVuY3kiLCJyZWNvcmRPcGVyYXRpb24iLCJwcmVzZXJ2ZSIsImRlcElkeCIsInNhdmVJZHgiLCJyZWNvcmRTaG93VGV4dE9wZXJhdGlvbiIsImRlcHMiLCJiYm94VG9DbGlwQm94RHJvcE9wZXJhdGlvbiIsIl90YWtlUGVuZGluZ0RlcGVuZGVuY2llcyIsIl9leHRyYWN0T3BlcmF0aW9uIiwib3BlcmF0aW9uIiwiX3B1c2hQZW5kaW5nRGVwZW5kZW5jaWVzIiwidGFrZURlYnVnTWV0YWRhdGEiLCJDYW52YXNOZXN0ZWREZXBlbmRlbmN5VHJhY2tlciIsImRlcGVuZGVuY3lUcmFja2VyIiwiaWdub3JlQkJveGVzIiwibmVzdGluZ0xldmVsIiwic2F2ZXNMZXZlbCIsIkRlcGVuZGVuY2llcyIsImltYWdlWE9iamVjdCIsInRyYW5zZm9ybUFuZEZpbGwiLCJQYXRoVHlwZSIsIlNIQURJTkciLCJhcHBseUJvdW5kaW5nQm94IiwicmVnaW9uIiwiQmFzZVNoYWRpbmdQYXR0ZXJuIiwiaXNNb2RpZnlpbmdDdXJyZW50VHJhbnNmb3JtIiwiZ2V0UGF0dGVybiIsIlJhZGlhbEF4aWFsU2hhZGluZ1BhdHRlcm4iLCJJUiIsIl9iYm94IiwiX2NvbG9yU3RvcHMiLCJfcDAiLCJfcDEiLCJfcjAiLCJfcjEiLCJfY3JlYXRlR3JhZGllbnQiLCJncmFkIiwiY3JlYXRlTGluZWFyR3JhZGllbnQiLCJjcmVhdGVSYWRpYWxHcmFkaWVudCIsImNvbG9yU3RvcCIsImFkZENvbG9yU3RvcCIsIm93bmVyIiwicGF0aFR5cGUiLCJwYXR0ZXJuIiwib3duZXJCQm94IiwiZ2V0Q2xpcHBlZFBhdGhCb3VuZGluZ0JveCIsInRtcENhbnZhcyIsImNhY2hlZENhbnZhc2VzIiwiZ2V0Q2FudmFzIiwidG1wQ3R4IiwiY2xlYXJSZWN0IiwiYmVnaW5QYXRoIiwiYmFzZVRyYW5zZm9ybSIsImZpbGxTdHlsZSIsImNyZWF0ZVBhdHRlcm4iLCJkb21NYXRyaXgiLCJzZXRUcmFuc2Zvcm0iLCJkcmF3VHJpYW5nbGUiLCJwMyIsImMxIiwiYzIiLCJjMyIsInJvd1NpemUiLCJzY2FsZVgiLCJzY2FsZVkiLCJjMXIiLCJjMWciLCJjMWIiLCJjMnIiLCJjMmciLCJjMmIiLCJjM3IiLCJjM2ciLCJjM2IiLCJ4YSIsImNhciIsImNhZyIsImNhYiIsInhiIiwiY2JyIiwiY2JnIiwiY2JiIiwieDFfIiwieDJfIiwiZHJhd0ZpZ3VyZSIsImZpZ3VyZSIsInBzIiwiY3MiLCJ2ZXJ0aWNlc1BlclJvdyIsInJvd3MiLCJjb2xzIiwicSIsIk1lc2hTaGFkaW5nUGF0dGVybiIsIl9jb29yZHMiLCJfZmlndXJlcyIsIl9ib3VuZHMiLCJfYmFja2dyb3VuZCIsIl9jcmVhdGVNZXNoQ2FudmFzIiwiY29tYmluZWRTY2FsZSIsIkVYUEVDVEVEX1NDQUxFIiwiTUFYX1BBVFRFUk5fU0laRSIsIkJPUkRFUl9TSVpFIiwiYm91bmRzV2lkdGgiLCJib3VuZHNIZWlnaHQiLCJwYWRkZWRXaWR0aCIsInBhZGRlZEhlaWdodCIsImNyZWF0ZUltYWdlRGF0YSIsInB1dEltYWdlRGF0YSIsIm1hdHJpeFNjYWxlWCIsIm1hdHJpeFNjYWxlWSIsInRlbXBvcmFyeVBhdHRlcm5DYW52YXMiLCJEdW1teVNoYWRpbmdQYXR0ZXJuIiwiZ2V0U2hhZGluZ1BhdHRlcm4iLCJQYWludFR5cGUiLCJDT0xPUkVEIiwiVU5DT0xPUkVEIiwiVGlsaW5nUGF0dGVybiIsImNhbnZhc0dyYXBoaWNzRmFjdG9yeSIsIm9wZXJhdG9yTGlzdCIsInhzdGVwIiwieXN0ZXAiLCJwYWludFR5cGUiLCJ0aWxpbmdUeXBlIiwiY3JlYXRlUGF0dGVybkNhbnZhcyIsImNvbWJpbmVkU2NhbGVYIiwiY29tYmluZWRTY2FsZVkiLCJyZWRyYXdIb3Jpem9udGFsbHkiLCJyZWRyYXdWZXJ0aWNhbGx5IiwieFNjYWxlZFN0ZXAiLCJ5U2NhbGVkU3RlcCIsInhTY2FsZWRXaWR0aCIsInlTY2FsZWRIZWlnaHQiLCJkaW14IiwiZ2V0U2l6ZUFuZFNjYWxlIiwiZGlteSIsImdyYXBoaWNzIiwiY3JlYXRlQ2FudmFzR3JhcGhpY3MiLCJncm91cExldmVsIiwic2V0RmlsbEFuZFN0cm9rZVN0eWxlVG9Db250ZXh0IiwiY2xpcEJib3giLCJleGVjdXRlT3BlcmF0b3JMaXN0IiwiZW5kRHJhd2luZyIsImRpbXgyIiwiZGlteTIiLCJ4U2l6ZSIsInlTaXplIiwidG1wQ2FudmFzMiIsInRtcEN0eDIiLCJqaiIsInJlYWxPdXRwdXRTaXplIiwiYmJveFdpZHRoIiwiYmJveEhlaWdodCIsInN0cm9rZVN0eWxlIiwiZmlsbENvbG9yIiwic3Ryb2tlQ29sb3IiLCJjb252ZXJ0QmxhY2tBbmRXaGl0ZVRvUkdCQSIsInNyY1BvcyIsIm5vbkJsYWNrQ29sb3IiLCJpbnZlcnNlRGVjb2RlIiwiemVyb01hcHBpbmciLCJvbmVNYXBwaW5nIiwid2lkdGhJblNvdXJjZSIsIndpZHRoUmVtYWluZGVyIiwic3JjTGVuZ3RoIiwiZGVzdFBvcyIsImVsZW0yIiwiZWxlbSIsIk1JTl9GT05UX1NJWkUiLCJNQVhfRk9OVF9TSVpFIiwiRVhFQ1VUSU9OX1RJTUUiLCJFWEVDVVRJT05fU1RFUFMiLCJGVUxMX0NIVU5LX0hFSUdIVCIsIlNDQUxFX01BVFJJWCIsIlhZIiwiTUlOX01BWF9JTklUIiwibWlycm9yQ29udGV4dE9wZXJhdGlvbnMiLCJkZXN0Q3R4IiwiX3JlbW92ZU1pcnJvcmluZyIsIl9fb3JpZ2luYWxTYXZlIiwiX19vcmlnaW5hbFJlc3RvcmUiLCJfX29yaWdpbmFsUm90YXRlIiwiX19vcmlnaW5hbFNjYWxlIiwiX19vcmlnaW5hbFRyYW5zbGF0ZSIsIl9fb3JpZ2luYWxUcmFuc2Zvcm0iLCJfX29yaWdpbmFsU2V0VHJhbnNmb3JtIiwiX19vcmlnaW5hbFJlc2V0VHJhbnNmb3JtIiwicmVzZXRUcmFuc2Zvcm0iLCJfX29yaWdpbmFsQ2xpcCIsIl9fb3JpZ2luYWxNb3ZlVG8iLCJfX29yaWdpbmFsTGluZVRvIiwiX19vcmlnaW5hbEJlemllckN1cnZlVG8iLCJiZXppZXJDdXJ2ZVRvIiwiX19vcmlnaW5hbFJlY3QiLCJfX29yaWdpbmFsQ2xvc2VQYXRoIiwiX19vcmlnaW5hbEJlZ2luUGF0aCIsImNwMXgiLCJjcDF5IiwiY3AyeCIsImNwMnkiLCJDYWNoZWRDYW52YXNlcyIsImNhbnZhc0ZhY3RvcnkiLCJjYW52YXNFbnRyeSIsImRyYXdJbWFnZUF0SW50ZWdlckNvb3JkcyIsInNyY0ltZyIsInNyY1giLCJzcmNZIiwic3JjVyIsInNyY0giLCJkZXN0WCIsImRlc3RZIiwiZGVzdFciLCJkZXN0SCIsInRsWCIsInJUbFgiLCJ0bFkiLCJyVGxZIiwiYnJYIiwicldpZHRoIiwiYnJZIiwickhlaWdodCIsIkNhbnZhc0V4dHJhU3RhdGUiLCJwcmVJbml0IiwiYWxwaGFJc1NoYXBlIiwiZm9udFNpemUiLCJmb250U2l6ZVNjYWxlIiwidGV4dE1hdHJpeCIsInRleHRNYXRyaXhTY2FsZSIsImxlYWRpbmciLCJsaW5lWCIsImxpbmVZIiwiY2hhclNwYWNpbmciLCJ3b3JkU3BhY2luZyIsInRleHRIU2NhbGUiLCJ0ZXh0UmVuZGVyaW5nTW9kZSIsInRleHRSaXNlIiwicGF0dGVybkZpbGwiLCJwYXR0ZXJuU3Ryb2tlIiwiZmlsbEFscGhhIiwic3Ryb2tlQWxwaGEiLCJsaW5lV2lkdGgiLCJhY3RpdmVTTWFzayIsInRyYW5zZmVyTWFwcyIsImdldFBhdGhCb3VuZGluZ0JveCIsInhTdHJva2VQYWQiLCJ5U3Ryb2tlUGFkIiwidXBkYXRlQ2xpcEZyb21QYXRoIiwic3RhcnROZXdQYXRoQW5kQ2xpcEJveCIsImlzRW1wdHlDbGlwIiwicHV0QmluYXJ5SW1hZ2VEYXRhIiwiaW1nRGF0YSIsInBhcnRpYWxDaHVua0hlaWdodCIsImZ1bGxDaHVua3MiLCJ0b3RhbENodW5rcyIsImNodW5rSW1nRGF0YSIsInRoaXNDaHVua0hlaWdodCIsImVsZW1zSW5UaGlzQ2h1bmsiLCJkZXN0MzIiLCJkZXN0MzJEYXRhTGVuZ3RoIiwiZnVsbFNyY0RpZmYiLCJzcmNEaWZmIiwia0VuZCIsImtFbmRVbnJvbGxlZCIsIm1hc2siLCJzcmNCeXRlIiwicHV0QmluYXJ5SW1hZ2VNYXNrIiwiY29weUN0eFN0YXRlIiwic291cmNlQ3R4IiwicHJvcGVydGllcyIsInNldExpbmVEYXNoIiwiZ2V0TGluZURhc2giLCJsaW5lRGFzaE9mZnNldCIsInJlc2V0Q3R4VG9EZWZhdWx0IiwiZmlsbFJ1bGUiLCJnbG9iYWxBbHBoYSIsImxpbmVDYXAiLCJsaW5lSm9pbiIsIm1pdGVyTGltaXQiLCJnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24iLCJnZXRJbWFnZVNtb290aGluZ0VuYWJsZWQiLCJpbnRlcnBvbGF0ZSIsImFjdHVhbFNjYWxlIiwiZnJvdW5kIiwiTElORV9DQVBfU1RZTEVTIiwiTElORV9KT0lOX1NUWUxFUyIsIk5PUk1BTF9DTElQIiwiRU9fQ0xJUCIsIkNhbnZhc0dyYXBoaWNzIiwiY2FudmFzQ3R4IiwiY29tbW9uT2JqcyIsIm9wdGlvbmFsQ29udGVudENvbmZpZyIsImFubm90YXRpb25DYW52YXNNYXAiLCJzdGF0ZVN0YWNrIiwicGVuZGluZ0NsaXAiLCJwZW5kaW5nRU9GaWxsIiwieG9ianMiLCJncm91cFN0YWNrIiwic21hc2tTdGFjayIsInNtYXNrQ291bnRlciIsInRlbXBTTWFzayIsInN1c3BlbmRlZEN0eCIsImNvbnRlbnRWaXNpYmxlIiwiY2FjaGVkUGF0dGVybnMiLCJ2aWV3cG9ydFNjYWxlIiwib3V0cHV0U2NhbGVYIiwib3V0cHV0U2NhbGVZIiwiX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmciLCJfY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCIsIl9jYWNoZWRCaXRtYXBzTWFwIiwiZ2V0T2JqZWN0IiwiZmFsbGJhY2siLCJiZWdpbkRyYXdpbmciLCJ0cmFuc3BhcmVuY3kiLCJzYXZlZEZpbGxTdHlsZSIsImZpbGxSZWN0IiwidHJhbnNwYXJlbnRDYW52YXMiLCJjb21wb3NpdGVDdHgiLCJleGVjdXRpb25TdGFydElkeCIsImNvbnRpbnVlQ2FsbGJhY2siLCJzdGVwcGVyIiwib3BlcmF0aW9uc0ZpbHRlciIsImFyZ3NBcnJheSIsImZuQXJyYXkiLCJhcmdzQXJyYXlMZW4iLCJjaHVua09wZXJhdGlvbnMiLCJlbmRUaW1lIiwic3RlcHMiLCJmbklkIiwiZm5BcmdzIiwibmV4dEJyZWFrUG9pbnQiLCJicmVha0l0IiwiZGVwT2JqSWQiLCJvYmpzUG9vbCIsInJlc3RvcmVJbml0aWFsU3RhdGUiLCJpblNNYXNrTW9kZSIsIkhUTUxDYW52YXNFbGVtZW50IiwiZHJhd0ZpbHRlciIsImhjbUZpbHRlcklkIiwic2F2ZWRGaWx0ZXIiLCJfc2NhbGVJbWFnZSIsImltZyIsImRpc3BsYXlXaWR0aCIsImRpc3BsYXlIZWlnaHQiLCJ3aWR0aFNjYWxlIiwiaGVpZ2h0U2NhbGUiLCJwYWludFdpZHRoIiwicGFpbnRIZWlnaHQiLCJ0bXBDYW52YXNJZCIsIl9jcmVhdGVNYXNrQ2FudmFzIiwiaXNQYXR0ZXJuRmlsbCIsImN1cnJlbnRUcmFuc2Zvcm0iLCJjYWNoZUtleSIsIm1hc2tDYW52YXMiLCJtYWluS2V5IiwiY2FjaGVkSW1hZ2UiLCJvZmZzZXRYMiIsIm9mZnNldFkyIiwibWFza1RvQ2FudmFzIiwiZHJhd25XaWR0aCIsImRyYXduSGVpZ2h0IiwiZmlsbENhbnZhcyIsImZpbGxDdHgiLCJpbWFnZVNtb290aGluZ0VuYWJsZWQiLCJkYXNoQXJyYXkiLCJkYXNoUGhhc2UiLCJmbGF0bmVzcyIsInN0YXRlcyIsImNoZWNrU01hc2tTdGF0ZSIsImJlZ2luU01hc2tNb2RlIiwiZW5kU01hc2tNb2RlIiwiY2FjaGVJZCIsInNjcmF0Y2hDYW52YXMiLCJjb21wb3NlIiwiZGlydHlCb3giLCJzbWFzayIsImNvbXBvc2VTTWFzayIsImxheWVyQ3R4IiwibGF5ZXJCb3giLCJsYXllck9mZnNldFgiLCJsYXllck9mZnNldFkiLCJsYXllcldpZHRoIiwibGF5ZXJIZWlnaHQiLCJnZW5lcmljQ29tcG9zZVNNYXNrIiwic3VidHlwZSIsImJhY2tkcm9wIiwidHJhbnNmZXJNYXAiLCJtYXNrQ3R4IiwibWFza09mZnNldFgiLCJtYXNrT2Zmc2V0WSIsIm1hc2tYIiwibWFza1kiLCJjbGlwMiIsIm9sZCIsIm9wIiwib3V0ZXJFeHRyYVNpemUiLCJwYXRoMmQiLCJfcGF0aFN0YXJ0SWR4IiwiY29uc3VtZVBhdGgiLCJuZXdQYXRoIiwiYWRkUGF0aCIsIm11bHRpcGx5U2VsZiIsInJlc2NhbGVBbmRTdHJva2UiLCJuZWVkUmVzdG9yZSIsInBhdGhzIiwicGVuZGluZ1RleHRQYXRocyIsInByZU11bHRpcGx5U2VsZiIsInNwYWNpbmciLCJmb250UmVmTmFtZSIsImZvbnRPYmoiLCJmb250RGlyZWN0aW9uIiwidHlwZWZhY2UiLCJicm93c2VyRm9udFNpemUiLCJyaXNlIiwiZ2V0U2NhbGVkUGF0aCIsInBhaW50Q2hhciIsInBhdHRlcm5GaWxsVHJhbnNmb3JtIiwicGF0dGVyblN0cm9rZVRyYW5zZm9ybSIsImZpbGxTdHJva2VNb2RlIiwiaXNBZGRUb1BhdGhTZXQiLCJzY2FsZWRQYXRoIiwiaW52UGF0dGVyblRyYW5zZm9ybSIsIm1lYXN1cmVUZXh0Iiwic3Ryb2tlVGV4dCIsImlzRm9udFN1YnBpeGVsQUFFbmFibGVkIiwiZ2x5cGhzIiwic2hvd1R5cGUzVGV4dCIsImdseXBoc0xlbmd0aCIsInNwYWNpbmdEaXIiLCJ3aWR0aEFkdmFuY2VTY2FsZSIsInNpbXBsZUZpbGxUZXh0IiwiZ2V0U2luZ2xlUGl4ZWxXaWR0aCIsImNoYXJzIiwiZ2x5cGgiLCJ1bmljb2RlIiwiam9pbmVkQ2hhcnMiLCJyZXN0b3JlTmVlZGVkIiwiaXNTcGFjZSIsImZvbnRDaGFyIiwiYWNjZW50Iiwic2NhbGVkWCIsInNjYWxlZFkiLCJ2bWV0cmljIiwidngiLCJ2eSIsIm1lYXN1cmVkV2lkdGgiLCJjaGFyYWN0ZXJTY2FsZVgiLCJpc0luRm9udCIsInNjYWxlZEFjY2VudFgiLCJzY2FsZWRBY2NlbnRZIiwiY2hhcldpZHRoIiwiaXNUZXh0SW52aXNpYmxlIiwic3BhY2luZ0xlbmd0aCIsIm9wZXJhdG9yTGlzdElkIiwieFdpZHRoIiwieVdpZHRoIiwibGx4IiwibGx5IiwidXJ4IiwidXJ5IiwiZ2V0Q29sb3JOX1BhdHRlcm4iLCJyZW5kZXJpbmdPcElkeCIsIl9nZXRQYXR0ZXJuIiwiaW52IiwiZ3JvdXAiLCJjdXJyZW50Q3R4IiwiaXNvbGF0ZWQiLCJrbm9ja291dCIsImJvdW5kcyIsImNhbnZhc0JvdW5kcyIsImdyb3VwQ3R4Iiwic3RhcnRUcmFuc2Zvcm1JbnZlcnNlIiwiY3VycmVudE10eCIsImhhc093bkNhbnZhcyIsImFubm90YXRpb25DYW52YXMiLCJzYXZlZEN0eCIsInNrZXdYIiwic2tld1kiLCJwb3NpdGlvbnMiLCJ0cmFucyIsImltYWdlcyIsImFwcGx5VHJhbnNmZXJNYXBzVG9DYW52YXMiLCJhcHBseVRyYW5zZmVyTWFwc1RvQml0bWFwIiwiaW1nVG9QYWludCIsIkhUTUxFbGVtZW50IiwiaXNWaXNpYmxlIiwiaXNDb250ZW50VmlzaWJsZSIsImFic0RldCIsIm5vcm1YIiwibm9ybVkiLCJnZXRTY2FsZUZvclN0cm9raW5nIiwic2NhbGVkTGluZVdpZHRoIiwic2NhbGVkWExpbmVXaWR0aCIsInNjYWxlZFlMaW5lV2lkdGgiLCJiYXNlQXJlYSIsInNhdmVSZXN0b3JlIiwiZGFzaGVzIiwiQ3NzRm9udEluZm8iLCJ2aWV3IiwiZGVjb2RlciIsInN0cmluZ3MiLCJlbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJlbmNvZGVkU3RyaW5ncyIsInN0cmluZ3NMZW5ndGgiLCJlbmNvZGVkIiwiZW5jb2RlIiwic2V0VWludDMyIiwiVGV4dERlY29kZXIiLCJyZWFkU3RyaW5nIiwiZ2V0VWludDMyIiwiU3lzdGVtRm9udEluZm8iLCJlbmNvZGVkU3R5bGVTdHlsZSIsImVuY29kZWRTdHlsZVdlaWdodCIsImxlbmd0aEVzdGltYXRlIiwic2V0VWludDgiLCJndWVzc0ZhbGxiYWNrIiwiZ2V0VWludDgiLCJzdHlsZUxlbmd0aCIsIndlaWdodExlbmd0aCIsIkZvbnRJbmZvIiwiYm9vbHMiLCJPRkZTRVRfTlVNQkVSUyIsIk9GRlNFVF9CQk9YIiwiT0ZGU0VUX0ZPTlRfTUFUUklYIiwiT0ZGU0VUX0RFRkFVTFRfVk1FVFJJQ1MiLCJPRkZTRVRfU1RSSU5HUyIsInJlYWRCb29sZWFuIiwiYnl0ZU9mZnNldCIsImJpdE9mZnNldCIsInJlYWROdW1iZXIiLCJnZXRGbG9hdDY0IiwibnVtQ29vcmRzIiwiZ2V0SW50MTYiLCJudW1Qb2ludHMiLCJudW1NZXRyaWNzIiwic3RyaW5nRGF0YSIsInN5c3RlbUZvbnRJbmZvTGVuZ3RoIiwiY3NzRm9udEluZm9MZW5ndGgiLCJjc3NGb250SW5mb0RhdGEiLCJzeXN0ZW1Gb250SW5mb0RhdGEiLCJzeXN0ZW1Gb250SW5mb0J1ZmZlciIsImNzc0ZvbnRJbmZvQnVmZmVyIiwibnVtQm9vbHMiLCJib29sQnl0ZSIsImJvb2xCaXQiLCJiaXRzIiwic2V0RmxvYXQ2NCIsImNvb3JkIiwic2V0SW50MTYiLCJtZXRyaWMiLCJHbG9iYWxXb3JrZXJPcHRpb25zIiwicG9ydCIsIndvcmtlclBvcnQiLCJXb3JrZXIiLCJ3b3JrZXJTcmMiLCJNZXRhZGF0YSIsInBhcnNlZERhdGEiLCJnZXRSYXciLCJJTlRFUk5BTCIsIk9wdGlvbmFsQ29udGVudEdyb3VwIiwiaXNEaXNwbGF5IiwiaXNQcmludCIsInVzZXJTZXQiLCJyZW5kZXJpbmdJbnRlbnQiLCJ1c2FnZSIsInJiR3JvdXBzIiwidmlld1N0YXRlIiwicHJpbnRTdGF0ZSIsIl9zZXRWaXNpYmxlIiwiaW50ZXJuYWwiLCJPcHRpb25hbENvbnRlbnRDb25maWciLCJjYWNoZWRHZXRIYXNoIiwiZ3JvdXBzIiwiaW5pdGlhbEhhc2giLCJvcmRlciIsImNyZWF0b3IiLCJiYXNlU3RhdGUiLCJvZmYiLCJnZXRIYXNoIiwiZXZhbHVhdGVWaXNpYmlsaXR5RXhwcmVzc2lvbiIsIm9wZXJhdG9yIiwiZXhwcmVzc2lvbiIsInBvbGljeSIsInNldFZpc2liaWxpdHkiLCJwcmVzZXJ2ZVJCIiwicmJHcm91cCIsIm90aGVySWQiLCJzZXRPQ0dTdGF0ZSIsImhhc0luaXRpYWxWaXNpYmlsaXR5IiwiZ2V0T3JkZXIiLCJnZXRHcm91cCIsIlBERkRhdGFUcmFuc3BvcnRTdHJlYW0iLCJwZGZEYXRhUmFuZ2VUcmFuc3BvcnQiLCJkaXNhYmxlUmFuZ2UiLCJkaXNhYmxlU3RyZWFtIiwiaW5pdGlhbERhdGEiLCJwcm9ncmVzc2l2ZURvbmUiLCJjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSIsIl9xdWV1ZWRDaHVua3MiLCJfcHJvZ3Jlc3NpdmVEb25lIiwiX2NvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lIiwiX3BkZkRhdGFSYW5nZVRyYW5zcG9ydCIsIl9pc1N0cmVhbWluZ1N1cHBvcnRlZCIsIl9pc1JhbmdlU3VwcG9ydGVkIiwiX2NvbnRlbnRMZW5ndGgiLCJfZnVsbFJlcXVlc3RSZWFkZXIiLCJfcmFuZ2VSZWFkZXJzIiwiYWRkUmFuZ2VMaXN0ZW5lciIsImJlZ2luIiwiX29uUmVjZWl2ZURhdGEiLCJhZGRQcm9ncmVzc0xpc3RlbmVyIiwidG90YWwiLCJfb25Qcm9ncmVzcyIsImFkZFByb2dyZXNzaXZlUmVhZExpc3RlbmVyIiwiYWRkUHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXIiLCJfb25Qcm9ncmVzc2l2ZURvbmUiLCJ0cmFuc3BvcnRSZWFkeSIsIl9lbnF1ZXVlIiwicmFuZ2VSZWFkZXIiLCJfYmVnaW4iLCJfcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoIiwiX2xvYWRlZCIsIm9uUHJvZ3Jlc3MiLCJfcmVtb3ZlUmFuZ2VSZWFkZXIiLCJyZWFkZXIiLCJnZXRGdWxsUmVhZGVyIiwicXVldWVkQ2h1bmtzIiwiUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJlYWRlciIsImdldFJhbmdlUmVhZGVyIiwiUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJhbmdlUmVhZGVyIiwicmVxdWVzdERhdGFSYW5nZSIsImNhbmNlbEFsbFJlcXVlc3RzIiwiX3N0cmVhbSIsIl9kb25lIiwiX2ZpbGVuYW1lIiwiX3JlcXVlc3RzIiwiX2hlYWRlcnNSZWFkeSIsInJlcXVlc3RDYXBhYmlsaXR5IiwiaGVhZGVyc1JlYWR5IiwiaXNSYW5nZVN1cHBvcnRlZCIsImlzU3RyZWFtaW5nU3VwcG9ydGVkIiwiY29udGVudExlbmd0aCIsIl9lbmQiLCJfcXVldWVkQ2h1bmsiLCJyZXF1ZXN0c0NhcGFiaWxpdHkiLCJnZXRGaWxlbmFtZUZyb21Db250ZW50RGlzcG9zaXRpb25IZWFkZXIiLCJjb250ZW50RGlzcG9zaXRpb24iLCJuZWVkc0VuY29kaW5nRml4dXAiLCJ0b1BhcmFtUmVnRXhwIiwicmZjMjYxNnVucXVvdGUiLCJ1bmVzY2FwZSIsInJmYzU5ODdkZWNvZGUiLCJyZmMyMDQ3ZGVjb2RlIiwiZml4dXBFbmNvZGluZyIsInJmYzIyMzFnZXRwYXJhbSIsImF0dHJpYnV0ZVBhdHRlcm4iLCJmbGFncyIsInRleHRkZWNvZGUiLCJlbmNvZGluZyIsImZhdGFsIiwiY29udGVudERpc3Bvc2l0aW9uU3RyIiwiaXRlciIsInF1b3QiLCJwYXJ0IiwicGFydHMiLCJxdW90aW5kZXgiLCJleHR2YWx1ZSIsImVuY29kaW5nZW5kIiwibGFuZ3ZhbHVlIiwiY2hhcnNldCIsImNyZWF0ZUhlYWRlcnMiLCJpc0h0dHAiLCJodHRwSGVhZGVycyIsImhlYWRlcnMiLCJIZWFkZXJzIiwiZ2V0UmVzcG9uc2VPcmlnaW4iLCJ2YWxpZGF0ZVJhbmdlUmVxdWVzdENhcGFiaWxpdGllcyIsInJlc3BvbnNlSGVhZGVycyIsInJhbmdlQ2h1bmtTaXplIiwicmV0dXJuVmFsdWVzIiwiYWxsb3dSYW5nZVJlcXVlc3RzIiwic3VnZ2VzdGVkTGVuZ3RoIiwiY29udGVudEVuY29kaW5nIiwiZXh0cmFjdEZpbGVuYW1lRnJvbUhlYWRlciIsImNyZWF0ZVJlc3BvbnNlRXJyb3IiLCJ2YWxpZGF0ZVJlc3BvbnNlU3RhdHVzIiwiY3JlYXRlRmV0Y2hPcHRpb25zIiwid2l0aENyZWRlbnRpYWxzIiwiY3JlZGVudGlhbHMiLCJyZWRpcmVjdCIsImdldEFycmF5QnVmZmVyIiwiUERGRmV0Y2hTdHJlYW0iLCJfcmVzcG9uc2VPcmlnaW4iLCJfcmFuZ2VSZXF1ZXN0UmVhZGVycyIsIlBERkZldGNoU3RyZWFtUmVhZGVyIiwiUERGRmV0Y2hTdHJlYW1SYW5nZVJlYWRlciIsIl9yZWFkZXIiLCJfd2l0aENyZWRlbnRpYWxzIiwiX2hlYWRlcnNDYXBhYmlsaXR5IiwiX2Rpc2FibGVSYW5nZSIsIl9yYW5nZUNodW5rU2l6ZSIsIl9hYm9ydENvbnRyb2xsZXIiLCJnZXRSZWFkZXIiLCJfcmVhZENhcGFiaWxpdHkiLCJyZXNwb25zZU9yaWdpbiIsIk9LX1JFU1BPTlNFIiwiUEFSVElBTF9DT05URU5UX1JFU1BPTlNFIiwibmV0d29ya19nZXRBcnJheUJ1ZmZlciIsInhociIsIk5ldHdvcmtNYW5hZ2VyIiwiY3VyclhocklkIiwicGVuZGluZ1JlcXVlc3RzIiwieGhySWQiLCJwZW5kaW5nUmVxdWVzdCIsInNldFJlcXVlc3RIZWFkZXIiLCJleHBlY3RlZFN0YXR1cyIsIm9uRXJyb3IiLCJvblN0YXRlQ2hhbmdlIiwib25wcm9ncmVzcyIsIm9uSGVhZGVyc1JlY2VpdmVkIiwib25Eb25lIiwieGhyU3RhdHVzIiwib2tfcmVzcG9uc2Vfb25fcmFuZ2VfcmVxdWVzdCIsInJhbmdlSGVhZGVyIiwiZ2V0UmVzcG9uc2VIZWFkZXIiLCJnZXRSZXF1ZXN0WGhyIiwiaXNQZW5kaW5nUmVxdWVzdCIsImFib3J0UmVxdWVzdCIsIlBERk5ldHdvcmtTdHJlYW0iLCJfc291cmNlIiwiX21hbmFnZXIiLCJfb25SYW5nZVJlcXVlc3RSZWFkZXJDbG9zZWQiLCJQREZOZXR3b3JrU3RyZWFtRnVsbFJlcXVlc3RSZWFkZXIiLCJQREZOZXR3b3JrU3RyZWFtUmFuZ2VSZXF1ZXN0UmVhZGVyIiwib25DbG9zZWQiLCJtYW5hZ2VyIiwiX3VybCIsIl9mdWxsUmVxdWVzdElkIiwiX29uSGVhZGVyc1JlY2VpdmVkIiwiX29uRG9uZSIsIl9vbkVycm9yIiwiX2NhY2hlZENodW5rcyIsIl9zdG9yZWRFcnJvciIsImZ1bGxSZXF1ZXN0WGhySWQiLCJmdWxsUmVxdWVzdFhociIsInJlc3BvbnNlVVJMIiwicmF3UmVzcG9uc2VIZWFkZXJzIiwiZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIiwidHJpbVN0YXJ0IiwibGVuZ3RoQ29tcHV0YWJsZSIsIl9yZXF1ZXN0SWQiLCJfY2xvc2UiLCJ1cmxSZWdleCIsInBhcnNlVXJsT3JQYXRoIiwic291cmNlVXJsIiwiUERGTm9kZVN0cmVhbSIsIlBERk5vZGVTdHJlYW1Gc0Z1bGxSZWFkZXIiLCJQREZOb2RlU3RyZWFtRnNSYW5nZVJlYWRlciIsIl9yZWFkYWJsZVN0cmVhbSIsImxzdGF0IiwiX3NldFJlYWRhYmxlU3RyZWFtIiwiY3JlYXRlUmVhZFN0cmVhbSIsIl9lcnJvciIsInJlYWRhYmxlU3RyZWFtIiwiSU5JVElBTF9EQVRBIiwiUERGT2JqZWN0cyIsImVuc3VyZU9iaiIsIm9iajIiLCJNQVhfVEVYVF9ESVZTX1RPX1JFTkRFUiIsIkRFRkFVTFRfRk9OVF9TSVpFIiwiVGV4dExheWVyIiwiZGlzYWJsZVByb2Nlc3NJdGVtcyIsImZvbnRJbnNwZWN0b3JFbmFibGVkIiwibGFuZyIsImxheW91dFRleHRQYXJhbXMiLCJyb290Q29udGFpbmVyIiwic3R5bGVDYWNoZSIsInRleHRDb250ZW50SXRlbXNTdHIiLCJ0ZXh0Q29udGVudFNvdXJjZSIsInRleHREaXZQcm9wZXJ0aWVzIiwiYXNjZW50Q2FjaGUiLCJjYW52YXNDb250ZXh0cyIsImNhbnZhc0N0eEZvbnRzIiwibWluRm9udFNpemUiLCJwZW5kaW5nVGV4dExheWVycyIsIkZvbnRJbnNwZWN0b3IiLCJlbnN1cmVNaW5Gb250U2l6ZUNvbXB1dGVkIiwiZmluYWxseSIsImZvbnRGYW1pbHlNYXAiLCJwdW1wIiwicHJvY2Vzc0l0ZW1zIiwib25CZWZvcmUiLCJnZXRDdHgiLCJsYXlvdXQiLCJhYm9ydEV4IiwiYXBwZW5kVGV4dCIsImdlb20iLCJ0ZXh0RGl2IiwiaGFzVGV4dCIsImhhc0VPTCIsImF0YW4yIiwiZm9udE5hbWUiLCJQSSIsImZvbnRTdWJzdGl0dXRpb24iLCJmb250SGVpZ2h0IiwiZm9udEFzY2VudCIsImdldEFzY2VudCIsInNpbiIsImNvcyIsInNjYWxlRmFjdG9yU3RyIiwiZGl2U3R5bGUiLCJkYXRhc2V0IiwiZm9udFN1YnN0aXR1dGlvbkxvYWRlZE5hbWUiLCJzaG91bGRTY2FsZVRleHQiLCJhYnNTY2FsZVgiLCJhYnNTY2FsZVkiLCJiciIsImVuc3VyZUN0eEZvbnQiLCJjbGVhbnVwIiwiYWxwaGEiLCJjYWNoZWQiLCJsaW5lSGVpZ2h0IiwiY2FjaGVkQXNjZW50IiwibWV0cmljcyIsImZvbnRCb3VuZGluZ0JveEFzY2VudCIsImZvbnRCb3VuZGluZ0JveERlc2NlbnQiLCJyYXRpbyIsIlJFTkRFUklOR19DQU5DRUxMRURfVElNRU9VVCIsImdldERvY3VtZW50IiwidGFzayIsIlBERkRvY3VtZW50TG9hZGluZ1Rhc2siLCJwYXNzd29yZCIsInJhbmdlVHJhbnNwb3J0IiwiUERGRGF0YVJhbmdlVHJhbnNwb3J0Iiwid29ya2VyIiwiUERGV29ya2VyIiwidmVyYm9zaXR5MiIsImRvY0Jhc2VVcmwiLCJjTWFwVXJsIiwiY01hcFBhY2tlZCIsIkNNYXBSZWFkZXJGYWN0b3J5IiwiaWNjVXJsIiwic3RhbmRhcmRGb250RGF0YVVybCIsIlN0YW5kYXJkRm9udERhdGFGYWN0b3J5Iiwid2FzbVVybCIsIldhc21GYWN0b3J5IiwiaWdub3JlRXJyb3JzIiwic3RvcEF0RXJyb3JzIiwibWF4SW1hZ2VTaXplIiwiaXNFdmFsU3VwcG9ydGVkMiIsImNocm9tZSIsImNhbnZhc01heEFyZWFJbkJ5dGVzIiwiZW5hYmxlWGZhIiwiZGlzYWJsZUF1dG9GZXRjaCIsInBkZkJ1ZyIsIkNhbnZhc0ZhY3RvcnkiLCJGaWx0ZXJGYWN0b3J5IiwidXNlV2FzbSIsInVzZVN5c3RlbUZvbnRzIiwidXNlV29ya2VyRmV0Y2giLCJ0cmFuc3BvcnRGYWN0b3J5IiwiY01hcFJlYWRlckZhY3RvcnkiLCJzdGFuZGFyZEZvbnREYXRhRmFjdG9yeSIsIndhc21GYWN0b3J5IiwiX3dvcmtlciIsImRvY1BhcmFtcyIsImFwaVZlcnNpb24iLCJldmFsdWF0b3JPcHRpb25zIiwidHJhbnNwb3J0UGFyYW1zIiwibG9hZGluZ1BhcmFtcyIsImRlc3Ryb3llZCIsIndvcmtlcklkUHJvbWlzZSIsIm1lc3NhZ2VIYW5kbGVyIiwibmV0d29ya1N0cmVhbSIsIk5ldHdvcmtTdHJlYW0iLCJ3b3JrZXJJZCIsInRyYW5zcG9ydCIsIldvcmtlclRyYW5zcG9ydCIsIl90cmFuc3BvcnQiLCJfcGVuZGluZ0Rlc3Ryb3kiLCJvblBhc3N3b3JkIiwicHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXJzIiwicHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXJzIiwicHJvZ3Jlc3NMaXN0ZW5lcnMiLCJyYW5nZUxpc3RlbmVycyIsIm9uRGF0YVJhbmdlIiwib25EYXRhUHJvZ3Jlc3MiLCJvbkRhdGFQcm9ncmVzc2l2ZVJlYWQiLCJvbkRhdGFQcm9ncmVzc2l2ZURvbmUiLCJQREZEb2N1bWVudFByb3h5IiwicGRmSW5mbyIsIl9wZGZJbmZvIiwibnVtUGFnZXMiLCJmaW5nZXJwcmludHMiLCJpc1B1cmVYZmEiLCJfaHRtbEZvclhmYSIsImFsbFhmYUh0bWwiLCJnZXRQYWdlIiwiZ2V0UGFnZUluZGV4IiwicmVmIiwiZ2V0RGVzdGluYXRpb25zIiwiZ2V0RGVzdGluYXRpb24iLCJnZXRQYWdlTGFiZWxzIiwiZ2V0UGFnZUxheW91dCIsImdldFBhZ2VNb2RlIiwiZ2V0Vmlld2VyUHJlZmVyZW5jZXMiLCJnZXRPcGVuQWN0aW9uIiwiZ2V0QXR0YWNobWVudHMiLCJwYWdlSW5kZXhlc1RvU2tpcCIsImdldEpTQWN0aW9ucyIsImdldERvY0pTQWN0aW9ucyIsImdldE91dGxpbmUiLCJnZXRPcHRpb25hbENvbnRlbnRDb25maWciLCJnZXRSZW5kZXJpbmdJbnRlbnQiLCJnZXRQZXJtaXNzaW9ucyIsImdldE1ldGFkYXRhIiwiZ2V0TWFya0luZm8iLCJzYXZlRG9jdW1lbnQiLCJnZXREb3dubG9hZEluZm8iLCJkb3dubG9hZEluZm9DYXBhYmlsaXR5Iiwia2VlcExvYWRlZEZvbnRzIiwic3RhcnRDbGVhbnVwIiwibG9hZGluZ1Rhc2siLCJjYWNoZWRQYWdlTnVtYmVyIiwiZ2V0RmllbGRPYmplY3RzIiwiaGFzSlNBY3Rpb25zIiwiZ2V0Q2FsY3VsYXRpb25PcmRlcklkcyIsIlBERlBhZ2VQcm94eSIsInBlbmRpbmdDbGVhbnVwIiwicGFnZUluZm8iLCJfcGFnZUluZGV4IiwiX3BhZ2VJbmZvIiwiX3N0YXRzIiwiX3BkZkJ1ZyIsIl9pbnRlbnRTdGF0ZXMiLCJyZWNvcmRlZEJCb3hlcyIsImdldFZpZXdwb3J0IiwiZ2V0QW5ub3RhdGlvbnMiLCJnZXRQYWdlSlNBY3Rpb25zIiwiZ2V0WGZhIiwiY2FudmFzQ29udGV4dCIsImFubm90YXRpb25Nb2RlIiwib3B0aW9uYWxDb250ZW50Q29uZmlnUHJvbWlzZSIsInByaW50QW5ub3RhdGlvblN0b3JhZ2UiLCJyZWNvcmRPcGVyYXRpb25zIiwiaW50ZW50QXJncyIsImludGVudFN0YXRlIiwic3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCIsImludGVudFByaW50IiwiZGlzcGxheVJlYWR5Q2FwYWJpbGl0eSIsImxhc3RDaHVuayIsInNlcGFyYXRlQW5ub3RzIiwiX3B1bXBPcGVyYXRvckxpc3QiLCJyZWNvcmRGb3JEZWJ1Z2dlciIsIkJvb2xlYW4iLCJTdGVwcGVyTWFuYWdlciIsInNob3VsZFJlY29yZE9wZXJhdGlvbnMiLCJyZW5kZXJUYXNrcyIsImludGVybmFsUmVuZGVyVGFzayIsImdmeCIsInNldE9wZXJhdG9yQkJveGVzIiwidHJ5Q2xlYW51cCIsIl9hYm9ydE9wZXJhdG9yTGlzdCIsIlN0YXRzIiwiSW50ZXJuYWxSZW5kZXJUYXNrIiwidXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwicmVuZGVyVGFzayIsImluaXRpYWxpemVHcmFwaGljcyIsIm9wZXJhdG9yTGlzdENoYW5nZWQiLCJnZXRPcGVyYXRvckxpc3QiLCJvcExpc3RSZWFkQ2FwYWJpbGl0eSIsIm9wTGlzdFRhc2siLCJzdHJlYW1UZXh0Q29udGVudCIsImluY2x1ZGVNYXJrZWRDb250ZW50IiwiZGlzYWJsZU5vcm1hbGl6YXRpb24iLCJURVhUX0NPTlRFTlRfQ0hVTktfU0laRSIsImhpZ2hXYXRlck1hcmsiLCJnZXRUZXh0Q29udGVudCIsImdldFN0cnVjdFRyZWUiLCJfZGVzdHJveSIsIndhaXRPbiIsImZvcmNlIiwiY29tcGxldGVkIiwicmVzZXRTdGF0cyIsIl9zdGFydFJlbmRlclBhZ2UiLCJfcmVuZGVyUGFnZUNodW5rIiwib3BlcmF0b3JMaXN0Q2h1bmsiLCJhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZSIsInN0cmVhbVJlYWRlciIsImRlbGF5IiwiY3VyQ2FjaGVLZXkiLCJjdXJJbnRlbnRTdGF0ZSIsIl9QREZXb3JrZXIiLCJjYWNoZWRQb3J0IiwiX3NldHVwRmFrZVdvcmtlckdsb2JhbCIsImxvYWRlciIsIldvcmtlck1lc3NhZ2VIYW5kbGVyIiwiX2lzU2FtZU9yaWdpbiIsIl9jcmVhdGVDRE5XcmFwcGVyIiwidGVybWluYXRlRWFybHkiLCJzZW5kVGVzdCIsInRlc3RPYmoiLCJ3b3JrZXJIYW5kbGVyIiwic2V0dXAiLCJwZGZqc1dvcmtlciIsIm90aGVyVXJsIiwid3JhcHBlciIsImNyZWF0ZU9iamVjdFVSTCIsImZyb21Qb3J0IiwibWV0aG9kUHJvbWlzZXMiLCJwYWdlQ2FjaGUiLCJwYWdlUHJvbWlzZXMiLCJwYWdlUmVmQ2FjaGUiLCJwYXNzd29yZENhcGFiaWxpdHkiLCJmYWN0b3J5IiwiZm9udExvYWRlciIsIl9wYXJhbXMiLCJkZXN0cm95Q2FwYWJpbGl0eSIsIl9uZXR3b3JrU3RyZWFtIiwiX2Z1bGxSZWFkZXIiLCJfbGFzdFByb2dyZXNzIiwic2V0dXBNZXNzYWdlSGFuZGxlciIsImNhY2hlU2ltcGxlTWV0aG9kIiwiY2FjaGVkUHJvbWlzZSIsImlzT3BMaXN0IiwibW9kaWZpZWRJZHNIYXNoIiwiY2FjaGVLZXlCdWYiLCJ0ZXJtaW5hdGVkIiwic2luayIsInJlYWR5UmVhc29uIiwiX251bVBhZ2VzIiwiaHRtbEZvclhmYSIsInVwZGF0ZVBhc3N3b3JkIiwiZXJyIiwiZXhwb3J0ZWREYXRhIiwiZXhwb3J0ZWRFcnJvciIsImZvbnQyIiwiZm9udEFkZGVkIiwiaW1hZ2VSZWYiLCJwYWdlUHJveHkiLCJkYXRhTGVuIiwicmVmU3RyIiwicmVzdWx0cyIsImNsZWFudXBTdWNjZXNzZnVsIiwiUmVuZGVyVGFzayIsIm9uQ29udGludWUiLCJmb3JtIiwickFGIiwiY2FudmFzSW5Vc2UiLCJvcGVyYXRvckxpc3RJZHgiLCJydW5uaW5nIiwiZ3JhcGhpY3NSZWFkeUNhbGxiYWNrIiwiZ3JhcGhpY3NSZWFkeSIsIl91c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjYW5jZWxsZWQiLCJfY2FuY2VsQm91bmQiLCJfY29udGludWVCb3VuZCIsIl9jb250aW51ZSIsIl9zY2hlZHVsZU5leHRCb3VuZCIsIl9zY2hlZHVsZU5leHQiLCJfbmV4dEJvdW5kIiwiX25leHQiLCJfY2FudmFzIiwiX2NhbnZhc0NvbnRleHQiLCJfZW5hYmxlSFdBIiwiX2RlcGVuZGVuY3lUcmFja2VyIiwiX29wZXJhdGlvbnNGaWx0ZXIiLCJpbml0IiwiZ2V0TmV4dEJyZWFrUG9pbnQiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInVwZGF0ZU9wZXJhdG9yTGlzdCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImJ1aWxkIiwiQ29sb3JQaWNrZXIiLCJidXR0b25Td2F0Y2giLCJkZWZhdWx0Q29sb3IiLCJkcm9wZG93biIsImRyb3Bkb3duV2FzRnJvbUtleWJvYXJkIiwiaXNNYWluQ29sb3JQaWNrZXIiLCJvcGVuRHJvcGRvd25BQyIsImwxMG5Db2xvciIsIl9oaWRlRHJvcGRvd25Gcm9tS2V5Ym9hcmQiLCJfY29sb3JTZWxlY3RGcm9tS2V5Ym9hcmQiLCJfbW92ZVRvTmV4dCIsIl9tb3ZlVG9QcmV2aW91cyIsIl9tb3ZlVG9CZWdpbm5pbmciLCJfbW92ZVRvRW5kIiwiYmx1ZSIsImdyZWVuIiwicGluayIsInJlZCIsInllbGxvdyIsIm9wZW5Ecm9wZG93biIsImtleURvd24iLCJzd2F0Y2giLCJhcmlhSGlkZGVuIiwicmVuZGVyTWFpbkRyb3Bkb3duIiwiZ2V0RHJvcGRvd25Sb290IiwiYXJpYU9yaWVudGF0aW9uIiwiYXJpYUxhYmVsbGVkQnkiLCJyb2xlIiwiYXJpYU11bHRpU2VsZWN0YWJsZSIsImFyaWFTZWxlY3RlZCIsImNvbG9yU2VsZWN0IiwidXBkYXRlQ29sb3IiLCJpc0Ryb3Bkb3duVmlzaWJsZSIsIm5leHRTaWJsaW5nIiwicHJldmlvdXNTaWJsaW5nIiwiZGV0YWlsIiwiQmFzaWNDb2xvclBpY2tlciIsImNvbG9yVHlwZSIsImNvbG9yVmFsdWUiLCJtYWtlQ29sb3JDb21wIiwic2NhbGVBbmRDbGFtcCIsIkNvbG9yQ29udmVydGVycyIsIkNNWUtfRyIsIkdfQ01ZSyIsIkdfUkdCIiwiR19yZ2IiLCJHX0hUTUwiLCJHIiwiUkdCX0ciLCJSR0JfcmdiIiwiUkdCX0hUTUwiLCJUX0hUTUwiLCJUX3JnYiIsIkNNWUtfUkdCIiwiQ01ZS19yZ2IiLCJDTVlLX0hUTUwiLCJjb21wb25lbnRzIiwiUkdCX0NNWUsiLCJCYXNlU1ZHRmFjdG9yeSIsInNraXBEaW1lbnNpb25zIiwiX2NyZWF0ZVNWRyIsIkRPTVNWR0ZhY3RvcnkiLCJhbm5vdGF0aW9uX2xheWVyX0RFRkFVTFRfRk9OVF9TSVpFIiwiR2V0RWxlbWVudHNCeU5hbWVTZXQiLCJUSU1FWk9ORV9PRkZTRVQiLCJnZXRUaW1lem9uZU9mZnNldCIsIkFubm90YXRpb25FbGVtZW50RmFjdG9yeSIsIkxpbmtBbm5vdGF0aW9uRWxlbWVudCIsIlRleHRBbm5vdGF0aW9uRWxlbWVudCIsImZpZWxkVHlwZSIsIlRleHRXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCIsInJhZGlvQnV0dG9uIiwiUmFkaW9CdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudCIsImNoZWNrQm94IiwiQ2hlY2tib3hXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCIsIlB1c2hCdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudCIsIkNob2ljZVdpZGdldEFubm90YXRpb25FbGVtZW50IiwiU2lnbmF0dXJlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQiLCJXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCIsIlBvcHVwQW5ub3RhdGlvbkVsZW1lbnQiLCJGcmVlVGV4dEFubm90YXRpb25FbGVtZW50IiwiTGluZUFubm90YXRpb25FbGVtZW50IiwiU3F1YXJlQW5ub3RhdGlvbkVsZW1lbnQiLCJDaXJjbGVBbm5vdGF0aW9uRWxlbWVudCIsIlBvbHlsaW5lQW5ub3RhdGlvbkVsZW1lbnQiLCJDYXJldEFubm90YXRpb25FbGVtZW50IiwiSW5rQW5ub3RhdGlvbkVsZW1lbnQiLCJQb2x5Z29uQW5ub3RhdGlvbkVsZW1lbnQiLCJIaWdobGlnaHRBbm5vdGF0aW9uRWxlbWVudCIsIlVuZGVybGluZUFubm90YXRpb25FbGVtZW50IiwiU3F1aWdnbHlBbm5vdGF0aW9uRWxlbWVudCIsIlN0cmlrZU91dEFubm90YXRpb25FbGVtZW50IiwiU3RhbXBBbm5vdGF0aW9uRWxlbWVudCIsIkZpbGVBdHRhY2htZW50QW5ub3RhdGlvbkVsZW1lbnQiLCJBbm5vdGF0aW9uRWxlbWVudCIsInVwZGF0ZXMiLCJoYXNCb3JkZXIiLCJwb3B1cEVsZW1lbnQiLCJpc1JlbmRlcmFibGUiLCJpZ25vcmVCb3JkZXIiLCJjcmVhdGVRdWFkcmlsYXRlcmFscyIsImRvd25sb2FkTWFuYWdlciIsImltYWdlUmVzb3VyY2VzUGF0aCIsInJlbmRlckZvcm1zIiwic3ZnRmFjdG9yeSIsImVuYWJsZUNvbW1lbnQiLCJlbmFibGVTY3JpcHRpbmciLCJfZmllbGRPYmplY3RzIiwiZmllbGRPYmplY3RzIiwiX2NyZWF0ZUNvbnRhaW5lciIsIl9jcmVhdGVRdWFkcmlsYXRlcmFscyIsIl9oYXNQb3B1cERhdGEiLCJfaXNFZGl0YWJsZSIsImlzRWRpdGFibGUiLCJoYXNQb3B1cERhdGEiLCJjb21tZW50VGV4dCIsImNvbW1lbnREYXRhIiwiaGFzQ29tbWVudEJ1dHRvbiIsImhhc1BvcHVwRWxlbWVudCIsInF1YWRQb2ludHMiLCJpbmtMaXN0cyIsImlua0xpc3QiLCJfbm9ybWFsaXplUG9pbnQiLCJyZW1vdmVQb3B1cCIsIm5ld1BvcHVwIiwic2V0UmVjdEVkaXRlZCIsIl9jcmVhdGVQb3B1cCIsInJlc2V0RWRpdGVkIiwiY3VycmVudFJlY3QiLCJzZXRSb3RhdGlvbiIsImFsdGVybmF0aXZlVGV4dCIsIm5vUm90YXRlIiwicm90YXRpb24yIiwiYm9yZGVyU3R5bGUiLCJib3JkZXJXaWR0aCIsImhvcml6b250YWxSYWRpdXMiLCJob3Jpem9udGFsQ29ybmVyUmFkaXVzIiwidmVydGljYWxSYWRpdXMiLCJ2ZXJ0aWNhbENvcm5lclJhZGl1cyIsInJhZGl1cyIsImJvcmRlclJhZGl1cyIsImJvcmRlckJvdHRvbVN0eWxlIiwiYm9yZGVyQ29sb3IiLCJfY29tbW9uQWN0aW9ucyIsInNldENvbG9yIiwianNOYW1lIiwic3R5bGVOYW1lIiwiY29sb3JBcnJheSIsIm5vVmlldyIsIm5vUHJpbnQiLCJ1c2VyTmFtZSIsInJlYWRvbmx5IiwiX3NldFJlcXVpcmVkIiwidGV4dENvbG9yIiwiX2Rpc3BhdGNoRXZlbnRGcm9tU2FuZGJveCIsImFjdGlvbnMiLCJqc0V2ZW50IiwiY29tbW9uQWN0aW9ucyIsIl9zZXREZWZhdWx0UHJvcGVydGllc0Zyb21KUyIsImV2ZW50UHJveHkiLCJyZWN0QmxYIiwicmVjdEJsWSIsInJlY3RUclgiLCJyZWN0VHJZIiwic3ZnQnVmZmVyIiwiY2xpcFBhdGgiLCJyZWN0V2lkdGgiLCJyZWN0SGVpZ2h0IiwiYmFja2dyb3VuZEltYWdlIiwicG9wdXBEYXRhIiwidGl0bGVPYmoiLCJwYXJlbnRSZWN0IiwiX2NvbW1lbnRNYW5hZ2VyIiwiZXh0cmFQb3B1cEVsZW1lbnQiLCJfZ2V0RWxlbWVudHNCeU5hbWUiLCJza2lwSWQiLCJmaWVsZHMiLCJmaWVsZE9iaiIsImV4cG9ydFZhbHVlcyIsImV4cG9ydFZhbHVlIiwiZG9tRWxlbWVudCIsImdldEVsZW1lbnRzQnlOYW1lIiwibWF5YmVTaG93IiwiZm9yY2VIaWRlIiwiZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCIsImFkZEhpZ2hsaWdodEFyZWEiLCJ0cmlnZ2VycyIsIl9lZGl0T25Eb3VibGVDbGljayIsImFubm90YXRpb25FZGl0b3JUeXBlIiwiRWRpdG9yQW5ub3RhdGlvbkVsZW1lbnQiLCJjcmVhdGVPclVwZGF0ZVBvcHVwIiwicmVuZGVyQ29tbWVudEJ1dHRvbiIsImlzVG9vbHRpcE9ubHkiLCJsaW5rIiwiaXNCb3VuZCIsIl9iaW5kTmFtZWRBY3Rpb24iLCJvdmVybGFpZFRleHQiLCJhdHRhY2htZW50IiwiYmluZEF0dGFjaG1lbnQiLCJhdHRhY2htZW50RGVzdCIsImJpbmRTZXRPQ0dTdGF0ZSIsIl9iaW5kTGluayIsIkFjdGlvbiIsIl9iaW5kSlNBY3Rpb24iLCJyZXNldEZvcm0iLCJfYmluZFJlc2V0Rm9ybUFjdGlvbiIsInNldEludGVybmFsTGluayIsImRlc3RpbmF0aW9uIiwiZ2V0RGVzdGluYXRpb25IYXNoIiwib25jbGljayIsImdvVG9EZXN0aW5hdGlvbiIsImdldEFuY2hvclVybCIsImV4ZWN1dGVOYW1lZEFjdGlvbiIsIm9wZW5PckRvd25sb2FkRGF0YSIsImV4ZWN1dGVTZXRPQ0dTdGF0ZSIsIm90aGVyQ2xpY2tBY3Rpb24iLCJyZXNldEZvcm1GaWVsZHMiLCJyZWZzIiwicmVzZXRGb3JtUmVmcyIsImluY2x1ZGUiLCJhbGxGaWVsZHMiLCJmaWVsZElkcyIsImZpZWxkTmFtZSIsImZpZWxkIiwiYWxsSWRzIiwiZGlzcGF0Y2hFdmVudCIsIkV2ZW50Iiwic2hvd0VsZW1lbnRBbmRIaWRlQ2FudmFzIiwiX2dldEtleU1vZGlmaWVyIiwiX3NldEV2ZW50TGlzdGVuZXIiLCJlbGVtZW50RGF0YSIsImJhc2VOYW1lIiwiZXZlbnROYW1lIiwidmFsdWVHZXR0ZXIiLCJtb2RpZmllciIsImZvY3VzZWQiLCJfc2V0RXZlbnRMaXN0ZW5lcnMiLCJCbHVyIiwiRm9jdXMiLCJfc2V0QmFja2dyb3VuZENvbG9yIiwiX3NldFRleHRTdHlsZSIsIlRFWFRfQUxJR05NRU5UIiwiZm9udENvbG9yIiwiZGVmYXVsdEFwcGVhcmFuY2VEYXRhIiwiY29tcHV0ZWRGb250U2l6ZSIsInJvdW5kVG9PbmVEZWNpbWFsIiwibXVsdGlMaW5lIiwibnVtYmVyT2ZMaW5lcyIsInRleHRBbGlnbm1lbnQiLCJ0ZXh0QWxpZ24iLCJpc1JlcXVpcmVkIiwiaGFzQXBwZWFyYW5jZSIsImZpZWxkVmFsdWUiLCJzZXRQcm9wZXJ0eU9uU2libGluZ3MiLCJrZXlJblN0b3JhZ2UiLCJtYXhMZW4iLCJjaGFyTGltaXQiLCJmaWVsZEZvcm1hdHRlZFZhbHVlcyIsImZvcm1hdHRlZFZhbHVlIiwiY29tYiIsInVzZXJWYWx1ZSIsImxhc3RDb21taXR0ZWRWYWx1ZSIsImNvbW1pdEtleSIsImRvTm90U2Nyb2xsIiwib3ZlcmZsb3dZIiwib3ZlcmZsb3dYIiwicmVhZE9ubHkiLCJkYXRldGltZUZvcm1hdCIsImRhdGV0aW1lVHlwZSIsInRpbWVTdGVwIiwiaGFzRGF0ZU9yVGltZSIsImRlZmF1bHRGaWVsZFZhbHVlIiwiYmx1ckxpc3RlbmVyIiwic2Nyb2xsTGVmdCIsImdldEhvdXJzIiwiZ2V0TWludXRlcyIsImdldFNlY29uZHMiLCJ0b0lTT1N0cmluZyIsInNlbFJhbmdlIiwic2V0U2VsZWN0aW9uUmFuZ2UiLCJ3aWxsQ29tbWl0Iiwic2VsU3RhcnQiLCJzZWxlY3Rpb25TdGFydCIsInNlbEVuZCIsInNlbGVjdGlvbkVuZCIsIl9ibHVyTGlzdGVuZXIiLCJLZXlzdHJva2UiLCJpbnB1dFR5cGUiLCJjaGFuZ2UiLCJmaWVsZFdpZHRoIiwiY29tYldpZHRoIiwibGV0dGVyU3BhY2luZyIsInZlcnRpY2FsQWxpZ24iLCJjaGVja2JveCIsImN1ckNoZWNrZWQiLCJidXR0b25WYWx1ZSIsInJhZGlvIiwicGRmQnV0dG9uVmFsdWUiLCJsaW5rRWxlbWVudCIsInNlbGVjdEVsZW1lbnQiLCJhZGRBbkVtcHR5RW50cnkiLCJjb21ibyIsIm11bHRpU2VsZWN0IiwibXVsdGlwbGUiLCJvcHRpb25FbGVtZW50IiwiZGlzcGxheVZhbHVlIiwicmVtb3ZlRW1wdHlFbnRyeSIsIm5vbmVPcHRpb25FbGVtZW50IiwiaXNFeHBvcnQiLCJzZWxlY3RlZFZhbHVlcyIsImdldEl0ZW1zIiwibXVsdGlwbGVTZWxlY3Rpb24iLCJmaW5kSW5kZXgiLCJzZWxlY3RDaGlsZCIsImluZGljZXMiLCJlZGl0YWJsZSIsImNoYW5nZUV4IiwiY3JlYXRlUG9wdXAiLCJQb3B1cEVsZW1lbnQiLCJib3VuZEtleURvd24iLCJib3VuZEhpZGUiLCJib3VuZFNob3ciLCJib3VuZFRvZ2dsZSIsImRhdGVPYmoiLCJwaW5uZWQiLCJwb3B1cEFib3J0Q29udHJvbGxlciIsImNvbW1lbnRCdXR0b24iLCJ3YXNWaXNpYmxlIiwiZmlyc3RFbGVtZW50IiwidHJpZ2dlciIsImFkZEV2ZW50TGlzdGVuZXJzIiwic2V0Q29tbWVudEJ1dHRvblBvc2l0aW9uIiwiaGFzT3duQnV0dG9uIiwidG9nZ2xlUG9wdXAiLCJzaG93UG9wdXAiLCJoaWRlUG9wdXAiLCJwYXJlbnRDb250YWluZXIiLCJ1cGRhdGVDb21tZW50QnV0dG9uUG9zaXRpb24iLCJhZnRlciIsIm91dGxpbmVDb2xvciIsImhlYWRlciIsImRhdGVUaW1lIiwibWFrZVBvcHVwQ29udGVudCIsInBvcHVwTGluZXMiLCJwb3B1cENvbnRlbnQiLCJsaW5lQXR0cmlidXRlcyIsInNldFBvc2l0aW9uIiwidXNlUGFyZW50UmVjdCIsIm5vcm1hbGl6ZWRSZWN0IiwiSE9SSVpPTlRBTF9TUEFDRV9BRlRFUl9BTk5PVEFUSU9OIiwicG9wdXBMZWZ0IiwicG9wdXBUb3AiLCJ0ZXh0UG9zaXRpb24iLCJsaW5lU3BhbiIsImxpbmVDb29yZGluYXRlcyIsInNxdWFyZSIsImNpcmNsZSIsInBvbHlsaW5lIiwiY29udGFpbmVyQ2xhc3NOYW1lIiwic3ZnRWxlbWVudE5hbWUiLCJ2ZXJ0aWNlcyIsInBvaW50cyIsInBvbHlsaW5lc0dyb3VwRWxlbWVudCIsInBvbHlsaW5lcyIsInRoaWNrbmVzcyIsIm1hcmsiLCJ1bmRlcmxpbmUiLCJzdHJpa2VvdXQiLCJkb3dubG9hZCIsIkFubm90YXRpb25MYXllciIsImFjY2Vzc2liaWxpdHlNYW5hZ2VyIiwiZWRpdGFibGVBbm5vdGF0aW9ucyIsInN0cnVjdFRyZWVMYXllciIsImFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIiLCJfYW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlciIsImhhc0VkaXRhYmxlQW5ub3RhdGlvbnMiLCJhcHBlbmRFbGVtZW50IiwicG9wdXBFbGVtZW50cyIsImNvbnRlbnRFbGVtZW50IiwiYXJpYUF0dHJpYnV0ZXMiLCJnZXRBcmlhQXR0cmlidXRlcyIsIm1vdmVFbGVtZW50SW5ET00iLCJhbm5vdGF0aW9ucyIsInBvcHVwVG9FbGVtZW50cyIsImVsZW1lbnRQYXJhbXMiLCJub0hUTUwiLCJpc1BvcHVwQW5ub3RhdGlvbiIsInJlbmRlcmVkIiwic2V0QW5ub3RhdGlvbkNhbnZhc01hcCIsImFkZExpbmtBbm5vdGF0aW9ucyIsIl9kZWZhdWx0Qm9yZGVyU3R5bGUiLCJyZXBsYWNlV2l0aCIsImVkaXRhYmxlQW5ub3RhdGlvbiIsIl9oYXNOb0NhbnZhcyIsImdldEVkaXRhYmxlQW5ub3RhdGlvbnMiLCJnZXRFZGl0YWJsZUFubm90YXRpb24iLCJodG1sRWxlbWVudCIsInJhd1dpZHRoIiwiRU9MX1BBVFRFUk4iLCJGcmVlVGV4dEVkaXRvciIsImVkaXRvckRpdklkIiwiZWRpdE1vZGVBQyIsIl9mcmVlVGV4dERlZmF1bHRDb250ZW50IiwiX2ludGVybmFsUGFkZGluZyIsIl9kZWZhdWx0Q29sb3IiLCJfZGVmYXVsdEZvbnRTaXplIiwiX3RyYW5zbGF0ZUVtcHR5IiwiX2NvbG9yUGlja2VyIiwidXBkYXRlRm9udFNpemUiLCJzZXRGb250c2l6ZSIsImVkaXRvckRpdiIsInNldEVkaXRvckRpbWVuc2lvbnMiLCJzYXZlZEZvbnRzaXplIiwiY29sIiwic2F2ZWRDb2xvciIsIm92ZXJsYXlEaXYiLCJjb250ZW50RWRpdGFibGUiLCJlZGl0b3JEaXZLZXlkb3duIiwiZWRpdG9yRGl2Rm9jdXMiLCJlZGl0b3JEaXZCbHVyIiwiZWRpdG9yRGl2SW5wdXQiLCJlZGl0b3JEaXZQYXN0ZSIsImlubmVyVGV4dCIsImV4dHJhY3RUZXh0IiwicHJldkNoaWxkIiwiY2hpbGROb2RlcyIsImdldE5vZGVDb250ZW50Iiwic2F2ZWREaXNwbGF5Iiwic2F2ZWRWaXNpYmlsaXR5Iiwic2F2ZWRUZXh0IiwibmV3VGV4dCIsInRyaW1FbmQiLCJzZXRUZXh0Iiwic2V0Q29udGVudCIsIm5vZGVWYWx1ZSIsImRlc2VyaWFsaXplQ29udGVudCIsImRlbGV0ZUZyb21Eb2N1bWVudCIsImluc2VydE5vZGUiLCJjb2xsYXBzZVRvU3RhcnQiLCJzdGFydENvbnRhaW5lciIsInN0YXJ0T2Zmc2V0IiwiYnVmZmVyQmVmb3JlIiwiYnVmZmVyQWZ0ZXIiLCJuZXdSYW5nZSIsIlJhbmdlIiwiYmVmb3JlTGVuZ3RoIiwic2V0U3RhcnQiLCJzZXRFbmQiLCJyZW1vdmVBbGxSYW5nZXMiLCJhZGRSYW5nZSIsInJlcGxhY2VDaGlsZHJlbiIsInNlcmlhbGl6ZUNvbnRlbnQiLCJwYWRkaW5nIiwiaGFzRWxlbWVudENoYW5nZWQiLCJPdXRsaW5lIiwidG9TVkdQYXRoIiwiX3JvdGF0aW9uIiwiX3Jlc2NhbGUiLCJfcmVzY2FsZUFuZFN3YXAiLCJfdHJhbnNsYXRlIiwic3ZnUm91bmQiLCJfbm9ybWFsaXplUGFnZVBvaW50IiwiY3JlYXRlQmV6aWVyUG9pbnRzIiwiRnJlZURyYXdPdXRsaW5lciIsImlubmVyTWFyZ2luIiwibGFzdCIsIm1pbl9kaXN0Iiwic2NhbGVGYWN0b3IiLCJNSU5fRElTVCIsIk1JTl9ESUZGIiwiTUlOIiwiZ2V0TGFzdENvb3JkcyIsImxhc3RUb3AiLCJsYXN0Qm90dG9tIiwiZGlmZlgiLCJkaWZmWSIsImRpZmZEIiwiSyIsIm5YIiwiblkiLCJ0aFgiLCJ0aFkiLCJ0b1NWR1BhdGhUd29Qb2ludHMiLCJ0b1NWR1BhdGhFbmQiLCJ0b1NWR1BhdGhTdGFydCIsImxhc3RUb3BYIiwibGFzdFRvcFkiLCJsYXN0Qm90dG9tWCIsImxhc3RCb3R0b21ZIiwibmV3RnJlZURyYXdPdXRsaW5lIiwib3V0bGluZSIsIkZyZWVEcmF3T3V0bGluZSIsImdldE91dGxpbmVzIiwiZ2V0T3V0bGluZVR3b1BvaW50cyIsIk4iLCJnZXRPdXRsaW5lRW5kIiwiZ2V0T3V0bGluZVN0YXJ0IiwiZmlyc3RQb2ludCIsImxhc3RQb2ludCIsImNvbXB1dGVNaW5NYXgiLCJmaXJzdFBvaW50WCIsImZpcnN0UG9pbnRZIiwibGFzdFBvaW50WCIsImxhc3RQb2ludFkiLCJsdHJDYWxsYmFjayIsImJlemllckJib3giLCJuZXdPdXRsaW5lciIsImdldE5ld091dGxpbmUiLCJvdXRsaW5lciIsIkhpZ2hsaWdodE91dGxpbmVyIiwidmVydGljYWxFZGdlcyIsImludGVydmFscyIsIkVQU0lMT04iLCJzaGlmdGVkTWluWCIsInNoaWZ0ZWRNaW5ZIiwibGFzdEVkZ2UiLCJlZGdlIiwib3V0bGluZVZlcnRpY2FsRWRnZXMiLCJicmVha0VkZ2UiLCJlZGdlcyIsImFsbEVkZ2VzIiwiZWRnZTEiLCJlZGdlMiIsIm91dGxpbmVzIiwiSGlnaGxpZ2h0T3V0bGluZSIsImJpbmFyeVNlYXJjaCIsIm1pZGRsZSIsInk0IiwicG9seWdvbiIsInByZXZYIiwicHJldlkiLCJjbGFzc05hbWVzRm9yT3V0bGluaW5nIiwiRnJlZUhpZ2hsaWdodE91dGxpbmVyIiwiRnJlZUhpZ2hsaWdodE91dGxpbmUiLCJIaWdobGlnaHRFZGl0b3IiLCJjbGlwUGF0aElkIiwiZm9jdXNPdXRsaW5lcyIsImhpZ2hsaWdodERpdiIsImhpZ2hsaWdodE91dGxpbmVzIiwiaXNGcmVlSGlnaGxpZ2h0Iiwib3V0bGluZUlkIiwiX2RlZmF1bHRPcGFjaXR5IiwiX2RlZmF1bHRUaGlja25lc3MiLCJfZnJlZUhpZ2hsaWdodElkIiwiX2ZyZWVIaWdobGlnaHQiLCJfZnJlZUhpZ2hsaWdodENsaXBJZCIsIl9tb3ZlQ2FyZXQiLCJoaWdobGlnaHRJZCIsImNyZWF0ZUZyZWVPdXRsaW5lcyIsImFkZFRvRHJhd0xheWVyIiwiY3JlYXRlT3V0bGluZXMiLCJudW1iZXJPZkNvbG9ycyIsIm91dGxpbmVyRm9yT3V0bGluZSIsImV4dHJhVGhpY2tuZXNzIiwiZHJhd0xheWVyIiwiZmluYWxpemVEcmF3IiwiZHJhd091dGxpbmUiLCJyb290Q2xhc3MiLCJoaWdobGlnaHRPdXRsaW5lIiwiZnJlZSIsInVwZGF0ZVByb3BlcnRpZXMiLCJyb3RhdGVCYm94IiwidXBkYXRlVGhpY2tuZXNzIiwic2V0Q29sb3JBbmRPcGFjaXR5Iiwib3BhIiwic2F2ZWRPcGFjaXR5Iiwic2F2ZWRUaGlja25lc3MiLCJzZXRUaGlja25lc3MiLCJ0aCIsImNoYW5nZVRoaWNrbmVzcyIsImdldFJvdGF0aW9uIiwiYWRkVW5kb2FibGVFZGl0b3IiLCJjbGVhbkRyYXdMYXllciIsIm11c3RCZVNlbGVjdGVkIiwiZHJhdyIsInBvaW50ZXJvdmVyIiwiaG92ZXJlZCIsInBvaW50ZXJsZWF2ZSIsInNldENhcmV0Iiwic2VyaWFsaXplQm94ZXMiLCJzZXJpYWxpemVPdXRsaW5lcyIsInN0YXJ0SGlnaGxpZ2h0aW5nIiwiZW5kSGlnaGxpZ2h0IiwiaGlnaGxpZ2h0TW92ZSIsInF1YWRQb2ludHMyIiwiY29sb3IyIiwib3BhY2l0eTIiLCJpbmtMaXN0czIiLCJEcmF3aW5nT3B0aW9ucyIsInN2Z1Byb3BlcnRpZXMiLCJ1cGRhdGVQcm9wZXJ0eSIsInVwZGF0ZVNWR1Byb3BlcnR5IiwidG9TVkdQcm9wZXJ0aWVzIiwidXBkYXRlQWxsIiwiRHJhd2luZ0VkaXRvciIsImRyYXdPdXRsaW5lcyIsIm11c3RCZUNvbW1pdHRlZCIsIl9jdXJyZW50RHJhd0lkIiwiX2N1cnJlbnRQYXJlbnQiLCJjdXJyZW50RHJhdyIsImN1cnJlbnREcmF3aW5nQUMiLCJjdXJyZW50RHJhd2luZ09wdGlvbnMiLCJjdXJyZW50UG9pbnRlcklkIiwiY3VycmVudFBvaW50ZXJUeXBlIiwiY3VycmVudFBvaW50ZXJJZHMiLCJjdXJyZW50TW92ZVRpbWVzdGFtcCIsIl9JTk5FUl9NQVJHSU4iLCJfZHJhd0lkIiwiX2FkZE91dGxpbmVzIiwiY3JlYXRlRHJhd091dGxpbmVzIiwiZHJhd0lkIiwiZHJhd2luZ09wdGlvbnMiLCJfZHJhd2luZ09wdGlvbnMiLCJkZWZhdWx0UHJvcGVydGllcyIsImNyZWF0ZURyYXdpbmciLCJ1cGRhdGVCYm94IiwiX21lcmdlU1ZHUHJvcGVydGllcyIsImRlZmF1bHRTVkdQcm9wZXJ0aWVzIiwicDFLZXlzIiwiZ2V0RGVmYXVsdERyYXdpbmdPcHRpb25zIiwiX29wdGlvbnMiLCJ0eXBlc01hcCIsInN1cHBvcnRNdWx0aXBsZURyYXdpbmdzIiwicHJvcGVydHlOYW1lIiwiX2RlZmF1bHREcmF3aW5nT3B0aW9ucyIsIl91cGRhdGVQcm9wZXJ0eSIsInNhdmVkVmFsdWUiLCJnZXRQYXRoUmVzaXppbmdTVkdQcm9wZXJ0aWVzIiwiY29udmVydFRvRHJhd1NwYWNlIiwicm90YXRlQm94IiwiZ2V0UGF0aFJlc2l6ZWRTVkdQcm9wZXJ0aWVzIiwiX3giLCJfeSIsImdldFBhdGhUcmFuc2xhdGVkU1ZHUHJvcGVydGllcyIsIm1vdmluZyIsInVwZGF0ZVBhcmVudCIsImNvbnZlcnRUb1BhcmVudFNwYWNlIiwicFciLCJwSCIsInVwZGF0ZVJvdGF0aW9uIiwidXBkYXRlUGFyZW50RGltZW5zaW9ucyIsIm9uU2NhbGVDaGFuZ2luZ1doZW5EcmF3aW5nIiwiZHJhd0RpdiIsImNyZWF0ZURyYXdlckluc3RhbmNlIiwiX3BhcmVudFdpZHRoIiwiX3BhcmVudEhlaWdodCIsInN0YXJ0RHJhd2luZyIsIl9pc0xUUiIsIl9lbmREcmF3IiwiaXNDYW5jZWxsYWJsZSIsInJlbW92ZUxhc3RFbGVtZW50IiwiX2RyYXdNb3ZlIiwidGltZVN0YW1wIiwic3RhcnROZXciLCJfY2xlYW51cCIsImxhc3RFbGVtZW50IiwiZ2V0TGFzdEVsZW1lbnQiLCJzZXRMYXN0RWxlbWVudCIsImlzQWJvcnRlZCIsImNyZWF0ZURyYXdpbmdPcHRpb25zIiwiX2RhdGEiLCJkZXNlcmlhbGl6ZURyYXciLCJfcGFnZVgiLCJfcGFnZVkiLCJfcGFnZVdpZHRoIiwiX3BhZ2VIZWlnaHQiLCJfaW5uZXJXaWR0aCIsInNlcmlhbGl6ZURyYXciLCJJbmtEcmF3T3V0bGluZXIiLCJsYXN0U1ZHUGF0aCIsImxhc3RJbmRleCIsIklua0RyYXdPdXRsaW5lIiwibm9ybWFsaXplUG9pbnQiLCJmaXJzdFgiLCJmaXJzdFkiLCJzZWNvbmRYIiwic2Vjb25kWSIsImMxeCIsImMxeSIsImMyeCIsImMyeSIsImN1cnJlbnRSb3RhdGlvbiIsImNvbXB1dGVCYm94Iiwic2VyaWFsaXplZExpbmVzIiwic2VyaWFsaXplZFBvaW50cyIsImdldEJCb3hXaXRoTm9NYXJnaW4iLCJyZXNjYWxlRm4iLCJuZXdMaW5lcyIsImdldE1hcmdpbkNvbXBvbmVudHMiLCJtYXJnaW4iLCJtYXJnaW5YIiwibWFyZ2luWSIsIm9sZE1hcmdpblgiLCJvbGRNYXJnaW5ZIiwibmV3TWFyZ2luWCIsIm5ld01hcmdpblkiLCJkaWZmTWFyZ2luWCIsImRpZmZNYXJnaW5ZIiwicm90YXRpb25UcmFuc2Zvcm0iLCJzMXgiLCJzMXkiLCJzMngiLCJzMnkiLCJ0eDIiLCJ0eTIiLCJuZXdQYXJlbnRXaWR0aCIsIm5ld1BhcmVudEhlaWdodCIsIklua0RyYXdpbmdPcHRpb25zIiwidmlld2VyUGFyYW1ldGVycyIsIl92aWV3UGFyYW1ldGVycyIsIklua0VkaXRvciIsIkNvbnRvdXJEcmF3T3V0bGluZSIsIkJBU0VfSEVBREVSX0xFTkdUSCIsIlBPSU5UU19QUk9QRVJUSUVTX05VTUJFUiIsIlNpZ25hdHVyZUV4dHJhY3RvciIsIlBBUkFNRVRFUlMiLCJzaWdtYVNGYWN0b3IiLCJzaWdtYVIiLCJrZXJuZWxTaXplIiwibmVpZ2hib3JJbmRleFRvSWQiLCJpMCIsImowIiwibmVpZ2hib3JJZFRvSW5kZXgiLCJjbG9ja3dpc2VOb25aZXJvIiwia2siLCJzaGlmdEkiLCJzaGlmdEoiLCJjb3VudGVyQ2xvY2t3aXNlTm9uWmVybyIsImZpbmRDb250b3VycyIsInRocmVzaG9sZCIsIm5iZCIsImxuYmQiLCJjb250b3VycyIsImlqIiwicGl4IiwiajIiLCJpc0hvbGUiLCJjb250b3VyIiwiY29udG91cjAiLCJpMSIsImoxIiwiaTMiLCJqMyIsImk0IiwiajQiLCJpajMiLCJkb3VnbGFzUGV1Y2tlckhlbHBlciIsImF4IiwiYXkiLCJhYngiLCJhYnkiLCJkaXN0IiwibmFieCIsIm5hYnkiLCJhYSIsImludlMiLCJwaGkiLCJhdGFuIiwiY29zUGhpIiwic2luUGhpIiwidG1heCIsInBvbHkiLCJwYXJ0aWFsUGhpIiwiZG1heCIsImRvdWdsYXNQZXVja2VyIiwiYmlsYXRlcmFsRmlsdGVyIiwic2lnbWFTIiwia2VybmVsIiwic2lnbWFTMiIsImhhbGZTaXplIiwiZXhwIiwicmFuZ2VWYWx1ZXMiLCJzaWdtYVIyIiwib3V0IiwiaGlzdG9ncmFtIiwibm9ybSIsIm5laWdoYm91ciIsImdldEhpc3RvZ3JhbSIsInRvVWludDgiLCJndWVzc1RocmVzaG9sZCIsIk0iLCJMIiwic3BvcyIsImdldEdyYXlQaXhlbHMiLCJvcmlnaW5hbEJpdG1hcCIsInByZXZXaWR0aCIsInByZXZIZWlnaHQiLCJsb2cyIiwiaXN0ZXBzIiwib2Zmc2NyZWVuMiIsImN0eDIiLCJncmF5SW1hZ2UiLCJ1aW50OEJ1ZiIsImV4dHJhY3RDb250b3Vyc0Zyb21UZXh0IiwiZm9udFN0eWxlIiwiU0NBTEUiLCJjb250b3VyTGlzdCIsInByb2Nlc3NEcmF3bkxpbmVzIiwiY3VydmVzIiwibXVzdFNtb290aCIsImFyZUNvbnRvdXJzIiwibGluZXNBbmRQb2ludHMiLCJ4U2NhbGUiLCJ5U2NhbGUiLCJuZXdDdXJ2ZXMiLCJyZWR1Y2VkUG9pbnRzIiwibmV3UG9pbnRzIiwiY29tcHJlc3NTaWduYXR1cmUiLCJtaW5EaWZmIiwibWF4RGlmZiIsIm91dGxpbmVzTGVuZ3RoIiwiZHgiLCJidWZmZXJUeXBlIiwiaGVhZGVyTGVuZ3RoIiwiQllURVNfUEVSX0VMRU1FTlQiLCJDb21wcmVzc2lvblN0cmVhbSIsIndyaXRlciIsImdldFdyaXRlciIsIkJ1ZmZlckN0b3IiLCJkaWZmcyIsIlJlc3BvbnNlIiwicmVhZGFibGUiLCJkZWNvbXByZXNzU2lnbmF0dXJlIiwic2lnbmF0dXJlRGF0YSIsIkRlY29tcHJlc3Npb25TdHJlYW0iLCJudW1iZXJPZkRyYXdpbmdzIiwiZGlmZnNPZmZzZXQiLCJTaWduYXR1cmVPcHRpb25zIiwiRHJhd25TaWduYXR1cmVPcHRpb25zIiwiU2lnbmF0dXJlRWRpdG9yIiwiaXNFeHRyYWN0ZWQiLCJzaWduYXR1cmVVVUlEIiwiX2RlZmF1bHREcmF3blNpZ25hdHVyZU9wdGlvbnMiLCJoYXNEZXNjcmlwdGlvbiIsImhhc0Rlc2NyaXB0aW9uU3RhdHMiLCJoYXNOb0FsdFRleHQiLCJ1dWlkIiwiaGVpZ2h0SW5QYWdlIiwiYWRkU2lnbmF0dXJlIiwic2V0VXVpZCIsImdldFNpZ25hdHVyZVByZXZpZXciLCJvdXRsaW5lRGF0YSIsImhhc0JlZW5TYXZlZCIsImdldEZyb21JbWFnZSIsImdldEZyb21UZXh0IiwiZm9udEluZm8iLCJnZXREcmF3blNpZ25hdHVyZSIsImlzU2lnbmF0dXJlIiwiYWx0IiwiU3RhbXBFZGl0b3IiLCJiaXRtYXBJZCIsImJpdG1hcFByb21pc2UiLCJiaXRtYXBVcmwiLCJiaXRtYXBGaWxlIiwiYml0bWFwRmlsZU5hbWUiLCJtaXNzaW5nQ2FudmFzIiwicmVzaXplVGltZW91dElkIiwiaGFzQmVlbkFkZGVkSW5VbmRvU3RhY2siLCJwYXN0ZUVkaXRvciIsImdldEFzRmlsZSIsImhhc0FsdFRleHRTdGF0cyIsImdldEJpdG1hcEZldGNoZWQiLCJmcm9tSWQiLCJnZXRCaXRtYXBEb25lIiwiYWx0X3RleHRfbW9kYWwiLCJhbHRfdGV4dF90eXBlIiwibWxHdWVzc0FsdFRleHQiLCJ1cGRhdGVBbHRUZXh0RGF0YSIsImlzRW5hYmxlZEZvciIsImNvcHlDYW52YXMiLCJndWVzcyIsImNoYW5uZWxzIiwiZ2V0Qml0bWFwIiwiYWNjZXB0IiwiZmlsZXMiLCJjbGljayIsImRyYXdCaXRtYXAiLCJNQVhfUkFUSU8iLCJtYXhEYXRhRGltZW5zaW9uIiwibWF4UHJldmlld0RpbWVuc2lvbiIsImJpdG1hcFdpZHRoIiwiYml0bWFwSGVpZ2h0Iiwib3V0cHV0U2NhbGUiLCJzY2FsZWRXaWR0aCIsInNjYWxlZEhlaWdodCIsInNjYWxlQml0bWFwIiwiYm94RGltIiwiYm94RGltV2lkdGgiLCJib3hEaW1IZWlnaHQiLCJwYXR0ZXJuQ3R4IiwiZGF0YVdpZHRoIiwiZGF0YUhlaWdodCIsIm9mZnNjcmVlbkN0eCIsInNlcmlhbGl6ZUJpdG1hcCIsInRvVXJsIiwidG9EYXRhVVJMIiwic3RydWN0UGFyZW50IiwiYml0bWFwSWQyIiwiYml0bWFwMiIsIl9zdHJ1Y3RUcmVlIiwiY2hhbmdlcyIsImlzU2FtZSIsImlzU2FtZUFsdFRleHQiLCJzdGFtcHMiLCJhcmVhIiwicHJldkRhdGEiLCJpc1NhbWVQYWdlSW5kZXgiLCJBbm5vdGF0aW9uRWRpdG9yTGF5ZXIiLCJhbGxvd0NsaWNrIiwiY2xpY2tBQyIsImVkaXRvckZvY3VzVGltZW91dElkIiwiaGFkUG9pbnRlckRvd24iLCJpc0Rpc2FibGluZyIsImlzRW5hYmxpbmciLCJkcmF3aW5nQUMiLCJmb2N1c2VkRWxlbWVudCIsInRleHRTZWxlY3Rpb25BQyIsInRleHRMYXllckRibENsaWNrQUMiLCJsYXN0UG9pbnRlckRvd25UaW1lc3RhbXAiLCJfaW5pdGlhbGl6ZWQiLCJpc0ludmlzaWJsZSIsImRpc2FibGVUZXh0U2VsZWN0aW9uIiwidG9nZ2xlQW5ub3RhdGlvbkxheWVyUG9pbnRlckV2ZW50cyIsImVuYWJsZVRleHRTZWxlY3Rpb24iLCJhbGxFZGl0b3JzSXRlcmF0b3IiLCJhbm5vdGF0aW9uRWxlbWVudElkcyIsIkRCTF9DTElDS19USFJFU0hPTEQiLCJjbGFzc0xpc3QyIiwiZWxlbWVudHNGcm9tUG9pbnQiLCJjaGFuZ2VkQW5ub3RhdGlvbnMiLCJyZXNldEFubm90YXRpb25zIiwiZWRpdGFibGVzIiwiY3VycmVudEFjdGl2ZSIsInRleHRMYXllclBvaW50ZXJEb3duIiwiYXR0YWNoIiwicmVtb3ZlUG9pbnRlckluVGV4dExheWVyIiwiY3VycmVudEVkaXRvclR5cGUiLCJjcmVhdGVOZXdFZGl0b3IiLCJnZXRDZW50ZXJQb2ludCIsImN1cnJlbnRNb2RlIiwic3RhcnREcmF3aW5nU2Vzc2lvbiIsInBhdXNlIiwib2xkUm90YXRpb24iLCJEcmF3TGF5ZXIiLCJtYXBwaW5nIiwidG9VcGRhdGUiLCJfc3ZnRmFjdG9yeSIsInNldEJveCIsImNyZWF0ZVNWRyIsImNyZWF0ZUNsaXBQYXRoIiwicGF0aElkIiwiY2xpcFBhdGhVc2UiLCJpc1BhdGhVcGRhdGFibGUiLCJoYXNDbGlwIiwidXNlIiwibXVzdFJlbW92ZVNlbGZJbnRlcnNlY3Rpb25zIiwibWFza0lkIiwidXNlMSIsInVzZTIiLCJjbG9uZU5vZGUiLCJlbGVtZW50T3JJZCIsInBhdGhFbGVtZW50IiwiX3BkZmpzVGVzdGluZ1V0aWxzIiwicGRmanNMaWIiLCJGZWF0dXJlVGVzdCIsIkltYWdlS2luZCIsInBkZmpzIiwiU2hhcGUiLCJ0b2xlcmFuY2UiLCJ4dCIsInl0IiwiUG9pbnQiLCJlcXVhbCIsIkxpbmVEaXJlY3Rpb24iLCJMaW5lRGlyZWN0aW9uMiIsIkxpbmUiLCJ0byIsImludGVyc2VjdGlvbnMiLCJnYXBzIiwiX3ZhbGlkIiwidmFsaWQiLCJub3JtYWxpemVkIiwiYWRkR2FwIiwiY29udGFpbnNQb2ludCIsImFkZEludGVyc2VjdGlvblBvaW50IiwiaW50UG9pbnQiLCJ0aGlzTm9ybWFsaXplZCIsImxpbmVOb3JtYWxpemVkIiwiaXNPayIsIlRhYmxlRGF0YSIsIm1pblhZIiwibWF4WFkiLCJyb3dQaXZvdHMiLCJjb2xQaXZvdHMiLCJmaW5kQ2VsbCIsInJvdyIsImNlbGwiLCJjZWxsQ291bnQiLCJhY2MiLCJyb3dDb3VudCIsInZpcnR1YWxDZWxsQ291bnQiLCJhbGxDZWxsQ291bnQiLCJjb2xzcGFuIiwicm93c3BhbiIsInRvQXJyYXkiLCJ0YWJsZUFyciIsInJvd0FyciIsIlRhYmxlIiwiaExpbmVzIiwidkxpbmVzIiwiSG9yaXpvbnRhbCIsIlZlcnRpY2FsIiwiaXNWYWxpZCIsInJvd1NldCIsImNvbFNldCIsImhhc0ludGVyc2VjdGlvbiIsImZsYWciLCJ2TGluZSIsImhMaW5lIiwiZ2V0U2FtZUhvcml6b250YWwiLCJzYW1lIiwiZ2V0U2FtZVZlcnRpY2FsIiwibWVyZ2VIb3Jpem9udGFsTGluZXMiLCJsMSIsImwyIiwicmVzdWx0TGluZSIsInByZXZMaW5lIiwiY3VyckxpbmUiLCJnYXBMaW5lIiwibWVyZ2VWZXJ0aWNhbExpbmVzIiwibmV3SExpbmVzIiwibWVyZ2VkIiwibmV3VkxpbmVzIiwidmVydGljYWxFeGlzdHMiLCJnYXAiLCJob3Jpem9udGFsRXhpc3RzIiwiZmluZEJvdHRvbUxpbmVJbmRleCIsImgySW5kZXgiLCJ4TWlkZGxlIiwiZmluZFZlcnRpY2FsTGluZUluZGV4cyIsInRvcEhMaW5lIiwieU1pZGRsZSIsImdldFJvdyIsImgxSW5kZXgiLCJ0YWJsZVJvdyIsInZMaW5lSW5kZXhlcyIsImxlZnRWTGluZSIsInJpZ2h0VkxpbmUiLCJib3R0b21ITGluZUluZGV4IiwiYm90dG9tSExpbmUiLCJ0YWJsZUNlbGwiLCJjb2xTcGFuIiwicm93U3BhbiIsInRvRGF0YSIsInByZXZITGluZSIsImN1cnJITGluZSIsIllNaWRkbGUiLCJyb3dEYXRhIiwiTGluZVN0b3JlIiwiYWRkUmVjdGFuZ2xlIiwiZ2V0TGluZXMiLCJnZXRUYWJsZURhdGEiLCJ0YWJsZXMiLCJnZXRUYWJsZXMiLCJmaWxsZWQiLCJ0cnlGaWxsIiwiZmlsbFRhYmxlIiwidmFsaWRUYWJsZXMiLCJub3JtYWxpemVIb3Jpem9udGFsIiwibm9ybWFsaXplVmVydGljYWwiLCJzYW1lWSIsIm1hcmdlSG9yaXpvbnRhbExpbmVzIiwic2FtZVgiLCJtYXJnZVZlcnRpY2FsTGluZXMiLCJzYW1lWUxpbmVzIiwiTUlOX1NBRkVfSU5URUdFUiIsInNhbWVYTGluZXMiLCJSZWN0YW5nbGUiLCJnZXRIZWFkZXIiLCJmZXRjaDIiLCJoZWFkUmVzcCIsImhlYWRlcnNPYmoiLCJpc1BkZiIsInJhbmdlUmVzcCIsImhlYWRlclN0ciIsIkltYWdlUmVzdWx0IiwiZ2V0UGFnZUltYWdlIiwicGFnZURhdGEiLCJwYWdlcyIsIlhNUF9EQVRFX1BST1BFUlRJRVMiLCJJbmZvUmVzdWx0IiwiZ2V0RGF0ZU5vZGUiLCJDcmVhdGlvbkRhdGUiLCJNb2REYXRlIiwicGFyc2VJU09EYXRlU3RyaW5nIiwiWG1wQ3JlYXRlRGF0ZSIsIlhtcE1vZGlmeURhdGUiLCJYbXBNZXRhZGF0YURhdGUiLCJYYXBDcmVhdGVEYXRlIiwiWGFwTW9kaWZ5RGF0ZSIsIlhhcE1ldGFkYXRhRGF0ZSIsImlzb0RhdGVTdHJpbmciLCJwYXJzZWREYXRlIiwic2V0RGVmYXVsdFBhcnNlUGFyYW1ldGVycyIsImxpbmVUaHJlc2hvbGQiLCJjZWxsVGhyZXNob2xkIiwiY2VsbFNlcGFyYXRvciIsImxpbmVFbmZvcmNlIiwicGFnZUpvaW5lciIsImltYWdlVGhyZXNob2xkIiwiaW1hZ2VEYXRhVXJsIiwiaW1hZ2VCdWZmZXIiLCJQYXRoR2VvbWV0cnkiLCJQYXRoR2VvbWV0cnkyIiwiU2NyZWVuc2hvdFJlc3VsdCIsIlRhYmxlUmVzdWx0IiwibWVyZ2VkVGFibGVzIiwiVGV4dFJlc3VsdCIsImdldFBhZ2VUZXh0IiwiUERGUGFyc2UiLCJwcm9ncmVzcyIsImRvYyIsImlzTm9kZUpTMiIsInNldFdvcmtlciIsImdldEluZm8iLCJwZXJtaXNzaW9uIiwicGFnZUxhYmVscyIsInBhcnNlUGFnZUluZm8iLCJzaG91bGRQYXJzZSIsInBhZ2VMaW5rUmVzdWx0IiwiZ2V0UGFnZUxpbmtzIiwicGFnZUxhYmVsIiwibGlua3MiLCJ1bnNhZmVVcmwiLCJnZXRUZXh0IiwiY3VycmVudFBhZ2UiLCJ0b3RhbFBhZ2UiLCJwYXJ0aWFsIiwicGFyc2VQYXJhbXMiLCJwYXJzZUh5cGVybGlua3MiLCJnZXRIeXBlcmxpbmtzIiwidG0iLCJwb3NBcnIiLCJoaXQiLCJsYXN0SXRlbSIsImlzQ3VycmVudEl0ZW1IYXNOZXdMaW5lIiwiaXRlbUpvaW5lciIsInJlY3RWcCIsInVzZWQiLCJnZXRJbWFnZSIsIm9wcyIsInBhZ2VJbWFnZXMiLCJpc0NvbW1vbiIsImltZ1Byb21pc2UiLCJyZXNvbHZlRW1iZWRkZWRJbWFnZSIsImNvbnZlcnRUb1JHQkEiLCJkYXRhVXJsIiwidG9CdWZmZXIiLCJub2RlQnVmZmVyIiwicGl4ZWxJbmRleCIsImJ5dGUiLCJiaXQiLCJpc1doaXRlIiwiZ3JheSIsImJ5dGVzUGVyUGl4ZWwiLCJwZGZPYmplY3RzIiwiZGF0YUJ1ZmYiLCJnZXRTY3JlZW5zaG90IiwiZGVzaXJlZFdpZHRoIiwicmVuZGVyQ29udGV4dCIsImdldFRhYmxlIiwiZ2V0UGFnZVRhYmxlcyIsInRhYmxlRGF0YUFyciIsImZpbGxQYWdlVGFibGVzIiwicGFnZVRhYmxlUmVzdWx0IiwiZ2V0UGF0aEdlb21ldHJ5IiwibW0iLCJ1bmRlZmluZWQiLCJobGluZSIsInZsaW5lIiwibGluZVN0b3JlIiwidHJhbnNmb3JtTWF0cml4IiwidHJhbnNmb3JtU3RhY2siLCJvcExpc3QiLCJwZyIsInJlc3RvcmVkTWF0cml4IiwicGFnZVRhYmxlcyIsInRleHRJdGVtIiwicGFnZVRhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdf-parse/dist/cjs/index.cjs\n");

/***/ })

};
;